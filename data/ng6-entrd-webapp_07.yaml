- en: Create a Router-First Line-of-Business App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个路由优先的业务应用
- en: Line-of-Business (**LOB**) applications are the bread and butter of the software
    development world. As defined in Wikipedia, LOB is a general term, which refers
    to a product or a set of related products that serve a particular customer transaction
    or business need. LOB apps present a good opportunity to demonstrate a variety
    of features and functionality without getting into contorted or specialized scenarios
    that large enterprise applications usually require. In a sense, they are the 80-20
    learning experience. I must, however, point out a curious thing about LOB apps—if
    you end up building a semi-useful LOB app, the demand for it will grow uncontrollably,
    and you will quickly become the victim of your own success. This is why you should
    treat the start of every new project as an opportunity, a coding-kata if you will, to
    get better at creating more flexible architectures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 业务应用（LOB）是软件开发世界的基础。根据维基百科的定义，LOB 是一个通用术语，指的是为特定客户交易或业务需求提供产品或一组相关产品。LOB 应用程序提供了展示各种功能和功能的良好机会，而无需涉及大型企业应用程序通常需要的扭曲或专业化场景。在某种意义上，它们是
    80-20 的学习经验。然而，我必须指出有关 LOB 应用程序的一个奇怪之处——如果您最终构建了一个半有用的 LOB 应用程序，对它的需求将不受控制地增长，您很快就会成为自己成功的受害者。这就是为什么您应该把每个新项目的开始视为一个机会，一个编码的机会，以便更好地创建更灵活的架构。
- en: In this chapter and the remaining chapters, we’ll set up a new application with
    rich features that can meet the demands of an LOB application with a scalable
    architecture and engineering best practices that will help you start small and
    be able to grow your solution quickly if there’s demand. We will follow the Router-first
    design pattern, relying on reusable components to create a grocery store LOB named
    LemonMart.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和其余章节中，我们将建立一个具有丰富功能的新应用程序，可以满足可扩展架构和工程最佳实践的 LOB 应用程序的需求，这将帮助您在有需求时快速启动并迅速扩展解决方案。我们将遵循路由优先的设计模式，依赖可重用的组件来创建一个名为
    LemonMart 的杂货店 LOB。
- en: 'In this chapter, you will learn to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学会以下内容：
- en: Effectively use CLI to create major Angular Components and CLI Scaffolds
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效使用 CLI 创建主要的 Angular 组件和 CLI 脚手架
- en: Learn how to build Router-first Apps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何构建路由优先应用
- en: Branding, Custom and Material Iconography
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 品牌、自定义和材料图标
- en: Debug complicated apps with Augury
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Augury 调试复杂的应用程序
- en: Enable lazy loading
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用延迟加载
- en: Create a walking skeleton
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个基本框架
- en: 'The code samples provided in this book require Angular version 5 and 6\. Angular
    5 code is runtime compatible with Angular 6\. Angular 6 will be supported in LTS
    until October 2019\. The most up-to-date versions of the code repositories may
    be found at the following URLs:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的代码示例需要 Angular 版本 5 和 6。Angular 5 代码与 Angular 6 兼容。Angular 6 将在 LTS 中得到支持，直到
    2019 年 10 月。代码存储库的最新版本可以在以下网址找到：
- en: For Chapters 2 to 6, LocalCast Weather at [Github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第 2 到 6 章，LocalCast Weather 在 [Github.com/duluca/local-weather-app](https://github.com/duluca/local-weather-app)
- en: For Chapters 7 to 12, LemonMart at [Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第 7 到 12 章，LemonMart 在 [Github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
- en: Angular cheat sheet
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 技巧表
- en: Before we dive in to creating our LOB app, I have included a cheat sheet for
    you to familiarize yourself with common Angular syntax and CLI commands, because
    going forward, this syntax and these commands will be used without their purpose
    explicitly explained. Take some time to review and orient yourself with new Angular
    syntax, major components, CLI scaffolds, and common pipes. You may find the list
    especially useful if your background is with AngularJS, since you will need to
    unlearn some old syntax.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入创建LOB应用程序之前，我为您提供了一个速查表，让您熟悉常见的Angular语法和CLI命令，因为在接下来的过程中，这些语法和命令将被使用，而不会明确解释它们的目的。花些时间来审查和熟悉新的Angular语法、主要组件、CLI脚手架和常见管道。如果您的背景是AngularJS，您可能会发现这个列表特别有用，因为您需要放弃一些旧的语法。
- en: Binding
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定
- en: 'Binding, or data binding, refers to an automatic, one or two-way connection
    between a variable in code and a value displayed or input in an HTML template
    or another component:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定，或数据绑定，指的是代码中变量与HTML模板或其他组件中显示或输入的值之间的自动单向或双向连接：
- en: '| **Type** | **Syntax ** | **Data direction** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **语法** | **数据方向** |'
- en: '| Interpolation Property'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '| 插值属性'
- en: Attribute
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 属性
- en: Class
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Style | `{{expression}}``[target]="expression"``bind-target="expression"` |
    One-way from data source
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 样式 | `{{expression}}``[target]="expression"``bind-target="expression"` | 从数据源单向
- en: to view target |
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到视图目标 |
- en: '| Event | `(target)="statement"` `on-target="statement"` | One-way from view
    target'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 事件 | `(目标)="语句"` `on-目标="语句"` | 从视图目标单向
- en: to data source |
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 到数据源 |
- en: '| Two-way | `[(target)]="expression"` `bindon-target="expression"` | Two-way
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 双向 | `[(target)]="expression"` `bindon-target="expression"` | 双向 |'
- en: Source: [https://angular.io/guide/template-syntax#binding-syntax-an-overview](https://angular.io/guide/template-syntax#binding-syntax-an-overview)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://angular.io/guide/template-syntax#binding-syntax-an-overview](https://angular.io/guide/template-syntax#binding-syntax-an-overview)
- en: Built-in directives
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置指令
- en: 'Directives encapsulate coded behaviors that can be applied as attributes to
    HTML elements or other components:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 指令封装了可以作为属性应用到HTML元素或其他组件的编码行为：
- en: '| **Name** | **Syntax ** | **Purpose** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **语法** | **目的** |'
- en: '| Structural Directives | `*ngIf``*ngFor``*ngSwitch` | Controls structural
    layout of the HTML and if elements get added or removed from the DOM |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 结构指令 | `*ngIf``*ngFor``*ngSwitch` | 控制HTML的结构布局，以及元素是否从DOM中添加或移除 |'
- en: '| Attribute Directives | `[class]``[style]``[(model)]` | Listens to and modifies
    the behavior of other HTML elements, attributes, properties, and components, such
    as CSS classes, HTML styles, and HTML form elements |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 属性指令 | `[class]``[style]``[(model)]` | 监听并修改其他HTML元素、属性、属性和组件的行为，如CSS类、HTML样式和HTML表单元素
    |'
- en: Structural Directives Source: [https://angular.io/guide/structural-directives](https://angular.io/guide/structural-directives)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令来源：[https://angular.io/guide/structural-directives](https://angular.io/guide/structural-directives)
- en: Attribute Directives Source: [https://angular.io/guide/template-syntax#built-in-attribute-directives](https://angular.io/guide/template-syntax#built-in-attribute-directives)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指令来源：[https://angular.io/guide/template-syntax#built-in-attribute-directives](https://angular.io/guide/template-syntax#built-in-attribute-directives)
- en: Common pipes
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见管道
- en: Pipes modify how a data-bound value is displayed in the HTML template.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 管道修改了数据绑定值在HTML模板中的显示方式。
- en: '| **Name** | **Purpose** | **Usage** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **目的** | **用法** |'
- en: '| Date | Formats a date according to locale rules | `{{date_value &#124; date[:format]}}`
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | 根据区域设置规则格式化日期 | `{{date_value &#124; date[:format]}}` |'
- en: '| Text Transformation | Transforms text to uppercase, lowercase, or title case
    | `{{value &#124; uppercase}}``{{value &#124; lowercase}}``{{value &#124; titlecase
    }}` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 文本转换 | 将文本转换为大写、小写或标题大小写 | `{{value &#124; uppercase}}``{{value &#124; lowercase}}``{{value
    &#124; titlecase }}` |'
- en: '| Decimal | Formats a number according to locale rules | `{{number &#124; number[:digitInfo]}}`
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 小数 | 根据区域规则，将数字格式化 | `{{number &#124; number[:digitInfo]}}` |'
- en: '| Percent | Formats a number as a percentage according to locale rules | `{{number
    &#124; percent[:digitInfo]}}` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 百分比 | 根据区域规则，将数字格式化为百分比 | `{{number &#124; percent[:digitInfo]}}` |'
- en: '| Currency | Formats a number as currency with currency code and symbol according
    to locale rules | `{{number &#124; currency[:currencyCode [:symbolDisplay[:digitInfo]]]}}`
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 货币 | 根据区域规则，将数字格式化为带有货币代码和符号的货币 | `{{number &#124; currency[:currencyCode
    [:symbolDisplay[:digitInfo]]]}}` |'
- en: Pipes Source: [https://angular.io/guide/pipes](https://angular.io/guide/pipes)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 管道来源：[https://angular.io/guide/pipes](https://angular.io/guide/pipes)
- en: Starter commands, major components, and CLI scaffolds
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动命令，主要组件和CLI脚手架
- en: 'Starter commands help generate new projects or add dependencies. Angular CLI
    commands help create major components by automatically generating boilerplate
    scaffolding code with ease. For the list of full set of commands, visit [https://github.com/angular/angular-cli/wiki](https://github.com/angular/angular-cli/wiki):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 启动命令帮助生成新项目或添加依赖项。Angular CLI命令帮助创建主要组件，通过自动生成样板脚手架代码来轻松完成。有关完整命令列表，请访问[https://github.com/angular/angular-cli/wiki](https://github.com/angular/angular-cli/wiki)：
- en: '| **Name** | **Purpose ** | **CLI Command** |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **目的** | **CLI命令** |'
- en: '| New | Creates a new Angular application with initialized git repository,
    package.json, and routing already configured. Run from parent folder. | `npx @angular/cli
    new project-name --routing` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 新建 | 创建一个新的Angular应用程序，并初始化git存储库，配置好package.json和路由。从父文件夹运行。 | `npx @angular/cli
    new project-name --routing` |'
- en: '| Update | Updates Angular, RxJS, and Angular Material dependencies. Rewrites
    code, if necessary, to maintain compatibility. | `npx ng update` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 更新 | 更新Angular，RxJS和Angular Material依赖项。如有必要，重写代码以保持兼容性。 | `npx ng update`
    |'
- en: '| Add Material | Installs and configures Angular Material dependencies. | `npx
    ng add @angular/material` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 添加材料 | 安装和配置Angular Material依赖项。 | `npx ng add @angular/material` |'
- en: '| Module | Creates a new  `@NgModule` class. Uses `--routing` to add routing
    for submodules. Optionally, import new module into a parent module using `--module`.
    | `ng g module new-module` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 创建一个新的`@NgModule`类。使用`--routing`来为子模块添加路由。可选地，使用`--module`将新模块导入到父模块中。
    | `ng g module new-module` |'
- en: '| Component | Creates a new `@Component` class. Uses `--module` to specify
    parent module. Optionally, use `--flat` to skip directory creation, `-t` for an
    inline template, and `-s` for an inline style. | `ng g component new-component`
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 创建一个新的`@Component`类。使用`--module`来指定父模块。可选地，使用`--flat`来跳过目录创建，`-t`用于内联模板，和`-s`用于内联样式。
    | `ng g component new-component` |'
- en: '| Directive | Creates a new `@Directive` class. Optionally, uses `--module`
    to scope directives for a given submodule. | `ng g directive new-directive` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 创建一个新的`@Directive`类。可选地，使用`--module`来为给定子模块范围内的指令。 | `ng g directive
    new-directive` |'
- en: '| Pipe | Creates a new `@Pipe` class. Optionally, use `--module` to scope pipes
    for a given submodule. | `ng g pipe new-pipe` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 管道 | 创建一个新的`@Pipe`类。可选地，使用`--module`来为给定子模块范围内的管道。 | `ng g pipe new-pipe`
    |'
- en: '| Service | Creates a new `@Injectable` class. Uses `--module` to provide a 
    service for a given submodule. Services are not automatically imported to a module.
    Optionally use `--flat` false to create service under a directory. | `ng g service
    new-service` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 服务 | 创建一个新的`@Injectable`类。使用`--module`为给定子模块提供服务。服务不会自动导入到模块中。可选地使用`--flat`
    false在目录下创建服务。 | `ng g service new-service` |'
- en: '| Guard | Creates a new `@Injectable` class, which implements the Route lifecycle
    hook `CanActivate`. Uses `--module` to provide a guard for a given submodule.
    Guards are not automatically imported to a module. | `ng g guard new-guard` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| Guard | 创建一个新的`@Injectable`类，实现路由生命周期钩子`CanActivate`。使用`--module`为给定的子模块提供守卫。守卫不会自动导入到模块中。|
    `ng g guard new-guard` |'
- en: '| Class | Creates a bare-bones class. | `ng g class new-class` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| Class | 创建一个简单的类。| `ng g class new-class` |'
- en: '| Interface | Creates a bare-bones interface. | `ng g interface new-interface`
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| Interface | 创建一个简单的接口。| `ng g interface new-interface` |'
- en: '| Enum | Creates a bare-bones enum. | `ng g enum new-enum` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| Enum | 创建一个简单的枚举。| `ng g enum new-enum` |'
- en: In order to properly scaffold some of the components listed earlier under a
    custom module, such as `my-module`, you can prepend the module name before the
    name of what you intend to generate, for example, `ng g c my-module/my-new-component`.
    Angular CLI will properly wire up and place the new component under the `my-module` folder.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确地为自定义模块下列出的一些组件进行脚手架搭建，比如`my-module`，你可以在你打算生成的名称前面加上模块名称，例如`ng g c my-module/my-new-component`。Angular
    CLI将正确地连接并将新组件放置在`my-module`文件夹下。
- en: Configure Angular CLI autocomplete
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Angular CLI自动完成
- en: 'You get an autocomplete experience when working with Angular CLI. Execute the
    appropriate command for your `*nix` environment:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Angular CLI时，您将获得自动完成的体验。执行适合您的`*nix`环境的适当命令：
- en: 'For bash shell:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于bash shell：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For zsh shell:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于zsh shell：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For Windows users using git bash shell:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于使用git bash shell的Windows用户：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Router-first architecture
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器优先架构
- en: The Angular router, shipped in the `@angular/router` package, is a central and
    critical part of building **single-page-applications** (**SPAs**) that act and
    behave like regular websites that are easy to navigate using browser controls
    or the zoom or microzoom controls.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器，打包在`@angular/router`包中，是构建**单页应用程序**（**SPAs**）的中心和关键部分，它的行为和操作方式类似于普通网站，可以使用浏览器控件或缩放或微缩放控件轻松导航。
- en: Angular Router has advanced features such as lazy loading, router outlets, auxiliary
    routes, smart active link tracking, and the ability to be expressed as an `href`,
    which enables a highly flexible Router-first app architecture leveraging stateless
    data-driven components using RxJS `SubjectBehavior`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器具有高级功能，如延迟加载、路由器出口、辅助路由、智能活动链接跟踪，并且可以表达为`href`，这使得使用RxJS `SubjectBehavior`的无状态数据驱动组件的高度灵活的路由器优先应用程序架构成为可能。
- en: Large teams can work against a single-code base, with each team responsible
    of a module's development, without stepping on each other's toes, while enabling
    easy continuous integration. Google, with its billions of lines of code, works
    against a single code base for a very good reason. Integration, after the fact,
    is very expensive.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大型团队可以针对单一代码库进行工作，每个团队负责一个模块的开发，而不会互相干扰，同时实现简单的持续集成。谷歌之所以选择针对数十亿行代码进行单一代码库的工作，是有很好的原因的。事后的集成非常昂贵。
- en: Small teams can remix their UI layouts on the fly to quickly respond to changes
    without having to rearchitect their code. It is easy to underestimate the amount
    of time wasted due to late game changes in layout or navigation. Such changes
    are easier to absorb by larger teams but a costly endeavor for small teams.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 小团队可以随时重新调整他们的UI布局，以快速响应变化，而无需重新设计他们的代码。很容易低估由于布局或导航的后期更改而浪费的时间。这样的变化对于大型团队来说更容易吸收，但对于小团队来说是一项昂贵的努力。
- en: With lazy-loading, all developers benefit from sub-second first meaningful paints,
    because the file size of the core user experience that's delivered to the browser
    is kept at a minimum at build time. The size of a module impacts download and
    loading speed, because the more a browser has to do, the longer it will take for
    a user to see the first screen of the app. By defining lazy-loaded modules, each
    module can be packaged as separated files, which can be downloaded and loaded
    individually and as needed. Smart active link tracking results in a superior developer
    and user experience, making it very easy to implement highlighting features to
    indicate to the user the current tab or portion of the app that is currently active.
    Auxiliary routes maximize the reuse of components and help pull off complicated
    state transitions with ease. With auxiliary routes, you can render multiple master
    and detail views using only a single outer template. You can also control how
    the route is displayed to the user in the browser's URL bar and compose routes
    using `routerLink`, in templates, and `Router.navigate`, in code, driving complicated
    scenarios.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过延迟加载，所有开发人员都可以从次秒级的首次有意义的绘制中受益，因为在构建时将传递给浏览器的核心用户体验文件大小保持在最低限度。模块的大小影响下载和加载速度，因为浏览器需要做的越多，用户看到应用程序的第一个屏幕就需要的时间就越长。通过定义延迟加载的模块，每个模块都可以打包为单独的文件，可以根据需要单独下载和加载。智能活动链接跟踪可以提供卓越的开发人员和用户体验，非常容易实现突出显示功能，以指示用户当前活动的选项卡或应用程序部分。辅助路由最大化了组件的重用，并帮助轻松实现复杂的状态转换。通过辅助路由，您可以仅使用单个外部模板呈现多个主视图和详细视图。您还可以控制路由在浏览器的URL栏中向用户显示的方式，并使用`routerLink`在模板中和`Router.navigate`在代码中组合路由，驱动复杂的场景。
- en: 'In order to pull off a router-first implementation, you need to do this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个以路由为先的实现，您需要这样做：
- en: Define user roles early on
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 早期定义用户角色
- en: Design with lazy loading in mind
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计时考虑延迟加载
- en: Implement a walking-skeleton navigation experience
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个骨架导航体验
- en: Design around major data components
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 围绕主要数据组件进行设计
- en: Enforce a decoupled component architecture
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个解耦的组件架构
- en: Differentiate between user controls and components
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 区分用户控件和组件
- en: Maximize code reuse
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最大化代码重用
- en: User roles normally indicate the job function of a user, such as a manager or
    data-entry specialist. In technical terms, they can be thought of as a group of
    actions that a particular class of user is allowed to execute. Defining user roles
    help identify sub modules that can then be configured to be lazy loaded. After
    all, a data-entry specialist won't ever see most of the screens that a manager
    can, so why deliver those assets to those users and slow down their experience? Lazy
    loading is critical in creating a scalable application architecture, not only
    from an application perspective, but also from a high-quality and efficient development
    perspective. Configuring lazy loading can be tricky, which is why it is important
    to nail down a walking-skeleton navigation experience early on.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 用户角色通常表示用户的工作职能，例如经理或数据录入专员。在技术术语中，它们可以被视为特定类别用户被允许执行的一组操作。定义用户角色有助于识别可以配置为延迟加载的子模块。毕竟，数据录入专员永远不会看到经理可以看到的大多数屏幕，那么为什么要将这些资产传递给这些用户并减慢他们的体验呢？延迟加载在创建可扩展的应用程序架构方面至关重要，不仅从应用程序的角度来看，而且从高质量和高效的开发角度来看。配置延迟加载可能会很棘手，这就是为什么及早确定骨架导航体验非常重要的原因。
- en: Identifying major data components that your users will work with, such as invoice
    or people objects, will help you avoid over-engineering your application. Designing
    around major data components will inform API design early on and help define `BehaviorSubject`
    data anchors that you will use to achieve a stateless, data-driven design to ensure
    a decoupled component architecture, as detailed in [Chapter 6](2d361227-9c8f-4487-bb14-592ca16c0f5a.xhtml),
    *Reactive Forms and Component Interaction*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 识别用户将使用的主要数据组件，例如发票或人员对象，将帮助您避免过度设计您的应用程序。围绕主要数据组件进行设计将在早期确定API设计，并帮助定义`BehaviorSubject`数据锚点，以实现无状态、数据驱动的设计，确保解耦的组件架构，详见[第6章](2d361227-9c8f-4487-bb14-592ca16c0f5a.xhtml)，*响应式表单和组件交互*。
- en: Finally, identify self-contained user controls that encapsulate unique behaviors
    that you wish to create for your app. User controls will likely be created as
    directives or components that have data-binding properties and tightly-coupled
    controller logic and templates. Components, on the other hand, will leverage router
    life cycle events to parse parameters and perform CRUD operations on data. Identifying
    these component reuses early on will result in creating more flexible components
    that can be reused in multiple contexts as orchestrated by the router, maximizing
    code reuse.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，识别封装了您希望为应用程序创建的独特行为的自包含用户控件。用户控件可能会被创建为具有数据绑定属性和紧密耦合的控制器逻辑和模板的指令或组件。另一方面，组件将利用路由器生命周期事件来解析参数并对数据执行CRUD操作。在早期识别这些组件重用将导致创建更灵活的组件，可以在路由器协调下在多个上下文中重用，最大程度地实现代码重用。
- en: Creating LemonMart
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建LemonMart
- en: LemonMart will be a mid-sized line-of-business application with over 90 code
    files. We will start our journey by creating a new Angular app with routing and
    Angular Material configured from the get go.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: LemonMart将是一个中型的业务应用程序，拥有超过90个代码文件。我们将从创建一个新的Angular应用程序开始，其中包括路由和Angular Material的配置。
- en: Creating a Router-first app
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个以路由为先的应用程序
- en: 'With the Router-first approach, we will want to enable routing early on in
    our application:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 采用以路由为先的方法，我们将希望在应用程序早期启用路由：
- en: 'You can create the new application with routing already configured by executing
    this command:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过执行以下命令创建已经配置了路由的新应用程序：
- en: 'Ensure that `@angular/cli` is not installed globally, or you may run into errors:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 确保未全局安装`@angular/cli`，否则可能会遇到错误：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A new `AppRoutingModule` file has been created for us:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个新的`AppRoutingModule`文件已经为我们创建了：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will be defining routes inside the routes array. Note that routes array is
    passed in to be configured as the root routes for the application, the default
    root route being `/`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在routes数组中定义路由。请注意，routes数组被传入以配置为应用程序的根路由，默认的根路由为`/`。
- en: 'When configuring your `RouterModule`, you can pass in additional options to
    customize the default behavior of the Router, such as when you attempt to load
    a route that is already being displayed, instead of taking no action, you can
    force a reload of the component. To enable this behavior, create your router like `RouterModule.forRoot(routes,
    { onSameUrlNavigation: ''reload'' })`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '在配置您的`RouterModule`时，您可以传入其他选项来自定义路由器的默认行为，例如当您尝试加载已经显示的路由时，而不是不采取任何操作，您可以强制重新加载组件。要启用此行为，请创建您的路由器如下：`RouterModule.forRoot(routes,
    { onSameUrlNavigation: ''reload'' })`。'
- en: 'Finally, `AppRoutingModule` is registered with `AppModule`, as shown:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`AppRoutingModule`被注册到`AppModule`中，如下所示：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Configuring Angular.json and Package.json
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Angular.json和Package.json
- en: 'Here''s a quick summary of configuration steps covered in Chapters 2-6\. If
    you''re unfamiliar with a step, refer to prior chapters. You should complete these
    steps before moving forward:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第2-6章中涵盖的配置步骤的快速摘要。如果您对某个步骤不熟悉，请参考之前的章节。在继续之前，您应该完成这些步骤：
- en: Modify `angular.json` and `tslint.json` to enforce your settings and coding
    standards
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`angular.json`和`tslint.json`以强制执行您的设置和编码标准。
- en: Install `npm i -D prettier`
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`npm i -D prettier`
- en: Add `prettier` settings to `package.json`
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`prettier`设置添加到`package.json`
- en: Configure your development serve port to other than `4200`, such as `5000`
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将开发服务器端口配置为除`4200`之外的其他端口，例如`5000`
- en: Add the `standardize` script and update `start` and `build` scripts
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`standardize`脚本并更新`start`和`build`脚本
- en: Add npm Scripts for Docker to `package.json`
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Docker添加npm脚本到`package.json`
- en: Establish dev norms and document it in your project, `npm i -D dev-norms` then
    `npx dev-norms create`
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立开发规范并在项目中记录，`npm i -D dev-norms`然后`npx dev-norms create`
- en: If you use VS Code, set up the `extensions.json` and `settings.json` files
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用VS Code，请设置`extensions.json`和`settings.json`文件
- en: 'You may configure the TypeScript Hero extension to auto organize and prune
    import statements, but adding `"typescriptHero.imports.organizeOnSave": true`
    to `settings.json`. If combined with the setting `"files.autoSave": "onFocusChange"`
    you may find that the tool aggressively cleans unused imports as you are trying
    to type them out. Ensure that this setting works for you and doesn''t collide
    with any other tools or VS Code''s own import organization feature.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以配置TypeScript Hero扩展以自动组织和修剪导入语句，只需将`"typescriptHero.imports.organizeOnSave":
    true`添加到`settings.json`中。如果与设置`"files.autoSave": "onFocusChange"`结合使用，您可能会发现该工具在您尝试输入时会积极清除未使用的导入。确保此设置适用于您，并且不会与任何其他工具或VS
    Code自己的导入组织功能发生冲突。'
- en: Execute `npm run standardize`
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`npm run standardize`
- en: Refer to [Chapter 3](4e68114e-68b7-4fe6-a853-81347e981667.xhtml),*Prepare Angular
    App for Production Release*, for further configuration details.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[第3章](4e68114e-68b7-4fe6-a853-81347e981667.xhtml)，*为生产发布准备Angular应用*，以获取更多配置细节。
- en: You can get the npm Scripts for Docker at [bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker) and
    npm Scripts for AWS at [bit.ly/npmScriptsForAWS](http://bit.ly/npmScriptsForAWS).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker)获取Docker的npm脚本，以及在[bit.ly/npmScriptsForAWS](http://bit.ly/npmScriptsForAWS)获取AWS的npm脚本。
- en: Configuring Material and Styles
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Material和样式
- en: 'We will also need to set up Angular Material and configure a theme to use,
    as covered in [Chapter 5](5e0df0e8-57a6-47dc-86c8-d56f6e35021e.xhtml), *Enhance
    Angular App with Angular Material*:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设置Angular Material并配置要使用的主题，如[第5章](5e0df0e8-57a6-47dc-86c8-d56f6e35021e.xhtml)中所述，*使用Angular
    Material增强Angular应用*：
- en: 'Install Angular Material:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Angular Material：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Import and export `MatButtonModule`, `MatToolbarModule`, and `MatIconModule`
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入和导出`MatButtonModule`，`MatToolbarModule`和`MatIconModule`
- en: Configure your default theme and register other Angular dependencies
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置默认主题并注册其他Angular依赖项
- en: Add common css to `styles.css` as shown below,
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将通用css添加到`styles.css`中，如下所示，
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Refer to [Chapter 5](5e0df0e8-57a6-47dc-86c8-d56f6e35021e.xhtml), *Enhance Angular
    App with Angular Material*, for further configuration details.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多配置详细信息，请参阅[第5章](5e0df0e8-57a6-47dc-86c8-d56f6e35021e.xhtml)，*使用Angular Material增强Angular应用*。
- en: Designing LemonMart
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计LemonMart
- en: It is important to build a rudimentary road map to follow, from the database
    to the frontend, while also avoiding over-engineering. This initial design phase
    is critical to the long-term health and success of your project, where any existing
    silos between teams must be broken down and an overall technical vision well understood
    by all members of the team. This is easier said than done, and there are volumes
    of books written on the topic.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建从数据库到前端的基本路线图的同时，避免过度工程化非常重要。这个初始设计阶段对项目的长期健康和成功至关重要，团队之间任何现有的隔离必须被打破，并且整体技术愿景必须被团队的所有成员充分理解。这并不是说起来容易做起来难，关于这个话题已经有大量的书籍写成。
- en: In engineering, there's no one right answer to a problem, so it is important
    to remember that no one person can ever have all the answers nor a crystal clear
    vision. It is important that technical and non-technical leaders create a safe
    space with opportunities for open discussion and experimentation as part of the
    culture. The humility and empathy that comes along with being able to court such
    uncertainty as a team is as important as any single team member's technical capabilities.
    Every team member must be comfortable with checking their egos out at the door,
    because our collective goal will be to grow and evolve an application to ever-changing
    requirements during the development cycle. You will know that you have succeeded
    if individual parts of the software you created is easily replaceable by anyone.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在工程领域，没有一个问题有唯一正确的答案，因此重要的是要记住没有一个人可以拥有所有答案，也没有一个人可以有清晰的愿景。技术和非技术领导者之间创造一个安全的空间，提供开放讨论和实验的机会是文化的一部分，这一点非常重要。能够在团队中面对这种不确定性所带来的谦卑和同理心与任何单个团队成员的技术能力一样重要。每个团队成员都必须习惯于把自己的自我放在一边，因为我们的集体目标将是在开发周期内发展和演变应用程序以适应不断变化的需求。如果你能够知道你已经成功了，那么你所创建的软件的各个部分都可以很容易地被任何人替换。
- en: Identifying user roles
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定用户角色
- en: The first step of our design will be to think about you using the application
    and why.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的第一步是考虑您使用应用程序的原因。
- en: 'We envision four user states or roles for LemonMart:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为LemonMart设想了四种用户状态或角色：
- en: Authenticated, any authenticated user would have access to their profile
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证用户，任何经过认证的用户都可以访问他们的个人资料
- en: Cashier, whose sole role is to check out customers
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收银员，其唯一角色是为客户结账。
- en: Clerk, whose sole role is to perform inventory-related functions
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 店员，其唯一角色是执行与库存相关的功能
- en: Manager, who can perform all actions a cashier and a clerk can perform but also
    have access to administrative functions
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经理，可以执行收银员和店员可以执行的所有操作，但也可以访问管理功能
- en: With this in mind, we can start a high-level design of our app.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，我们可以开始设计我们应用程序的高级设计。
- en: Identifying high-level modules with site map
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用站点地图确定高级模块
- en: 'Develop a high-level site map of your application, as shown:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 制作应用程序的高级站点地图，如下所示：
- en: '![](Images/87ef861d-200d-4e44-bed9-807ca9b3e2c4.png)Landing pages for usersI
    used MockFlow.com''s SiteMap tool to create the site map'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/87ef861d-200d-4e44-bed9-807ca9b3e2c4.png)用户的登陆页面我使用了MockFlow.com的SiteMap工具来创建站点地图'
- en: shown at [https://sitemap.mockflow.com](https://sitemap.mockflow.com).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 显示在[https://sitemap.mockflow.com](https://sitemap.mockflow.com)。
- en: 'Upon first examination, three high-level modules emerge as lazy-loading candidates:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在首次检查时，三个高级模块出现为延迟加载的候选项：
- en: Point of Sale (POS)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 销售点（POS）
- en: Inventory
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库存
- en: Manager
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经理
- en: Cashier will only have access to the POS module and component. The Clerk will
    only have access to the Inventory module, which will include additional screen
    for Stock Entry, Products, and Categories management components.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 收银员只能访问POS模块和组件。店员只能访问库存模块，其中包括库存录入、产品和类别管理组件的额外屏幕。
- en: '![](Images/b7feb50e-d0cd-403a-8f50-9f68ad8737cd.png)Inventory pages'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 库存页面
- en: Finally, the Manager will be able to access all three modules with the Manager
    module, including User management and Receipt lookup components.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，管理者将能够通过管理模块访问所有三个模块，包括用户管理和收据查找组件。
- en: '![](Images/a5aee264-31a6-4403-9d1a-4f71820a93f4.png)Manager pages'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 管理页面
- en: There's great benefit to enable lazy-loading for all three modules, since cashiers
    and clerks will never use components belonging to other user roles, there's no
    reason to send those bytes down to their devices. This means as the Manager module
    gains more advanced reporting features or new roles are added to the application,
    the POS module will be unaffected by the bandwidth and memory impact of an otherwise
    growing application. This means less support calls and consistent performance
    on the same hardware for a much longer period of time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 启用所有三个模块的延迟加载有很大好处，因为收银员和店员永远不会使用属于其他用户角色的组件，所以没有理由将这些字节发送到他们的设备上。这意味着当管理模块获得更多高级报告功能或新角色添加到应用程序时，POS模块不会受到应用程序增长的带宽和内存影响。这意味着更少的支持电话，并且在同一硬件上保持一致的性能更长的时间。
- en: Generating router-enabled modules
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成启用路由的模块
- en: 'Now that we have our high-level components defined as Manager, Inventory, and
    POS, we can define them as modules. These modules will be different from the ones
    you''ve created so far, for routing and Angular Material. We can create the user
    profile as a component on the app module; however, note that user profile will
    only ever be used for already authenticated users, so it makes sense to define
    a fourth module only meant for authenticated users in general. This way, you will
    ensure that your app''s first payload remains as minimal as possible. In addition,
    we will create a Home component to contain the landing experience for our app
    so that we can keep implementation details out of `app.component`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了高级组件作为管理者、库存和POS，我们可以将它们定义为模块。这些模块将与您迄今为止创建的模块不同，用于路由和Angular Material。我们可以将用户配置文件创建为应用程序模块上的一个组件；但是，请注意，用户配置文件只会用于已经经过身份验证的用户，因此定义一个专门用于一般经过身份验证用户的第四个模块是有意义的。这样，您将确保您的应用程序的第一个有效载荷保持尽可能小。此外，我们将创建一个主页组件，用于包含我们应用程序的着陆体验，以便我们可以将实现细节从`app.component`中排除出去：
- en: 'Generate `manager`, `inventory`, `pos`, and `user` modules, specifying their
    target module and routing capabilities:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成`manager`，`inventory`，`pos`和`user`模块，指定它们的目标模块和路由功能：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As discussed in [Chapter 1](ff3bb319-cb7a-49d8-9f23-aa9a3727122c.xhtml),* Setting
    Up Your Development Environment*, if you have configured `npx` to automatically
    recognize `ng` as a command, you can save some more keystrokes so that you won't
    have to append `npx` to your commands every time. Do not globally install `@angular/cli`.
    Note the abbreviate command structure, where `ng generate module manager` becomes
    `ng g m manager`, and similarly, `--module` becomes `-m`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](ff3bb319-cb7a-49d8-9f23-aa9a3727122c.xhtml)中所讨论的*设置您的开发环境*，如果您已经配置`npx`自动识别`ng`作为命令，您可以节省更多按键，这样您就不必每次都添加`npx`到您的命令中。不要全局安装`@angular/cli`。请注意缩写命令结构，其中`ng
    generate module manager`变成`ng g m manager`，同样，`--module`变成了`-m`。
- en: Verify that you don't have CLI errors.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您是否没有CLI错误。
- en: Note that using `npx` on Windows may encounter an error such as Path must be
    a string. Received undefined. This error doesn't seem to have any effect on the
    successful operation of the command, which is why it is critical to always inspect
    what the CLI tool generated.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Windows上使用`npx`可能会遇到错误，例如路径必须是字符串。收到未定义。这个错误似乎对命令的成功操作没有任何影响，这就是为什么始终要检查CLI工具生成的内容是至关重要的。
- en: 'Verify the folder and the files are created:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证文件夹和文件是否已创建：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Examine how `ManagerModule` has been wired.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`ManagerModule`的连接方式。
- en: 'A child module implements an `@NgModule` similar to `app.module`. The biggest
    difference is that a child module does not implement the `bootstrap` property,
    which is required for your root module, to initialize your Angular app:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 子模块实现了类似于`app.module`的`@NgModule`。最大的区别是子模块不实现`bootstrap`属性，这是你的根模块所需的，用于初始化你的Angular应用程序：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since we have specified the `-m` option, the module has been imported into
    `app.module`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们指定了`-m`选项，该模块已被导入到`app.module`中：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In addition, because we also specified the `--routing` option, a routing module
    has been created and imported into `ManagerModule`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为我们还指定了`--routing`选项，一个路由模块已经被创建并导入到`ManagerModule`中：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that `RouterModule` is being configured using `forChild`, as opposed to `forRoot`,
    which was the case for the `AppRouting` module. This way, the router understands
    the proper relationship between routes defined in different modules' contexts
    and can correctly prepend `/manager` to all child routes in this example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`RouterModule`正在使用`forChild`进行配置，而不是`forRoot`，这是`AppRouting`模块的情况。这样，路由器就能理解在不同模块上下文中定义的路由之间的正确关系，并且可以在这个例子中正确地在所有子路由前面添加`/manager`。
- en: The CLI doesn't respect your `tslint.json` settings. If you have correctly configured
    your VS Code environment with prettier, your Code Styling preferences will be
    applied as you work on each file or, globally, when you run the prettier command.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: CLI不尊重你的`tslint.json`设置。如果你已经正确配置了VS Code环境并使用prettier，你的代码样式偏好将在你每个文件上工作时应用，或者在全局运行prettier命令时应用。
- en: Designing the home route
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计home路由
- en: 'Consider the following mock-up as the landing experience for LemonMart:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下模拟作为LemonMart的登陆体验：
- en: '![](Images/07e577f7-b81e-4f2a-8fbe-df27bafba4bd.png)LemonMart Landing Experience'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/07e577f7-b81e-4f2a-8fbe-df27bafba4bd.png)LemonMart登陆体验'
- en: Unlike the `LocalCastWeather` app, we don't want all this markup to be in the `App`
    component. The `App` component is the root element of your entire application;
    therefore, it should only contain elements that will persistently appear throughout
    your application. In the following annotated mock-up, the toolbar marked as 1
    will be persistent throughout the app.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与`LocalCastWeather`应用程序不同，我们不希望所有这些标记都在`App`组件中。`App`组件是整个应用程序的根元素；因此，它应该只包含将在整个应用程序中持续出现的元素。在下面的注释模拟中，标记为1的工具栏将在整个应用程序中持续存在。
- en: 'The area marked as 2 will house the home component, which itself will contain
    a login user control, marked as 3:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为2的区域将容纳home组件，它本身将包含一个登录用户控件，标记为3：
- en: '![](Images/791d4e08-a0ab-4976-ace6-00e9a9680d9c.png)LemonMart Layout Structure'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/791d4e08-a0ab-4976-ace6-00e9a9680d9c.png)LemonMart布局结构'
- en: 'It is a best practice to create your default or landing component as a separate
    element in Angular. This helps reduce the amount of code that must be loaded and
    logic executed in every page, but it also results in a more flexible architecture
    when utilizing the router:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，将默认或登陆组件创建为单独的元素是最佳实践。这有助于减少必须加载的代码量和在每个页面上执行的逻辑，但在利用路由器时也会导致更灵活的架构：
- en: 'Generate the `home` component with inline template and styles:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联模板和样式生成`home`组件：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, you are ready to configure the router.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好配置路由器了。
- en: Setting up default routes
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置默认路由
- en: 'Let''s get started with setting up a simple route for LemonMart:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始为LemonMart设置一个简单的路由：
- en: 'Configure your `home` route:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置你的`home`路由：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We first define a path for `'home'` and inform the router to render `HomeComponent`
    by setting the component property. Then, we set the default path of the application
    `''` to be redirected to `'/home'`. By setting the `pathMatch` property, we always
    ensure that this very specific instance of the home route will be rendered as
    the landing experience.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为`'home'`定义一个路径，并通过设置组件属性来告知路由渲染`HomeComponent`。然后，我们将应用的默认路径`''`重定向到`'/home'`。通过设置`pathMatch`属性，我们始终确保主页路由的这个非常特定的实例将作为着陆体验呈现。
- en: Create a `pageNotFound` component with an inline template
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有内联模板的`pageNotFound`组件
- en: 'Configure a wildcard route for `PageNotFoundComponent`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`PageNotFoundComponent`配置通配符路由：
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This way, any route that is not matched will be directed to the `PageNotFoundComponent`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，任何未匹配的路由都将被重定向到`PageNotFoundComponent`。
- en: RouterLink
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RouterLink
- en: 'When a user lands on the `PageNotFoundComponent`, we would like them to be
    redirected to the `HomeComponent` using the `RouterLink` direction:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登陆到`PageNotFoundComponent`时，我们希望他们通过`RouterLink`重定向到`HomeComponent`：
- en: 'Implement an inline template to link back to home using `routerLink`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个内联模板，使用`routerLink`链接回主页：
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This navigation can also be done via an `<a href>` tag implementation; however,
    in more dynamic and complicated navigation scenarios, you will lose features such
    as automatic active link tracking or dynamic link generation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这种导航也可以通过`<a href>`标签实现；然而，在更动态和复杂的导航场景中，您将失去诸如自动活动链接跟踪或动态链接生成等功能。
- en: The Angular bootstrap process will ensure that `AppComponent` is inside the
    `<app-root>` element in your `index.html`. However, we must manually define where
    we would like `HomeComponent` to render, to finalize the router configuration.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的引导过程将确保`AppComponent`在您的`index.html`中的`<app-root>`元素内。然而，我们必须手动定义我们希望`HomeComponent`呈现的位置，以完成路由器配置。
- en: Router outlet
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由出口
- en: '`AppComponent` is considered a root element for the root router defined in
    `app-routing.module`, which allows us to define outlets within this root element
    to dynamically load any content we wish using the `<router-outlet>` element:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppComponent`被视为在`app-routing.module`中定义的根路由的根元素，这使我们能够在此根元素内定义outlets，以使用`<router-outlet>`元素动态加载任何我们希望的内容：'
- en: Configure `AppComponent` to use inline template and styles
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`AppComponent`以使用内联模板和样式
- en: Add the toolbar for your application
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的应用程序添加工具栏
- en: Add the name of your application as a button link so that it takes the user
    to the home page when clicked on
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的应用程序名称作为按钮链接添加，以便在点击时将用户带到主页
- en: 'Add `<router-outlet>` for the content to render:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`<router-outlet>`以渲染内容：
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, the contents of home will render inside `<router-outlet>`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，主页的内容将在`<router-outlet>`内呈现。
- en: Branding, Custom, and Material Icons
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 品牌、自定义和Material图标
- en: In order to construct an attractive and intuitive toolbar, we must introduce
    some iconography and branding to the app so that the users can easily navigate
    through the app with the help of familiar icons.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个吸引人且直观的工具栏，我们必须向应用引入一些图标和品牌，以便用户可以通过熟悉的图标轻松浏览应用。
- en: Branding
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 品牌
- en: In terms of branding, you should ensure that your web app should have custom
    color palette and integrate with desktop and mobile browser features to bring
    forward your app's name and iconography.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在品牌方面，您应该确保您的Web应用程序具有自定义色板，并与桌面和移动浏览器功能集成，以展示您应用的名称和图标。
- en: Color palette
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 色板
- en: 'Pick a color palette using the Material Color tool, as discussed in [Chapter
    5](5e0df0e8-57a6-47dc-86c8-d56f6e35021e.xhtml), *Enhance Angular App with Angular
    Material*. Here''s the one I picked for LemonMart:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Material Color工具选择一个色板，如[第5章](5e0df0e8-57a6-47dc-86c8-d56f6e35021e.xhtml)中所讨论的，*使用Angular
    Material增强Angular应用*。这是我为LemonMart选择的色板：
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Implementing browser manifest and icons
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现浏览器清单和图标
- en: 'You need to ensure that the browser shows the correct title text and icon in
    a Browser tab. Further, a manifest file should be created that implements specific
    icons for various mobile operating systems, so that if a user pins your website,
    a desirable icon is displayed similar to other app icons on a phone. This will
    ensure that if a user favorites or pin your web app on their mobile device''s
    home screen, they''ll get a native-looking app icon:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保浏览器在浏览器选项卡中显示正确的标题文本和图标。此外，应创建一个清单文件，为各种移动操作系统实现特定的图标，以便用户将您的网站固定在手机上时，会显示一个理想的图标，类似于手机上的其他应用图标。这将确保如果用户将您的Web应用添加到其移动设备的主屏幕上，他们将获得一个本地外观的应用图标：
- en: Create or obtain an SVG version of your website's logo from a designer or site
    like [https://www.flaticon.com](https://www.flaticon.com)
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从设计师或网站（如[https://www.flaticon.com](https://www.flaticon.com)）获取您网站标志的SVG版本
- en: 'In this case, I will be using a particular lemon image:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我将使用一个特定的柠檬图片：
- en: '![](Images/ba4618d3-21b7-4b40-b2e7-a4243495bb5a.jpg)LemonMart''s signature
    logoWhen using images you find on the internet, pay attention to applicable copyrights.
    In this case, I have purchased a license to be able to publish this lemon logo,
    but you may grab your own copy at the following URL, given that you provide the
    required attribution to the author of the image: [https://www.flaticon.com/free-icon/lemon_605070](https://www.flaticon.com/free-icon/lemon_605070).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/ba4618d3-21b7-4b40-b2e7-a4243495bb5a.jpg) LemonMart的标志性标志在使用互联网上找到的图像时，请注意适用的版权。在这种情况下，我已经购买了许可证以便发布这个柠檬标志，但是您可以在以下网址获取您自己的副本，前提是您提供图像作者所需的归属声明：[https://www.flaticon.com/free-icon/lemon_605070](https://www.flaticon.com/free-icon/lemon_605070)。'
- en: Generate `favicon.ico` and manifest files using a tool such as [https://realfavicongenerator.net](https://realfavicongenerator.net)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[https://realfavicongenerator.net](https://realfavicongenerator.net)等工具生成`favicon.ico`和清单文件
- en: Adjust settings for iOS, Android, Windows Phone, macOS, and Safari to your liking
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您的喜好调整iOS、Android、Windows Phone、macOS和Safari的设置
- en: Ensure that you set a version number, favicons can be notorious with caching;
    a random version number will ensure that users always get the latest version
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保设置一个版本号，favicons可能会因缓存而臭名昭著；一个随机的版本号将确保用户始终获得最新版本
- en: Download and extract the generated `favicons.zip` file into your `src` folder
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并提取生成的`favicons.zip`文件到您的`src`文件夹中。
- en: 'Edit the `angular.json` file to include the new assets in your app:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`angular.json`文件以在您的应用程序中包含新的资产：
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Insert the generated code in the `<head>` section of your `index.html`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的代码插入到`index.html`的`<head>`部分中：
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Ensure that your new favicon displays correctly
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的新favicon显示正确
- en: To further your branding, consider configuring a custom Material theme and leveraging
    [https://material.io/color](https://material.io/color/), as discussed in *Chapter
    5, Enhance Angular App with Angular Material*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步推广您的品牌，请考虑配置自定义的Material主题并利用[https://material.io/color](https://material.io/color/)，如*第5章，使用Angular
    Material增强Angular应用*中所讨论的那样。
- en: Custom icons
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义图标
- en: 'Now, let''s add your custom branding inside your Angular app. You will need
    the svg icon you used to create your favicon:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在您的Angular应用程序中添加您的自定义品牌。您将需要用于创建favicon的svg图标：
- en: Place the image under `src/app/assets/img/icons`, named `lemon.svg`
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像放在`src/app/assets/img/icons`下，命名为`lemon.svg`
- en: Import `HttpClientModule` to `AppComponent` so that the `.svg` file can be requested
    over HTTP
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`HttpClientModule`导入`AppComponent`，以便可以通过HTTP请求`.svg`文件
- en: 'Update `AppComponent` to register the new svg file as an icon:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`AppComponent`以注册新的svg文件作为图标：
- en: '[PRE22]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the icon to the toolbar:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图标添加到工具栏：
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now let's add the remaining icons for menu, user profile, and logout.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为菜单、用户资料和注销添加剩余的图标。
- en: Material icons
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Material图标
- en: Angular Material works out of the box with Material Design icons, which can
    be imported into your app as a web font in your `index.html`. It is possible to
    self-host the font; however, if you go down that path, you also don't get the
    benefit of the user's browser having already cached the font when they visited
    another website, saving the speed and latency of downloading a 42-56 KB file in
    the process. The complete list of icons can be found at [https://material.io/icons/](https://material.io/icons/).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material可以与Material Design图标直接配合使用，可以在`index.html`中将其作为Web字体导入到您的应用程序中。也可以自行托管字体；但是，如果您选择这条路，您也无法获得用户的浏览器在访问其他网站时已经缓存了字体的好处，从而节省了下载42-56
    KB文件的速度和延迟。完整的图标列表可以在[https://material.io/icons/](https://material.io/icons/)找到。
- en: 'Now let''s update the toolbar with some icons and setup the home page with
    a minimal template for a fake login button:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用一些图标更新工具栏，并为主页设置一个最小的模板，用于模拟登录按钮：
- en: 'Ensure Material icons `<link>` tag has been added to `index.html`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Material图标`<link>`标签已添加到`index.html`：
- en: '[PRE24]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Instructions on how to self-host can be found under the Self Hosting section
    at [http://google.github.io/material-design-icons/#getting-icons](http://google.github.io/material-design-icons/#getting-icons).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何自行托管的说明可以在[http://google.github.io/material-design-icons/#getting-icons](http://google.github.io/material-design-icons/#getting-icons)的自行托管部分找到。
- en: Once configured, working with Material icons is easy.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完成后，使用Material图标非常容易。
- en: Update the toolbar to place a Menu button to the left of the title.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新工具栏，将菜单按钮放置在标题左侧。
- en: Add an `fxFlex` so that the remaining icons are right aligned.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`fxFlex`，以便将剩余的图标右对齐。
- en: 'Add user profile and logout icons:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加用户个人资料和注销图标：
- en: '[PRE25]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add a minimal template for a login:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个最小的登录模板：
- en: '[PRE26]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Your app should look similar to this screenshot:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序应该类似于这个屏幕截图：
- en: '![](Images/2af6a8ec-e862-4438-aedb-17741cc1c0af.png)LemonMart with minimal
    login'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/2af6a8ec-e862-4438-aedb-17741cc1c0af.png)LemonMart with minimal
    login'
- en: There's still some work to be done, in terms of implementing and showing/hiding
    the menu, profile, and logout icons, given the user's authentication status. We
    will cover this functionality in [Chapter 9](55413e2b-68e2-4dd0-9018-133008fc3321.xhtml),
    *Design Authentication and Authorization*. Now that you've set up basic routing
    for your app, you need to learn how to debug your Angular app before we move on
    to setting up lazily loaded modules with subcomponents.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现和显示/隐藏菜单、个人资料和注销图标方面还有一些工作要做，考虑到用户的身份验证状态。我们将在[第9章](55413e2b-68e2-4dd0-9018-133008fc3321.xhtml)中涵盖这些功能，*设计身份验证和授权*。现在您已经为应用程序设置了基本路由，需要学习如何在移动到设置带有子组件的延迟加载模块之前调试您的Angular应用程序。
- en: Angular Augury
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular Augury
- en: 'Augury is a Chrome Dev Tools extension for debugging and profiling Angular
    applications. It is a purpose-built tool to help developers visually navigate
    the component tree, inspect the state of the router, and enable break point debugging
    by source-mapping between the generated JavaScript code and the TypeScript code
    that the developer coded in. You can download Augury from [augury.angular.io](http://augury.angular.io).
    Once installed, when you open Chrome Dev Tools for your Angular app, you''ll note
    a new tab for Augury, as illustrated:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Augury是用于调试和分析Angular应用程序的Chrome Dev Tools扩展。这是一个专门为帮助开发人员直观地浏览组件树、检查路由状态并通过源映射在生成的JavaScript代码和开发人员编写的TypeScript代码之间启用断点调试的工具。您可以从[augury.angular.io](http://augury.angular.io)下载Augury。安装后，当您为Angular应用程序打开Chrome
    Dev Tools时，您会注意到一个新的Augury标签，如下所示：
- en: '![](Images/a1606151-2a70-4096-8584-6a92f3a908fe.png)Chrome Dev Tools Augury'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome Dev Tools Augury
- en: 'Augury provides useful and critical information in understanding how your Angular
    app is behaving at runtime:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Augury在理解您的Angular应用程序在运行时的行为方面提供了有用和关键的信息：
- en: Current Angular version is listed, in this case, as version 5.1.2
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前的Angular版本列出为版本5.1.2
- en: Component Tree
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件树
- en: Router Tree shows all the routes that have been configured in the app
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由器树显示了应用程序中配置的所有路由
- en: NgModules shows the `AppModule` and Sub-Modules of the app
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NgModules显示了`AppModule`和应用程序的子模块
- en: Component Tree
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件树
- en: 'The Component Tree tab shows how all app components are related and how they
    interact with each other:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 组件树选项卡显示了所有应用程序组件之间的关系以及它们如何相互作用：
- en: 'Select a particular component, such as `HomeComponent`, as follows:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择特定组件，如`HomeComponent`，如下所示：
- en: '![](Images/9149a7d0-d849-4eb5-a669-d1a34a27b6ac.png)Augury Component Tree'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/9149a7d0-d849-4eb5-a669-d1a34a27b6ac.png)Augury组件树'
- en: The Properties tab on the right-hand side will display a link called View Source,
    which you can use to debug your component. Further below, you will be able to
    observe the state of properties of the component, such as the displayLogin boolean,
    including services that you have injected into the component and their state.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的属性选项卡将显示一个名为“查看源代码”的链接，您可以使用它来调试您的组件。在下面更深的地方，您将能够观察组件属性的状态，例如displayLogin布尔值，包括您注入到组件中的服务及其状态。
- en: You can change the value of any property by double-clicking on the value. For
    example, if you would like to change the value of displayLogin to `false`, simply
    double-click on the blue box that contains the true value and type in false. You
    will be able to observe the effects of your changes in your Angular app.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过双击值来更改任何属性的值。例如，如果您想将displayLogin的值更改为`false`，只需双击包含true值的蓝色框并输入false。您将能够观察到您的更改在您的Angular应用程序中的影响。
- en: In order to observe the runtime component hierarchy of `HomeComponent`, you
    can observe the Injector Graph.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了观察`HomeComponent`的运行时组件层次结构，您可以观察注射器图。
- en: 'Click on the Injector Graph tab, as shown:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击注射器图选项卡，如下所示：
- en: '![](Images/7a070a59-28ee-47dd-9537-c6abf5dfd6a9.png)Augury Injector Graph'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/7a070a59-28ee-47dd-9537-c6abf5dfd6a9.png)Augury注射器图'
- en: This view shows how your selected component came to be rendered. In this case,
    we can observe that `HomeComponent` was rendered within `AppComponent`. This visualization
    can be very helpful in tracking down the implementation of a particular component
    in an unfamiliar code base or where a deep component tree exists.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 该视图显示了您选择的组件是如何被渲染的。在这种情况下，我们可以观察到`HomeComponent`在`AppComponent`内部被渲染。这种可视化在追踪陌生代码库中特定组件的实现或存在深层组件树的情况下非常有帮助。
- en: Break point debugging
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断点调试
- en: Let me restate, for the record, that `console.log` statements shall never be
    checked in to your repository. In general, they are a waste of your time, because
    it requires editing code and later cleaning up your code. Furthermore, Augury
    already provides the state of your components, so in straightforward cases, you
    should be able to leverage it observe or coerce state.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我再次重申，`console.log`语句绝对不应该提交到您的代码库中。一般来说，它们是浪费您的时间，因为它需要编辑代码，然后清理您的代码。此外，Augury已经提供了您组件的状态，因此在简单的情况下，您应该能够利用它来观察或强制状态。
- en: There are some niche use cases, where `console.log` statements can be useful. These
    are mostly asynchronous workflows that operate in parallel and are dependent on
    timely user interaction. In these cases, console logs can help you better understand
    the flow of events and interaction between various components.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特定用例，其中`console.log`语句可能会有用。这些大多是并行操作的异步工作流，并且依赖于及时的用户交互。在这些情况下，控制台日志可以帮助您更好地理解事件流和各个组件之间的交互。
- en: Augury is not yet sophisticated enough to resolve asynchronous data or data
    returned via functions. There are other common cases, where you would like to
    observe the state of properties as they are being set, and even be able to change
    their values on the fly to force your code to execute branching logic in `if`-`else`
    or `switch` statements. For these cases, you should be using break point debugging.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Augury目前还不够复杂，无法解决异步数据或通过函数返回的数据。还有其他常见情况，你可能希望观察属性的状态在设置时，甚至能够实时更改它们的值，以强制代码执行`if`-`else`或`switch`语句中的分支逻辑。对于这些情况，你应该使用断点调试。
- en: 'Let''s presume that some basic logic exists on `HomeComponent`, which sets
    a `displayLogin` `boolean`, based on an `isAuthenticated` value retrieved from
    an `AuthService`, as demonstrated:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`HomeComponent`上存在一些基本逻辑，它根据从`AuthService`获取的`isAuthenticated`值设置了一个`displayLogin`布尔值，如下所示：
- en: '[PRE27]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now observe the state of the value of `displayLogin` and the `isAuthenticated`
    function as they are being set, then observe the change in the value of `displayLogin`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在观察`displayLogin`的值和`isAuthenticated`函数在设置时的状态，然后观察`displayLogin`值的变化：
- en: Click on the View Source link on `HomeComponent`
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`HomeComponent`上的查看源链接
- en: Drop a break point on the first line inside the `ngOnInit` function
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ngOnInit`函数内的第一行上设置一个断点
- en: Refresh the page
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新页面
- en: 'Chrome Dev Tools will switch over to the Source tab, and you''ll see your break
    point hit, as highlighted in blue here:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Chrome Dev Tools将切换到源标签页，你会看到断点被触发，如蓝色所示：
- en: '![](Images/f5c756b8-0127-47e6-bbe3-b838ed2b9af7.png)Chrome Dev Tools break
    point debugging'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/f5c756b8-0127-47e6-bbe3-b838ed2b9af7.png)Chrome Dev Tools断点调试'
- en: Hover over `this.displayLogin` and observe that its value is set to `true`
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 悬停在`this.displayLogin`上并观察其值设置为`true`
- en: If hovering over `this.authService.isAuthenticated()`, you will not be able
    to observe its value
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果悬停在`this.authService.isAuthenticated()`上，你将无法观察到其值
- en: While your break point is hit, you can access the current scope of the state
    in the console, which means you can execute the function and observe its value.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的断点被触发时，你可以在控制台中访问当前状态的作用域，这意味着你可以执行函数并观察其值。
- en: 'Execute `isAuthenticated()` in the console:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中执行`isAuthenticated()`：
- en: '[PRE28]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You'll observe that it returns `true`, which is what `this.displayLogin` is
    set to. You can still coerce the value of `displayLogin` in the console.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到它返回了`true`，这就是`this.displayLogin`的设置值。你仍然可以在控制台中强制转换`displayLogin`的值。
- en: 'Set `displayLogin` to `false`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`displayLogin`设置为`false`：
- en: '[PRE29]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you observe the value of `displayLogin`, either by hovering over it or retrieving
    it from the control, you'll see that the value is set to `false`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你观察`displayLogin`的值，无论是悬停在上面还是从控制台中检索，你会发现值被设置为`false`。
- en: Leveraging break point debugging basics, you can debug complicated scenarios
    without changing your source code at all.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 利用断点调试基础知识，你可以在不改变源代码的情况下调试复杂的场景。
- en: Router Tree
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由树
- en: 'The Router Tree tab will display the current state of the router. This can
    be a very helpful tool in visualizing the relationship between routes and components,
    as shown:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 路由树标签将显示路由的当前状态。这可以是一个非常有用的工具，可以帮助你可视化路由和组件之间的关系，如下所示：
- en: '![](Images/31dc905e-b0e8-43af-bf4f-4354bc30a8ce.png)Augury Router Tree'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/31dc905e-b0e8-43af-bf4f-4354bc30a8ce.png)Augury路由树'
- en: The preceding router tree demonstrates a deeply nested routing structure with
    master-detail views. You can see the absolute path and parameters required to
    render a given component by clicking on the circular node.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的路由树展示了一个深度嵌套的路由结构，其中包含主细节视图。你可以通过点击圆形节点来查看渲染给定组件所需的绝对路径和参数。
- en: As you can see, for `PersonDetailsComponent`, it can get complicated to determine,
    exactly, the set of parameters needed to render this detail portion of a master-detail
    view.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于`PersonDetailsComponent`来说，确定需要渲染主细节视图中的详细部分所需的参数集可能会变得复杂。
- en: NgModules
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgModules
- en: 'The NgModules tab displays the `AppModule` and any other submodule that is
    currently loaded into memory:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: NgModules选项卡显示了当前加载到内存中的`AppModule`和任何其他子模块：
- en: Launch the `/home` route of the app
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序的`/home`路由
- en: 'Observe the NgModules tab, as follows:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察NgModules选项卡，如下所示：
- en: '![](Images/c0304718-ed0f-45b5-95a0-e2b33ce8641e.png)Augury NgModules'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/c0304718-ed0f-45b5-95a0-e2b33ce8641e.png)Augury NgModules'
- en: You'll note that only the `AppModule` is loaded. However, since our application
    has a lazy-loaded architecture, none of our other modules are yet loaded.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到只有`AppModule`被加载。但是，由于我们的应用程序采用了延迟加载的架构，我们的其他模块尚未被加载。
- en: Navigate to a page in the `ManagerModule`
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`ManagerModule`中的一个页面
- en: Then, navigate to a page in the `UserModule`
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，导航到`UserModule`中的一个页面
- en: Finally, navigate back to the `/home` route
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，导航回到`/home`路由
- en: 'Observe the NgModules tab, as shown:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察NgModules选项卡，如下所示：
- en: '![](Images/08d7ca69-7989-459b-bdff-77b76691b3d9.png)Augury NgModules with Three
    Modules'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/08d7ca69-7989-459b-bdff-77b76691b3d9.png)Augury NgModules with Three
    Modules'
- en: Now, you'll observe that three modules have been loaded into memory.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您会注意到已经加载了三个模块到内存中。
- en: NgModules is an important tool to visualize the impact of your design and architecture.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: NgModules是一个重要的工具，可以可视化设计和架构的影响。
- en: Submodules with lazy loading
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有延迟加载的子模块
- en: Lazy loading allows the Angular build process, powered by webpack, to separate
    our web application into different JavaScript files called chunks. By separating
    out portions of the application into separate submodules, we allow these modules
    and their dependencies to be bundled into separate chunks, thus keeping the initial JavaScript
    bundle size to a minimum. As the application grows, the time to first meaningful
    paint remains a constant, instead of consistently increasing over time. Lazy loading
    is critical to achieving a scalable application architecture.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟加载允许由webpack驱动的Angular构建过程将我们的Web应用程序分隔成不同的JavaScript文件，称为块。通过将应用程序的部分分离成单独的子模块，我们允许这些模块及其依赖项被捆绑到单独的块中，从而将初始JavaScript捆绑包大小保持在最小限度。随着应用程序的增长，首次有意义的绘制时间保持恒定，而不是随着时间的推移不断增加。延迟加载对于实现可扩展的应用程序架构至关重要。
- en: We will now go over how to set up a submodule with components and routes. We
    will also use Augury to observe the effects of our various router configurations.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍如何设置具有组件和路由的子模块。我们还将使用Augury来观察我们各种路由配置的效果。
- en: Configuring submodules with components and routes
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置具有组件和路由的子模块
- en: 'The manager module needs a landing page, as shown in this mock-up:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 管理模块需要一个着陆页，如此模拟所示：
- en: '![](Images/7dae93fc-fe0e-4ca2-a439-3e58106c8bb9.png)Manager''s DashboardLet''s
    start by creating the home screen for the `ManagerModule`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/7dae93fc-fe0e-4ca2-a439-3e58106c8bb9.png)Manager''s Dashboard让我们从为`ManagerModule`创建主屏幕开始：'
- en: 'Create the `ManagerHome` component:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ManagerHome`组件：
- en: '[PRE30]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In order to create the new component under the `manager` folder, we must prefix
    `manager/` in front of the component name. In addition, we specify that the component
    should be imported and declared with the `ManagerModule`. Since this is another
    landing page, it is unlikely to be complicated enough to require separate HTML
    and CSS files. You can use `--inline-style` (alias `-s`) and/or `--inline-template`
    (alias `-t`) to avoid creating additional files.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`manager`文件夹下创建新组件，我们必须在组件名称前面加上`manager/`前缀。此外，我们指定该组件应该被导入并在`ManagerModule`中声明。由于这是另一个着陆页，它不太可能复杂到需要单独的HTML和CSS文件。您可以使用`--inline-style`（别名`-s`）和/或`--inline-template`（别名`-t`）来避免创建额外的文件。
- en: 'Verify that your folder structure looks as follows:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您的文件夹结构如下：
- en: '[PRE31]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Configure the `ManagerHome` component''s route with `manager-routing.module`,
    similar to how we configured the `Home` component with `app-route.module`:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`manager-routing.module`配置`ManagerHome`组件的路由，类似于我们如何使用`app-route.module`配置`Home`组件：
- en: '[PRE32]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You will note that `http://localhost:5000/manager` doesn't actually resolve
    to a component yet, because our Angular app isn't aware that `ManagerModule` exists.
    Let's first try the brute-force, eager-loading approach to import `manager.module`
    and register the manager route with our app.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到`http://localhost:5000/manager`实际上还没有解析到一个组件，因为我们的Angular应用程序不知道`ManagerModule`的存在。让我们首先尝试强制急加载的方法，导入`manager.module`并注册manager路由到我们的应用程序。
- en: Eager loading
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 急加载
- en: 'This section is purely an exercise to demonstrate how the concepts we have
    learned so far in importing and registering routes doesn''t result in a scalable
    solution, regardless of eagerly or lazily loading components:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分纯粹是为了演示我们迄今为止学到的导入和注册路由的概念，并不会产生可扩展的解决方案，无论是急加载还是懒加载组件：
- en: 'Import the `manager.module` to `app.module`:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`manager.module`导入到`app.module`中：
- en: '[PRE33]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You will note that `http://localhost:5000/manager` still doesn't render its
    home component.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到`http://localhost:5000/manager`仍然没有渲染其主组件。
- en: 'Use Augury to debug the router state, as shown:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Augury调试路由状态，如下所示：
- en: '![](Images/f0329219-b967-45ca-b949-33b7bab07308.png)Router Tree with Eager
    Loading'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/f0329219-b967-45ca-b949-33b7bab07308.png)带有急加载的路由树'
- en: It seems as if the `/manager` path is correctly registered and pointed at the
    correct component, `ManagerHomeComponent`. The issue here is that the `rootRouter` configured
    in `app-routing.module` isn't aware of the `/manager` path, so the `**` path is
    taking precedence and rendering the `PageNotFoundComponent` instead.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 似乎`/manager`路径已经正确注册并指向正确的组件`ManagerHomeComponent`。问题在于`app-routing.module`中配置的`rootRouter`并不知道`/manager`路径，因此`**`路径优先，并渲染`PageNotFoundComponent`。
- en: 'As a final exercise, implement the `''manager''` path in `app-routing.module`
    and assign `ManagerHomeComponent` to it as you would normally:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后的练习，在`app-routing.module`中实现`'manager'`路径，并像平常一样将`ManagerHomeComponent`分配给它：
- en: '[PRE34]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You'll now note that `http://localhost:5000/manager` renders correctly, by displaying
    `manager-home works!`; however, if you debug the router state through Augury,
    you will note that the `/manager` is registered twice.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您会注意到`http://localhost:5000/manager`正确显示`manager-home works!`；然而，如果您通过Augury调试路由状态，您会注意到`/manager`注册了两次。
- en: This solution doesn't scale well, because it forces all developers to maintain
    a single master file to import and configure every module. It is ripe for merge
    conflicts and frustration, hoping that team members do not register the same route
    multiple times.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案不太可扩展，因为它强制所有开发人员维护一个单一的主文件来导入和配置每个模块。它容易产生合并冲突和沮丧，希望团队成员不会多次注册相同的路由。
- en: 'It is possible to engineer a solution to divide up the modules into multiple
    files. Instead of the standard `*-routing.module`, you can implement the Route
    array in `manager.module` and export it. Consider the following example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设计一个解决方案将模块分成多个文件。您可以在`manager.module`中实现Route数组并导出它，而不是标准的`*-routing.module`。考虑以下示例：
- en: '[PRE35]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'These files will then need to be individually imported into `app-routing.module`
    and configured using the `children` attribute:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 然后需要将这些文件单独导入到`app-routing.module`中，并使用`children`属性进行配置：
- en: '[PRE36]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This solution will work and it is a correct solution, as demonstrated by the
    Augury Router tree here:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案将起作用，这是一个正确的解决方案，正如Augury路由树所示：
- en: '![](Images/5ca66d17-bbea-47b3-ae9d-2ce7bb069aaf.png)Router Tree with children
    routes'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/5ca66d17-bbea-47b3-ae9d-2ce7bb069aaf.png)带有子路由的路由树'
- en: There are no duplicate registrations, because we removed `manager-routing.module`.
    In addition, we don't have to import `ManagerHomeComponent` outside of `manager.module`,
    resulting in a much better scalable solution. However, as the app grows, we must
    still register modules with `app.module`, and the submodules are still coupled
    to the parent `app.module` in potentially unpredictable ways. Further, this code
    can't be chunked, because any code that is imported using import is viewed as
    a hard dependency.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 没有重复的注册，因为我们删除了`manager-routing.module`。此外，我们不必在`manager.module`之外导入`ManagerHomeComponent`，从而得到一个更好的可扩展解决方案。然而，随着应用程序的增长，我们仍然必须在`app.module`中注册模块，并且子模块仍然以潜在不可预测的方式耦合到父`app.module`中。此外，这段代码无法被分块，因为使用`import`导入的任何代码都被视为硬依赖。
- en: Lazy loading
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载
- en: Now that you understand how eager-loading of modules work, you will be able
    to better understand the code we are about to write, which may otherwise seem
    like black-magic, and magical (aka misunderstood) code always leads to spaghetti
    architectures.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了模块的急加载如何工作，您将能够更好地理解我们即将编写的代码，否则这些代码可能看起来像黑魔法，而神奇（也就是被误解的）代码总是导致意大利面式架构。
- en: 'We will now evolve the eager-loading solution to be a lazy-loading one. In
    order to load routes from a different module, we know we can''t simply import
    them, otherwise they will be eagerly loaded. The answer lies in configuring a
    route using the `loadChildren` attribute with string informing the Router how
    to load a submodule in `app-routing.module.ts`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将急加载解决方案演变为懒加载解决方案。为了从不同模块加载路由，我们知道不能简单地导入它们，否则它们将被急加载。答案在于在`app-routing.module.ts`中使用`loadChildren`属性配置路由，该属性使用字符串通知路由器如何加载子模块：
- en: Ensure that any module you intend to lazy load is *not* imported in ``app.module``
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您打算懒加载的任何模块都*不*被导入到`app.module`中
- en: Remove any routes added to `ManagerModule`
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除添加到`ManagerModule`的任何路由
- en: Ensure that `ManagerRoutingModule` is imported into `ManagerModule`
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`ManagerRoutingModule`被导入到`ManagerModule`中。
- en: 'Implement or update the manager path with the `loadChildren` attribute:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`loadChildren`属性实现或更新管理器路径：
- en: '[PRE37]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Lazy loading is achieved via a clever trick that avoids using an `import` statement.
    A string literal with two parts is defined, where the first part defines the location
    of the module file, such as `app/manager/manager.module`, and the second part
    defines the class name of the module. A string can be interpreted during the build
    process and at runtime, to dynamically create chunks, load the right module and
    instantiate the correct class. `ManagerModule` then acts as if its own Angular
    app and manages all of its children dependencies and routes.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载是通过一个巧妙的技巧实现的，避免使用`import`语句。定义一个具有两部分的字符串文字，其中第一部分定义了模块文件的位置，例如`app/manager/manager.module`，第二部分定义了模块的类名。在构建过程和运行时可以解释字符串，以动态创建块，加载正确的模块并实例化正确的类。`ManagerModule`然后就像它自己的Angular应用程序一样，管理着所有子依赖项和路由。
- en: 'Update the `manager-routing.module` routes, considering that manager is now
    their root route:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`manager-routing.module`路由，考虑到manager现在是它们的根路由：
- en: '[PRE38]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can now update the route for `ManagerHomeComponent` to a more meaningful
    `'home'` path. This path won't clash with the one found in `app-routing.module`,
    because in this context, `'home'` resolves to `'manager/home'` and, similarly,
    where path is empty, the URL will look like `http://localhost:5000/manager`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将`ManagerHomeComponent`的路由更新为更有意义的`'home'`路径。这个路径不会与`app-routing.module`中找到的路径冲突，因为在这个上下文中，`'home'`解析为`'manager/home'`，同样，当路径为空时，URL看起来像`http://localhost:5000/manager`。
- en: 'Confirm that lazy loading is working by looking at Augury, as follows:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查看Augury来确认懒加载是否起作用，如下所示：
- en: '![](Images/cefe01e3-4052-4e6f-913d-cd3d872cbfa0.png)Router Tree with lazy loadingThe
    root node for `ManagerHomeComponent` is now named `manager [Lazy]`.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/cefe01e3-4052-4e6f-913d-cd3d872cbfa0.png)带有延迟加载的路由树`ManagerHomeComponent`的根节点现在命名为`manager
    [Lazy]`。'
- en: Completing the walking skeleton
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成骨架走向
- en: 'Using the site map, we have created for LemonMart, from earlier in the chapter,
    we need to complete the walking skeleton navigation experience for the app. In
    order to create this experience, we will need to create some buttons to link all
    modules and components together. We will go at this module by module:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在本章前面创建的LemonMart站点地图，我们需要完成应用程序的骨架导航体验。为了创建这种体验，我们需要创建一些按钮来链接所有模块和组件。我们将逐个模块进行：
- en: 'Before we start, update the login button on `home.component` to link to the
    `Manager` module:'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始之前，更新`home.component`上的登录按钮，链接到`Manager`模块：
- en: '[PRE39]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Manager module
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理模块
- en: Since we already enabled lazy loading for `ManagerModule`, let's go ahead and
    complete the rest of the navigational elements for it.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经为`ManagerModule`启用了延迟加载，让我们继续完成它的其他导航元素。
- en: In the current setup, `ManagerHomeComponent` renders in the `<router-outlet>`
    defined in `app.component`, so when the user navigates from `HomeComponent` to
    `ManagerHomeComponent`, the toolbar implemented in `app.component` remains a constant.
    If we implement a similar toolbar that persists throughout `ManagerModule`, we
    can create a consistent UX for navigating subpages across modules.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前设置中，`ManagerHomeComponent`在`app.component`中定义的`<router-outlet>`中呈现，因此当用户从`HomeComponent`导航到`ManagerHomeComponent`时，`app.component`中实现的工具栏保持不变。如果我们在`ManagerModule`中实现类似的工具栏，我们可以为跨模块导航子页面创建一致的用户体验。
- en: 'For this to work, we need to replicate the parent-child relationship between
    `app.component` and `home/home.component`, where the parent implements the toolbar
    and a `<router-outlet>` so that children elements can be rendered in there:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个工作，我们需要复制`app.component`和`home/home.component`之间的父子关系，其中父级实现工具栏和`<router-outlet>`，以便子元素可以在其中呈现：
- en: 'Start by creating the base `manager` component:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建基本的`manager`组件：
- en: '[PRE40]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `--flat` option skips directory creation and places the component directly
    under the `manager` folder, just like `app.component` residing directly under
    the `app` folder.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`--flat`选项跳过目录创建，直接将组件放在`manager`文件夹下，就像`app.component`直接放在`app`文件夹下一样。'
- en: 'Implement a navigational toolbar with `activeLink` tracking:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`activeLink`跟踪实现导航工具栏：
- en: '[PRE41]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It must be noted that submodules don't automatically have access to services
    or components created in parent modules. This is an important default behavior
    to preserve a decoupled architecture. However, there are certain cases where it
    is desirable to share some amount of code. In this case, `mat-toolbar` needs to
    be reimported. Since the `MatToolbarModule` is already loaded in `src/app/material.module.ts`,
    we can just import this module into `manager.module.ts` and there will not be
    a performance or memory penalty for doing so.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，子模块不会自动访问父模块中创建的服务或组件。这是为了保持解耦架构的重要默认行为。然而，在某些情况下，有必要共享一些代码。在这种情况下，需要重新导入`mat-toolbar`。由于`MatToolbarModule`已经在`src/app/material.module.ts`中加载，我们可以将这个模块导入到`manager.module.ts`中，这样做不会产生性能或内存开销。
- en: '`ManagerComponent` should be imported into `ManagerModule`:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ManagerComponent`应该被导入到`ManagerModule`中：'
- en: '[PRE42]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create components for the subpages:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为子页面创建组件：
- en: '[PRE43]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create the parent/children routing. We know that we need the following routes
    to be able to navigate to our subpages, as follows:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建父/子路由。我们知道我们需要以下路由才能导航到我们的子页面，如下所示：
- en: '[PRE44]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In order to target the `<router-outlet>` defined in `manager.component`, we
    need to create a parent route first and then specify routes for the subpages:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定位在`manager.component`中定义的`<router-outlet>`，我们需要首先创建一个父路由，然后为子页面指定路由：
- en: '[PRE45]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You should now be able to navigate through the app. When you click on the Login
    as Manager button, you will be taken to the page shown here. The clickable targets
    are highlighted, as shown:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该能够浏览应用程序。当您单击“登录为经理”按钮时，您将被带到此处显示的页面。可单击的目标已突出显示，如下所示：
- en: '![](Images/16f4d60a-a3a9-4f65-9f74-992c704c63f2.png)Manager''s Dashboard with
    clickable targets highlighted'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/16f4d60a-a3a9-4f65-9f74-992c704c63f2.png)带有可单击目标的经理仪表板
- en: If you click on LemonMart, you will be taken to the home page. If you click
    on Manager's Dashboard, User Management or Receipt Lookup, you will be navigated
    to the corresponding subpage, while active link will be bold and underlined on
    the toolbar.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您单击LemonMart，您将被带到主页。如果您单击“经理仪表板”，“用户管理”或“收据查找”，您将被导航到相应的子页面，而工具栏上的活动链接将以粗体和下划线显示。
- en: User module
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户模块
- en: 'Upon login, users will be able to access their profiles and view a list of
    actions they can access in the LemonMart app through a side navigation menu. In
    [Chapter 9](55413e2b-68e2-4dd0-9018-133008fc3321.xhtml), *Design Authentication
    and Authorization*, when we implement authentication and authorization, we will
    be receiving the role of the user from the server. Based on the role of the user,
    we will be able to automatically navigate or limit the options users can see.
    We will implement these components in this module so that they will only be loaded
    once a user is logged in. For the purpose of completing the walking skeleton,
    we will ignore authentication-related concerns:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，用户将能够通过侧边导航菜单访问其个人资料，并查看他们可以在LemonMart应用程序中访问的操作列表。在[第9章](55413e2b-68e2-4dd0-9018-133008fc3321.xhtml)中，*设计身份验证和授权*，当我们实现身份验证和授权时，我们将从服务器接收用户的角色。根据用户的角色，我们将能够自动导航或限制用户可以看到的选项。我们将在此模块中实现这些组件，以便它们只在用户登录后加载一次。为了完成骨架的搭建，我们将忽略与身份验证相关的问题：
- en: 'Create the necessary components:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建必要的组件：
- en: '[PRE47]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Implement routing:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现路由：
- en: 'Start with implementing the lazy loading in `app-routing`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 从在`app-routing`中实现懒加载开始：
- en: '[PRE48]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Ensure that  `PageNotFoundComponent` route is always the last route in `app-routing.module`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`app-routing.module`中的`PageNotFoundComponent`路由始终是最后一个路由。
- en: 'Now implement the child routes in `user-routing`:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`user-routing`中实现子路由：
- en: '[PRE49]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We are implementing routing for `NavigationMenuComponent`, because it'll be
    directly used as an HTML element. In addition, since `userModule` doesn't have
    a landing page, there's no default path defined.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在为`NavigationMenuComponent`实现路由，因为它将直接用作 HTML 元素。此外，由于`userModule`没有着陆页面，因此没有定义默认路径。
- en: 'Wire up the user and logout icons:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接用户和注销图标：
- en: '[PRE50]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Icon buttons can be cryptic, so it's a good idea to add tooltips to them. In
    order for tooltips to work, switch from the `mat-icon-button` directive to the `mat-mini-fab`
    directive and ensure that you import `MatTooltipModule` in `material.module`.
    In addition, ensure that you add `aria-label` for icon only buttons so that users
    with disabilities relying on screen readers can still navigate your web application.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 图标按钮可能会让人费解，因此最好为它们添加工具提示。为了使工具提示起作用，请从`mat-icon-button`指令切换到`mat-mini-fab`指令，并确保在`material.module`中导入`MatTooltipModule`。此外，确保为仅包含图标的按钮添加`aria-label`，以便依赖屏幕阅读器的残障用户仍然可以浏览您的
    Web 应用程序。
- en: Ensure that the app works.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保应用程序正常运行。
- en: 'You''ll note that the two buttons are too close to each other, as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，两个按钮彼此之间距离太近，如下所示：
- en: '![](Images/daf74636-eb0d-4688-bca3-2305ebb2ecc3.png)Toolbar with icons'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: ！[](Images/daf74636-eb0d-4688-bca3-2305ebb2ecc3.png)带图标的工具栏
- en: 'You can fix the icon layout issue by adding `fxLayoutGap="8px"` to `<mat-toolbar>`;
    however, now the lemon logo is too far apart from the app name, as shown:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过在`<mat-toolbar>`中添加`fxLayoutGap="8px"`来解决图标布局问题；然而，现在柠檬标志与应用程序名称相距太远，如图所示：
- en: '![](Images/83d825ac-5e6f-474f-913f-c5773d0780ab.png)Toolbar with padded icons'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/83d825ac-5e6f-474f-913f-c5773d0780ab.png)带有填充图标的工具栏'
- en: 'The logo layout issue can be fixed by merging the icon and the button:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过合并图标和按钮来解决标志布局问题：
- en: '[PRE51]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As shown in the following screenshot, the grouping fixes the layout issue:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，分组修复了布局问题：
- en: '![](Images/6bcb1dd7-d85d-479a-ae80-8eb0e03656e3.png)Toolbar with grouped and
    padded elements'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/6bcb1dd7-d85d-479a-ae80-8eb0e03656e3.png)带有分组和填充元素的工具栏'
- en: This is a more desirable from a UX perspective as well; now users can go back
    to the home page by clicking on the lemon as well.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户体验的角度来看，这更加理想；现在用户也可以通过点击柠檬返回到主页。
- en: POS and inventory modules
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POS和库存模块
- en: Our walking skeleton presumes the role of the manager. To be able to access
    all components we are about to create, we need to enable the manager to be able
    to access pos and inventory modules.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本框架假定经理的角色。为了能够访问我们即将创建的所有组件，我们需要使经理能够访问pos和inventory模块。
- en: 'Update `ManagerComponent` with two new buttons:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`ManagerComponent`，添加两个新按钮：
- en: '[PRE52]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that these router links will navigate use out of `ManagerModule`, so it
    is normal for the toolbar to disappear.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些路由链接将会将我们从“ManagerModule”中导航出去，因此工具栏消失是正常的。
- en: Now, it'll be up to you to implement the last two remaining modules.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要实现剩下的两个模块。
- en: POS module
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POS模块
- en: 'POS module is very similar to the user module, except that `PosComponent` will
    be the default route. This will be a complicated component with some subcomponents,
    so ensure that it is created with a directory:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: POS模块与用户模块非常相似，只是`PosComponent`将成为默认路由。这将是一个复杂的组件，带有一些子组件，因此请确保它是在一个目录中创建的：
- en: Create the `PosComponent`
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`PosComponent`
- en: Register `PosComponent` as the default route
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“PosComponent”注册为默认路由
- en: Configure lazy loading for `PosModule`
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为“PosModule”配置延迟加载
- en: Ensure that the app works
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保应用程序正常运行
- en: Inventory module
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库存模块
- en: 'Inventory module is very similar to `ManagerModule`, as shown:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 库存模块与“ManagerModule”非常相似，如图所示：
- en: '![](Images/a2721b96-90be-449b-b50e-5988fb751ee1.png)Inventory Dashboard mock-up'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/a2721b96-90be-449b-b50e-5988fb751ee1.png)库存仪表盘模拟'
- en: Create a base `Inventory` component
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建基本的“Inventory”组件
- en: Register the `MaterialModule`
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册“MaterialModule”
- en: Create Inventory Dashboard, Stock Entry, Products, and Categories components
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建库存仪表盘、库存录入、产品和类别组件
- en: Configure parent-children routes in `inventory-routing.module`
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“inventory-routing.module”中配置父子路由
- en: Configure lazy loading for ``InventoryModule``
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为“InventoryModule”配置延迟加载
- en: 'Ensure that app works, as shown:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保应用程序正常运行，如下所示：
- en: '![](Images/f88c694c-8e92-47c3-bc73-c713a735534c.png)LemonMart Inventory Dashboard'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/f88c694c-8e92-47c3-bc73-c713a735534c.png)LemonMart库存仪表盘'
- en: Now that the walking skeleton of the app is completed, it is important to inspect
    the router tree to ensure that lazy loading has been configured correctly and
    module aren't unintentionally being eager loaded.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序的基本框架已经完成，重要的是检查路由树，以确保延迟加载已经正确配置，并且模块没有意外地急加载。
- en: Inspect router tree
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查路由树
- en: 'Navigate to the base route of the app and use Augury to inspect the router
    tree, as illustrated:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到应用程序的基本路由，并使用Augury检查路由树，如图所示：
- en: '![](Images/23455131-eadf-44ea-b937-3f331d03b588.png)Router Tree with eager
    loading mistakes'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/23455131-eadf-44ea-b937-3f331d03b588.png)急加载错误的路由树'
- en: Everything, but initially required components, should be denoted with the [Lazy]
    attribute. If, for some reason, routes are not denoted with [Lazy], chances are
    that they are mistakenly being imported in `app.module` or some other component.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最初需要的组件之外，其他所有内容都应该用[Lazy]属性标记。如果由于某种原因，路由没有用[Lazy]标记，那么它们很可能被错误地导入到`app.module`或其他组件中。
- en: In the preceding screenshot, you may note that `ProfileComponent` and `LogoutComponent`
    are eagerly loaded, whereas the `user` module is correctly labeled as [Lazy].
    Even multiple visual inspections through the tooling and the code base may leave
    you searching for the culprit. However, if you run a global search for `UserModule`,
    you'll quickly discover that it was being imported into `app.module`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，您可能会注意到`ProfileComponent`和`LogoutComponent`是急加载的，而`user`模块被正确标记为[Lazy]。即使通过工具和代码库进行多次视觉检查，也可能让您寻找罪魁祸首。但是，如果您全局搜索`UserModule`，您很快就会发现它被导入到`app.module`中。
- en: 'To be on the safe side make sure to remove any import statements for modules
    in `app.module` and your file should look like the one below:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，请确保删除`app.module`中的模块导入语句，您的文件应该像下面这样：
- en: '[PRE53]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The next screenshot shows the corrected router tree:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张截图显示了修正后的路由器树：
- en: '![](Images/a0e0138e-e2be-48a1-8e2c-c8a86f7b2ca0.png)Router Tree with lazy loadingEnsure
    that `npm test` and `npm run e2e` executes without errors before moving on.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/a0e0138e-e2be-48a1-8e2c-c8a86f7b2ca0.png)带有延迟加载的路由器树确保在继续之前执行`npm
    test`和`npm run e2e`时没有错误。'
- en: Common Testing Module
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用测试模块
- en: Now that we have a lot of modules to deal with, it becomes tedious to configure
    the imports and providers for each spec file individually. For this purpose, I
    recommend creating a common testing module to contain generic configuration that
    you can reuse across the board.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有很多模块要处理，配置每个规范文件的导入和提供者变得很繁琐。为此，我建议创建一个通用测试模块，其中包含您可以在各个领域重复使用的通用配置。
- en: First start by creating a new `.ts` file.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的`.ts`文件。
- en: Create `common/common.testing.ts`
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`common/common.testing.ts`
- en: 'Populate it with common testing providers, fakes and modules, shown as follows:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用通用测试提供者、虚拟和模块填充它，如下所示：
- en: I have provided fake implementations of `ObservableMedia`, `MatIconRegistry`,
    `DomSanitizer`, along with arrays for `commonTestingProviders` and `commonTestingModules`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提供了`ObservableMedia`、`MatIconRegistry`、`DomSanitizer`的虚拟实现，以及`commonTestingProviders`和`commonTestingModules`的数组。
- en: '[PRE54]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now let''s see a sample use of this shared configuration file:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下这个共享配置文件的示例用法：
- en: '[PRE55]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Most other modules will just need `commonTestingModules` to be imported.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数其他模块只需要导入`commonTestingModules`。
- en: Don't move on until all your tests are passing!
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有测试通过之前不要继续前进！
- en: Summary
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you mastered how to effectively use Angular CLI to create major
    Angular components and scaffolds. You created the branding of your app, leveraging
    custom and built-in Material iconography. You learned how to debug complicated
    Angular apps with Augury. Finally, you began building Router-first apps, defining
    user roles early on, designing with lazy loading in mind and nailing down a walking-skeleton
    navigation experience early on.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何有效地使用Angular CLI来创建主要的Angular组件和脚手架。您创建了您的应用的品牌，利用了自定义和内置的Material图标。您学会了如何使用Augury调试复杂的Angular应用。最后，您开始构建基于路由器的应用程序，尽早定义用户角色，考虑懒加载的设计，并尽早确定行走骨架导航体验。
- en: 'To recap, in order to pull off a Router-first implementation, you need to do
    this:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，为了实现基于路由器的实现，您需要这样做：
- en: Define user roles early on
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽早定义用户角色
- en: Design with lazy loading in mind
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑懒加载的设计
- en: Implement a walking-skeleton navigation experience
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个行走骨架导航体验
- en: Design around major data components
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 围绕主要数据组件进行设计
- en: Enforce a decoupled component architecture
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强制执行解耦的组件架构
- en: Differentiate between user controls and components
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 区分用户控件和组件
- en: Maximize code reuse
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最大程度地重用代码
- en: In this chapter, you executed steps 1-3; in the next three chapters, you will
    execute steps 4-7\. In [Chapter 8](efa828d3-c66a-4fa9-9b31-11a42937253a.xhtml),
    *Continuous Integration and API Design, *we will go over designing around major
    data components and enable Continuous Integration to ensure a high-quality deliverable.
    In [Chapter 9](55413e2b-68e2-4dd0-9018-133008fc3321.xhtml), *Design Authentication
    and Authorization*, we will deep dive into security considerations and design
    a conditional navigation experience. In [Chapter 10](99f040e3-89f0-4ac8-a849-4cef38e7a992.xhtml),
    *Angular App Design and Recipes*, we will tie everything together by sticking
    to a decoupled component architecture, smartly choosing between creating user
    controls versus components and maximizing code reuse with various TypeScript,
    RxJS, and Angular coding techniques.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，您执行了1-3步；在接下来的三章中，您将执行4-7步。在[第8章](efa828d3-c66a-4fa9-9b31-11a42937253a.xhtml)中，《持续集成和API设计》，我们将讨论围绕主要数据组件进行设计，并启用持续集成以确保高质量的可交付成果。在[第9章](55413e2b-68e2-4dd0-9018-133008fc3321.xhtml)中，《设计身份验证和授权》，我们将深入探讨安全考虑，并设计有条件的导航体验。在[第10章](99f040e3-89f0-4ac8-a849-4cef38e7a992.xhtml)中，《Angular应用设计和配方》，我们将通过坚持解耦的组件架构，巧妙选择创建用户控件与组件，并利用各种TypeScript、RxJS和Angular编码技术来最大程度地重用代码。
