- en: Going into Production
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入生产环境
- en: Our application is almost ready and it's time to go into production. Since this
    is the age of cloud computing, we will be deploying our application to a cloud
    provider—Heroku, to be specific. Before we go on and deploy intended for Linux,
    but it is possible to use it with Mac and Windows using tools such as our application
    into production, we need to make sure our application is production ready in our
    local environment. It would also be beneficial to make ourselves familiar with
    technologies and tools that will be useful at this stage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序几乎准备好了，现在是时候进入生产环境了。由于这是云计算的时代，我们将把我们的应用程序部署到云服务提供商——具体来说，是Heroku。在我们继续部署我们的应用程序到生产环境之前，我们需要确保我们的应用程序在我们的本地环境中已经准备好。熟悉在这个阶段将会有用的技术和工具也会很有益处。
- en: 'In this chapter, we will learn about the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: An introduction to Docker
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker简介
- en: Starting the production database with Docker
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker启动生产数据库
- en: An introduction to Spring profiles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring配置简介
- en: Packaging the application for local deployment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包应用程序以进行本地部署
- en: Upgrading to the newest version of JHipster
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级到JHipster的最新版本
- en: An introduction to the deployment options supported by JHipster
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JHipster支持的部署选项简介
- en: Production deployment to Heroku cloud
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Heroku云上进行生产部署
- en: An Introduction to Docker
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker简介
- en: Docker is one of the most disruptive technologies to have taken center stage
    in the world of DevOps in recent times. Docker is a technology that enables operating-system-level
    virtualization or containerization, and is also open source and free to use. Docker
    is intended for Linux, but it is possible to use it with Mac and Windows using
    tools such as Docker for Mac and Docker for Windows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是近年来在DevOps领域占据中心舞台的最具颠覆性的技术之一。Docker是一种使操作系统级别的虚拟化或容器化成为可能的技术，它也是开源的，并且可以免费使用。Docker旨在用于Linux，但可以使用Docker
    for Mac和Docker for Windows等工具在Mac和Windows上使用。
- en: Docker containers
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker容器
- en: 'When we talk about containers in the Docker world, we are technically talking
    about Linux containers. As stated by Red Hat on their website ([https://www.redhat.com/en/topics/containers/whats-a-linux-container](https://www.redhat.com/en/topics/containers/whats-a-linux-container)):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Docker世界中谈论容器时，从技术上讲，我们是在谈论Linux容器。正如红帽在其网站上所述（[https://www.redhat.com/en/topics/containers/whats-a-linux-container](https://www.redhat.com/en/topics/containers/whats-a-linux-container)）：
- en: A Linux container is a set of processes that are isolated from the rest of the
    system, running from a distinct image that provides all files necessary to support
    the processes. By providing an image that contains all of an application’s dependencies,
    it is portable and consistent as it moves from development to testing, and finally
    to production.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Linux容器是一组从系统其余部分隔离出来的进程，它们从一个提供所有必要文件以支持这些进程的独立镜像中运行。通过提供一个包含应用程序所有依赖项的镜像，它在从开发到测试，最后到生产的移动过程中是可移植的和一致的。
- en: Though the concept is not new, Docker makes it possible to create containers
    that are easy to build, deploy, version, and share. A Docker container only contains
    dependencies that are required for the application to run on the host OS; it shares
    the OS and other dependencies for the host system hardware. This makes a Docker
    container lighter than a **virtual machine** (**VM**) in terms of size and resource
    usage as it doesn't have to ship an entire OS and emulate virtual hardware. Hence, Docker
    made virtual machines obsolete in many of the traditional use cases that were
    handled using VM technologies. This also means that, with Docker, we will be able
    to run more applications on the same hardware compared to running with VMs. Docker
    containers are instances of a docker image, which is a set of layers which describes
    the application that is being containerized. They contain the code, runtime, libraries,
    environment variables, and configuration files needed to run the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个概念并不新颖，但Docker使得创建易于构建、部署、版本控制和共享的容器成为可能。Docker容器仅包含在宿主操作系统上运行应用程序所需的依赖项；它共享宿主系统硬件的操作系统和其他依赖项。这使得Docker容器在大小和资源使用方面比虚拟机（VM）更轻，因为它不需要传输整个操作系统和模拟虚拟硬件。因此，Docker在很多传统使用场景中使虚拟机变得过时，这些场景原本是通过虚拟机技术处理的。这也意味着，与使用虚拟机相比，使用Docker我们可以在相同的硬件上运行更多的应用程序。Docker容器是Docker镜像的实例，Docker镜像是一组层，它描述了正在容器化的应用程序。它们包含运行应用程序所需的代码、运行时、库、环境变量和配置文件。
- en: The Dockerfile
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile
- en: A Dockerfile is a set of instructions that tells Docker how to build a Docker
    image. By running the `docker build` command on a specific Dockerfile, we will
    produce a docker image that can be used to create Docker containers. Existing
    docker images can be used as a base for new Dockerfiles, hence letting you reuse
    and extend existing images.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 是一组指令，告诉 Docker 如何构建 Docker 镜像。通过在特定的 Dockerfile 上运行 `docker build`
    命令，我们将生成一个可用于创建 Docker 容器的 Docker 镜像。现有的 Docker 镜像可以用作新 Dockerfile 的基础，因此可以重用和扩展现有镜像。
- en: 'The following code is from the Dockerfile of our application:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自我们应用程序的 Dockerfile：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `FROM` instruction specifies the base image to use while initializing the
    build. Here, we specify open JDK 8 as our Java runtime.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM` 指令指定初始化构建时使用的基镜像。在这里，我们指定 Open JDK 8 作为我们的 Java 运行时。'
- en: The `ENV` instruction is used to set environment variables, and the `CMD` instruction
    is used to specify commands to be executed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV` 指令用于设置环境变量，而 `CMD` 指令用于指定要执行的命令。'
- en: The `EXPOSE` instruction is used to specify the port that the container listens
    to during runtime.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE` 指令用于指定容器在运行时监听的端口。'
- en: Visit [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
    for a complete reference.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
    获取完整的参考。
- en: The Docker Hub
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Hub
- en: Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)) is the online
    registry provided by Docker. It can be used to publish public and private docker
    images. This makes sharing and reusing docker images extremely easy.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)) 是 Docker 提供的在线注册库。它可以用来发布公共和私有
    Docker 镜像。这使得共享和重用 Docker 镜像变得极其容易。
- en: To get a docker image from the registry, we just need to run `docker pull <image-name>`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要从注册库获取 Docker 镜像，我们只需运行 `docker pull <image-name>`。
- en: This makes it easy to use third-party tools without having to install them locally
    by just pulling and running the container from the registry.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得在不本地安装第三方工具的情况下，只需从注册库拉取并运行容器即可轻松使用第三方工具。
- en: Docker compose
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Docker compose is a tool in the Docker platform that is used to define and run
    multi-container applications. It lets us define how a container will behave when
    it is run in production, and also lets us define other services that it depends
    on and how services work with each other. Each application is a service as it
    defines the behavior of the container, for example, what port it runs on, what
    environment variables it uses, and so on. A YAML file is used for this. A single
    `docker.compose.yml` file can define all the services that are required for a
    multi-container application and can then be started with a single command. We
    will see more about Docker and docker -compose in [Chapter 11](9362521a-199a-4dda-ae0d-e55d9ed76957.xhtml), *Deploying
    with Docker Compose*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 是 Docker 平台中的一个工具，用于定义和运行多容器应用程序。它让我们定义容器在生产环境中运行时的行为，还让我们定义它所依赖的其他服务以及服务之间如何协同工作。每个应用程序都是一个服务，因为它定义了容器的行为，例如它运行在哪个端口上，它使用哪些环境变量，等等。使用
    YAML 文件进行此操作。单个 `docker-compose.yml` 文件可以定义多容器应用程序所需的所有服务，然后可以通过单个命令启动。我们将在第 11
    章 [Deploying with Docker Compose](9362521a-199a-4dda-ae0d-e55d9ed76957.xhtml)
    中了解更多关于 Docker 和 docker-compose 的内容。
- en: Visit [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)
    to learn more about Docker.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)
    了解更多关于 Docker 的信息。
- en: 'The following table is a list of useful commands for Docker and Docker compose:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了 Docker 和 Docker Compose 的有用命令：
- en: '| `docker build -t myapp:1.0.` | Build an image from the Dockerfile in the
    current directory and tag the image |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `docker build -t myapp:1.0.` | 从当前目录的 Dockerfile 构建镜像并标记镜像 |'
- en: '| `docker images` | List all images that are locally stored with the Docker engine
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `docker images` | 列出本地存储的所有 Docker 镜像 |'
- en: '| `docker pull alpine:3.4` | Pull an image from a registry |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `docker pull alpine:3.4` | 从注册库拉取镜像 |'
- en: '| `docker push myrepo/myalpine:3.4` | Push an image to a registry |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `docker push myrepo/myalpine:3.4` | 将镜像推送到注册库 |'
- en: '| `docker login` | Log in to a registry (the Docker Hub, by default) |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `docker login` | 登录到注册库（默认为 Docker Hub） |'
- en: '| `docker run --rm -it -p 5000:80 -v /dev/code alpine:3.4 /bin/sh` | Run a
    docker container**--rm**: Remove container automatically after it exits **-it**:
    Connect the container to the Terminal'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '| `docker run --rm -it -p 5000:80 -v /dev/code alpine:3.4 /bin/sh` | 运行 Docker
    容器**--rm**：容器退出后自动删除 **-it**：将容器连接到终端'
- en: '**-p**: Expose port `5000` externally and map to port `80`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**-p**：外部暴露端口 `5000` 并映射到端口 `80`'
- en: '**-v**: Create a host mapped volume inside the container'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**-v**：在容器内创建一个主机挂载卷'
- en: '**alpine:3.4**: The image from which the container is instantiated'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**alpine:3.4**：从该镜像实例化的容器'
- en: '**/bin/sh**: The command to run inside the container |'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**/bin/sh**：在容器内运行的命令'
- en: '| `docker stop myApp` | Stop a running container |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `docker stop myApp` | 停止一个正在运行的容器 |'
- en: '| `docker ps` | List the running containers |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `docker ps` | 列出正在运行的容器 |'
- en: '| `docker rm -f $(docker ps -aq)` | Delete all running and stopped containers
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `docker rm -f $(docker ps -aq)` | 删除所有正在运行和已停止的容器 |'
- en: '| `docker exec -it web bash` | Create a new bash process inside the container
    and connect it to the Terminal |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `docker exec -it web bash` | 在容器内创建一个新的bash进程并将其连接到终端 |'
- en: '| `docker logs --tail 100 web` | Print the last 100 lines of a container''s
    logs |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `docker logs --tail 100 web` | 打印容器日志的最后100行 |'
- en: '| `docker-compose up` | Start the services defined in the `docker-compose.yml`
    file in the current folder |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `docker-compose up` | 启动当前文件夹中 `docker-compose.yml` 文件定义的服务 |'
- en: '| `docker-compose down` | Stop the services defined in the `docker-compose.yml`
    file in the current folder |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `docker-compose down` | 停止当前文件夹中 `docker-compose.yml` 文件定义的服务 |'
- en: Starting the production database with Docker
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker启动生产数据库
- en: 'JHipster creates a Dockerfile for the application and provides `docker-compose`
    files for all the technologies we choose, such as the database, search engine,
    Jenkins, and so on, under `src/main/docker`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster为应用程序创建一个Dockerfile，并为我们在 `src/main/docker` 下选择的所有技术（如数据库、搜索引擎、Jenkins等）提供
    `docker-compose` 文件：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s see how we can start our production database using Docker from the compose
    file provided under `src/main/docker/mysql.yml`. You will need to use a Terminal
    for the following instructions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用在 `src/main/docker/mysql.yml` 下提供的组合文件来使用Docker启动我们的生产数据库。你将需要使用终端来执行以下指令：
- en: Run `docker --version` and `docker-compose --version` to ensure these are installed.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `docker --version` 和 `docker-compose --version` 以确保这些已安装。
- en: Run `docker ps` to list the running containers. If you are not already running
    any containers, you should see an empty list.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `docker ps` 以列出正在运行的容器。如果你还没有运行任何容器，你应该看到一个空列表。
- en: Let's start the DB by running `docker-compose -f src/main/docker/mysql.yml up`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过运行 `docker-compose -f src/main/docker/mysql.yml up` 来启动数据库。
- en: 'You will see the following console output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下控制台输出：
- en: '![](img/0a0b7920-48c2-4abd-a248-20fb92ab1dfc.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a0b7920-48c2-4abd-a248-20fb92ab1dfc.png)'
- en: If you want to run the service in the background, pass the `-d` flag to the
    command. `docker-compose -f src/main/docker/mysql.yml up -d` will let you continue
    to use the same Terminal without having to switch to another.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在后台运行服务，将 `-d` 标志传递给命令。`docker-compose -f src/main/docker/mysql.yml up -d`
    将允许你继续使用相同的终端，而无需切换到另一个。
- en: 'Now if you run `docker ps` again, it should list the database service that
    we started:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你再次运行 `docker ps`，它应该会列出我们启动的数据库服务：
- en: '![](img/163a93cf-8eb3-4041-ac9e-c9000aa34411.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/163a93cf-8eb3-4041-ac9e-c9000aa34411.png)'
- en: An introduction to Spring profiles
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring配置文件的介绍
- en: Before we prepare our application for production, let's talk a little bit about
    Spring profiles.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们准备应用程序投入生产之前，让我们简单谈谈Spring配置文件。
- en: Spring profiles ([https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-definition-profiles-java](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-definition-profiles-java))
    let you change the way your application behaves based on environments. This is
    achieved using the `@Profile` annotations and profile-specific configuration files,
    which can be activated by specifying the `spring.profiles.active` property. Based
    on the profile that we set here, Spring will choose the appropriate `application.properties/application.yml`
    files and will include/exclude components that are included/excluded for the specific
    profile using the `@Profile` annotation in the Java source code. For example,
    if we set `spring.profiles.active=prod`, all the Spring components that have `@Profile("prod")`
    will be instantiated and any component that has `@Profile("!prod")` will be excluded.
    Similarly, Spring will load and use the `application-prod.yml` or `application-prod.properties`
    file if it is available on the classpath.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 配置文件（[https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-definition-profiles-java](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-definition-profiles-java)）允许您根据环境更改应用程序的行为。这是通过使用
    `@Profile` 注解和特定配置文件来实现的，可以通过指定 `spring.profiles.active` 属性来激活。根据我们在这里设置的配置文件，Spring
    将选择适当的 `application.properties/application.yml` 文件，并使用 Java 源代码中的 `@Profile` 注解包含/排除特定配置文件包含/排除的组件。例如，如果我们设置
    `spring.profiles.active=prod`，所有具有 `@Profile("prod")` 的 Spring 组件都将被实例化，任何具有 `@Profile("!prod")`
    的组件将被排除。同样，如果 `application-prod.yml` 或 `application-prod.properties` 文件在类路径上可用，Spring
    将加载并使用它。
- en: 'JHipster configures a `dev` and `prod` profile by default and includes an `application-dev.yml`
    and `application-prod.yml` in the `src/main/resources/config` folder, along with
    the base `application.yml` file. JHipster goes a step further and provides a `dev`
    and `prod` profile for the Gradle build as well (Available for Maven as well)
    so that we can build/run the application for a particular profile, which is very
    handy. Here are the profile and database configurations defined in the `application-dev.yml`
    file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 默认配置了 `dev` 和 `prod` 配置文件，并在 `src/main/resources/config` 文件夹中包含了 `application-dev.yml`
    和 `application-prod.yml` 文件，以及基本的 `application.yml` 文件。JHipster 还更进一步，为 Gradle
    构建提供了 `dev` 和 `prod` 配置文件（同样适用于 Maven），这样我们就可以为特定配置文件构建/运行应用程序，这非常方便。以下是 `application-dev.yml`
    文件中定义的配置文件和数据库配置：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following profiles are available in a JHipster application:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 应用程序中可用的配置文件如下：
- en: '| `dev` | Tuned for development and productivity, it enables Spring dev tools,
    in-memory databases, and so on |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `dev` | 专为开发和生产力优化，启用了 Spring 开发工具、内存数据库等 |'
- en: '| `prod` | Tuned for production, it focuses on performance and stability |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `prod` | 专为生产优化，侧重于性能和稳定性 |'
- en: '| `swagger` | Enables Swagger documentation for the API |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `swagger` | 启用 API 的 Swagger 文档 |'
- en: '| `no-liquibase` | Disables Liquibase, and is useful in production environments
    where you don''t want Liquibase to run |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `no-liquibase` | 禁用 Liquibase，在不需要 Liquibase 运行的生产环境中很有用 |'
- en: Packaging the application for local deployment
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包应用程序以进行本地部署
- en: Now let's build our application and deploy it locally. This can be done in two
    ways, either using Docker or by building and executing a WAR file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建我们的应用程序并将其本地部署。这可以通过两种方式完成，要么使用 Docker，要么构建并执行一个 WAR 文件。
- en: Building and deploying using Docker
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 构建和部署
- en: Let's use a Gradle task to build our docker image.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Gradle 任务来构建我们的 Docker 镜像。
- en: Use the `./gradlew tasks` command to list all available tasks.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `./gradlew tasks` 命令列出所有可用任务。
- en: 'In your Terminal, go to the project root folder and execute; `./gradlew bootRepackage
    -Pprod buildDocker`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中，进入项目根目录并执行；`./gradlew bootRepackage -Pprod buildDocker`：
- en: '**bootRepackage**: Builds an executable archive (WAR) file for the application'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bootRepackage**：为应用程序构建可执行归档（WAR）文件'
- en: '**-Pprod**: Specifies the profile to use'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-Pprod**：指定要使用的配置文件'
- en: '**buildDocker**: Builds a docker image based on the Dockerfile present in the `src/main/docker`
    folder'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**buildDocker**：基于 `src/main/docker` 文件夹中的 Dockerfile 构建 Docker 镜像'
- en: If you are using JHipster Version 5 or above, use `bootWar` instead of the `bootRepackage`
    command in Gradle.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 JHipster 版本 5 或更高版本，请使用 `bootWar` 命令代替 Gradle 中的 `bootRepackage` 命令。
- en: '2\. Once the task is completed successfully, we can deploy our app by running:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 任务成功完成后，我们可以通过运行以下命令来部署我们的应用程序：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will also start the MySQL DB if you haven't started it already. If you
    already have it running from the previous step, then `docker-compose` will just
    skip it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有启动 MySQL 数据库，这将也会启动它。如果您已经在之前的步骤中启动了它，那么 `docker-compose` 将会跳过这一步。
- en: 'Our application will be ready once we see the following output in the console.
    As you can see, it''s running with the `prod` and `swagger` profiles:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在控制台看到以下输出时，我们的应用程序就准备好了。如您所见，它正在使用 `prod` 和 `swagger` 配置运行：
- en: '![](img/8b7871d3-eb48-463f-9b18-466c3f0fb218.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b7871d3-eb48-463f-9b18-466c3f0fb218.png)'
- en: Visit `http://localhost:8080` in your favorite browser to see the application
    in action.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您最喜欢的浏览器访问 `http://localhost:8080` 来查看应用程序的实际运行情况。
- en: Building and deploying an executable archive
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和部署可执行存档
- en: 'If you prefer not to use Docker, then we could deploy the app with a production
    profile locally by completing the following steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用 Docker，则可以通过完成以下步骤在本地使用生产配置部署应用程序：
- en: First, make sure that MySQL DB is running from the previous step; otherwise,
    start it using `docker-compose -f src/main/docker/mysql.yml up -d`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，请确保 MySQL 数据库在之前的步骤中正在运行；如果不是，请使用 `docker-compose -f src/main/docker/mysql.yml
    up -d` 启动它。
- en: Now let's create an executable archive for the prod profile by running `./gradlew
    bootRepackage -Pprod`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们通过运行 `./gradlew bootRepackage -Pprod` 来为 prod 配置创建一个可执行的存档。
- en: Once the build is successful, there will be two archives (WAR) created under
    `build/libs`. The `store-0.0.1-SNAPSHOT.war` file is an executable archive which
    can be run directly on a JVM, and the `store-0.0.1-SNAPSHOT.war.original` is a
    normal WAR file that can be deployed to a server such as JBoss or Tomcat.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦构建成功，`build/libs` 下将创建两个存档（WAR）。`store-0.0.1-SNAPSHOT.war` 文件是一个可执行存档，可以直接在
    JVM 上运行，而 `store-0.0.1-SNAPSHOT.war.original` 是一个普通的 WAR 文件，可以部署到服务器，如 JBoss 或
    Tomcat。
- en: Let's use the executable archive. Just run `./build/libs/store-0.0.1-SNAPSHOT.war`
    to start the application. If you are on Windows, run `java -jar build/libs/store-0.0.1-SNAPSHOT.war`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用可执行存档。只需运行 `./build/libs/store-0.0.1-SNAPSHOT.war` 来启动应用程序。如果您使用的是 Windows，请运行
    `java -jar build/libs/store-0.0.1-SNAPSHOT.war`。
- en: Once the application starts up, you will see the URL printed on the console.
    Visit `http://localhost:8080` in your favorite browser to see the application
    in action.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序启动，您将在控制台上看到打印的 URL。使用您最喜欢的浏览器访问 `http://localhost:8080` 来查看应用程序的实际运行情况。
- en: Upgrading to the newest version of JHipster
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级到 JHipster 的最新版本
- en: JHipster provides an upgrade sub-generator ([http://www.jhipster.tech/upgrading-an-application/](http://www.jhipster.tech/upgrading-an-application/)) to
    help you upgrade an application with a new JHipster version of it. It is quite
    useful as it automates a lot of manual steps for you, and the only thing you need
    to do is resolve merge conflicts if there are any after the upgrade is complete.
    Let's upgrade our application, shall we?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 提供了一个升级子生成器 ([http://www.jhipster.tech/upgrading-an-application/](http://www.jhipster.tech/upgrading-an-application/))，以帮助您使用新的
    JHipster 版本升级应用程序。它非常有用，因为它为您自动化了许多手动步骤，您唯一需要做的是在升级完成后解决任何合并冲突。让我们升级我们的应用程序，怎么样？
- en: In your Terminal, execute the `jhipster upgrade` command. The upgrade process
    will start if there is a new version of JHipster available; otherwise the process
    will exit.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中，执行 `jhipster upgrade` 命令。如果有新的 JHipster 版本可用，则升级过程将开始；如果没有，则进程将退出。
- en: 'Once the process starts, you will see a detailed console log of what is going
    on. As you can see, this sub-generator uses the global JHipster version instead
    of the local one, unlike other sub-generators:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进程开始，您将看到详细的控制台日志，显示正在发生的事情。如您所见，这个子生成器使用的是全局 JHipster 版本，而不是本地版本，这与其他子生成器不同：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The sub-generator does the following in order:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 子生成器按以下顺序执行：
- en: Checks whether there is a new version of JHipster available (not applicable
    if you are using `--force`).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否有新的 JHipster 版本可用（如果使用 `--force` 则不适用）。
- en: Checks whether the application is already initialized as a GIT repository; otherwise,
    JHipster will initialize one for you and commit the current codebase to the master
    branch.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查应用程序是否已经初始化为 GIT 仓库；如果不是，JHipster 将为您初始化一个，并将当前代码库提交到 master 分支。
- en: Checks to ensure that there are no uncommitted local changes in the repository.
    The process will exit if it finds any uncommitted changes.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查确保仓库中没有未提交的本地更改。如果发现任何未提交的更改，则进程将退出。
- en: Checks whether a `jhipster_upgrade` branch exists. If not, a branch is created.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否存在 `jhipster_upgrade` 分支。如果不存在，则创建一个分支。
- en: Checks out the `jhipster_upgrade` branch.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检出 `jhipster_upgrade` 分支。
- en: Upgrades JHipster to the latest available version globally.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将JHipster升级到最新版本。
- en: Cleans the current project directory.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理当前项目目录。
- en: Regenerates the application using the `jhipster --force --with-entities` command.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`jhipster --force --with-entities`命令重新生成应用程序。
- en: Commits the generated code to the `jhipster_upgrade` branch.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的代码提交到`jhipster_upgrade`分支。
- en: Merges the `jhipster_upgrade` branch back to the original branch from where
    the `jhipster upgrade` command was launched.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`jhipster_upgrade`分支合并回启动`jhipster upgrade`命令的原始分支。
- en: 'Let''s see what has changed after the upgrade before we resolve the merge conflicts.
    See the changes staged. Carefully check the changes to make sure everything is
    in order, especially in the files where we made customizations earlier. My changelog
    looks like this; note that I truncated the bottom as there were 147 updated files:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决合并冲突之前，先看看升级后有什么变化。查看已暂存的更改。仔细检查更改，确保一切正常，特别是在我们之前进行过自定义的文件中。我的变更日志如下；注意，由于有147个文件被更新，所以我截断了底部：
- en: '![](img/385098d9-1701-4287-bbdc-1b12e53d1500.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/385098d9-1701-4287-bbdc-1b12e53d1500.png)'
- en: Thankfully, we have only three conflicts and hence they should be easy to resolve.
    The conflict in `package.json` arises from the change we made to integrate Bootswatch.
    Carefully resolve the conflict stage in the file and move on to next file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们只有三个冲突，因此它们应该很容易解决。`package.json`中的冲突源于我们为了集成Bootswatch所做的更改。仔细解决文件中的冲突暂存，然后继续下一个文件。
- en: 'Once all the conflicts are resolved, stage the files and commit them:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有冲突都得到解决，暂存文件并将它们提交：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Ensure that everything works. Run the server-side and client-side tests using
    `./gradlew test && yarn && yarn test`, and start the application to verify this
    by running the `./gradlew clean webpackBuildDev bootRun` command.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 确保一切正常工作。使用`./gradlew test && yarn && yarn test`运行服务器端和客户端测试，并通过运行`./gradlew
    clean webpackBuildDev bootRun`命令启动应用程序来验证这一点。
- en: An introduction to deployment options supported by JHipster
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JHipster支持的部署选项简介
- en: Now that we have verified our production builds by deploying it locally, let's
    see how we can take it to actual production by using a cloud service. JHipster
    supports most of the cloud platforms out of the box, and provides special sub-generator
    commands for the popular ones such as Heroku, Cloudfoundry, and AWS.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过本地部署验证了我们的生产构建，让我们看看如何通过使用云服务将其推向实际生产。JHipster默认支持大多数云平台，并为流行的平台如Heroku、Cloudfoundry和AWS提供了特殊的子生成器命令。
- en: JHipster also supports platforms such as Openshift, Google Cloud (using Kubernetes),
    and Rancher, but let's see them in upcoming chapters as they are more geared towards
    microservices. In theory, though, you could use them for Monolith deployments
    as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster还支持如OpenShift、Google Cloud（使用Kubernetes）和Rancher等平台，但让我们在接下来的章节中了解它们，因为它们更适合微服务。尽管如此，从理论上讲，您也可以将它们用于单体部署。
- en: Heroku
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Heroku
- en: Heroku ([https://www.heroku.com/](https://www.heroku.com/)) is the cloud platform
    from Salesforce. It lets you deploy, manage, and monitor your applications on
    the cloud. Heroku has a focus on Applications rather than on containers and supports
    languages ranging from NodeJS to Java to Go. JHipster provides the Heroku sub-generator,
    which was built and is maintained by Heroku, making it easy to deploy JHipster
    apps to Heroku cloud. It makes use of the Heroku CLI, and you need a Heroku account
    to use it. The sub-generator can be used to deploy and update your application
    to Heroku.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku ([https://www.heroku.com/](https://www.heroku.com/))是Salesforce的云平台。它允许您在云上部署、管理和监控应用程序。Heroku专注于应用程序而不是容器，并支持从NodeJS到Java再到Go的各种语言。JHipster提供了Heroku子生成器，该生成器由Heroku构建和维护，使得将JHipster应用程序部署到Heroku云变得容易。它使用Heroku
    CLI，您需要一个Heroku账户才能使用它。子生成器可用于部署和更新您的应用程序到Heroku。
- en: Visit [http://www.jhipster.tech/heroku/](http://www.jhipster.tech/heroku/) for
    more info.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[http://www.jhipster.tech/heroku/](http://www.jhipster.tech/heroku/)获取更多信息。
- en: Cloud Foundry
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cloud Foundry
- en: Cloud Foundry is a multi-cloud computing platform governed by Cloud Foundry
    Foundation. It was originally created by VMWare, and is now under Pivotal, the
    company behind Spring Framework. It offers a multi-cloud solution which is currently
    supported by **Pivotal Cloud Foundry** (**PCF**), **Pivotal Web Services** (**PWS**),
    Atos Canary, SAP cloud platform, and IBM Bluemix among others. The platform is
    open source and hence can be used to set up your own private instance. JHipster
    provides a sub-generator to deploy JHipster applications to any Cloud Foundry
    provider easily. It makes use of the Cloud Foundry command line tool.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Foundry 是由 Cloud Foundry 基金会管理的多云计算平台。它最初由 VMWare 创建，现在是 Spring 框架背后的公司
    Pivotal 的旗下。它提供了一种多云解决方案，目前由 **Pivotal Cloud Foundry** (**PCF**), **Pivotal Web
    Services** (**PWS**), Atos Canary, SAP 云平台和 IBM Bluemix 等支持。该平台是开源的，因此可以用来设置自己的私有实例。JHipster
    提供了一个子生成器，可以轻松地将 JHipster 应用程序部署到任何 Cloud Foundry 提供商。它使用 Cloud Foundry 命令行工具。
- en: Visit [http://www.jhipster.tech/cloudfoundry/](http://www.jhipster.tech/cloudfoundry/)
    for more info.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [http://www.jhipster.tech/cloudfoundry/](http://www.jhipster.tech/cloudfoundry/)
    获取更多信息。
- en: Amazon Web Services
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Amazon Web Services
- en: '**Amazon Web Services** (**AWS**) is the leading cloud computing platform that
    offers platform, software, and infrastructure as a service. AWS offers Elastic
    Beanstalk as a simple platform to deploy and manage your applications on the cloud.
    JHipster provides a sub-generator to deploy JHipster applications to AWS or Boxfuse
    ([http://www.jhipster.tech/boxfuse](http://www.jhipster.tech/boxfuse)/), an alternative
    service.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**Amazon Web Services** (**AWS**) 是领先的云计算平台，提供平台、软件和基础设施作为服务。AWS 提供了 Elastic
    Beanstalk 作为在云上部署和管理应用程序的简单平台。JHipster 提供了一个子生成器，可以将 JHipster 应用程序部署到 AWS 或 Boxfuse
    ([http://www.jhipster.tech/boxfuse](http://www.jhipster.tech/boxfuse)/)，一个替代服务。'
- en: Visit [http://www.jhipster.tech/aws/](http://www.jhipster.tech/aws/) for more
    info.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [http://www.jhipster.tech/aws/](http://www.jhipster.tech/aws/) 获取更多信息。
- en: Production deployment to Heroku cloud
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将生产部署到 Heroku 云平台
- en: We need to choose a cloud provider. For this demo, let's choose Heroku.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要选择一个云提供商。对于这个演示，让我们选择 Heroku。
- en: Though the Heroku account is free and you get free credits, you will have to
    provide your credit card information to use MySQL and other add-ons. You will
    only be charged if you exceed the free quota.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Heroku账户是免费的，并且你可以获得免费额度，但为了使用MySQL和其他附加组件，你将需要提供信用卡信息。只有当你超出免费配额时，你才会被收费。
- en: 'Let''s deploy our application to Heroku by completing the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤将我们的应用程序部署到 Heroku：
- en: First, you need to create an account in Heroku ([https://signup.heroku.com/](https://signup.heroku.com/)).
    It is free and you get free credits as well.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要在 Heroku 中创建一个账户 ([https://signup.heroku.com/](https://signup.heroku.com/))。这是免费的，你也会获得免费额度。
- en: Install the Heroku CLI tool by following  [https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下链接 [https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli)
    安装 Heroku CLI 工具。
- en: Verify that the Heroku CLI is installed fine by running `heroku --version`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `heroku --version` 验证 Heroku CLI 是否安装正常。
- en: Login to Heroku by running `heroku login`. When prompted, enter your Heroku
    email and password.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `heroku login` 登录到 Heroku。当提示时，输入你的 Heroku 电子邮件和密码。
- en: Now run the `jhipster heroku` command. You will start seeing questions.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行 `jhipster heroku` 命令。你将开始看到问题。
- en: 'Choose a name you like when asked Name to deploy as: (store). By, default it
    will use the application name. Try to choose a unique name since the Heroku namespace
    is shared.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被问及部署名称时，选择你喜欢的名称：（存储）。默认情况下，它将使用应用程序名称。尽量选择一个独特的名称，因为 Heroku 命名空间是共享的。
- en: Next, you will be asked to choose a region—On which region do you want to deploy? Choose
    between US and EU, and proceed.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你将被要求选择一个区域——你希望在哪个区域部署？选择美国或欧盟，然后继续。
- en: The generator will create the required files and accept changes suggested by
    the Gradle build files.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成器将创建所需的文件，并接受 Gradle 构建文件建议的更改。
- en: 'The console output will look like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出将看起来像这样：
- en: '![](img/0c22002f-f3e7-4535-bbd4-2c805f16922f.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0c22002f-f3e7-4535-bbd4-2c805f16922f.png)'
- en: The generated `.yml` files add Heroku-specific configurations for the application.
    The `Procfile` contains the specific command that will be executed on Heroku for
    the application. The Gradle build is also modified to include dependencies required
    by Heroku.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 `.yml` 文件为应用程序添加了 Heroku 特定的配置。`Procfile` 包含了在 Heroku 上执行的应用程序特定命令。Gradle
    构建也被修改以包含 Heroku 所需的依赖项。
- en: 'After generating the files, it will build the application and will start uploading
    artifacts. This may take several minutes based on your network latency. Once this
    has been successfully completed, you should see the following screen:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 生成文件后，它将构建应用程序并开始上传工件。这可能会根据你的网络延迟需要几分钟。一旦成功完成，你应该会看到以下屏幕：
- en: '![](img/eb2b31e1-4456-4b8d-83e1-4873bfc9d5ae.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb2b31e1-4456-4b8d-83e1-4873bfc9d5ae.png)'
- en: Now run the `heroku open` command to open the deployed application in a browser.
    That's it, you have successfully deployed your application to Heroku with a few
    commands.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 `heroku open` 命令以在浏览器中打开已部署的应用程序。就这样，你已成功使用几个命令将应用程序部署到 Heroku。
- en: When you update the application further, you can rebuild the package using `./gradlew
    -Pprod bootRepackage` and then redeploy it using the `heroku deploy:jar --jar
    build/libs/*war` command.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进一步更新应用程序时，你可以使用 `./gradlew -Pprod bootRepackage` 命令重新构建包，然后使用 `heroku deploy:jar
    --jar build/libs/*war` 命令重新部署它。
- en: 'Don''t forget to commit the changes made to `git` by executing the following
    command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记通过执行以下命令将所做的更改提交到 `git`：
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Deployment to production is one of the most important phases of application
    development, and is the most crucial one as well. With the help of JHipster, we
    deployed our application to a cloud provider with ease. We also learned about
    Docker and the various other deployment options available. We also made use of
    the upgrade sub-generator to keep our application up-to-date with JHipster.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 部署到生产是应用程序开发中最重要阶段之一，也是最重要的一个。借助 JHipster，我们轻松地将应用程序部署到了云服务提供商。我们还了解了 Docker
    和其他可用的各种部署选项。我们还使用了升级子生成器来确保我们的应用程序与 JHipster 保持最新。
- en: So far, we've seen how we can develop and deploy a monolithic e-commerce application
    using JHipster. We started with a monolith and, in the upcoming chapters, we will
    see how we can scale our application into a microservice architecture with the
    help of JHipster.  In the next chapter, we will learn about different microservice
    technologies and tools. So, stay tuned!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了如何使用 JHipster 开发和部署单体电子商务应用程序。我们从一个单体开始，在接下来的章节中，我们将看到如何在 JHipster
    的帮助下将我们的应用程序扩展到微服务架构。在下一章中，我们将学习关于不同的微服务技术和工具。所以，请保持关注！
