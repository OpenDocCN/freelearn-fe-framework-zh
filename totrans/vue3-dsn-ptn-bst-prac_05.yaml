- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Single-Page Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单页应用
- en: In this chapter, we continue to increase our skills in Vue 3 with the introduction
    of **single-page applications** (**SPAs**). We will learn what distinguishes them
    from regular websites and will dive into their key characteristics. To put this
    into action, we will build a new version of our To-Do application using the Vue
    Router and a different pattern of communication than the previous chapters. We
    will also learn authentication methods with code samples.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过介绍**单页应用**（**SPAs**）继续提高我们在Vue 3中的技能。我们将学习它们与常规网站的区别，并深入研究它们的关键特性。为了将这一点付诸实践，我们将使用Vue
    Router构建我们待办事项应用的新版本，并使用与之前章节不同的通信模式。我们还将通过代码示例学习认证方法。
- en: 'By the end of this chapter, you will know the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解以下内容：
- en: How to create SPAs with Vue 3
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Vue 3创建SPA
- en: How to organize your application to make use of the Vue Router with different
    routing strategies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何组织您的应用以利用Vue Router的不同路由策略
- en: How to reimplement our To-Do application with a practical application of different
    patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用不同模式的实际应用重新实现我们的待办事项应用
- en: How to implement different patterns of authentication in your SPA
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在您的SPA中实现不同的认证模式
- en: While the previous chapter was somewhat heavy with foundational knowledge, from
    now onward, we center more on practical matters. Because of this, you will need
    access to the example applications to follow through.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上一章在基础知识方面有些繁重，但从现在开始，我们将更多地关注实际问题。因此，您需要访问示例应用以继续学习。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub, at [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter05](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter05).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter05](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/Chapter05)。
- en: 'Check out the following video to see the Code in Action: [https://packt.link/RnAyz](https://packt.link/RnAyz)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：[https://packt.link/RnAyz](https://packt.link/RnAyz)
- en: What is a SPA?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是SPA？
- en: To explain what a SPA is, we should first explain how we interact with the **World
    Wide Web** (**WWW** or **W3**). When we enter an address in a web browser, we
    receive a web page sent by a web server. In the most basic form, a website is
    just a collection of pages, mostly what we call “static pages”. Static in this
    context means that the same files in the server are sent without modification.
    This makes a website very fast and secure. However, a purely static site does
    not offer much interactivity with the end user. Sometimes this is referred to
    as **Web 1.0**. Server and browser scripting came in to solve this limitation
    and gave birth to **multi-page applications** (**MPAs**). Pages could now be either
    static or dynamically generated on the server, which in turn could also receive
    calls for new pages with additional data that processes them and returns a new
    page in response. These new pages “generated on the fly” are called **dynamic**
    and made it possible to have applications. These technologies made it possible
    for blogs, services, and businesses to proliferate.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要解释什么是单页应用（SPA），我们首先应该解释我们如何与**万维网**（**WWW**或**W3**）交互。当我们在一个网页浏览器中输入地址时，我们会收到由一个网络服务器发送的网页。在最基本的形式中，一个网站只是一个页面的集合，大多数是我们所说的“静态页面”。在这个语境中，“静态”意味着服务器上的相同文件在发送时没有经过修改。这使得网站非常快且安全。然而，一个纯静态网站与最终用户之间的交互性并不强。有时这被称为**Web
    1.0**。服务器和浏览器脚本的出现解决了这一限制，并催生了**多页应用**（**MPAs**）。页面现在可以是静态的，也可以在服务器上动态生成，服务器也可以接收请求新页面的调用，这些调用会处理额外的数据并返回一个新的页面作为响应。这些“即时生成”的新页面被称为**动态**，使得应用成为可能。这些技术使得博客、服务和商业得以迅速发展。
- en: It was with the introduction of key technologies such as asynchronous communications
    (**AJAX**), more powerful JavaScript, local storage methodologies, increased network
    speeds, and computational power that we came to what is known as **Web 2.0**.
    It was now possible to load a single file into the browser and use JavaScript
    to take control of the entire interface and interactivity, producing rich and
    heavily interactive applications without generating new pages on the server. The
    SPA only contacts the server to load bits of data, the UI, and so on, as needed.
    It is now possible to migrate to web technologies what were traditional “desktop-only”
    applications, such as text editors, spreadsheets, rich email clients, graphic
    design suites, and so on. *Office 365*, *Google Docs*, *Photoshop online*, *Telegram*,
    *Discord*, *Netflix*, *YouTube*, and so on are good examples of SPAs. It is important
    to acknowledge that the introduction of SPAs does not invalidate the use of MPAs
    or make them obsolete—each has its utility in certain contexts. Most blogs and
    news sites today are, in fact, MPAs and still constitute a significant part of
    the internet. The most complex web applications today include a mixture of MPAs
    and SPAs, working together. SPAs can even be installed as hybrid applications
    on desktop and mobile devices. We will see how to implement this in [*Chapter
    6*](B18602_06.xhtml#_idTextAnchor148), *Progressive* *Web Applications*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在异步通信（**AJAX**）、更强大的JavaScript、本地存储方法、网络速度和计算能力的引入下，我们来到了被称为**Web 2.0**的时代。现在，我们可以将单个文件加载到浏览器中，并使用JavaScript控制整个界面和交互性，从而在不生成新页面的情况下创建丰富且高度交互的应用程序。SPA仅在需要时与服务器联系，加载数据片段、UI等。现在，可以将传统的“仅桌面”应用程序，如文本编辑器、电子表格、丰富的电子邮件客户端、图形设计套件等迁移到网络技术。*Office
    365*、*Google Docs*、*Photoshop在线*、*Telegram*、*Discord*、*Netflix*、*YouTube*等都是SPA的良好例子。重要的是要认识到，SPA的引入并没有使MPA的使用无效或使其过时——每种方法在特定环境中都有其用途。实际上，今天的许多博客和新闻网站都是MPA，并且仍然是互联网的重要组成部分。当今最复杂的网络应用程序包括MPA和SPA的混合使用，共同工作。SPA甚至可以作为混合应用程序安装在桌面和移动设备上。我们将在[*第6章*](B18602_06.xhtml#_idTextAnchor148)，“渐进式Web应用程序”中看到如何实现这一点。
- en: Moving forward, with the explosion of distributed and decentralized computing,
    and smart blockchains, the technology that makes up SPAs has gained even more
    relevance. While not fully rooted in general use, this new era in web evolution
    is called **Web 3.0**. We will see in this chapter more about this topic, with
    examples.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着分布式和去中心化计算的爆发，以及智能区块链的出现，构成单页应用（SPAs）的技术获得了更大的相关性。尽管尚未完全融入通用应用，但这个网络演化的新时代被称为**Web
    3.0**。在本章中，我们将更深入地探讨这个主题，并举例说明。
- en: 'All the applications that we have made this far fall into the SPA category,
    even if we have not used their full potential yet. Vue 3 is specially designed
    to create these types of applications, and is one of the most relevant technologies
    for such an approach, together with *React*, *Angular*, *Svelte*, and others.
    But not everything is sugar, glitter, and rainbows. As with any technology, there
    are trade-offs to using SPAs. In the next table, we list some of them:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们制作的所有应用程序都属于SPA类别，即使我们还没有充分利用它们的潜力。Vue 3专门设计用于创建这些类型的应用程序，并且是与*React*、*Angular*、*Svelte*等其他技术一样相关的技术之一。但并非一切都是甜蜜、闪亮和彩虹。与任何技术一样，使用SPA也有其权衡。在下一表中，我们列出了一些：
- en: '| **Advantages** | **Disadvantages** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **优点** | **缺点** |'
- en: '|'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Faster and smarter loading times
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载速度更快，更智能
- en: Local caching for improved performance
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地缓存以提高性能
- en: Rich UIs and interactivity
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丰富的UI和交互性
- en: Easier to develop and test than MPAs
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比MPA更容易开发和测试
- en: More efficient use of code and templates, with less network communication (as
    compared to full-page re/loads)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与完整页面重新/加载相比，更有效地使用代码和模板，减少网络通信。
- en: '|'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Difficult for search engines to index or discover
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对搜索引擎索引或发现困难
- en: Increased complexity
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂性增加
- en: Increased load time and slower time for first interactivity
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载时间增加和首次交互速度变慢
- en: '|'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Table 5.1 – Advantages and trade-offs for SPAs
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 – SPAs的优缺点和权衡
- en: 'As you can see, the list of advantages is by far more important than the disadvantages.
    You should consider using a SPA when the application requires significant user
    interactivity and real-time feedback. Now that we have a better idea of what a
    SPA is, let’s see the key concept at the core of their functionality: the application
    **router**.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，优势列表远远比劣势列表重要。当应用需要显著的用户交互和实时反馈时，你应该考虑使用SPA。现在我们已经对SPA有了更好的了解，让我们看看它们功能核心的关键概念：应用**路由**。
- en: The Vue 3 router
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue 3 路由
- en: 'Vue is a great framework to build SPAs, but without a router, the task would
    soon become quite complex. The Vue router is an official plugin that takes over
    the navigation of the application and matches a URL to a component. This gives
    us the advantages of an MPA. With the router, we can do the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Vue是一个构建单页应用（SPA）的出色框架，但没有路由，任务很快就会变得相当复杂。Vue路由是一个官方插件，它接管了应用的导航并将URL与组件匹配。这为我们带来了多页应用（MPA）的优势。有了路由，我们可以做以下事情：
- en: Create and manage dynamic routes to components, matching parameters to props
    automatically if needed
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和管理指向组件的动态路由，如果需要，自动将参数匹配到props
- en: Identify routes (addresses and components) by name and trigger navigation by
    code
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过名称识别路由（地址和组件），并通过代码触发导航
- en: Load components dynamically when needed, thus reducing the bundle size
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要时动态加载组件，从而减少包的大小
- en: Create a natural and logical way to approach website navigation and code splitting
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一种自然且逻辑的方法来处理网站导航和代码拆分
- en: Control navigation with well-known events, before and after navigation occurred
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用已知事件控制导航，在导航发生前后
- en: Create page transition animations in a way that is not possible with MPAs
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以MPAs无法实现的方式创建页面过渡动画
- en: The implementation of the Vue 3 router is simple and follows the same methodology
    as with other components of the ecosystem. Let’s take our project from [*Chapter
    4*](B18602_04.xhtml#_idTextAnchor102), *User Interface Composition with Components*,
    and modify it to use the Vue router.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 3 路由的实现简单，遵循与生态系统其他组件相同的方法论。让我们从[*第4章*](B18602_04.xhtml#_idTextAnchor102)，*使用组件的用户界面组合*，修改我们的项目以使用Vue路由。
- en: Installation
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'When starting a new project, you may have noticed that the installer menu gives
    you the option to install the Vue router. If you have not selected this option,
    as we did in our example app, the installation afterward is quite simple. In a
    terminal, in the project directory, just execute the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始一个新的项目时，你可能已经注意到安装程序菜单为你提供了安装Vue路由的选项。如果你没有选择此选项，就像我们在示例应用中所做的那样，之后的安装相当简单。在终端中，在项目目录下，只需执行以下命令：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The command will download and install the dependencies, just as with any other
    package in the `node_modules` directory. In order to use it in our application,
    we need to do the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将下载并安装依赖项，就像在`node_modules`目录中的任何其他包一样。为了在我们的应用中使用它，我们需要做以下操作：
- en: Create our routes.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的路由。
- en: Link the routes to our components.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路由链接到我们的组件。
- en: Include the router in our application.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路由包含在我们的应用中。
- en: Set our templates where the router will display our components.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置路由将显示我们的组件的模板。
- en: 'As with much of the framework, the router does not specify in which directories
    or organization your routes should be placed, or your components for that matter.
    However, there is a convention that we will use that has become the de facto standard
    in the industry. In the `/src` folder, create the following directories:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与框架中的许多其他组件一样，路由没有指定你的路由应该放在哪个目录或组织结构中，或者你的组件也是如此。然而，我们将会使用一种已经成为行业默认标准的约定。在`/src`文件夹中，创建以下目录：
- en: '`/router` (or `/routes`): Here, we will have our JavaScript files with the
    routes for our application'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/router`（或`/routes`）：在这里，我们将放置我们应用的JavaScript文件，包含路由'
- en: '`/views`: This folder will contain the top-level components that match the
    application navigation (as a best practice)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/views`：这个文件夹将包含与应用导航匹配的最高级组件（作为最佳实践）'
- en: With these directories in place, we are ready to start modifying our application
    to include route navigation. Before that, let’s take a look at what we want to
    achieve with our router.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些目录就位后，我们就可以开始修改我们的应用以包含路由导航了。在此之前，让我们看看我们希望通过路由实现什么。
- en: A new To-Do application
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个新的待办事项应用
- en: 'Our new application will reuse the components to display our To-Do list, but
    also will accommodate the creation of multiple lists or projects. We will display
    a sidebar with all our projects, and when selecting them, the list will be updated11\.
    These projects will also be persisted in the browser, so we can come back to them
    later by using `localStorage`. We will then have a very simple navigation, with
    two top-level pages (components):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新应用程序将重用组件来显示我们的待办事项列表，但也将容纳创建多个列表或项目。我们将显示一个侧边栏，其中包含所有我们的项目，并在选择它们时，列表将更新11。这些项目也将保存在浏览器中，因此我们可以通过使用
    `localStorage` 在以后返回它们。然后我们将有一个非常简单的导航，包含两个顶级页面（组件）：
- en: A landing page where we can create new projects
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以创建新项目的登录页面
- en: A project page where we can work with our to-do list
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以处理我们的待办事项列表的项目页面
- en: 'Following these simple premises, our application once finished will look like
    this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 依据这些简单的原则，我们的应用程序完成后将看起来像这样：
- en: '![Figure 5.1 – Our landing page](img/Figure_5.01_B18602.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 我们的登录页面](img/Figure_5.01_B18602.jpg)'
- en: Figure 5.1 – Our landing page
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 我们的登录页面
- en: 'As you can see in *Figure 5**.1*, the landing page is also the place where
    we can create new projects. We use modal dialogs to collect user input, just as
    we did before. On the sidebar, we display a link to the **Home** page (the landing
    page) and a list with all the names of the different projects that we have created.
    When you click on each one, the route in the browser (URL) will update as well
    as the page, and we will see something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 *图 5**.1* 中所见，登录页面也是我们可以创建新项目的地方。我们使用模态对话框来收集用户输入，就像我们之前做的那样。在侧边栏中，我们显示一个链接到
    **主页**（登录页面）以及一个包含我们创建的所有不同项目名称的列表。当您点击任何一个时，浏览器中的路由（URL）以及页面都将更新，我们将看到如下内容：
- en: '![Figure 5.2 – A To-Do project page](img/Figure_5.02_B18602.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 待办事项项目页面](img/Figure_5.02_B18602.jpg)'
- en: Figure 5.2 – A To-Do project page
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 待办事项项目页面
- en: You may recognize this last screenshot, as it is what our `ToDoProject.vue`
    component displays. As a matter of fact, it will require very little modification
    to reach this result. For now, let’s begin with the routes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经认出了这个最后的截图，因为它就是我们的 `ToDoProject.vue` 组件显示的内容。实际上，要达到这个结果需要非常少的修改。现在，让我们从路由开始。
- en: Routes’ definition and the Router object
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由定义和路由对象
- en: 'To create routes for our project, we need to first define them in their own
    module. In the `/router` directory, create an `index.js` file with the following
    content:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的项目创建路由，我们首先需要在它们自己的模块中定义它们。在 `/router` 目录中，创建一个 `index.js` 文件，内容如下：
- en: /src/router/index.js
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: /src/router/index.js
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We start our file by importing two constructors from the `vue-router` package,
    in line `//1`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `vue-router` 包中导入两个构造函数开始我们的文件，在行 `//1`：
- en: '`createRouter`, which will create a router object that we can inject into our
    application as a plugin'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createRouter`，它将创建一个路由对象，我们可以将其作为插件注入到我们的应用程序中'
- en: '`createWebHashHistory`, which is a constructor that we will pass to our router
    object and indicates how it will manage the URL rewriting in the browser'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createWebHashHistory`，这是一个构造函数，我们将将其传递给我们的路由对象，并指示它如何管理浏览器中的 URL 重写'
- en: '`Web hash history` will display `#` (a numeral sign) in the URL and will indicate
    that all navigation points to a single file. All navigation and URL parameters
    will follow this sign. It is the easiest method and does not require any special
    configuration. However, the other available methods are **Web history** (also
    known as *HTML5 mode* or *pretty URLs*) and **Memory**. Web history does not use
    the hash notation, but does require a special server configuration. We will see
    how to accomplish this with examples in [*Chapter 10*](B18602_10.xhtml#_idTextAnchor224),
    *Deploying Your Application*. Memory mode does not modify the URL and is mostly
    used for web views (as in hybrid frameworks such as NW.js, Electron, Tauri, Cordova,
    Capacitor, and so on) and **server-side rendering** (**SSR**). For now, we will
    stay with the **Web hash** **history** method.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Web hash history` 将在 URL 中显示 `#`（一个数字符号），并指示所有导航都指向单个文件。所有导航和 URL 参数都将遵循此符号。这是最简单的方法，不需要任何特殊配置。然而，其他可用的方法还有
    **Web history**（也称为 *HTML5 模式* 或 *美观的 URL*）和 **Memory**。Web history 不使用哈希符号，但需要特殊的服务器配置。我们将在
    [*第 10 章*](B18602_10.xhtml#_idTextAnchor224) 的示例中看到如何完成，*部署您的应用程序*。Memory 模式不会修改
    URL，主要用于网页视图（如 NW.js、Electron、Tauri、Cordova、Capacitor 等混合框架）和 **服务器端渲染**（**SSR**）。现在，我们将继续使用
    **Web hash** **历史**方法。'
- en: 'In line `//2`, we import a component using the static notation, and we define
    a `routes` array with our routes. Each route is represented by an object with
    at least the following fields:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在行`//2`中，我们使用静态符号导入了一个组件，并定义了一个包含我们的路由的`routes`数组。每个路由都由一个至少包含以下字段的对象表示：
- en: '`path`: A string that represents the URL associated with the component'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：表示与组件关联的URL的字符串'
- en: '`name`: A string that behaves like a unique ID for the route and that we can
    call programmatically'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：一个字符串，它像一个唯一的ID一样作用于路由，并且我们可以通过编程方式调用它'
- en: '`component`: The component to render'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`component`：要渲染的组件'
- en: Notice how in line `//2` we import a static component, but in line `//3`, we
    use the dynamic import notation. This implies that the first route (named `"landing"`)
    will be included in the main bundle, but the second route ( in line `//3`, named
    `"project"`) will only be loaded the first time it is needed, from a separate
    bundle. Using routes, we can create a strategy for improving our application loading
    and bundle size.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在行`//2`中我们导入了一个静态组件，但在行`//3`中，我们使用了动态导入符号。这意味着第一个路由（命名为`"landing"`)将被包含在主包中，但第二个路由（在行`//3`中，命名为`"project"`)只有在第一次需要时才会从单独的包中加载。使用路由，我们可以为提高我们的应用程序加载和包大小创建一个策略。
- en: Finally, in line `//4`, we create our `router` object using the constructor
    and passing an options object. Notice in line `//5` how we pass the `history`
    field a constructor for our chosen `history` method. We also pass our routes (obviously),
    and also as an example here, we create one of the possible *navigation guards*,
    to make sure that after navigating to each route, the window scrolls all the way
    to the top. Without this, we may encounter a strange side effect, with the scroll
    not changing between “*pages*." Navigation guards are triggered before and after
    a navigation event. They can be used in a multitude of situations, such as authentication
    control or data preloading. Please refer to the official documentation for a complete
    list of guards, with examples ([https://router.vuejs.org/guide/advanced/navigation-guards.html](https://router.vuejs.org/guide/advanced/navigation-guards.html)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在行`//4`中，我们使用构造函数创建我们的`router`对象，并传递一个选项对象。注意在行`//5`中，我们如何传递`history`字段一个我们选择的`history`方法的构造函数。我们还传递了我们的路由（显然），并且作为一个例子，我们创建了一个可能的*导航守卫*，以确保在导航到每个路由后，窗口滚动到顶部。如果没有这个，我们可能会遇到一个奇怪的副作用，滚动不会在“*页面*”之间改变。导航守卫在导航事件之前和之后触发。它们可以在多种情况下使用，例如身份验证控制或数据预加载。请参阅官方文档以获取守卫的完整列表，包括示例（[https://router.vuejs.org/guide/advanced/navigation-guards.html](https://router.vuejs.org/guide/advanced/navigation-guards.html)）。
- en: 'In our second route, we have also included a variant in the notation of the
    path, with the inclusion of a named parameter prefixed by a semicolon (`:id`).
    This route will match anything following `/project/` and assign it to a reactive
    variable, which we can access programmatically (we will see how this works later).
    The route also has an additional field, `props: true`. This indicates that the
    parameter named in the path will be automatically passed as a prop to the component
    if the component has defined a prop with the same name. This will become useful
    and apparent in the next sections.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们的第二个路由中，我们还包含了路径表示法中的一个变体，通过包含一个以分号（`;`)为前缀的命名参数（`:id`)。这个路由将匹配`/project/`之后的所有内容，并将其分配给一个响应式变量，我们可以通过编程方式访问它（我们将在后面看到它是如何工作的）。该路由还有一个额外的字段，`props:
    true`。这表示路径中命名的参数将被自动传递给组件作为prop，如果组件定义了具有相同名称的prop。这将在下一节中变得有用和明显。'
- en: 'With our routes and router defined, it is time to import them into our `main.js`
    file and attach them to our application. The file will look now like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了我们的路由和路由器之后，现在是时候将它们导入到我们的`main.js`文件中，并将它们附加到我们的应用程序上了。文件现在看起来是这样的：
- en: /src/main.js
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: /src/main.js
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Easy enough—it is now time to create components that are currently missing and
    adapt the ones we have. Before dealing with the code, let’s see which new components
    the router provides our application with.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 足够简单——现在是时候创建目前缺失的组件，并调整我们已有的组件了。在处理代码之前，让我们看看路由器为我们应用程序提供了哪些新组件。
- en: Router template components
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由模板组件
- en: 'When we include the router in the application, it injects into the global scope
    the following new components:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将路由器包含到应用程序中时，它会将以下新组件注入到全局作用域中：
- en: '`RouterView`: This component provides the placeholder where the route components
    will be rendered.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RouterView`：这个组件提供了将要渲染的路由组件的占位符。'
- en: '`RouterLink`: Provides an easy way to link to routes; through the use of handy
    props and styles, we can control the appearance and final render element.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RouterLink`：提供了一种简单的方式来链接到路由；通过使用方便的属性和样式，我们可以控制外观和最终渲染元素。'
- en: 'Together with the router and routes definition, these two components in our
    template make it possible to offer navigation and better organize our code. Before
    we dig into their details, let’s see them in action in our application. Let’s
    start modifying our `App.vue` component to turn it into a layout container (styles
    omitted):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与路由和路由定义一起，我们模板中的这两个组件使我们能够提供导航并更好地组织我们的代码。在我们深入探讨它们的细节之前，让我们看看它们在我们应用程序中的实际应用。让我们开始修改我们的`App.vue`组件，将其转换为布局容器（省略了样式）：
- en: App.vue
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: App.vue
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, we include a new component, `Sidebar`, which will contain the
    main navigation for our application. Then, we just place a single `<router-view>`
    component, where our router will render each page. When it comes to the styles,
    I will refer to the code in GitHub for the details. Now, it is time to create
    the `Sidebar` component in the `/src/components/Sidebar/Sidebar.vue` path and
    copy the code from the repository. There is a lot to see in this small file. Let’s
    start looking into the template and how we use the `RouterLink` instances. The
    first one is static and points to the landing page. Instead of just using a link
    or an anchor tag, we define the target of the link as an object where we reference
    the name of the route directly:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们包含了一个新的组件`Sidebar`，它将包含我们应用程序的主要导航。然后，我们只放置一个`<router-view>`组件，我们的路由将在其中渲染每个页面。当涉及到样式时，我将参考GitHub中的代码来获取详细信息。现在，是时候在`/src/components/Sidebar/Sidebar.vue`路径下创建`Sidebar`组件，并从存储库中复制代码。在这个小文件中有许多内容可以查看。让我们从模板开始，看看我们如何使用`RouterLink`实例。第一个是静态的，指向主页。我们不是仅仅使用一个链接或锚标签，而是定义链接的目标为一个对象，其中直接引用路由的名称：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When this component is rendered, by default, it will become an anchor tag,
    and the `href` attribute will be dynamically converted to the appropriate route.
    If we change our route’s definition and give it another path, it won’t affect
    this code. It is a good practice to reference routes by their names, instead of
    by their URL. In the case that we need to pass some query string parameters to
    the URL, we can easily do it by passing an object with key/value members as a
    `params` attribute. Here is an example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个组件被渲染时，默认情况下，它将成为一个锚标签，并且`href`属性将被动态转换为适当的路由。如果我们更改路由的定义并给它另一个路径，这不会影响此代码。引用路由时使用其名称而不是URL是一个好的做法。如果我们需要将一些查询字符串参数传递给URL，我们可以通过传递一个具有键/值成员的对象作为`params`属性来轻松完成。以下是一个示例：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding `params` attribute will be rendered as a URI with the `?text=abc`
    query string. As we mentioned, if the route has the `props` attribute active and
    the receiving component has defined a prop of the same name, the value will be
    automatically assigned. This is a situation that allows us to generate a list
    of links and pass to our project page the ID of each project, as you can see next
    in the file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`params`属性将被渲染为一个带有`?text=abc`查询字符串的URI。正如我们提到的，如果路由有激活的`props`属性，并且接收到的组件已定义了同名属性，则值将自动分配。这种情况允许我们生成一个链接列表并将其传递给我们的项目页面，如你接下来在文件中看到的：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we create a project on the landing page, we automatically assign a unique
    ID to each one, which we use in the previous code. Just as with other props, we
    can watch the changes and react by loading the respective To-Do items for each
    project. With that in mind, we modified the `ToDoProject.vue` file to define the
    prop (no need to define the type):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在主页上创建一个项目时，我们自动为每个项目分配一个唯一的ID，我们在之前的代码中使用它。就像其他属性一样，我们可以监视变化并通过加载每个项目的相应待办事项来做出反应。考虑到这一点，我们修改了`ToDoProject.vue`文件来定义属性（不需要定义类型）：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And then, we also set a watcher to detect changes with these lines in the `script`
    section:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`script`部分也设置了一个监视器来检测这些行的变化：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This watch receives a function that returns the `prop` attribute and then runs
    the `loadProject()` function. At this point, you may ask why we need to do this
    since each URL is different. The answer is that Vue and the router only load a
    component the first time it’s needed. As long as it remains in view, it doesn’t
    reload it and only updates reactive properties. Since our `script setup` code
    only runs during the first load, at the moment of creation, we need a way to detect
    changes to run non-reactive operations, such as loading the To-Do items for the
    project from `localStorage`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个监视器接收一个返回`prop`属性的函数，然后运行`loadProject()`函数。此时，你可能会问为什么我们需要这样做，因为每个URL都是不同的。答案是Vue和路由器只在第一次需要时加载一个组件。只要它保持在视图中，它就不会重新加载它，而只更新响应式属性。由于我们的`script
    setup`代码只在第一次加载时运行，在创建的时刻，我们需要一种方法来检测变化以运行非响应式操作，例如从`localStorage`加载项目的待办事项。
- en: 'You can follow the rest of the changes in the repository. There is very little
    that changes in the components that work with the To-Do list, and that is the
    point of the encapsulation. Even the modification of `ToDoProject.vue` is small.
    However, there is one design decision that we need to point out: the use of the
    *pub/sub model* to keep the sidebar menu synchronized.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在仓库中查看其余的更改。与处理待办事项列表的组件相比，变化非常少，这正是封装的目的。即使是`ToDoProject.vue`的修改也很小。然而，有一个设计决策我们需要指出：使用*发布/订阅模型*来保持侧边栏菜单的同步。
- en: 'We have created a singleton with an event bus (`eventBus`). When we create
    a new project or delete it, we trigger an update event with this line:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用事件总线（`eventBus`）创建了一个单例。当我们创建或删除一个新项目时，我们通过这一行触发一个更新事件：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We register the listening events in those components that need it during the
    *mounting* lifecycle event of the component, and we de-register it before is *unmounted*.
    In our case, we only need this in the `Sidebar` component, but we could have it
    anywhere in our application as needed:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在组件的`mounting`生命周期事件中注册需要监听的事件，并在它`unmounted`之前注销。在我们的例子中，我们只需要在`Sidebar`组件中这样做，但根据需要，我们可以在应用程序的任何地方这样做：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The name of the event is trivial and does not follow any convention. In this
    book, we prefix it with a numeral sign, as a personal preference.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 事件名称很简单，不遵循任何约定。在这本书中，我们根据个人喜好在它前面加上一个数字符号。
- en: In previous implementations, as well as in the `ToDoProject.vue` component,
    we use the parent as the conduit to share information between sibling components,
    as we discussed previously. Here, we use another model, the *pub/sub pattern*,
    to avoid polluting the `App.vue` component with such a task. In [*Chapter 7*](B18602_07.xhtml#_idTextAnchor173),
    *Data Flow Management*, we will see other approaches for central state management.
    Let’s now take a closer look into more examples and details of using the router
    with more advanced scenarios.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的实现中，以及`ToDoProject.vue`组件中，我们使用父组件作为在兄弟组件之间共享信息的通道，正如我们之前讨论的那样。在这里，我们使用另一种模式，即*发布/订阅模式*，以避免将此类任务污染`App.vue`组件。在[*第7章*](B18602_07.xhtml#_idTextAnchor173)“数据流管理”中，我们将看到其他中央状态管理的方法。现在让我们更详细地看看使用路由器在更高级场景中的更多示例和细节。
- en: Nested routes, named views, and programmatic navigation
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套路由、命名视图和编程导航
- en: This far, we have created static and dynamic routes, even with some parameters
    in the address. But the router can do even more than that. By using named routes,
    we can also create “sub-routes” and named “sub-views” to create deeper navigation
    trees and complex layouts.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了静态和动态路由，甚至在地址中包含一些参数。但路由器可以做得更多。通过使用命名路由，我们还可以创建“子路由”和命名的“子视图”，以创建更深的导航树和复杂的布局。
- en: 'Let’s start with an example. Suppose we have a data structure on three levels,
    and we want to reactively present this to the user in such a way that they can
    choose one level, and then “drill down” to the details. We also want to have this
    reflected in the URL, in such a way that we can share or reference the full case.
    The levels, in this case, would be country, state, and city. The UI would then
    look something like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从例子开始。假设我们有一个三层的数据结构，并且我们希望以响应式的方式向用户展示，使他们能够选择一个层级，然后“深入”到细节。我们还想在URL中反映这一点，以便我们可以共享或引用整个案例。在这种情况下，层级将是国家、州和城市。UI将看起来像这样：
- en: '![Figure 5.3 – A selection using multiple named views and sub-routes](img/Figure_5.03_B18602.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 使用多个命名视图和子路由的选择](img/Figure_5.03_B18602.jpg)'
- en: Figure 5.3 – A selection using multiple named views and sub-routes
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 使用多个命名视图和子路由的选择
- en: 'As you can already guess from the screenshot, when the user selects the country,
    the state list is populated, and the URL is updated. When selecting a state, the
    city list is updated... and finally, when selecting the city, the information
    appears in the last column. You may have seen this method of navigation before.
    There are multiple ways to implement this, some more efficient than others. Our
    intent is to implement this as a learning exercise, so let’s start with the routes’
    definition. Here is a segment of our routes’ definition array:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从截图中所猜测的，当用户选择国家时，州列表被填充，并且 URL 被更新。当选择州时，城市列表被更新...最后，当选择城市时，信息出现在最后一列。你可能之前见过这种导航方法。有多种实现方式，其中一些比其他方式更高效。我们的意图是将此作为学习练习来实现，所以让我们从路由的定义开始。以下是我们的路由定义数组的一部分：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Nested routes’ definition
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套路由的定义
- en: 'At first sight, you will notice that not much has changed, save for the inclusion
    of a new attribute on the route: `children[]`. This attribute receives an array
    of routes, which in turn can have other children, as we see in the previous code
    snippet. Children routes will be rendered in the `RouteView` component of their
    parents, and their paths will be concatenated with their parents as well, unless
    they start with the root (with a backslash).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，你会发现变化不大，除了在路由上添加了一个新属性：`children[]`。这个属性接收一个路由数组，这些路由又可以有其他子路由，正如我们在前面的代码片段中所看到的。子路由将在其父组件的
    `RouteView` 组件中渲染，并且它们的路径将与父路径连接，除非它们以根（反斜杠）开头。
- en: 'To navigate to each route, we could use any of the methods recognized by the
    router. However, it is a good practice to use their names and pass any parameter
    or query string through an object, and let the router resolve the URL. As an example,
    see how in the `Directory.vue` component we use the `RouterLink` element:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要导航到每个路由，我们可以使用路由器识别的任何方法。然而，使用它们的名称，并通过一个对象传递任何参数或查询字符串，让路由器解析 URL 是一个好习惯。作为一个例子，看看在
    `Directory.vue` 组件中我们是如何使用 `RouterLink` 元素的：
- en: /src/views/Directory.vue component, lines 13-18
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src/views/Directory.vue` 组件，第 13-18 行'
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have included our `RouterLink` component inside of a loop, to create as many
    links as needed based on our data. The target of the link is set to an object,
    where we pass the name of the route (`states`), and pass parameters respecting
    the route and props definition for the component. Notice that the path of the
    component has been defined as a parameter (it starts with a colon character—`:country`)
    and it also matches the props definition of the object in `State.vue`. This correlation
    is what enables the router to automatically pass the data for us.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的循环中包含了 `RouterLink` 组件，根据我们的数据创建所需数量的链接。链接的目标被设置为对象，我们传递路由的名称（`states`），并传递符合路由和组件
    props 定义的参数。请注意，组件的路径已被定义为参数（以冒号字符开头——`:country`），它也匹配 `State.vue` 中对象的 props
    定义。这种关联使得路由器能够自动为我们传递数据。
- en: 'As you inspect the code, you will notice that in our smallest child component,
    the `City.vue` file, we define in our props both country and state. However, in
    the route definition, only one parameter appears: the state (`:state`). Nevertheless,
    when you run the example, you will notice that the prop is also populated. This
    happens because children components inherit, together with the URL path, all the
    parameters defined in the route of the parents. In this case, our component then
    also receives the `:country` parameter that was passed to the parent, even if
    it doesn’t show up in its specific route.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查代码时，你会注意到在我们的最小子组件 `City.vue` 文件中，我们在 props 中定义了国家和州。然而，在路由定义中，只出现了一个参数：州（`:state`）。然而，当你运行示例时，你会注意到
    prop 也有数据。这是因为子组件除了继承 URL 路径外，还继承了父路由中定义的所有参数。在这种情况下，我们的组件也接收到了传递给父组件的 `:country`
    参数，即使它没有出现在其特定的路由中。
- en: 'When you run the application, you will see something similar to this screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用程序时，你会看到类似于以下截图的内容：
- en: '![Figure 5.4 – Nested routes example, with selections](img/Figure_5.04_B18602.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 嵌套路由示例，带有选择](img/Figure_5.04_B18602.jpg)'
- en: Figure 5.4 – Nested routes example, with selections
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 嵌套路由示例，带有选择
- en: Only two countries have been included from static files, for simplicity. In
    a real-life project, this data would be retrieved from a database.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，只从静态文件中包含了两个国家。在实际项目中，这些数据将从数据库中检索。
- en: 'We have used until now “default” `RouteView` components, but the Vue router
    allows us to include multiple views in one component, by assigning them different
    names. We will only see the notation here, as the implementation is trivial. Consider
    a component with the following template:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的是“默认”的 `RouteView` 组件，但 Vue 路由允许我们在一个组件中包含多个视图，通过为它们分配不同的名称来实现。在这里我们只展示这个表示法，因为实现起来非常简单。考虑以下模板的组件：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we give our routes an identification with the `name`
    attribute. We also have a view without a name, in which case it is considered
    the “default” view, or with the name `default` as well. To make use of this new
    layout, the routes’ definition changes slightly. In each definition now, we do
    not have a `component` attribute, but instead, a `components` (in plural) attribute
    that expects an object. Each field’s name in the object must match the names given
    to our `RouterView` components and be equal to an object. For the previous piece
    of code, the equivalent route definition would be something like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `name` 属性为我们路由赋予了一个标识。我们还有一个没有名称的视图，在这种情况下，它被认为是“默认”视图，或者也可以命名为
    `default`。为了使用这种新的布局，路由的定义略有变化。现在，在每个定义中，我们没有 `component` 属性，而是有一个 `components`（复数）属性，它期望一个对象。对象中每个字段的名称必须与我们的
    `RouterView` 组件给出的名称相匹配，并且等于一个对象。对于前面的代码片段，等效的路由定义可能如下所示：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using this type of definition, we can create complex layouts, as we can also
    define sub-routes to make use of—for example—the header and sidebar from the parent
    and only render in the default view. We have an impressive number of possibilities
    for building dynamic UIs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种类型的定义，我们可以创建复杂的布局，因为我们还可以定义子路由来利用父组件中的头部和侧边栏，并且只在默认视图中渲染。我们在构建动态 UI 方面有令人印象深刻的可能性数量。
- en: 'One important topic that we must cover before moving to the next section is
    that of programmatic navigation. We have used thus far the new components provided
    by the router, but we can also trigger navigation directly from our JavaScript
    without having to rely on the user triggering an event. For this, the Vue Router
    provides us with two handy constructors to use in our components’ scripts: `useRoute`
    and `useRouter`. We import these constructors into our components with the following
    line:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一节之前，我们必须讨论的一个重要主题是程序化导航。到目前为止，我们已经使用了路由提供的新组件，但我们可以直接从我们的 JavaScript 中触发导航，而无需依赖于用户触发事件。为此，Vue
    Router 为我们提供了两个方便的构造函数，可以在组件的脚本中使用：`useRoute` 和 `useRouter`。我们使用以下行将这些构造函数导入到我们的组件中：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can imagine, `$route` provides us with information about the current
    route, while `$router` allows us to modify and trigger navigation events.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，`$route` 为我们提供了有关当前路由的信息，而 `$router` 允许我们修改和触发导航事件。
- en: 'The `$router` object provides several methods, of which the most often used
    are summarized in this table:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`$router` 对象提供了几个方法，其中最常用的总结如下表：'
- en: '| **Method** | **Description** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `.``push()` | The most important method. It pushes a new URL into the web
    history and navigates to the corresponding component. It is the programmatic equivalent
    of using `RouterLink`. It accepts either a string with the URL to navigate or
    an object with optional attributes. Here are some examples for each accepted parameter:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '| `.push()` | 最重要的方法。它将新的 URL 推入网络历史记录，并导航到相应的组件。它是使用 `RouterLink` 的程序等效。它接受一个字符串，其中包含要导航的
    URL，或者一个具有可选属性的对象。以下是每个接受参数的示例：'
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Of course, you can create complex routes by passing parameters and query strings.
    What is important to remember is that `.push` will update the navigation history
    in the browser. |
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以通过传递参数和查询字符串来创建复杂的路由。需要记住的是，`.push` 将会更新浏览器中的导航历史。|
- en: '| `.``replace()` | Replace the current navigation component, without modifying
    the URL. It accepts the same parameters as `.push`. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `.replace()` | 替换当前的导航组件，而不会修改 URL。它接受与 `.push` 相同的参数。|'
- en: '| `.``go()` | This method receives an integer number as a parameter and triggers
    navigation using the browser’s history. Positive numbers navigate forward and
    negative numbers go backward in the navigation history. Its most common use is
    for implementing a “go back” link in an application. Here are some examples:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '| `.go()` | 这个方法接收一个整数作为参数，并使用浏览器的历史记录触发导航。正数向前导航，负数在导航历史中向后导航。它最常见的使用是用于实现应用程序中的“返回”链接。以下是一些示例：'
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'As mentioned, these are the most commonly used methods and the ones you should
    have present. I can say that using these will cover the vast majority of regular
    necessities. A full list of methods available can be found in the official documentation
    and allow you to manage also edge cases that may arise. I encourage you to check
    them out, at least to be aware of them, at [https://router.vuejs.org/api/interfaces/Router.html](https://router.vuejs.org/api/interfaces/Router.html)#properties.
    Some of these edge cases could be: add and remove routes dynamically (`.addRoute()`
    and `.removeRoute()`), retrieve the registered routes (`.getRoutes()`), check
    whether a route exists before navigating to it (`.hasRoute()`), and so on. We
    will not use them, so it is not relevant to see them in detail here.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些是最常用的方法，也是你应该掌握的方法。我可以告诉你，使用这些方法可以满足绝大多数常规需求。所有可用方法的完整列表可以在官方文档中找到，并允许你管理可能出现的边缘情况。我鼓励你查看它们，至少要了解它们，可以在[https://router.vuejs.org/api/interfaces/Router.html](https://router.vuejs.org/api/interfaces/Router.html)#properties中查看。其中一些边缘情况可能包括：动态添加和删除路由（`.addRoute()`
    和 `.removeRoute()`）、检索已注册的路由（`.getRoutes()`）、在导航到路由之前检查路由是否存在（`.hasRoute()`）等等。我们不会使用它们，所以在这里详细查看它们并不相关。
- en: 'In contrast, the `$route` object gives us information about the current path
    (URL) where our component is being rendered. As with the previous example, here
    is a list of the most commonly used attributes, and their function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`$route` 对象为我们提供了有关组件正在渲染的当前路径（URL）的信息。与前面的示例一样，这里有一个最常用属性及其功能的列表：
- en: '| **Attributes** | **Description** |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `.``name` | Returns the current name of the route. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `.``name` | 返回当前路由的名称。|'
- en: '| `.``params` | Returns an object with the parameters provided with the path
    (URL). If these have been matched to props, the values may overlap. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `.``params` | 返回一个对象，其中包含与路径（URL）一起提供的参数。如果这些参数与props匹配，则值可能重叠。|'
- en: '| `.``query` | Returns an object with the decoded query string attached to
    the current path. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `.``query` | 返回一个对象，其中包含附加到当前路径的解码查询字符串。|'
- en: '| `.``hash` | If any, it returns the path in the URL following and including
    the hash sign (`#`). |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `.``hash` | 如果存在，则返回包含哈希符号（`#`）的URL路径。|'
- en: '| `.``fullPath` | Returns a string with the full path of the route. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `.``fullPath` | 返回路由的完整路径字符串。|'
- en: In the examples of this book, we will use `.name()`, `.params()`, and `.query()`
    on more than one occasion, as they tend to be the most commonly used as well.
    A full list of methods and properties can be found in the official documentation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的示例中，我们将多次使用 `.name()`、`.params()` 和 `.query()`，因为它们也是最常用的。所有方法和属性的完整列表可以在官方文档中找到。
- en: Important notation differences
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注释差异
- en: We have been using the `useRoute` and `useRouter` constructors in the Composition
    API with the `script setup` notation. In the Options API, there is no need to
    initialize these objects. Both are available automatically through `this.$route`
    and `this.$router`. Also, the `$route` and `$router` objects are available automatically
    in the template, when using the Composition API.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用 `useRoute` 和 `useRouter` 构造函数与 `script setup` 注释一起在组合式API中使用。在选项API中，不需要初始化这些对象。它们都通过
    `this.$route` 和 `this.$router` 自动提供。此外，当使用组合式API时，`$route` 和 `$router` 对象在模板中也是自动可用的。
- en: 'A full code example can be found in the GitHub repository, under `Chapter 5``/Nested
    Routes`, at this URL: [https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/chapter05](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/chapter05).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的代码示例可以在GitHub仓库中找到，位于 `Chapter 5``/Nested Routes` 目录下，URL为：[https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/chapter05](https://github.com/PacktPublishing/Vue.js-3-Design-Patterns-and-Best-Practices/tree/main/chapter05)。
- en: Now that we know how to handle routes, parameters, and query strings, it is
    time to look into some common patterns for authentication in SPAs, since different
    paths (URLs) are necessary for many of them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何处理路由、参数和查询字符串，是时候看看在单页应用（SPA）中的一些常见认证模式了，因为许多模式需要不同的路径（URL）。
- en: Exploring authentication patterns
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索认证模式
- en: The power of SPAs becomes apparent when there is also a server behind them providing
    additional services. One such service is authentication. In most applications,
    there will be the need to identify users and provide additional services based
    on their rights, status, privacy, group, or any other category pertaining to the
    context of the application. A clear example of this is webmail applications, such
    as *Outlook* or *Gmail*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当SPA背后也有服务器提供额外服务时，其力量就变得明显了。其中一项服务就是身份验证。在大多数应用中，都需要识别用户并根据他们的权利、状态、隐私、群体或其他与应用上下文相关的类别提供额外服务。一个明显的例子是网络邮件应用，如*Outlook*或*Gmail*。
- en: 'Current web standards provide us with several options to perform asynchronous
    communications with a server. These are often called `XMLHttpRequest` object for
    these network communications, but the new specifications provide us with a direct
    function, `fetch()`, which is more convenient and standard between browsers. While
    these methods are perfectly valid, for other uses than simple needs, it is better
    to use a library that provides more functionalities built on top of these technologies—for
    example, one that provides an `GET`, `POST`, `PUT`, `OPTIONS`, and `DELETE`) to
    easily consume **RESTful APIs** (where **REST** stands for **Representational
    State Transfer**, a type of architecture used in network communications). We will
    see more about this in [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186), *Multithreading
    with Web Workers*. For now, just keep in mind that a library to handle network
    asynchronous communications is a better path. In our case, we will use the excellent
    **Axios** library ([https://axios-http.com/](https://axios-http.com/)), which
    you can install in your application with the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当前网络标准为我们提供了与服务器进行异步通信的几种选项。这些通常被称为用于这些网络通信的`XMLHttpRequest`对象，但新的规范为我们提供了一个直接的功能，`fetch()`，它在浏览器之间更方便且更标准化。虽然这些方法对于其他用途而不是简单需求是完全可以接受的，但最好使用一个库，它在这些技术之上提供更多功能——例如，一个提供`GET`、`POST`、`PUT`、`OPTIONS`和`DELETE`的库，以便轻松消费**RESTful
    API**（其中**REST**代表**表示状态传输**，这是一种在网络通信中使用的架构）。我们将在[*第8章*](B18602_08.xhtml#_idTextAnchor186)中了解更多，*使用Web
    Workers进行多线程*。现在，只需记住，一个用于处理网络异步通信的库是更好的选择。在我们的案例中，我们将使用优秀的**Axios**库([https://axios-http.com/](https://axios-http.com/))，您可以使用以下命令将其安装到您的应用中：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, in your service or component, you can import and use the library with
    the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您的服务或组件中，您可以使用以下代码导入和使用该库：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The library exposes methods to match each HTTP request (`.get()`, `.post()`,
    `.put()`, and so on), each one returning a promise that resolves to the result
    of the request or rejects it in the case of error.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该库公开了匹配每个HTTP请求（`.get()`、`.post()`、`.put()`等等）的方法，每个方法都返回一个解析为请求结果或因错误而拒绝的承诺。
- en: With this introduction, we are ready to see some common patterns for authenticating
    users in our applications.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个介绍，我们准备好查看我们应用中用户身份验证的一些常见模式。
- en: Simple username and password authentication
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的用户名和密码认证
- en: 'This is the simplest approach to authenticating users, where the validation
    of credentials is made by our implementation on the server. In this case, our
    server backend provides the API to validate a set of credentials, gathered by
    our SPA. Traditionally, the credentials are stored in the server, on a database,
    and the communication will be performed on top of **Secure Sockets Layer** (**SSL**)
    or encrypted communication, which are the same thing. Let’s see the workflow graphically:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是认证用户的最简单方法，其中凭证的验证是由我们服务器上的实现完成的。在这种情况下，我们的服务器后端提供了API来验证由我们的SPA收集的一组凭证。传统上，凭证存储在服务器上，在数据库中，通信将在**安全套接字层**（**SSL**）或加密通信之上进行，这两者实际上是同一回事。让我们从图形上看看工作流程：
- en: '![Figure 5.5 – Simple username and password authentication](img/Figure_5.05_B18602.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 简单的用户名和密码认证](img/Figure_5.05_B18602.jpg)'
- en: Figure 5.5 – Simple username and password authentication
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 简单的用户名和密码认证
- en: 'In this workflow, the following occurs:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个工作流程中，以下情况会发生：
- en: The SPA collects username and password values and transmits them to a specific
    endpoint in our server for authentication.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SPA收集用户名和密码值，并将它们传输到我们服务器上的特定端点进行身份验证。
- en: The server uses information stored in a database to validate the username and
    password.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器使用存储在数据库中的信息来验证用户名和密码。
- en: The result of the operation is returned to the client SPA in response to their
    initial query (*1*).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作的结果作为对客户端SPA初始查询的响应返回(*1*)。
- en: 'Even though *Figure 5**.5* shows the number of steps, consider that all this
    is done in just one network call and its reply. Developing the validation code
    on the server is beyond the scope of this book, but the code inside our service
    or Vue 3 component would look something similar to this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管图5.5显示了步骤的数量，但请考虑所有这些都是在一次网络调用及其回复中完成的。在服务器上开发验证代码超出了本书的范围，但我们在服务或Vue 3组件内部的代码看起来会与此类似：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the implementation is quite straightforward and depends on our
    own logic and server API design. What is important to remember is to check the
    status of the response (everything between `200` and `299` is a success) and the
    data sent back by the server to act accordingly. Axios handles all the communication
    and data conversion for us (assuming our API receives and process JSON data).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，实现相当简单，取决于我们自己的逻辑和服务器API设计。重要的是要记住检查响应的状态（`200`到`299`之间的任何状态都是成功）以及服务器发送回的数据，然后相应地采取行动。Axios为我们处理所有通信和数据转换（假设我们的API接收和处理JSON数据）。
- en: In the case of success, we should save the result in our application state and
    allow access to the user accordingly, mostly by unlocking the navigation to private
    or restricted routes. We could apply this protection in a fair number of different
    ways, the most common being the use of navigation guards, the creation of dynamic
    routes, and so on.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的情况下，我们应该在我们的应用程序状态中保存结果，并相应地允许用户访问，主要是通过解锁导航到私有或受限路由。我们可以以多种不同的方式应用这种保护，最常见的是使用导航守卫、创建动态路由等。
- en: 'This method is perfectly valid, and commonly implemented by most applications.
    However, it has several drawbacks:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是完全有效的，并且被大多数应用程序普遍实现。然而，它有几个缺点：
- en: We are responsible for maintaining a database with usernames and passwords (encrypted,
    please!) and implementing the validation logic
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们负责维护一个包含用户名和密码（请加密！）的数据库，并实现验证逻辑
- en: We are legally responsible for handling the user data according to local legislation
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们根据当地法律对处理用户数据负有法律责任
- en: We are responsible for the entire security of the system, end to end
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们负责整个系统的安全性，从端到端
- en: The user has to remember or be responsible for their own credentials
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户必须记住或对自己的凭证负责
- en: We should provide ways to handle edge cases, as well as user problems and credential
    retrievals
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该提供处理边缘情况的方法，以及用户问题和凭证检索的方式
- en: These drawbacks are in no way a deterrent, but huge bullet points to keep in
    mind if we go this way. One way or another, most applications need to have a way
    to authenticate users, which depends on their own logic and implementation since
    not all of our users (depending on the context) will be willing to use another
    form of authentication, as we will see next.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些缺点绝不是阻碍，而是我们在选择这条路时要牢记的大要点。无论如何，大多数应用程序都需要有一种方式来验证用户身份，这取决于它们自己的逻辑和实现，因为并非所有用户（根据上下文）都愿意使用另一种身份验证方式，正如我们接下来将要看到的。
- en: OpenID and third-party authentication
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenID和第三方身份验证
- en: Beyond security concerns, a major issue when dealing with authentication is
    how easily these credentials are lost or mishandled by the end user. This happens
    to us all. The more services we access online, the larger the number of credentials
    a user needs to “remember." There are many different methods to tackle this issue,
    to reduce the load on the user in keeping track of all these usernames and passwords.
    One such standard is the **OpenID** protocol ([https://openid.net/](https://openid.net/)).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安全顾虑之外，处理身份验证时一个主要问题是如何容易地让最终用户丢失或不当处理这些凭证。这种情况我们每个人都可能遇到。我们在线访问的服务越多，用户需要“记住”的凭证数量就越大。有许多不同的方法来解决这个问题，以减轻用户在跟踪所有这些用户名和密码时的负担。其中一种标准是**OpenID**协议([https://openid.net/](https://openid.net/))。
- en: The OpenID protocol authenticates users without the need to share credentials
    (usernames and passwords) between sites. It is based on the workflow of the **OAuth
    2.0** protocol, which is used to securely shared information and resources without
    the need to use passwords as well. This is achieved by sharing tokens between
    the different actors. The standard for these communications is to use **JSON Web
    Tokens** (**JWTs**). There is a lot to unravel in this paragraph, so let’s see
    each one of these terms in a bit more detail so that we can better understand
    how this protocol works.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID 协议可以在不需要在网站之间共享凭据（用户名和密码）的情况下验证用户。它基于 **OAuth 2.0** 协议的工作流程，该协议用于在无需使用密码的情况下安全地共享信息和资源。这是通过在不同参与者之间共享令牌来实现的。这些通信的标准是使用
    **JSON Web Tokens**（JWT）。本段有很多内容需要解释，所以让我们更详细地看看这些术语，以便我们更好地理解该协议的工作原理。
- en: 'A JWT is a string that contains three sections, separated by a dot (`.`), and
    that have been encoded in Base64\. Each section then encodes a JSON object with
    the following information:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 是一个包含三个部分并由点（`.`）分隔的字符串，这些部分已被 Base64 编码。每个部分随后编码一个包含以下信息的 JSON 对象：
- en: '`Header`: This contains cryptographic information used to encode the token,
    such as the algorithm, the type of token (usually `JWT`), and in some cases even
    the type of data submitted in the payload.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`头部`：这包含用于编码令牌的加密信息，例如算法、令牌类型（通常是 `JWT`），以及在某些情况下甚至有效载荷中提交的数据类型。'
- en: '`Payload`: This object contains the information we want (need) to share, and
    is mostly “free format”, meaning that it can contain any `key:value` pair as needed.
    However, there are a few well-defined fields that can also be used, such as “`iat`”(`sub`”field,
    for subject).'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`有效载荷`：此对象包含我们想要（需要）共享的信息，并且主要是“自由格式”，这意味着它可以包含任何所需的 `key:value` 对。然而，也可以使用一些定义良好的字段，例如“`iat`”（`sub`
    字段，表示主题）。'
- en: '`Signature`: The signature is a string form by concatenating the encrypted
    string representations of the header and payload, expressed in Base64\. For the
    encryption, a secret key (a password) is used, only known to both the authenticating
    server and the website server.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`签名`：签名是通过连接头部和有效载荷的加密字符串表示形式（以 Base64 表示）得到的字符串。对于加密，使用一个秘密密钥（密码），只有认证服务器和网站服务器知道。'
- en: 'When a website in the workflow receives a token, it decodes and validates it
    using the secret key, using the same method as the issuer. If the signatures don’t
    match, then it is assumed that the token is corrupted or compromised, and it is
    rejected. A JWT can be intercepted and decoded by a third party, so this method
    acts as a failsafe against tampering. Let’s see an example of the creation of
    a token:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当工作流程中的网站收到一个令牌时，它会使用与发行者相同的方法使用秘密密钥对其进行解码和验证。如果签名不匹配，则假定令牌已被损坏或泄露，并将其拒绝。JWT
    可以被第三方拦截和解码，因此这种方法作为防止篡改的安全措施。让我们看看创建令牌的例子：
- en: '`{"alg": "HS256", "typ": "JWT"}`. Here, we use the `HS256` algorithm and declare
    the type used as `JWT`.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{"alg": "HS256", "typ": "JWT"}`。在这里，我们使用 `HS256` 算法并声明使用的类型为 `JWT`。'
- en: '`{"sub":"1234567890","name":"Pablo` `D. Garaguso","iat":``1516239022}`.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{"sub":"1234567890","name":"Pablo D. Garaguso","iat":1516239022}`。'
- en: '`secret key`.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secret key`。'
- en: 'With the preceding information, a signature field is created with this formula
    (assuming we have a function that encrypts text using the HS256 algorithm):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的信息的基础上，使用以下公式创建一个签名字段（假设我们有一个使用 HS256 算法加密文本的函数）：
- en: '`HMACSHA256(base64UrlEncode(header) + "." +` `base64UrlEncode` **(**`payload),"secret
    key")`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload),"secret
    key")`'
- en: 'Finally, the resulting strings in Base64 encoding are concatenated again to
    give us a perfectly functional token. Also, notice how each section (header, payload,
    and signature) appears separated by a period (`.`):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 Base64 编码的结果字符串再次连接起来，给我们一个完全有效的令牌。同时，请注意每个部分（头部、有效载荷和签名）是如何通过点（`.`）分隔的。
- en: '`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwi bmFtZSI6IlBhYmxvIEQuIEdhcmFndXNvIiwiaWF0IjoxNTE2MjM5MDIyfQ.mPr551``xpsCgmIzp8EZuSCoy7t7iQNpp_iGzIR14E_Jo`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwi bmFtZSI6IlBhYmxvIEQuIEdhcmFndXNvIiwiaWF0IjoxNTE2MjM5MDIyfQ.mPr551xpsCgmIzp8EZuSCoy7t7iQNpp_iGzIR14E_Jo`'
- en: To test this token, you can use a service such as [https://jwt-decoder.com/](https://jwt-decoder.com/).
    To validate it, however, you will need to use the secret key. You can test this
    at [https://jwt.io](https://jwt.io), where you can also find more information
    about this standard.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此令牌，您可以使用类似[https://jwt-decoder.com/](https://jwt-decoder.com/)的服务。然而，要验证它，您将需要使用密钥。您可以在[https://jwt.io](https://jwt.io)测试此，在那里您还可以找到更多关于此标准的信息。
- en: 'In the OpenID protocol, JWTs are used to transmit and validate information
    between parties, hence why is so important to understand this concept well. There
    are several workflows recognized by the protocol. Let’s see here a simplified
    representation of the **authorization code flow** ([https://openid.net/specs/openid-connect-core-1_0.html](https://openid.net/specs/openid-connect-core-1_0.html))
    of the protocol with all the actors, and then see the parts we need to implement
    this in our Vue 3 SPAs:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenID协议中，JWT用于在各方之间传输和验证信息，这就是为什么理解这个概念如此重要的原因。该协议认可了几个工作流程。让我们在这里看看协议的**授权代码流**（[https://openid.net/specs/openid-connect-core-1_0.html](https://openid.net/specs/openid-connect-core-1_0.html)）的简化表示，以及所有参与者，然后看看我们需要在我们的Vue
    3 SPAs中实现的部分：
- en: '![Figure 5.6 – The OpenID authorization code flow in all its beauty](img/Figure_5.06_B18602.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图5.6 – OpenID授权代码流的全貌](img/Figure_5.06_B18602.jpg)'
- en: Figure 5.6 – The OpenID authorization code flow in all its beauty
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – OpenID授权代码流的全貌
- en: 'As you can see, for this workflow to happen, we need three actors: 1) our SPA,
    handling multiple routes, 2) the authentication **service provider** (**SP**)
    server, and 3) our own backend server. It is possible to do the authentication
    and validation of our backend in the browser, then only needing two actors, but
    this is not recommended as it exposes the secret key in our JavaScript. The option
    is there, however, for embedded applications such as mobile apps where the user
    has no easy access to the page code (in hybrid applications).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，为了使此工作流程发生，我们需要三个参与者：1) 我们的单页应用（SPA），处理多个路由，2) 认证**服务提供商**（**SP**）服务器，以及3)
    我们自己的后端服务器。在浏览器中执行我们后端的认证和验证是可能的，这样只需要两个参与者，但这样做并不推荐，因为它会暴露我们的JavaScript中的密钥。然而，对于用户无法轻松访问页面代码的嵌入式应用程序（如移动应用）来说，这个选项是存在的。
- en: 'In order to implement the workflow, the client (our application) must register
    with the authentication service. The process depends on each entity, but as a
    result, we will have registered the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现工作流程，客户端（我们的应用）必须向认证服务进行注册。这个过程取决于每个实体，但结果是我们将注册以下内容：
- en: A `client_id` identification string, unique to our application.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个独特的`client_id`标识字符串，仅适用于我们的应用。
- en: A `secret_key` value, which will be known only to the authentication server
    and our backend application. This will be used to encode and sign our tokens.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`secret_key`值，这将只被认证服务器和我们的后端应用所知。这将用于编码和签名我们的令牌。
- en: A series of *endpoints* in the authentication server, and in our application
    where the user will be redirected in each step. Appropriate exchange of tokens
    will be done in these redirects as part of the query string in the URL.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证服务器中的一系列*端点*，以及在我们应用中，用户将在每个步骤被重定向的地方。在这些重定向过程中，将作为URL查询字符串的一部分进行适当的令牌交换。
- en: 'So, let’s see these steps in detail, and how to implement them in our Vue 3
    application:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们详细看看这些步骤，以及如何在我们的Vue 3应用中实现它们：
- en: '| **Step** | **Description** |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **描述** |'
- en: '| --- | --- |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | The user needs to be authenticated, so we redirect them to the endpoint
    given to us by the authentication server. The query string needs to be included
    with the following (mandatory) fields:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '| 1 | 用户需要被认证，因此我们将他们重定向到认证服务器给我们的端点。查询字符串需要包含以下（强制）字段：'
- en: '`scope`: **openid**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scope`：**openid**'
- en: '`response_type`: **code**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response_type`：**code**'
- en: '`client_id`: The client identification given by the authentication server'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client_id`：认证服务器提供的客户端标识'
- en: '`redirect_uri`: The same address that we registered with the server where the
    user will be redirected upon successful authentication'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirect_uri`：用户在成功认证后将被重定向到的与服务器注册的相同地址'
- en: '`state`: Any data or application state that we want to receive in return after
    the authentication'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`：我们希望在认证后返回的任何数据或应用状态'
- en: To prepare the redirection URL, we first create an object with the preceding
    fields and values, and use the `URLSearchParams` creator to create a query string
    (see [https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)):`const`
    `query_data={scope:"openid", ...},``query_string=new URLSearchParams(query_data).toString()`Next,
    we can use the location object to execute the redirection:`location.assign("https://auth_endpoint"
    + "?" +` `query_string)` |
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备重定向 URL，我们首先创建一个包含前面字段和值的对象，并使用 `URLSearchParams` 创建器来创建一个查询字符串（见 [https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)）:`const`
    `query_data={scope:"openid", ...},``query_string=new URLSearchParams(query_data).toString()`接下来，我们可以使用
    location 对象来执行重定向:`location.assign("https://auth_endpoint" + "?" +` `query_string)`
    |
- en: '| 2 | On successful authentication, the authentication server will redirect
    the user to the endpoint that we registered as the receiver. The query parameters
    sent will depend on the result of the operation:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '| 2 | 在成功认证后，认证服务器将用户重定向到我们注册为接收者的端点。发送的查询参数将取决于操作的结果：'
- en: 'Successful sign-in:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功登录：
- en: '`code`: The `identity_token`.'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`code`: `identity_token`。'
- en: '`state`: Any data we sent to the server and want back. We can use this to redirect
    the user inside our application, for example.'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`: 我们发送到服务器并希望返回的任何数据。我们可以使用它在我们应用程序内部重定向用户，例如。'
- en: 'Unsuccessful sign-in:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录失败：
- en: '`error`: An error code as specified by the protocol (`interaction_required`,
    `invalid_request_uri`, and so on).'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`: 根据协议指定的错误代码（`interaction_required`、`invalid_request_uri` 等）。'
- en: '|'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  | The redirect will trigger our application being loaded, and the router
    will render our designated component. In our script setup, we need to capture
    the query string passed to us, to be used later in the next step. One approach
    to do this without the use of third-party libraries is with the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '|  | 重定向将触发我们的应用程序加载，并且路由器将渲染我们指定的组件。在我们的脚本设置中，我们需要捕获传递给我们的查询字符串，以便在下一步中使用。一种不使用第三方库的方法是以下代码：'
- en: '[PRE21]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| 3 | In this step, we just send the code received to our backend, which would
    mean implementing the `sendToServer()` function mentioned previously. Since now
    we are dealing with our own implementation, the way to do this is trivial. In
    this example, we are using Axios:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '| 3 | 在这一步，我们只需将接收到的代码发送到我们的后端，这意味着实现之前提到的 `sendToServer()` 函数。由于我们现在处理的是自己的实现，这样做是显而易见的。在这个例子中，我们使用
    Axios：'
- en: '[PRE22]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the previous example, we have sent to our server the `code_token` string
    and received from our server the `identity_token` string as response. We then
    go one step beyond and set the default headers for our application to use the
    standard `Authorization` header, with a `Bearer` token. From then on, our server
    only needs to check the headers and verify that the operation requested belongs
    to a valid user. |
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们已经将 `code_token` 字符串发送到我们的服务器，并从我们的服务器接收了 `identity_token` 字符串作为响应。然后我们更进一步，将应用程序的默认头设置为使用标准的
    `Authorization` 头，带有 `Bearer` 令牌。从那时起，我们的服务器只需要检查头并验证请求的操作属于有效用户。 |
- en: Implementing the validation of the tokens and *steps 4* and *5* go beyond the
    scope of this book, as we are focusing on Vue 3 applications. As you can see,
    the part that our SPA needs to handle is quite simple and does not really involve
    much code (some error checking was omitted for the sake of brevity).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 验证令牌以及 *步骤 4* 和 *步骤 5* 超出了本书的范围，因为我们专注于 Vue 3 应用程序。正如你所见，我们的单页应用程序（SPA）需要处理的部分相当简单，实际上并不涉及太多代码（为了简洁起见，省略了一些错误检查）。
- en: There is a good number of syndicated authentication services, both free and
    paid, that we can implement in our application. Most common these days is to see
    badges redirecting users to use them, such as signing in with *Google*, *Facebook*,
    *Twitter*, *GitHub*, *Microsoft*, and so on. There are also meta-services that
    provide all the aforementioned providers inside well-packaged libraries, such
    as **Auth0** ([https://auth0.com/](https://auth0.com/), now part of **Okta**,
    [https://www.okta.com/](https://www.okta.com/)). When it comes to implementing
    this workflow, we are certainly not short of options.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有相当多的联合认证服务，既有免费的也有付费的，我们可以在我们的应用程序中实现。如今最常见的做法是看到徽章将用户重定向到使用它们，例如使用 *Google*、*Facebook*、*Twitter*、*GitHub*、*Microsoft*
    等进行登录。还有提供所有上述提供者并在良好包装的库中的元服务，例如 **Auth0** ([https://auth0.com/](https://auth0.com/),
    现在是 **Okta** 的部分，[https://www.okta.com/](https://www.okta.com/))。当涉及到实现此工作流程时，我们当然不会缺少选择。
- en: Passwordless or one-time password (OTP) authentication
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another solution to remove the use of credentials is to remove them altogether
    with passwordless access. The basic idea is to rely on the security of another
    system (email, mobile texts, authenticator apps, and so on) to validate the user.
    The process generates a time-sensitive “one-time use only” code and sends it to
    the user through the supporting system via the backend service. The frontend service
    (the application) awaits the right to be entered by the user in a determined time
    frame. For example, a common implementation is for the backend to send a text
    message to the user’s phone containing the code, which has to be entered into
    the application before the time expires.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a visual representation of this workflow, considering that the user
    has been registered with an email or phone number. These are supposed to be *well
    known*, meaning that the ownership has been verified:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Passwordless authentication based on email](img/Figure_5.07_B18602.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Passwordless authentication based on email
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding workflow, notice that the OTP code never reaches the web application
    until the user inputs it. The validation occurs in the backend, not in the frontend.
    This makes our application very simple, as it only needs to collect the email
    first and submit it to the server, and then wait for the specified time for a
    new input. In a service or component, using Axios, this code would look something
    like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we have omitted the imports and the template, as at this
    point they should be trivial for the reader. Our template should have at least
    an input to collect the email of the user, and a second input to collect the OTP
    code, plus two buttons to trigger on click the `signInUser()` function and the
    `checkOTP()` function. The first one will pass the email to the backend, and wait
    for a reply with at least a time in seconds to wait, which we use to start a timer
    (it is always good to let the user know how much time they have to enter the code).
    Nowadays, for emails and text messages, the standard is 60 seconds. When this
    happens, we also hide the first input and then show the “OTP” input form. When
    the user enters the code and clicks `checkOTP()` function is activated, and we
    pass the code again to the server waiting for a reply. On success, we can redirect
    the user to a protected area according to our application logic. Considering the
    triviality of the template, it would be a good exercise for the reader to create
    the component and template by themself. Then, a possible solution can be found
    in the code examples, in the [*Chapter* *5*](B18602_05.xhtml#_idTextAnchor130)
    folder.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Following a progressive approach to security, the next step is to join the
    previous approaches into a common new process: **two-factor authentication** (**2FA**),
    which we will see now.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 2FA - Two Factors Authentication
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In 2FA, our application merges two or more of the previous approaches to validate
    a user. The key concept behind this method is that even a third party or simple
    username and password are not enough, and the user needs to have a “secondary
    factor” to be validated—for example, the use of a registered email, phone number
    (for SMS submission of codes), authentication apps (example: Google Authenticator),
    a USB device, a security card (with a chip or band reader), and so on.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The workflow is simple but does require more from our backend than from our
    frontend application. Once our SPA authenticates our user using any of the methods
    listed previously, a second request is triggered on the backend to submit the
    proper query to the security device. Let’s assume that our user receives an SMS
    from our server with a code. Our SPA will wait and collect this code during a
    specific time frame (usually, 60 seconds), and submit it to the backend to a specific
    endpoint. It is the server that then validates the code. In reality, this is like
    having two or multiple passwords, whose validation is made in cascade. Any step
    fails, and the entire operation is discarded.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a visualization of the process:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – A simplified view of our SPA and server interactions with 2FA](img/Figure_5.08_B18602.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – A simplified view of our SPA and server interactions with 2FA
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the simplified workflow, the process of validating a user
    with 2FA (as with passwordless and OTM methods) does not rely so much on the code
    or some specific cryptography but on the use of clever communication and data
    isolation. The data and validation process never leaves our server or could be
    visible to an end user, even if opening the code of our SPA. In a way, you can
    think of this workflow as the concatenation of an OpenID or credentials authentication,
    followed by an OTP implementation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Our application’s main responsibility is just to collect the bits of data that
    make up each step and relay them to the server. In between, we could change the
    route or update the interface, but this implementation is trivial, so we won’t
    see specific code here (you can see previously how to programmatically change
    a route, for example).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: In general, 2FA is considered a “more secure method”, but it is not without
    its drawbacks, and it may not be the right fit for every application. For example,
    what happens if you know your username and password, but lose your secondary device
    (your mobile gets stolen, hacked, and so on)? Organizations that use this method
    often provide a way to recover your identity, often with expensive implementations
    (think of a bank and phone service). In the end, this method does apply one more
    layer of complexity in the authentication of users, and with it, another possible
    point of failure, ending with very frustrated users if not handled properly.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see next another authentication method that is gaining traction as the
    new kid on the block of authentication patterns: Web3 authentication.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Web3 authentication
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dig into the topic, we need to define what **Web3** is. There seems
    to be some confusion as to the extent of the definition, so for our purposes,
    Web3 is believed to be the next iteration or evolution of the internet, where
    the processing power is done in decentralized and distributed servers, using blockchain
    technologies. The most well-known and popular applications of these technologies
    nowadays are cryptocurrencies, decentralized self-governing organizations, decentralized
    finances, play-to-earn games, distributed cloud storage, and much more.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: A **blockchain** is a ledger that is maintained by a network of distributed
    computers. Anything written to it is immutable, and publicly visible by anyone
    on the network. Some blockchains are “smart”, meaning that they can contain not
    only data but also run applications, much like any backend service. The frontend
    applications that connect to a blockchain are called **distributed applications
    (DApps**), which are, for the most part, *SPAs*. For this task, the Vue 3 framework
    is very well suited, as we have seen thus far. A DApp must connect with a backend
    server that is part of the target blockchain network. These types of servers are
    known as **nodes**. In some cases, the DApp can interact directly with the blockchain.
    Most, if not all, blockchains use cryptocurrencies to regulate operations and
    reward the contributing nodes supporting the network. Cryptocurrencies are logically
    assigned to a unique blockchain ID called a “wallet”. These wallets implement
    some very smart cryptographic techniques to validate each other when performing
    operations, through the use of public and private keys. A user may have many wallets.
    There are no emails or ways to recover lost keys in a blockchain, and each wallet
    is unique.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: In order to resolve all this cryptographic signage and validation, and to make
    it easier for users, there are special plugins for browsers called “digital wallets,"
    as well as mobile application wallets that also implement web browsing. These
    applications hold the credentials and do the heavy lifting when dealing with the
    blockchain. There are, of course, numerous libraries to do the same tasks in pure
    JavaScript, but this goes beyond the scope of this book. What we will see next
    is how in our SPA, we can leverage the power of these technologies to identify
    a user, even automatically when visiting our application page.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'We will focus mainly on the biggest smart blockchain, the Ethereum network,
    as an example. The same workflow with more or fewer steps applies to other networks
    using different SDKs, so the migration or incorporation of additional blockchains
    is not too far away from our examples. The basic conceptual workflow is as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Import a library to connect to the network in our JavaScript, either through
    a library such as `web3js` ([https://www.npmjs.com/package/web3](https://www.npmjs.com/package/web3)),
    `ethjs``window.ethereum`
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Using the `ethereum` object, we request the user to connect their wallet to
    our site and retrieve the selected wallet address
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our application then can send to our backend the wallet ID (that is public)
    and use it as the unique ID for the user’s account
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As just mentioned, we will use the object injected by **MetaMask** (https://metamask.io/)
    since it is one of the best-known browser wallets. In this case, here is the code
    that requests the current user’s wallet:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That’s it! The highlighted line prompts *MetaMask* to open a new window and
    request the user’s permission to connect their wallet to your web application,
    and then return a handy promise. If approved, the result will be an array of strings,
    where the first position is the wallet address for the current network. If rejected,
    an error will be triggered.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: With MetaMask, you can open the **Developer Tools** in the browser and type
    in one line the preceding code to test it.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Using `windows` object a new object called `.solana`. Check the documentation
    of your target blockchain to become acquainted with the details of each implementation.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with each blockchain and the code thereof is beyond the scope of
    this book, so we will limit ourselves to identifying the user by their wallet
    address. Having obtained this identification, it is up to our application logic
    to store them for future reference, as it acts like the user ID.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: There are also third-party solutions to authenticate and interact with multiple
    blockchains, and we should consider them before implementing our own solution.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we considerably improved our application and created a sound
    SPA with navigation using the Vue router. This is an important concept to segment
    our application and organize the work between the members of a development team.
    Fractioning our application following the navigation path makes development and
    maintenance easier to approach and better organized. We also learned several authentication
    standard patterns that we can consider for our applications, covering a good number
    of scenarios used today in the industry, from the very basic username and password,
    all the way to the new Web3 DApps. We also took time to understand how standard
    protocols such as OAuth work, as well as OTPs, and how these can be implemented
    for an extra layer of security as a second-factor authentication. All these skills
    are relevant and necessary for today’s web application standards.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we continue expanding our technical knowledge with the
    introduction of **progressive web** **applications** (**PWAs**).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have covered multiple different topics and introduced new concepts in this
    chapter. Use the following questions to solidify what you just learned:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: When is better to use a SPA instead of an MPA and vice versa?
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the benefits of using a router in our SPA? Name at least three from
    your own analysis.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you use views to define the layout of your application?
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you access the parameters and query string passed to your route in your
    JavaScript?
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some common standard patterns to authenticate users?
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some security considerations when authenticating users in a SPA?
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
