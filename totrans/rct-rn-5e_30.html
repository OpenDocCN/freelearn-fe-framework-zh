<html><head></head><body>
  <div id="_idContainer243" class="Basic-Text-Frame">
    <h1 class="chapterNumber">28</h1>
    <h1 id="_idParaDest-314" class="chapterTitle">Going Offline</h1>
    <p class="normal">Users expect applications to operate seamlessly with unreliable network connections. If your mobile application can’t cope with transient network issues, your users will use a different app. When there’s no network, you have to persist data locally on the device. Alternatively, perhaps your app doesn’t even require network access, in which case you’ll still need to store data locally.</p>
    <p class="normal">In this chapter, you’ll learn how to do those three things with React Native. First, you’ll learn how to detect the state of the network connection. Second, you’ll learn how to store data locally. Lastly, you’ll learn how to synchronize local data that’s been stored due to network problems once it comes back online.</p>
    <p class="normal">In this chapter, we’ll cover the following topics:</p>
    <ul>
      <li class="bulletList">Detecting the state of the network</li>
      <li class="bulletList">Storing application data</li>
      <li class="bulletList">Synchronizing application data</li>
    </ul>
    <h1 id="_idParaDest-315" class="heading-1">Technical requirements</h1>
    <p class="normal">You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter28"><span class="url">https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter28</span></a>.</p>
    <h1 id="_idParaDest-316" class="heading-1">Detecting the state of the network</h1>
    <p class="normal">If your code tries to make a request over the network while disconnected using <code class="inlineCode">fetch()</code>, for example an error will occur. You probably have error-handling code in place for these <a id="_idIndexMarker910"/>scenarios already, since the server could return some other type of error.</p>
    <p class="normal">However, in the case of connectivity trouble, you might want to detect this issue before the user attempts to make network requests.</p>
    <p class="normal">There are two potential reasons for proactively detecting the network state. The first one is to prevent the user from performing any network requests until you’ve detected that the app is back online. To do that, you can display a friendly message to the user stating that, since the network is disconnected, they can’t do anything. The other possible benefit of early network state detection is that you can prepare to perform actions offline and sync the app state when the network is connected again.</p>
    <p class="normal">Let’s look at some code that uses the <code class="inlineCode">NetInfo</code> utility from the <code class="inlineCode">@react-native-community/netinfo</code> package to handle changes in network state:</p>
    <pre class="programlisting code"><code class="hljs-code">const connectedMap = {
  none: "Disconnected",
  unknown: "Disconnected",
  cellular: "Connected",
  wifi: "Connected",
  bluetooth: "Connected",
  ethernet: "Connected",
  wimax: "Connected",
  vpn: "Connected",
  other: "Connected",
} as const;
</code></pre>
    <p class="normal"><code class="inlineCode">connectedMap</code> covers all connection states and will help us to render them on the screen. Let’s now see the <code class="inlineCode">App</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">App</span>() {
  <span class="hljs-keyword">const</span> [connected, setConnected] = <span class="hljs-title">useState</span>(<span class="hljs-string">""</span>);
  <span class="hljs-title">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">function</span> <span class="hljs-title">onNetworkChange</span>(<span class="hljs-params">connection: NetInfoState</span>) {
      <span class="hljs-keyword">const</span> type = connection.<span class="hljs-property">type</span>;
      <span class="hljs-title">setConnected</span>(connectedMap[type]);
    }
    <span class="hljs-keyword">const</span> unsubscribe = <span class="hljs-title">NetInfo</span>.<span class="hljs-title">addEventListener</span>(onNetworkChange);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title">unsubscribe</span>();
    };
  }, []);
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">View</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.container}</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>{connected}<span class="hljs-tag">&lt;/</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">This component <a id="_idIndexMarker911"/>will render the state of the network based on the string values in <code class="inlineCode">connectedMap</code>. The <code class="inlineCode">onNetworkChange</code> event of the <code class="inlineCode">NetInfo</code> object will cause the connected state to change. </p>
    <p class="normal">For example, when you run this app for the first time, the screen might look like this:</p>
    <figure class="mediaobject"><img src="../Images/B19636_28_01.png" alt="Picture 1"/></figure>
    <p class="packt_figref">Figure 28.1: Connected state</p>
    <p class="normal">Then, if you turn <a id="_idIndexMarker912"/>off networking on your host machine, the network state will change on the emulated device as well, causing the state of our application to change, as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19636_28_02.png" alt="Picture 2"/></figure>
    <p class="packt_figref">Figure 28.2: Disconnected state</p>
    <p class="normal">This is how you <a id="_idIndexMarker913"/>can use network state detection in the app. As discussed, together with showing the message, you can use network state to prevent users from making API requests. Another valuable approach would be to save user inputs locally until the network gets back online. Let’s explore it in the next section.</p>
    <h1 id="_idParaDest-317" class="heading-1">Storing application data</h1>
    <p class="normal">To store data <a id="_idIndexMarker914"/>on the device, there is a special cross-platform solution called <code class="inlineCode">AsyncStorage</code> API. It works the same on both the iOS and Android platforms. You would use this API for <a id="_idIndexMarker915"/>applications that don’t require any network connectivity in the first place or to store data that will eventually be synchronized using an API endpoint once a network becomes available.</p>
    <p class="normal">To install the <code class="inlineCode">async-storage</code> package, run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">npx expo install @react-native-async-storage/async-storage
</code></pre>
    <p class="normal">Let’s look at some code that allows the user to enter a <code class="inlineCode">key</code> and a <code class="inlineCode">value</code> and then stores them:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">App</span>() {
  <span class="hljs-keyword">const</span> [key, setKey] = <span class="hljs-title">useState</span>(<span class="hljs-string">""</span>);
  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title">useState</span>(<span class="hljs-string">""</span>);
  <span class="hljs-keyword">const</span> [source, setSource] = useState&lt;<span class="hljs-title">KeyValuePair</span>[]&gt;([]);
</code></pre>
    <p class="normal">The <code class="inlineCode">key</code>, <code class="inlineCode">value</code>, and <code class="inlineCode">source</code> values will handle our state. To save it in <code class="inlineCode">AsyncStorage</code>, we need to define functions:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">function</span> <span class="hljs-title">setItem</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-title">AsyncStorage</span>.<span class="hljs-title">setItem</span>(key, value)
      .<span class="hljs-title">then</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title">setKey</span>(<span class="hljs-string">""</span>);
        <span class="hljs-title">setValue</span>(<span class="hljs-string">""</span>);
      })
      .<span class="hljs-title">then</span>(loadItems);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title">clearItems</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-title">AsyncStorage</span>.<span class="hljs-title">clear</span>();
  }
  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title">loadItems</span>() {
    <span class="hljs-keyword">const</span> keys = <span class="hljs-keyword">await</span> <span class="hljs-title">AsyncStorage</span>.<span class="hljs-title">getAllKeys</span>();
    <span class="hljs-keyword">const</span> values = <span class="hljs-keyword">await</span> <span class="hljs-title">AsyncStorage</span>.<span class="hljs-title">multiGet</span>(keys);
    <span class="hljs-title">setSource</span>([...values]);
  }
  <span class="hljs-title">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title">loadItems</span>();
  }, []);
</code></pre>
    <p class="normal">We’ve defined handlers to save values from the inputs, clear <code class="inlineCode">AsyncStorage</code>, and load saved items <a id="_idIndexMarker916"/>when we start the app. Here’s the markup that’s rendered by the <code class="inlineCode">App</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">View</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.container}</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>Key:<span class="hljs-tag">&lt;/</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">TextInput</span>
<span class="hljs-tag">        </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.input}</span>
<span class="hljs-tag">        </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">{key}</span>
<span class="hljs-tag">        </span><span class="hljs-attr">onChangeText</span><span class="hljs-tag">=</span><span class="hljs-string">{(v)</span><span class="hljs-tag"> =&gt;</span> {
          setKey(v);
        }}
      /&gt;
      <span class="hljs-tag">&lt;</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>Value:<span class="hljs-tag">&lt;/</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">TextInput</span>
<span class="hljs-tag">        </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.input}</span>
<span class="hljs-tag">        </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">{value}</span>
<span class="hljs-tag">        </span><span class="hljs-attr">onChangeText</span><span class="hljs-tag">=</span><span class="hljs-string">{(v)</span><span class="hljs-tag"> =&gt;</span> {
          setValue(v);
        }}
      /&gt;
      <span class="hljs-tag">&lt;</span><span class="hljs-name">View</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.controls}</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">Button</span><span class="hljs-tag"> </span><span class="hljs-attr">label</span><span class="hljs-tag">=</span><span class="hljs-string">"Add"</span><span class="hljs-tag"> </span><span class="hljs-attr">onPress</span><span class="hljs-tag">=</span><span class="hljs-string">{setItem}</span><span class="hljs-tag"> /&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">Button</span><span class="hljs-tag"> </span><span class="hljs-attr">label</span><span class="hljs-tag">=</span><span class="hljs-string">"Clear"</span><span class="hljs-tag"> </span><span class="hljs-attr">onPress</span><span class="hljs-tag">=</span><span class="hljs-string">{clearItems}</span><span class="hljs-tag"> /&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
</code></pre>
    <p class="normal">The markup in the preceding code block is represented as inputs and buttons to create, save, and delete items. Next, we will render the list of items with the <code class="inlineCode">FlatList</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code">      &lt;<span class="hljs-title">View</span> style={styles.<span class="hljs-property">list</span>}&gt;
        <span class="hljs-tag">&lt;</span><span class="hljs-name">FlatList</span>
<span class="hljs-tag">          </span><span class="hljs-attr">data</span><span class="hljs-tag">=</span><span class="hljs-string">{source.map(([key,</span><span class="hljs-tag"> </span><span class="hljs-attr">value</span><span class="hljs-tag">]) =&gt;</span> ({
            key: key.toString(),
            value,
          }))}
          renderItem={({ item: { value, key } }) =&gt; (
            <span class="hljs-tag">&lt;</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>
              {value} ({key})
            <span class="hljs-tag">&lt;/</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>
          )}
        /&gt;
      &lt;<span class="hljs-regexp">/View&gt;</span>
<span class="hljs-regexp">    &lt;/</span><span class="hljs-title">View</span>&gt;
  );
</code></pre>
    <p class="normal">Before we <a id="_idIndexMarker917"/>walk through what this code is doing, let’s take a look at the following screen, since it’ll explain most of what we’re going to cover when storing application data:</p>
    <figure class="mediaobject"><img src="../Images/B19636_28_03.png" alt="Picture 3"/></figure>
    <p class="packt_figref">Figure 28.3: Storing application data</p>
    <p class="normal">As you can see in <em class="italic">Figure 28.3</em>, there are two input fields and two buttons. The fields allow the user to enter a new <code class="inlineCode">key</code> and <code class="inlineCode">value</code>. The <strong class="screenText">Add</strong> button allows the user to store this key-value pair locally on their device, while the <strong class="screenText">Clear</strong> button clears any existing items that have been stored previously.</p>
    <p class="normal">The <code class="inlineCode">AsyncStorage</code> API works the same for both iOS and Android. Under the hood, <code class="inlineCode">AsyncStorage</code> works very differently, depending on which platform it’s running on. The reason React Native is able to expose the same storage API on both platforms is due to its simplicity: it’s just key-value pairs. Anything more complex than that is left up to the application developer.</p>
    <p class="normal">The abstractions <a id="_idIndexMarker918"/>that you’ve created around <code class="inlineCode">AsyncStorage</code> in this example are minimal. The idea is to set and get items. However, even straightforward actions like this deserve an abstraction layer. For example, the <code class="inlineCode">setItem()</code> method you’ve implemented here will make the asynchronous call to <code class="inlineCode">AsyncStorage</code> and update the item’s state once that has been completed. Loading items is even more complicated because you need to get the keys and values as two separate asynchronous operations.</p>
    <p class="normal">The reason we do this is to keep the UI responsive. If there are pending screen repaints that need to happen while data is being written to disk, preventing those from happening by blocking them would lead to a suboptimal user experience.</p>
    <p class="normal">In the next section, you’ll learn how to synchronize data that’s been stored locally while the device is offline with remote services once the device comes back online.</p>
    <h1 id="_idParaDest-318" class="heading-1">Synchronizing application data</h1>
    <p class="normal">So far in this chapter, you’ve learned how to detect the state of a network connection and how to <a id="_idIndexMarker919"/>store data locally in a React Native application. Now, it’s time to combine these two concepts and implement an app that can detect network outages and continue to function.</p>
    <p class="normal">The basic idea is to only make network requests when you know for sure that the device is online. If you know that it isn’t, you can store any changes in the state locally. Then, when you’re back online, you can synchronize those stored changes with the remote API.</p>
    <p class="normal">Let’s implement a simplified React Native app that does this. The first step is to implement an abstraction that sits between the React components and the network calls that store data. We’ll call this module <code class="inlineCode">store.ts</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title">set</span>(<span class="hljs-params">key: Key, value: boolean</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Promise</span>(<span class="hljs-function">(</span><span class="hljs-params">resolve, reject</span><span class="hljs-function">) =&gt;</span> {
    <span class="hljs-keyword">if</span> (connected) {
      fakeNetworkData[key] = value;
      <span class="hljs-title">resolve</span>(<span class="hljs-literal">true</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title">AsyncStorage</span>.<span class="hljs-title">setItem</span>(key, value.<span class="hljs-title">toString</span>()).<span class="hljs-title">then</span>(
        <span class="hljs-function">() =&gt;</span> {
          unsynced.<span class="hljs-title">push</span>(key);
          <span class="hljs-title">resolve</span>(<span class="hljs-literal">false</span>);
        },
        <span class="hljs-function">(</span><span class="hljs-params">err</span><span class="hljs-function">) =&gt;</span> <span class="hljs-title">reject</span>(err)
      );
    }
  });
}
</code></pre>
    <p class="normal">The <code class="inlineCode">set</code> method depends on the <code class="inlineCode">connected</code> variable, and depending on whether there is an internet <a id="_idIndexMarker920"/>connection or not, it handles the different logic. Actually, the <code class="inlineCode">get</code> method also follows the same approach:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">key?: Key</span>): <span class="hljs-title">Promise</span>&lt;boolean | <span class="hljs-keyword">typeof</span> fakeNetworkData&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Promise</span>(<span class="hljs-function">(</span><span class="hljs-params">resolve, reject</span><span class="hljs-function">) =&gt;</span> {
    <span class="hljs-keyword">if</span> (connected) {
      <span class="hljs-title">resolve</span>(key ? fakeNetworkData[key] : fakeNetworkData);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key) {
      <span class="hljs-title">AsyncStorage</span>.<span class="hljs-title">getItem</span>(key)
        .<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">item</span><span class="hljs-function">) =&gt;</span> <span class="hljs-title">resolve</span>(item === <span class="hljs-string">"true"</span>))
        .<span class="hljs-title">catch</span>(<span class="hljs-function">(</span><span class="hljs-params">err</span><span class="hljs-function">) =&gt;</span> <span class="hljs-title">reject</span>(err));
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title">AsyncStorage</span>.<span class="hljs-title">getAllKeys</span>()
        .<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">keys</span><span class="hljs-function">) =&gt;</span>
          <span class="hljs-title">AsyncStorage</span>.<span class="hljs-title">multiGet</span>(keys).<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">items</span><span class="hljs-function">) =&gt;</span>
            <span class="hljs-title">resolve</span>(<span class="hljs-title">Object</span>.<span class="hljs-title">fromEntries</span>(items) <span class="hljs-keyword">as</span> any)
          )
        )
        .<span class="hljs-title">catch</span>(<span class="hljs-function">(</span><span class="hljs-params">err</span><span class="hljs-function">) =&gt;</span> <span class="hljs-title">reject</span>(err));
    }
  });
}
</code></pre>
    <p class="normal">This module exports two functions, <code class="inlineCode">set()</code> and <code class="inlineCode">get()</code>. Their jobs are to set and get data, respectively. Since this is just a demonstration of how to sync between local storage and network endpoints, this module just mocks the actual network with the <code class="inlineCode">fakeNetworkData</code> object.</p>
    <p class="normal">Let’s start by looking at the <code class="inlineCode">set()</code> function. It’s an asynchronous function that will always return a promise that resolves to a Boolean value. If it’s true, it means that you’re online and that the call over the network was successful. If it’s false, it means that you’re offline, and <code class="inlineCode">AsyncStorage</code> was used to save the data.</p>
    <p class="normal">The same <a id="_idIndexMarker921"/>approach is used with the <code class="inlineCode">get()</code> function. It returns a promise that resolves a Boolean value that indicates the state of the network. If a key argument is provided, then the value for that key is looked up. Otherwise, all the values are returned, either from the network or from <code class="inlineCode">AsyncStorage</code>.</p>
    <p class="normal">In addition to these two functions, this module does two other things: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">NetInfo</span>.<span class="hljs-title">fetch</span>().<span class="hljs-title">then</span>(
  <span class="hljs-function">(</span><span class="hljs-params">connection</span><span class="hljs-function">) =&gt;</span> {
    connected = [<span class="hljs-string">"wifi"</span>, <span class="hljs-string">"unknown"</span>].<span class="hljs-title">includes</span>(connection.<span class="hljs-property">type</span>);
  },
  <span class="hljs-function">() =&gt;</span> {
    connected = <span class="hljs-literal">false</span>;
  }
);
<span class="hljs-title">NetInfo</span>.<span class="hljs-title">addEventListener</span>(<span class="hljs-function">(</span><span class="hljs-params">connection</span><span class="hljs-function">) =&gt;</span> {
  connected = [<span class="hljs-string">"wifi"</span>, <span class="hljs-string">"unknown"</span>].<span class="hljs-title">includes</span>(connection.<span class="hljs-property">type</span>);
  <span class="hljs-keyword">if</span> (connected &amp;&amp; unsynced.<span class="hljs-property">length</span>) {
    <span class="hljs-title">AsyncStorage</span>.<span class="hljs-title">multiGet</span>(unsynced).<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">items</span><span class="hljs-function">) =&gt;</span> {
      items.<span class="hljs-title">forEach</span>(<span class="hljs-function">(</span><span class="hljs-params">[key, val]</span><span class="hljs-function">) =&gt;</span> <span class="hljs-title">set</span>(key <span class="hljs-keyword">as</span> <span class="hljs-title">Key</span>, val === <span class="hljs-string">"true"</span>));
      unsynced.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;
    });
  }
});
</code></pre>
    <p class="normal">It uses <code class="inlineCode">NetInfo.fetch()</code> to set the connected state. Then, it adds a listener to listen for changes in the network state. This is how items that were saved locally when you were offline become synced with the network when it’s connected again.</p>
    <p class="normal">Now, let’s check out the main application that uses these functions:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">App</span>() {
  <span class="hljs-keyword">const</span> [message, setMessage] = useState&lt;string | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [first, setFirst] = <span class="hljs-title">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [second, setSecond] = <span class="hljs-title">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [third, setThird] = <span class="hljs-title">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> setters = <span class="hljs-keyword">new</span> <span class="hljs-title">Map</span>([
    [<span class="hljs-string">"first"</span>, setFirst],
    [<span class="hljs-string">"second"</span>, setSecond],
    [<span class="hljs-string">"third"</span>, setThird],
  ]);
</code></pre>
    <p class="normal">Here, we have <a id="_idIndexMarker922"/>defined the state variables that we will use in the <code class="inlineCode">Switch</code> components:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">function</span> <span class="hljs-title">save</span>(<span class="hljs-params">key: Key</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-function">(</span><span class="hljs-params">value: boolean</span><span class="hljs-function">) =&gt;</span> {
      <span class="hljs-title">set</span>(key, value).<span class="hljs-title">then</span>(
        <span class="hljs-function">(</span><span class="hljs-params">connected</span><span class="hljs-function">) =&gt;</span> {
          setters.<span class="hljs-title">get</span>(key)?.(value);
          <span class="hljs-title">setMessage</span>(connected ? <span class="hljs-literal">null</span> : <span class="hljs-string">"Saved Offline"</span>);
        },
        <span class="hljs-function">(</span><span class="hljs-params">err</span><span class="hljs-function">) =&gt;</span> {
          <span class="hljs-title">setMessage</span>(err);
        }
      );
    };
  }
</code></pre>
    <p class="normal">The <code class="inlineCode">save()</code> function helps us to reuse logic in a different <code class="inlineCode">Switch</code> component. Next, we have the <code class="inlineCode">useEffect</code> hook to get saved data when the page renders for the first time:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-title">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title">NetInfo</span>.<span class="hljs-title">fetch</span>().<span class="hljs-title">then</span>(<span class="hljs-function">() =&gt;</span>
      <span class="hljs-title">get</span>().<span class="hljs-title">then</span>(
        <span class="hljs-function">(</span><span class="hljs-params">items</span><span class="hljs-function">) =&gt;</span> {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-title">Object</span>.<span class="hljs-title">entries</span>(items)) {
            setters.<span class="hljs-title">get</span>(key)?.(value);
          }
        },
        <span class="hljs-function">(</span><span class="hljs-params">err</span><span class="hljs-function">) =&gt;</span> {
          <span class="hljs-title">setMessage</span>(err);
        }
      )
    );
  }, []);
</code></pre>
    <p class="normal">Next, let’s take <a id="_idIndexMarker923"/>a look at the final markup of the page:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">View</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.container}</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>{message}<span class="hljs-tag">&lt;/</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>First<span class="hljs-tag">&lt;/</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">Switch</span><span class="hljs-tag"> </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">{first}</span><span class="hljs-tag"> </span><span class="hljs-attr">onValueChange</span><span class="hljs-tag">=</span><span class="hljs-string">{save(</span><span class="hljs-tag">"</span><span class="hljs-attr">first</span><span class="hljs-tag">")} /&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>Second<span class="hljs-tag">&lt;/</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">Switch</span><span class="hljs-tag"> </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">{second}</span><span class="hljs-tag"> </span><span class="hljs-attr">onValueChange</span><span class="hljs-tag">=</span><span class="hljs-string">{save(</span><span class="hljs-tag">"</span><span class="hljs-attr">second</span><span class="hljs-tag">")} /&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>Third<span class="hljs-tag">&lt;/</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">Switch</span><span class="hljs-tag"> </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">{third}</span><span class="hljs-tag"> </span><span class="hljs-attr">onValueChange</span><span class="hljs-tag">=</span><span class="hljs-string">{save(</span><span class="hljs-tag">"</span><span class="hljs-attr">third</span><span class="hljs-tag">")} /&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
  );
</code></pre>
    <p class="normal">The job of the <code class="inlineCode">App</code> component is to save the state of three <code class="inlineCode">Switch</code> components, which is difficult when you’re providing the user with a seamless transition between online and offline modes. Thankfully, your <code class="inlineCode">set()</code> and <code class="inlineCode">get()</code> abstractions, which are implemented in another module, hide most of the details from the application’s functionality.</p>
    <p class="normal">Note, however, that you need to check the state of the network in this module before you attempt to load any items. If you don’t do this, then the <code class="inlineCode">get()</code> function will assume that you’re offline, even if the connection is fine. </p>
    <p class="normal">Here’s what the app looks like:</p>
    <figure class="mediaobject"><img src="../Images/B19636_28_04.png" alt="Picture 4"/></figure>
    <p class="packt_figref">Figure 28.4: Synchronizing application data</p>
    <p class="normal">Note that <a id="_idIndexMarker924"/>you won’t actually see the <strong class="screenText">Saved Offline</strong> message until you change something in the UI.</p>
    <h1 id="_idParaDest-319" class="heading-1">Summary</h1>
    <p class="normal">This chapter introduced us to storing data offline in React Native applications. The main reason we would want to store data locally is when the device goes offline and our app can’t communicate with a remote API. However, not all applications require API calls, and <code class="inlineCode">AsyncStorage</code> can be used as a general-purpose storage mechanism. We just need to implement the appropriate abstractions around it.</p>
    <p class="normal">We also learned how to detect changes in the network state of React Native apps. It’s important to know when the device has gone offline so that our storage layer doesn’t make pointless attempts at network calls. Instead, we can let the user know that the device is offline and then synchronize the application state when a connection is available.</p>
    <p class="normal">In the next chapter, we’ll learn how to import and use UI components from the NativeBase library.</p>
    <h1 id="_idParaDest-320" class="heading-1">Join us on Discord!</h1>
    <p class="normal">Read this book alongside other users and the authors themselves. Ask questions, provide solutions to other readers, chat with the authors, and more. Scan the QR code or visit the link to join the community.</p>
    <p class="normal"><a href="https://packt.link/ReactAndReactNative5e"><span class="url">https://packt.link/ReactAndReactNative5e</span></a></p>
    <p class="normal"><img src="../Images/QR_Code196803360665486921.png" alt="" role="presentation"/></p>
  </div>
</body></html>