- en: Chapter 1. Component-Based User Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we'll cover a lot of Angular-related topics in this book, the focus
    will be mainly on creating component-based user interfaces. It's one thing to
    understand a framework, such as Angular 2, but it's a whole different thing to
    establish an effective workflow using a component-based architecture. In this
    book, I'll try to explain the core concepts behind Angular 2 components and how
    we can leverage this architecture to create modern, efficient, and maintainable
    user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Besides learning all the necessary concepts behind Angular 2, we will together
    create a task-management application from scratch. This will allow us to explore
    different approaches to solve common UI problems using the component system that
    is provided by Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: '![Component-Based User Interfaces](img/image00298.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A preview of the task management application that we are going to build
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at how component-based user interfaces
    help us build greater applications. Over the course of this book, we will build
    an Angular 2 application together, where we will use the component-based approach
    to its full potential. This chapter will also introduce you to the technologies
    that are used in this book. The topics that we will cover in this chapter are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to component-based user interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation and composition using component-based user interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evolution of UI frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard and Web components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to the Angular 2 component system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your first Angular 2 component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview and history of ECMAScript and TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECMAScript 7 decorators as meta annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Node.js-based tooling using JSPM and SystemJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thinking of organisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today's user interfaces do not consist of just a bunch of form elements that
    are cobbled together onto a screen. Modern users experience design and innovative
    visual presentations of interactive content challenges technology more than ever.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, we almost always tend to think in pages when we flesh out concepts for
    web applications, such as the pages within a printed book. Well, this is probably
    the most efficient way to convey information for this kind of content and medium.
    You can skim through the pages one by one without any real physical effort, read
    paragraph by paragraph, and just scan through the chapters that you don't find
    interesting.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with thinking in pages too much is that this concept, which is borrowed
    from books, does not really translate well to how things work in the real world.
    The world is created from organisms that form a system of organisms together.
    This system itself forms an organism again, just on a higher level.
  prefs: []
  type: TYPE_NORMAL
- en: Take our bodies as an example. We mostly consist of independent organs that
    interact with each other using electrical and chemical signals. Organs themselves
    consist of proteins that on their own work like a machine to form a system. Down
    to the molecules, atoms, protons, and quarks, we can't really tell where one starts
    and where it ends. What we can tell for sure is that it's all about systems of
    organisms with interdependencies, and it is not about pages.
  prefs: []
  type: TYPE_NORMAL
- en: I like to view user interfaces as systems of organisms. Whether if, where, and
    how they are distributed to pages is subordinate while designing them. Also, they
    should work independently, and they should interact with each other on an interdependent
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Components – The organs of user interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"We''re not designing pages, we''re designing systems of components."*
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Stephen Hay* |'
  prefs: []
  type: TYPE_TB
- en: This quote by Stephen Hay from BDConf in Orlando 2012 brings it to the point.
    Interface design is really not about pages. To create efficient user interfaces
    for not only the users but also the developers who maintain them, we need to think
    in systems of components. Components are independent, but they can interact with
    each other and create larger components when they are arranged together. We need
    to look at user interfaces holistically and using components enables us to do
    this.
  prefs: []
  type: TYPE_NORMAL
- en: In the following topics, we're going to explore a few fundamental aspects of
    components. Some of these are already known from other concepts, such as **object-oriented
    programming** (**OOP**), but they appear in a slightly different light when thinking
    about components.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encapsulation is a very important factor when thinking about maintenance in
    a system. Having a classical OOP background, I've learned that encapsulation means
    bundling logic and data together into an isolated container. This way, we can
    operate on the container from the outside and treat it like a closed system.
  prefs: []
  type: TYPE_NORMAL
- en: There are many positive aspects of this approach when it comes to maintainability
    and accessibility. Dealing with closed systems is important for the organization
    of our code. However, this is even more importantly because we can organize ourselves
    while working with code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Encapsulation](img/image00299.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I have a pretty bad memory, and it's very important for me to find the right
    focus level when working on code. Immediate memory research told us that the human
    brain can remember about seven items at once on an average. Therefore, it's crucial
    for us to write code in such a way that it allows us to focus on fewer and smaller
    pieces at once.
  prefs: []
  type: TYPE_NORMAL
- en: A clear encapsulation helps us in organizing our code. We can maybe forget all
    the internals of the closed system and about the kind of logic and data that we've
    put into it. We can focus only on its surface, which allows us to work on a higher-abstraction
    level. Similar to the previous figure, without using a hierarchy of encapsulated
    components, we'd have all our code cobbled together on the same level.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation encourages us to isolate small and concise components and build
    a system of components. During development, we can focus on the internals of one
    component and only deal with the interface of other components.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we forget that all the organization of the coding we actually perform
    is for ourselves and not for the computer that runs this code. If this was for
    the computer, then we would probably all start writing in machine language again.
    A strong encapsulation helps us access specific code easily, focus on one layer
    of the code, and trust the underlying implementations within capsules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following JavaScript example shows you how to use encapsulation to write
    maintainable applications. Let''s assume that we are in a T-shirt factory, and
    we need some code to produce T-shirts with a background and foreground color.
    This example uses some new language features of ECMAScript 6\. If you''re not
    familiar with the language features of ECMAScript 6, don''t worry too much at
    this point. We will learn about these later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using a clean encapsulation, we can now work with the abstraction of color in
    our T-shirt. We don't need to worry about how to calculate the hexadecimal representation
    of colors at the T-shirt level because this is already done by the `Colour` class.
    This makes your application maintainable and keeps it very open for change.
  prefs: []
  type: TYPE_NORMAL
- en: I really recommend that you read about the SOLID principles if you haven't done
    so already. As the name already suggests, this assembly of principles is a solid
    power tool that can change the way you organize code tremendously. You can learn
    more about the SOLID principles in the book, *Agile Principles, Patterns*, *and
    Practices,* by Robert C. Martin.
  prefs: []
  type: TYPE_NORMAL
- en: Composability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Composition is a special kind of reusability. You don't extend an existing component,
    but you create a new larger component by composing many smaller components together
    into a system of components.
  prefs: []
  type: TYPE_NORMAL
- en: In OOP languages, composition is often used to get around the multiple inheritance
    issues that most OOP languages have. Subclass polymorphism is always great until
    you reach the point where your design does not match the latest requirements in
    your project. Let's look at a simple example that illustrates this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have a `Fisher` class and a `Developer` class, both of which hold specific
    behaviors. Now, you''d want to create a `FishingDeveloper` class that inherits
    both from `Fisher` and `Developer`. Unless you''re using a language that supports
    multiple inheritance (such as C++ does to a certain extent), you will not be able
    to reuse this functionality using inheritance. There is no way to tell the language
    that your new class should inherit from both super classes. Using composition,
    you can easily solve this problem. Instead of using inheritance, you''re composing
    a new `FishingDeveloper` class that delegates all behavior to an internal `Developer`
    and `Fisher` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Experience has taught us that composition is probably the most efficient way
    to reuse code. In contrast to inheritance, decoration, and other approaches to
    gain reusability, composition is probably the least intrusive and the most flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Recent versions of some languages also support a pattern called traits, that
    is, `mixins`. Traits allow you to reuse certain functionality and attributes from
    other classes in a way that is similar to multiple inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: If we think about the concept of composition, it's nothing more than designing
    organisms. We have the two `Developer` and `Fisher` organisms, and we unify their
    behaviors into a single `FishingDeveloper` organism.
  prefs: []
  type: TYPE_NORMAL
- en: Components, invented by nature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Components, embracing encapsulation, and composition are an effective way to
    build maintainable applications. Composed from components, applications are very
    resistant to the negative implications of change, and change is a necessary thing
    that will happen to every application. It's only a matter of time until your design
    will be challenged by the effects of change; therefore, it's very important to
    write code that can handle change as smoothly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Nature is the best teacher. Almost all the achievements in technological developments
    have their origin in observations of how nature solves problems. If we look at
    evolution, it's an ongoing redesign of matter by adapting to outer forces and
    constraints. Nature solves this by constant change using mutation and natural
    selection.
  prefs: []
  type: TYPE_NORMAL
- en: If we project the concept of evolution onto developing an application, we can
    say that nature does actually refactor its code in every single moment. This is
    actually the dream of every product manager—an application that can undergo constant
    change but does not lose any of its efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: I believe that there are two key concepts that play a major role in nature that
    allows it to apply constant change in its design without losing much efficiency.
    This uses encapsulation and composition. Coming back to the example of our bodies,
    we can actually tell that our organs use a very clear encapsulation. They use
    membranes to create isolation, veins to transport nutrition, and synapses to send
    messages. Also, they have interdependencies, and they communicate with electrical
    and chemical messages. Most obviously, they form larger systems, which is the
    core concept of composition.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are many other factors, and I'm not a professor in biology.
    However, I think it's a fascinating thing to see that we have learned to organize
    our code very similarly to how nature organizes matter.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of creating reusable UI components is quite old, and it was implemented
    in various languages and frameworks. One of the earliest systems that used UI
    components was probably the Xerox Alto system back in 1970s. It used reusable
    UI components that allowed developers to create an application by composing them
    on a screen where users could interact with them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Components, invented by nature](img/image00300.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The user interface of file manager on the Xerox Alto system from the 1970s.
  prefs: []
  type: TYPE_NORMAL
- en: Early frontend UI frameworks, such as DHTMLX, Ext JS, or jQuery UI implemented
    components in a more limited fashion that didn't provide great flexibility or
    extensibility. Most of these frameworks just provided widget libraries. The problem
    with UI widgets is that they mostly don't embrace the pattern of composition enough.
    You can arrange widgets on a page and they provide encapsulation, but with most
    toolkits, you can't create larger components by nesting them inside each other.
    Some toolkits solve this by providing a special kind of widget which was mostly
    called a container. However, this is not the same as a full-fledged component
    tree that allows you to create systems within systems. Containers were actually
    meant to provide a visual layout container rather than a composite container to
    form a larger system.
  prefs: []
  type: TYPE_NORMAL
- en: Usually when working with widgets on a page of our application, we'd have a
    large controller that controls all these widgets, user input, and states. However,
    we are left with two levels of composition, and there's no way that we can structure
    our code more granularly. There is the page and there are the widgets. Having
    a bunch of UI widgets is simply not enough, and we are almost back to the state
    where we create pages plastered with form elements.
  prefs: []
  type: TYPE_NORMAL
- en: I've been a user of JavaServer Faces for years, and besides all its problems,
    the concept of having reusable custom elements was groundbreaking. Using XHTML,
    one could write so-called composite components that consisted of other composite
    components or native HTML elements. A developer could gain a fantastic level of
    reusability using composition. The big issue in my view with this technology was
    that it did not address the concerns in the frontend enough to become really usable
    for complex user interactions. In fact, a framework like this should live completely
    within the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: My UI framework wishlist
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Usually when UI frameworks get compared, they get measured against each other
    based on metrics, such as widget count, theming capabilities, and asynchronous
    data retrieval features. Every framework has its strengths and weaknesses, but
    leaving all the extra features aside and reducing it to the core concerns of a
    UI framework, I only have a few metrics left that I''d like to be assessed. These
    metrics are, of course, not the only ones that are important in today''s UI development,
    but they also are the main factors toward building a clean architecture that supports
    the principle of change:'
  prefs: []
  type: TYPE_NORMAL
- en: I can create encapsulated components with clear interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I can create larger components by composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I can make components interact with each other within their hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're looking for a framework which enables you to take full advantage of
    component-based UI development, you should look for these three key measures.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, I think it's very important to understand the main purpose of
    the web and how it evolved. If we think of the web in its early days in the 1990s,
    it was probably only about hypertext. There were very basic semantics that could
    be used to structure information and display them to a user. HTML was created
    to hold structure and information. The need for custom visual presentation of
    information led to the development of CSS right after HTML started being widely
    used.
  prefs: []
  type: TYPE_NORMAL
- en: 'It was in the mid 1990s when Brendan Eich invented JavaScript, and it was first
    implemented in Netscape Navigator. By providing a way to implement behavior and
    state, JavaScript was the last missing piece for a full web customization:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Technology | Concern |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| HTML | Structure and information |'
  prefs: []
  type: TYPE_TB
- en: '| CSS | Presentation |'
  prefs: []
  type: TYPE_TB
- en: '| JavaScript | Behavior and state |'
  prefs: []
  type: TYPE_TB
- en: We have learned to keep these concerns as separate as possible in order to maintain
    a clean architecture. Although there are different opinions on this and some recent
    technologies also move away from this principle, I believe that a clean separation
    of these concerns is very important to create a maintainable application.
  prefs: []
  type: TYPE_NORMAL
- en: Leaving this view aside, the standard definition of encapsulation from OOP is
    just concerned about coupling and isolation of logic and data. This probably applies
    well to classic software components. However, as soon as we consider a user interface
    as part of an architecture, there is a new dimension that is added.
  prefs: []
  type: TYPE_NORMAL
- en: Classical MVC frameworks are view centric, and developers organize their code
    based on pages. You'll probably go ahead and create a new view that represents
    a page. Of course, your view needs a controller and model, so you'll also create
    them. The problem with organization by pages is that there's little to no gain
    of reusability. Once you've created a page and you'd like to reuse only some parts
    of the page, you will need a way to encapsulate only a specific part of this model—the
    view and the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'UI components solve this problem nicely. I like to see them as a modular approach
    to MVC. Although they still embrace the MVC pattern, they also establish encapsulation
    and composability. This way a view is a component itself, but it also consists
    of components. By composing views of components, one can gain a maximum amount
    of reusability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![My UI framework wishlist](img/image00301.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: UI components embrace MVC, but they also support encapsulation and composition
    on a much lower level
  prefs: []
  type: TYPE_NORMAL
- en: Technically, there are some challenges when implementing components with web
    technologies. JavaScript was always flexible enough to implement different patterns
    and paradigms. Working with encapsulation and composition isn't an issue at all,
    and the controlling part and the model of components can easily be implemented.
    Approaches, such as the revealing module pattern, namespaces, prototypes, or the
    recent ECMAScript 6 modules, provide all the tools that are needed from the JavaScript
    side.
  prefs: []
  type: TYPE_NORMAL
- en: However, for the view part of our components, we face some limitations. Although
    HTML supports great flexibility in terms of composability because the DOM tree
    is nothing else than a big composition, we have no way to reuse these compositions.
    We can only create one large composition, which is the page itself. HTML being
    only the final view that was delivered from the server, this was never really
    a real concern. Today's applications are much more demanding, and we need to have
    a fully-encapsulated component running in the browser, which also consists of
    a partial view.
  prefs: []
  type: TYPE_NORMAL
- en: We face the same problem with CSS. There is no real modularization and encapsulation
    while writing CSS, and we need to use namespaces and prefixes in order to segregate
    our CSS styles. Still, the whole cascading nature of CSS can easily destroy all
    encapsulation that we try to bring in place using CSS-structuring patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Time for new standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web standards have been evolving immensely in the last couple of years. There
    are so many new standards, and the browser became such a big multimedia framework,
    that it's hard for other platforms to compete with this.
  prefs: []
  type: TYPE_NORMAL
- en: I'd even go as far as to say that web technology will actually replace other
    frameworks in the future, and it probably will be renamed to multimedia technology
    or something similar. There's no reason why we need to use different native frameworks
    to create user interfaces and presentations. Web technologies embed so many features
    that it's hard to find a reason not to use them for any kind of application. Just
    look at the Firefox OS or the Chrome OS, which are designed to run with web technologies.
    I think it's only a matter of time until more operating systems and embedded devices
    make use of web technologies to implement their software. This is why I believe
    that at some point it will be questionable whether the term *web technologies*
    is still appropriate or whether we should replace it with a more general term.
  prefs: []
  type: TYPE_NORMAL
- en: Although we usually just see new features appear in browsers, there is a very
    open and long-winded standardization process behind them. It's very important
    to standardize features, but this takes a lot of time, especially when people
    disagree about different approaches to solving problems.
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to the concept of components, this is something where we really
    need support from web standards to break the current limitations. Fortunately,
    the W3C thought the same, and a group of developers started to work on specifications
    under the hood of an umbrella specification called *web components*.
  prefs: []
  type: TYPE_NORMAL
- en: The following topics will give you a brief overview over two specifications
    that also play a role in Angular 2 components. One of Angular 2's core strengths
    is that it acts more like a superset of web standards rather than being a complete
    isolated framework.
  prefs: []
  type: TYPE_NORMAL
- en: Template elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Template elements allow you to define regions within your HTML, which will not
    be rendered by the browser. You can then instantiate these document fragments
    with JavaScript and then place the resulting DOM within your document.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the browser is actually parsing the template content, it only does so
    in order to validate the HTML. Any immediate actions that the parser would usually
    execute will not be taken. Within the content of template elements, images will
    not be loaded and scripts won''t be executed. Only after a template is instantiated,
    the parser will take the necessary actions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple HTML example of a template element won''t display the heading on
    your page. As the heading is inside a template element, we first need to instantiate
    the template and add the resulting DOM into our document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using these three lines of JavaScript, we can instantiate the template and append
    it into our document.
  prefs: []
  type: TYPE_NORMAL
- en: Shadow DOM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This part of the web components specification was the missing piece to create
    proper DOM encapsulation and composition. With shadow DOM, we can create isolated
    parts of the DOM that are protected against regular DOM operations from the outside.
    Also, CSS will not reach into shadow DOM automatically, and we can create local
    CSS within our component.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you add a `style` tag inside shadow DOM, the styles are scoped to the root
    within the shadow DOM, and they will not leak outside. This enables a very strong
    encapsulation for CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Content insertion points make it easy to control content from the outside of
    a shadow DOM component, and it provides some kind of an interface to pass in content.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, shadow DOM is supported by most browsers although
    it still needs to be enabled in Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: Angular's component architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For me, the concept of directives from the first version of Angular changed
    the game in frontend UI frameworks. This was the first time that I felt that there
    was a simple yet powerful concept that allowed the creation of reusable UI components.
    Directives could communicate with DOM events or messaging services. They allowed
    you to follow the principle of composition, and you could nest directives and
    create larger directives that solely consisted of smaller directives arranged
    together. Actually, directives were a very nice implementation of components for
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll look into the component-based architecture of Angular
    2 and how the things we've learned about components will fit into Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Everything is a component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an early adopter of Angular 2 and while talking to other people about it,
    I got frequently asked what the biggest difference is to the first version. My
    answer to this question was always the same. Everything is a component.
  prefs: []
  type: TYPE_NORMAL
- en: '![Everything is a component](img/image00302.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For me, this paradigm shift was the most relevant change that both simplified
    and enriched the framework. Of course, there are a lot of other changes with Angular
    2\. However, as an advocate of component-based user interfaces, I've found that
    this change is the most interesting one. Of course, this change also came with
    a lot of architectural changes.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 supports the idea of looking at the user interface holistically and
    supporting composition with components. However, the biggest difference to its
    first version is that now your pages are no longer global views, but they are
    simply components that are assembled from other components. If you've been following
    this chapter, you'll notice that this is exactly what a holistic approach to user
    interfaces demands. No more pages but systems of components.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular 2 still uses the concept of directives, although directives are now
    really what the name suggests. They are orders for the browser to attach a given
    behavior to an element. Components are a special kind of directives that come
    with a view.
  prefs: []
  type: TYPE_NORMAL
- en: Your first component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Keeping up the tradition, before we start building a real application together,
    we should write our first `hello world` component with Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is already a fully-working Angular 2 application. We used ECMAScript 6
    classes to create the necessary encapsulation required for a component. You can
    also see a meta-annotation that is used to declaratively configure our component.
    This statement, which looks like a function call that is prefixed with an *at*
    symbol actually comes from the ECMAScript 7 decorator proposal.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ECMAScript 7 decorators are still very experimental at the time of writing this
    book. For the code in this book, we actually use the TypeScript transpiler version
    1.5 that already implements decorators with a slight twist to the original specification.
    TypeScript 1.5 is also used by the Angular 2 team to develop the core of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to understand that an element can only be bound to one single
    component. As a component always comes with a view, there is no way that we can
    bind more than one component to an element. On the other hand, an element can
    be bound to many directives, as directives don't come with a view but they only
    attach behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Component` decorator, we need to configure everything that is relevant
    to describe our component for Angular. This, of course, also includes our template
    for the view. In the preceding example, we are specifying our template directly
    within JavaScript as a string. We can also use the `templateUrl` property to specify
    a URL where the template should be loaded from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s enhance our example a little bit so that we can see how we can
    compose our application from smaller components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we have now created a small component that allows us to shout
    out words as we like. In our *Hello World* application, we make use of this component
    to shout out **Hello, World!**
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every directive or component that is used inside a components view template
    needs to be explicitly declared in the directives property of the view annotation.
    Otherwise, the compiler will not recognize the directive when it encounters the
    element in the template.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of this book and while writing our task management application,
    we will learn a lot more about the configuration and implementation of components.
    However, before we start with this in the second chapter, we should take a look
    at some tools and language features that we'll use during this book.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript of the future
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It was not so long ago that somebody asked me whether we should really use the
    bind function of ECMAScript 5.1, as then we'd probably run into browser compatibility
    issues. The web moves very fast, and we need to keep up the pace. We can't write
    code that does not use the latest features even if this would cause issues in
    old browsers.
  prefs: []
  type: TYPE_NORMAL
- en: The fantastic people from TC39, the technical committee that is responsible
    for writing the ECMAScript specification, have done a great job progressively
    enhancing the JavaScript language. This, and the fact that JavaScript is so flexible,
    allows us to use so-called polyfills and shims to make our code run in older browsers.
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 6 (also referred to as ECMAScript 2015) was published in June 2015,
    exactly four years after its predecessor. There is a massive amount of new API
    additions as well as a whole bunch of new language features. The language features
    are syntactic sugar, and ECMAScript 6 can be transpiled to its previous version
    where it runs perfectly in older browsers. At the time of writing this book, none
    of the current browser versions have fully implemented ECMAScript 6, but there's
    absolutely no reason not to use it for production applications.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Syntactic sugar is a design approach where we evolve a programming language
    while not breaking backwards compatibility. This allows language designers to
    come up with new syntax, which enriches developer experience but does not break
    the web. Every new feature needs to be translatable to the old syntax. This way,
    so-called transpilers can be used to convert code to older versions.
  prefs: []
  type: TYPE_NORMAL
- en: I speak JavaScript, translate, please!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While compilers compile from a higher-level language to a lower-level language,
    a transpiler or transcompiler acts more like a converter. It is a source-to-source
    compiler that translates code to run in a different interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Recently, there's a real battle among new languages that are transpiled to JavaScript
    and can run in the browser. I used Google Dart for quite some time, and I must
    admit, I really loved the language features. The problem with nonstandardized
    languages is that they depend heavily on community adoption and the hype. Also,
    it's almost certain that they will never run natively within the browser. This
    is also the reason why I prefer standard JavaScript, and the JavaScript of the
    future uses transpilers that allow me to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Some people argue that transpilers introduce code that does not run very performant
    and, therefore, recommend that you do not use ECMAScript 6 and transpilers at
    all. I don't agree with this because of many reasons. Usually, this is about performance
    in micro or even nanosecond areas where this often really does not matter for
    most applications.
  prefs: []
  type: TYPE_NORMAL
- en: I don't say performance doesn't matter, but performance needs to always be discussed
    within a context. If you're trying to optimize a loop within your application
    by reducing processing time from 10 microseconds to five microseconds where you'd
    never iterate over more than 100 items, then you're probably spending your time
    on the wrong things.
  prefs: []
  type: TYPE_NORMAL
- en: Also, a very important fact is that transpiled code is designed by people who
    understand micro performance optimization much better than I do, and I'm sure
    their code runs faster than mine. On top of this, a transpiler is probably also
    the right place where you'd want to do performance optimization because this code
    is automatically generated and you don't lose maintainability of your code through
    performance quirks.
  prefs: []
  type: TYPE_NORMAL
- en: I'd like to quote Donald Knuth here and say that premature optimization is the
    root of all evil. I really recommend that you read his paper on this topic (Donald
    Knuth, December 1974, *Structured Programming with go to Statements*). Just because
    the `goto` statements got banished from all modern programming languages, it doesn't
    mean this is less of a good read.
  prefs: []
  type: TYPE_NORMAL
- en: Later on in this chapter, you'll learn about tools that help you use transpilers
    easily within your project, and we'll take a look at the decisions and directions
    Angular went with their source code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a few language features that come with ECMAScript 6 and make our
    life much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes were among one the most requested features in JavaScript, and I was
    one of the people voting for it. Well, coming from an OOP background and being
    used to organizing everything within classes, it was hard for me to let go. Although,
    after working with modern JavaScript for some time, you'll reduce their use to
    the bare minimum and to exactly what they are made for—inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes in ECMAScript 6 provide you with syntactic sugar to deal with prototypes,
    constructor functions, super calls, and object property definitions in a way that
    you have the illusion that JavaScript could be a class-based OOP language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we learned in the previous topic about transpilers, ECMAScript 6 can be
    de-sugared to ECMAScript 5\. Let''s take a look at what a transpiler would produce
    from this simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This simple example can easily be built using ECMAScript 5\. However, once we
    use the more complex features of class-based object-oriented languages, the de-sugaring
    gets quite complicated.
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 6 classes introduce simplified syntax to write class member functions
    (static functions), the use of the super keyword, and inheritance using the `extends`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to read more about the features in classes and ECMAScript
    6, I highly recommend that you read the articles of Dr. Axel Rauschmayer ([http://www.2ality.com/](http://www.2ality.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modules provide a way to encapsulate your code and create privacy. In object-oriented
    languages, we usually use classes for this. However, I actually believe this is
    an antipattern rather than a good practice. Classes should be used where inheritance
    is desired and not just to structure your code.
  prefs: []
  type: TYPE_NORMAL
- en: I'm sure that you've encountered a lot of different module patterns in JavaScript
    already. One of the most popular ones that creates privacy using a function closure
    of an **immediately invoked function expression** (**IIFE**) is probably the revealing
    module pattern. If you'd like to read more about this and may be other great patterns,
    I recommend the book, *Learning JavaScript Design Patterns,* by Addy Osmani.
  prefs: []
  type: TYPE_NORMAL
- en: Within ECMAScript 6, we can now use modules to serve this purpose. We simply
    create one file per module, and then we use the import and export keywords to
    connect our modules together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the ECMAScript 6 module specification, we can actually export as many
    things as we like from each module. We can then import these named exports from
    any other module. We can have one default export per module, which is especially
    easy to import. Default exports don''t need to be named, and we don''t need to
    know their name when importing them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There are many combinations on how to use modules. We will discover some of
    these together while working on our task management application during the upcoming
    chapters. If you'd like to see more examples on how to use modules, I can recommend
    the Mozilla Developer Network documentation ([https://developer.mozilla.org](https://developer.mozilla.org))
    on the `import` and `export` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Template strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Template strings are a very simple, but they are an extremely useful addition
    to the JavaScript syntax. They serve three main purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing multiline strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String interpolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tagged template strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before template strings, it was quite verbose to write multiline strings. You
    needed to concatenate pieces of strings and append a new-line character yourself
    to the line endings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Using template strings, we can simplify this example a lot. We can write multiline
    strings, and we can also use the string interpolation functionality for our title
    variable that we used to concatenate earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note the back ticks instead of the previous single quotes. Template strings
    are always written between back ticks, and the parser will interpret all characters
    in between them as part of the resulting string. This way, the new-line characters
    present in our source file will also be part of the string automatically.
  prefs: []
  type: TYPE_NORMAL
- en: You can also see that we have used the dollar sign, followed by curly brackets
    to interpolate our strings. This allows us to write arbitrary JavaScript within
    strings and helps a lot while constructing HTML template strings.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about template strings on the Mozilla Developer Network.
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript or TypeScript?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TypeScript was created in 2012 by Anders Hejlsberg with the intention to implement
    the future standard of ECMAScript 6 but also to provide a superset of syntax and
    features that was not part of the specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many features in TypeScript as a superset to the ECMAScript 6 standard,
    including, but not limited to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Optional static typing with type annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enum types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to understand that all of the features that TypeScript provides
    as a superset are optional. You can write pure ECMAScript 6 and not take advantage
    of the additional features that TypeScript provides. The TypeScript compiler will
    still transcompile pure ECMAScript 6 code to ECMAScript 5 without any errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the features that are seen in TypeScript are actually already present
    in other languages, such as Java and C#. One goal of TypeScript was to provide
    language features that support workflows and better maintainability for large-scale
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with any nonstandard language is that nobody can tell how long the
    language will be maintained and how fast the momentum of the language will be
    in the future. In terms of support, the chances are high that TypeScript, with
    its sponsor Microsoft, will actually have a long life. However, there's still
    no guarantee that the momentum and trend of the language will keep moving at a
    reasonable pace. This problem does obviously not exist for standard ECMAScript
    6 because it's what the web of the future is made of and what browsers will speak
    natively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, there are valid reasons to use the extended features of TypeScript if
    you''d want to address the following concerns that clearly outweigh the negative
    implications of an uncertain future in your project:'
  prefs: []
  type: TYPE_NORMAL
- en: Large applications that undergo a huge amount of changes and refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large teams that require a strict governance while working on code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we'll use a TypeScript compiler, but we will work with standard
    ECMAScript 6 code with one exception that is covered in the next topic about decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Decorators are not part of the ECMAScript 6 specification, but they were proposed
    to the ECMAScript 7 standard for 2016\. They provide us with a way to decorate
    classes and properties during design time. This allows a developer to use meta-annotations
    while writing classes, and declaratively attach functionality to the class and
    its properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decorators are named after the decorator pattern that was initially described
    in the book *Design Patterns: Elements of Reusable Object-Oriented Software* of
    Erich Gamma and his colleagues, also known as the **Gang of Four** (**GoF**).'
  prefs: []
  type: TYPE_NORMAL
- en: The principle of decoration is that an existing procedure is intercepted and
    the decorator has the chance to either delegate, provide an alternative procedure,
    or do a mix from both.
  prefs: []
  type: TYPE_NORMAL
- en: '![Decorators](img/image00303.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Visualization of decoration in a dynamic environment with the example of a simple
    access procedure
  prefs: []
  type: TYPE_NORMAL
- en: Decorators in ECMAScript 7 can be used to annotate classes and class properties.
    Note that this also includes class methods, as class methods are also properties
    of the class prototype object. Decorators get defined as regular functions, and
    they can be attached to classes or class properties with the *at* symbol. Our
    decorator function will then be called with contextual information about the location
    of inclusion every time that the decorator is placed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple example that illustrates the use of a decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We have created a `logAccess` decorator that will log all function calls that
    are tagged with the decorator. If we look at the `MoneySafe` class, you can see
    that we have decorated the `openSafe` method with our `logAccess` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: The `logAccess` decorator function will be executed for each annotated property
    within our code. This enables us to intercept the property definition of the given
    property. Let's take a look at the signature of our decorator function. Decorator
    functions that are placed on class properties will be called with the target object
    of the property definition as a first parameter. The second parameter is the actual
    property name that is defined, followed by the last parameter, which is the descriptor
    object that is supposed to be applied to the object.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator gives us the opportunity to intercept the property definition.
    In our case, we use this ability to exchange the descriptor value (which is the
    annotated function) with a proxy function that will log the function call before
    calling the origin function (delegation). For simplification purposes, we've implemented
    a very simple yet incomplete function proxy. For real-world scenarios, it would
    be advisable to use a better proxy implementation, such as the ECMAScript 6 proxy
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators are a great feature to leverage aspect-oriented concepts and declaratively
    add behavior to our code at design time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a second example where we use an alternative way to declare
    and use decorators. We can treat decorators like function expressions where our
    decorator function is rewritten as a factory function. This form of usage is especially
    useful when you need to pass along configuration to the decorator, which is made
    available in the decorator factory function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have now learned how ECMAScript 7 decorators can help you to write declarative
    code that has an aspect-oriented twist to it. This simplifies development a lot
    because we can now think of behavior that we add to our classes during design
    time when we actually think about the class as a whole and write the initial stub
    of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decorators in TypeScript are slightly different than the decorators from ECMAScript
    7\. They are not limited to classes and class properties, but they can also be
    placed on parameters within the class methods. This allows you to annotate function
    parameters, which can be useful in some cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Angular uses this feature to simplify dependency injection on class constructors.
    As all directive, component, and service classes get instantiated from Angular
    dependency injection and not by us directly, these annotations help Angular find
    the correct dependencies. For this use-case, function parameter decorators actually
    make a lot of sense.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, there are still issues with the implementation of decorators on class
    method parameters, which is also why ECMAScript 7 does not support it. As this
    feature is crucial to build an Angular 2 application, we'll use the TypeScript
    compiler to transpile the code of our application. This is the only TypeScript-specific
    feature that we'll use in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to make use of all these future technologies, we need some tools to
    support us. We were already talking about ECMAScript 6 and decorators, where we
    actually prefer TypeScript decorators, as they support the function parameter
    decorators that are used by Angular 2\. Although the ECMAScript 6 syntax supports
    modules, we still need some sort of a module loader that will actually load the
    required modules in the browser or help us generate an executable bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js and NPM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js is JavaScript on steroids. Initially, a fork of the V8 JavaScript engine
    from the Google Chrome browser, Node.js was extended with more functionality,
    specifically to make JavaScript useful on the server-side. File handling, streams,
    system APIs, and a huge ecosystem of user-generated packages are just some of
    the facts that make this technology an outstanding partner for your web development.
  prefs: []
  type: TYPE_NORMAL
- en: The node package manager, NPM, is a door to over 200,000 packages and libraries
    that help you build your own application or library. The Node.js philosophy is
    very similar to the UNIX philosophy, where packages should stay small and sharp,
    but they should use composition to achieve greater goals.
  prefs: []
  type: TYPE_NORMAL
- en: To build our application, we will rely on Node.js as the host for the tools
    that we're going to use. We should, therefore, make sure that we install Node.js
    on our machine so that we are prepared for the next chapter, where we start to
    craft our task management application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can get Node.js from their website at [https://nodejs.org](https://nodejs.org),
    and it should be a breeze to install this on any kind of operating system by following
    the instructions on their website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve installed Node.js, we can perform a simple test to check whether
    everything is up and running. Open a terminal console and execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: SystemJS and JSPM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many module formats and module loaders out there, but there's one
    that rules them all in my opinion. SystemJS is built on top of an ES6 module loader
    polyfill and, therefore, moves very close to an upcoming standard. I strongly
    believe in standardization and, therefore, prefer SystemJS over other module loaders,
    such as RequireJS, Browserify, or webpack. We should stop using libraries where
    possible and rely on polyfills that make our browser capable of running the code
    of the future.
  prefs: []
  type: TYPE_NORMAL
- en: SystemJS is a universal module loader that is capable of loading many different
    module formats, such as AMD, CommonJS, and ECMAScript 6, and it also supports
    a very flexible shiming mechanism to modularize global JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: SystemJS also supports the most popular transpilers, including ECMAScript 6
    and TypeScript. This means that you can actually load ECMAScript 6 code directly
    in your browser, where it's transpiled by SystemJS in runtime. This is great during
    development, especially because you're allowed to load modules from any location,
    including remote HTTP locations, such as GitHub or the NPM repository.
  prefs: []
  type: TYPE_NORMAL
- en: JSPM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JavaScript package manager is not just another package manager for JavaScript.
    This is basically a mediator and manager for SystemJS that helps you look up packages
    from package repositories, such as Bower or NPM, and it creates the necessary
    configuration for SystemJS. JSPM is written in Node.js and does not come with
    its own remote package repository. As SystemJS needs URLs and module mappings
    to know where to load modules from, JSPM is your tool to create this necessary
    configuration and simplify package installation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with JSPM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create a simple application together using JSPM. First of all, we need
    to install two global modules with NPM. Besides JSPM, we''ll also install a tool
    called live-server, which will help us during development by providing an HTTP
    server that serves static files. It also has file change detection built-in, and
    it will reload your browser automatically once a file change has been detected.
    This provides a very short feedback loop and makes development a very fast process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command on your command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that on UNIX-like systems, such as Linux or Mac OS X, it's sometimes required
    to run NPM as a super user. It's also recommended that you use the **Node Version
    Manager** (**NVM**) to get around those issues ([https://github.com/creationix/nvm](https://github.com/creationix/nvm)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After installing JSPM and the `live-server` package, we can go ahead and create
    our first application using JSPM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new directory for the application, and open a terminal console within
    this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now execute the following command on your terminal console to install
    JSPM locally and initialize a new JSPM project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: JSPM will start a wizard that guides you though the initialization steps. You
    can answer all questions with the default answer (just hit *Enter*) except for
    the question about which transpiler you'd like to use that you should answer with
    TypeScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After JSPM installs all the necessary packages, we can go ahead and create
    our `index.html` file. Navigate to your project folder and create a new file,
    `index.html`, in your favorite editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This very minimalistic HTML is already the foundation for our JSPM Hello World
    application. After including the `SystemJS` library and the `config.js` file that
    was generated by JSPM, we only need to bootstrap our application by telling `SystemJS`
    which file to import.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we create our main application file, we will quickly install jQuery
    as a package, just to demonstrate how easily third-party libraries can be installed
    and used with `SystemJS` and JSPM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After installing jQuery, we can go ahead and create our `main.js` file inside
    of the application folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to run this example in the browser, we can now start our live server
    with the following command executed inside of the application folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After following the preceding steps, you should have a working example with
    ECMAScript 6 and SystemJS using the TypeScript transpiler. Using LiveReload, your
    browser should automatically open and display our Hello World application. You
    can also try now to modify the code a bit and change the sentence that is written
    to the DOM. You'll notice that once you save your changes, the browser will immediately
    reload the page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at a component-based approach to structure user interfaces,
    and we talked about the necessary aspects of its background to understand why
    we are moving in this direction with the web standard and frameworks, such as
    Angular. We also ensured that we are prepared with all the technology that we
    will use in the upcoming chapters in this book. You created your first simple
    example using JSPM, SystemJS, ECMAScript 6, and the TypeScript transpiler. Now,
    we are ready to start building our task-management system using a component-based
    architecture to its full potential.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to start building our task management application
    using Angular 2 components. We'll look at the initial steps that are required
    to create an Angular 2 application from scratch and flesh out the first few components
    in order to build a task list.
  prefs: []
  type: TYPE_NORMAL
