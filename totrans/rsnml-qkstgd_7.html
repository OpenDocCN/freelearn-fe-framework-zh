<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">JSON in Reason</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we'll learn how to work with JSON by building a simple customer management application. This application lives within the <kbd class="calibre11">/customers</kbd> route of our existing app and can create, read, and update customers. JSON data persists to <kbd class="calibre11">localStorage</kbd>. Throughout this chapter, we convert external JSON into a typed data structure that Reason can understand in two different ways:</p>
<ul class="calibre9">
<li class="calibre10">Using pure Reason</li>
<li class="calibre10">Using the <kbd class="calibre11">bs-json</kbd> library</li>
</ul>
<p class="mce-root">We'll compare and contrast each method at the end of the chapter. We'll also discuss how <strong class="calibre4">GraphQL</strong> can help provide a pleasant developer experience when working with JSON in a statically typed language such as Reason.</p>
<p class="mce-root">To follow along with building the customer management application, clone this book's GitHub repository and start from <kbd class="calibre11">Chapter07/app-start</kbd>:</p>
<pre class="calibre16"><strong class="calibre1">git clone https://github.com/PacktPublishing/ReasonML-Quick-Start-Guide.git</strong><br class="title-page-name"/><strong class="calibre1">c</strong><strong class="calibre1">d ReasonML-Quick-Start-Guide</strong><br class="title-page-name"/><strong class="calibre1">cd Chapter07/app-start<br class="title-page-name"/>npm install</strong></pre>
<p class="mce-root">In this chapter we will look at the following topics:</p>
<ul class="calibre9">
<li class="calibre10">Building views</li>
<li class="calibre10">Integrating with localStorage</li>
<li class="calibre10">Using bs-json</li>
<li class="calibre10">Using GraphQL</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building views</h1>
                </header>
            
            <article>
                
<p class="mce-root">In total, we'll have three views:</p>
<ul class="calibre9">
<li class="calibre10">A list view</li>
<li class="calibre10">A create view</li>
<li class="calibre10">An update view</li>
</ul>
<p class="mce-root">Each view has its own route. The create and update views share a common component because they're so similar.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">File structure</h1>
                </header>
            
            <article>
                
<p class="mce-root">Since our <kbd class="calibre11">bsconfig.json</kbd> includes subdirectories, we can create a <kbd class="calibre11">src/customers</kbd> directory to house related components, and BuckleScript will recursively look for Reason (and OCaml) files in subdirectories of <kbd class="calibre11">src</kbd>:</p>
<pre class="calibre16">/* bsconfig.json */<br class="title-page-name"/>...<br class="title-page-name"/>"sources": {<br class="title-page-name"/>  "dir": "src",<br class="title-page-name"/>  <strong class="calibre1">"subdirs": true</strong><br class="title-page-name"/>},<br class="title-page-name"/>...</pre>
<p class="mce-root">Let's move on and rename the <kbd class="calibre11">src/Page1.re</kbd> component to <kbd class="calibre11">src/customers/CustomerList.re</kbd>. In the same directory, we'll later create <kbd class="calibre11">Customer.re</kbd>, which will be used to both create and update individual customers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the router and navigation menu</h1>
                </header>
            
            <article>
                
<p class="mce-root">In <kbd class="calibre11">Router.re</kbd>, we'll replace the <kbd class="calibre11">/page1</kbd> route with the following:</p>
<pre class="calibre16">/* Router.re */<br class="title-page-name"/>let routes = [<br class="title-page-name"/>  ...<br class="title-page-name"/>  {href: "/customers", title: "Customer List", component: &lt;CustomerList /&gt;}<br class="title-page-name"/>  ...<br class="title-page-name"/>];</pre>
<p class="mce-root">We'll also add the routes for <kbd class="calibre11">/customers/create</kbd> and <kbd class="calibre11">/customers/:id</kbd>:</p>
<pre class="calibre16">/* Router.re */<br class="title-page-name"/>let routes = [<br class="title-page-name"/>  ...<br class="title-page-name"/>  {href: "/customers/create", title: "Create Customer", component: &lt;Customer /&gt;,},<br class="title-page-name"/>  {href: "/customers/:id", title: "Update Customer", component: &lt;Customer /&gt;}<br class="title-page-name"/>  ...<br class="title-page-name"/>];</pre>
<div class="packt_infobox">The router has been updated so it can handle route variables (such as <kbd class="calibre20">/customers/:id</kbd>). This change has been made for you in <kbd class="calibre20">Chapter07/app-start</kbd>.</div>
<p class="mce-root">Finally, be sure to also update the navigation menu in <kbd class="calibre11">&lt;App.re /&gt;</kbd>:</p>
<pre class="calibre16">/* App.re */<br class="title-page-name"/>render: self =&gt;<br class="title-page-name"/>  ...<br class="title-page-name"/>  &lt;ul&gt;<br class="title-page-name"/>    &lt;li&gt;<br class="title-page-name"/>      &lt;NavLink href="<strong class="calibre1">/customers</strong>"&gt;<br class="title-page-name"/>        {ReasonReact.string("<strong class="calibre1">Customers</strong>")}<br class="title-page-name"/>      &lt;/NavLink&gt;<br class="title-page-name"/>    &lt;/li&gt;<br class="title-page-name"/>  ...</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CustomerType.re</h1>
                </header>
            
            <article>
                
<p class="mce-root">This file will hold the customer type used by both <kbd class="calibre11">&lt;CustomerList /&gt;</kbd> and <kbd class="calibre11">&lt;Customer /&gt;</kbd>. This is done to avoid any circular dependency compiler errors:</p>
<pre class="calibre16">/* CustomerType.re */<br class="title-page-name"/>type address = {<br class="title-page-name"/>  street: string,<br class="title-page-name"/>  city: string,<br class="title-page-name"/>  state: string,<br class="title-page-name"/>  zip: string,<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>type t = {<br class="title-page-name"/>  id: int,<br class="title-page-name"/>  name: string,<br class="title-page-name"/>  address,<br class="title-page-name"/>  phone: string,<br class="title-page-name"/>  email: string,<br class="title-page-name"/>};</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CustomerList.re</h1>
                </header>
            
            <article>
                
<p class="mce-root">For now, we'll use a hardcoded array of customers. Soon, we'll retrieve this data from <kbd class="calibre11">localStorage</kbd>. The following component renders a styled array of customers. Each customer is wrapped in a <kbd class="calibre11">&lt;Link /&gt;</kbd> component. Clicking on a customer navigates to the update view:</p>
<pre class="calibre16">let component = ReasonReact.statelessComponent("CustomerList");<br class="title-page-name"/><br class="title-page-name"/>let customers: array(CustomerType.t) = [<br class="title-page-name"/>  {<br class="title-page-name"/>    id: 1,<br class="title-page-name"/>    name: "Christina Langworth",<br class="title-page-name"/>    address: {<br class="title-page-name"/>      street: "81 Casey Stravenue",<br class="title-page-name"/>      city: "Beattyview",<br class="title-page-name"/>      state: "TX",<br class="title-page-name"/>      zip: "57918",<br class="title-page-name"/>    },<br class="title-page-name"/>    phone: "877-549-1362",<br class="title-page-name"/>    email: "Christina.Langworth@gmail.com",<br class="title-page-name"/>  },<br class="title-page-name"/>  ...<br class="title-page-name"/>];<br class="title-page-name"/><br class="title-page-name"/>module Styles = {<br class="title-page-name"/>  open Css;<br class="title-page-name"/><br class="title-page-name"/>  let list =<br class="title-page-name"/>    style([<br class="title-page-name"/>      ...<br class="title-page-name"/>    ]);<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>let make = _children =&gt; {<br class="title-page-name"/>  ...component,<br class="title-page-name"/>  render: _self =&gt;<br class="title-page-name"/>    &lt;div&gt;<br class="title-page-name"/>      &lt;ul className=Styles.list&gt;<br class="title-page-name"/>        {<br class="title-page-name"/>          ReasonReact.array(<br class="title-page-name"/>            Belt.Array.map(customers, customer =&gt;<br class="title-page-name"/>              &lt;li key={string_of_int(customer.id)}&gt;<br class="title-page-name"/>                &lt;Link href={"/customers/" ++ string_of_int(customer.id)}&gt;<br class="title-page-name"/>                  &lt;p&gt; {ReasonReact.string(customer.name)} &lt;/p&gt;<br class="title-page-name"/>                  &lt;p&gt; {ReasonReact.string(customer.address.street)} &lt;/p&gt;<br class="title-page-name"/>                  &lt;p&gt; {ReasonReact.string(customer.phone)} &lt;/p&gt;<br class="title-page-name"/>                  &lt;p&gt; {ReasonReact.string(customer.email)} &lt;/p&gt;<br class="title-page-name"/>                &lt;/Link&gt;<br class="title-page-name"/>              &lt;/li&gt;<br class="title-page-name"/>            )<br class="title-page-name"/>          )<br class="title-page-name"/>        }<br class="title-page-name"/>      &lt;/ul&gt;<br class="title-page-name"/>    &lt;/div&gt;,<br class="title-page-name"/>};</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customer.re</h1>
                </header>
            
            <article>
                
<p class="mce-root">This reducer component renders a form where every customer field is editable inside an input element. The component has two modes—<kbd class="calibre11">Create</kbd> and <kbd class="calibre11">Update</kbd>—based on the <kbd class="calibre11">window.location.pathname</kbd>.</p>
<p class="mce-root">We start by binding to <kbd class="calibre11">window.location.pathname</kbd>, and defining our component's actions and state:</p>
<pre class="calibre16">/* Customer.re */<br class="title-page-name"/>[@bs.val] external pathname: string = "window.location.pathname";<br class="title-page-name"/><br class="title-page-name"/>type mode =<br class="title-page-name"/>  | Create<br class="title-page-name"/>  | Update;<br class="title-page-name"/><br class="title-page-name"/>type state = {<br class="title-page-name"/>  mode,<br class="title-page-name"/>  customer: CustomerType.t,<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>type action =<br class="title-page-name"/>  | Save(ReactEvent.Form.t);<br class="title-page-name"/><br class="title-page-name"/>let component = ReasonReact.reducerComponent("Customer");</pre>
<p class="mce-root">Next, we add our component styles using <kbd class="calibre11">bs-css</kbd>. To see the styles, check out <kbd class="calibre11">Chapter07/app-end/src/customers/Customer.re</kbd>:</p>
<pre class="calibre16">/* Customer.re */<br class="title-page-name"/>module Styles = {<br class="title-page-name"/>  open Css;<br class="title-page-name"/><br class="title-page-name"/>  let form =<br class="title-page-name"/>    style([<br class="title-page-name"/>      ...<br class="title-page-name"/>    ]);<br class="title-page-name"/>};</pre>
<p class="mce-root">For now, we will use a hardcoded customer array, which we create in the following snippet. The full array can be found at<span class="calibre5"> </span><kbd class="calibre11">Chapter07/app-end/src/customers/Customer.re</kbd><span class="calibre5">:</span></p>
<pre class="calibre16">/* Customer.re */<br class="title-page-name"/>let customers: array(CustomerType.t) = [|<br class="title-page-name"/>  {<br class="title-page-name"/>    id: 1,<br class="title-page-name"/>    name: "Christina Langworth",<br class="title-page-name"/>    address: {<br class="title-page-name"/>      street: "81 Casey Stravenue",<br class="title-page-name"/>      city: "Beattyview",<br class="title-page-name"/>      state: "TX",<br class="title-page-name"/>      zip: "57918",<br class="title-page-name"/>    },<br class="title-page-name"/>    phone: "877-549-1362",<br class="title-page-name"/>    email: "Christina.Langworth@gmail.com",<br class="title-page-name"/>  },<br class="title-page-name"/>  ...<br class="title-page-name"/>|];</pre>
<p class="mce-root">We also have helper functions, for the following reasons:</p>
<ul class="calibre9">
<li class="calibre10">To extract the customer ID from <kbd class="calibre11">window.location.pathname</kbd></li>
<li class="calibre10">To get a customer by ID</li>
<li class="calibre10">To generate a default customer:</li>
</ul>
<pre class="calibre16">let getId = pathname =&gt;<br class="title-page-name"/>  try (Js.String.replaceByRe([%bs.re "/\\D/g"], "", pathname)-&gt;int_of_string) {<br class="title-page-name"/>  | _ =&gt; (-1)<br class="title-page-name"/>  };<br class="title-page-name"/><br class="title-page-name"/>let getCustomer = customers =&gt; {<br class="title-page-name"/>  let id = getId(pathname);<br class="title-page-name"/>  customers |&gt; Js.Array.find(customer =&gt; customer.CustomerType.id == id);<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>let getDefault = customers: CustomerType.t =&gt; {<br class="title-page-name"/>  id: Belt.Array.length(customers) + 1,<br class="title-page-name"/>  name: "",<br class="title-page-name"/>  address: {<br class="title-page-name"/>    street: "",<br class="title-page-name"/>    city: "",<br class="title-page-name"/>    state: "",<br class="title-page-name"/>    zip: "",<br class="title-page-name"/>  },<br class="title-page-name"/>  phone: "",<br class="title-page-name"/>  email: "",<br class="title-page-name"/>};</pre>
<p class="mce-root">And, of course, the following is our component's <kbd class="calibre11">make</kbd> function:</p>
<pre class="calibre16">let make = _children =&gt; {<br class="title-page-name"/>  ...component,<br class="title-page-name"/>  initialState: () =&gt; {<br class="title-page-name"/>    let mode = Js.String.includes("create", pathname) ? Create : Update;<br class="title-page-name"/>    {<br class="title-page-name"/>      mode,<br class="title-page-name"/>      customer:<br class="title-page-name"/>        switch (mode) {<br class="title-page-name"/>        | Create =&gt; getDefault(customers)<br class="title-page-name"/>        | Update =&gt;<br class="title-page-name"/>          Belt.Option.getWithDefault(<br class="title-page-name"/>            getCustomer(customers),<br class="title-page-name"/>            getDefault(customers),<br class="title-page-name"/>          )<br class="title-page-name"/>        },<br class="title-page-name"/>    };<br class="title-page-name"/>  },<br class="title-page-name"/>  reducer: (action, state) =&gt;<br class="title-page-name"/>    switch (action) {<br class="title-page-name"/>    | Save(event) =&gt;<br class="title-page-name"/>      ReactEvent.Form.preventDefault(event);<br class="title-page-name"/>      ReasonReact.Update(state);<br class="title-page-name"/>    },<br class="title-page-name"/>  render: self =&gt;<br class="title-page-name"/>    &lt;form<br class="title-page-name"/>      className=Styles.form<br class="title-page-name"/>      onSubmit={<br class="title-page-name"/>        event =&gt; {<br class="title-page-name"/>          ReactEvent.Form.persist(event);<br class="title-page-name"/>          self.send(Save(event));<br class="title-page-name"/>        }<br class="title-page-name"/>      }&gt;<br class="title-page-name"/>      &lt;label&gt;<br class="title-page-name"/>        {ReasonReact.string("Name")}<br class="title-page-name"/>        &lt;input type_="text" defaultValue={self.state.customer.name} /&gt;<br class="title-page-name"/>      &lt;/label&gt;<br class="title-page-name"/>      &lt;label&gt;<br class="title-page-name"/>        {ReasonReact.string("Street Address")}<br class="title-page-name"/>        &lt;input<br class="title-page-name"/>          type_="text"<br class="title-page-name"/>          defaultValue={self.state.customer.address.street}<br class="title-page-name"/>        /&gt;<br class="title-page-name"/>      &lt;/label&gt;<br class="title-page-name"/>      &lt;label&gt;<br class="title-page-name"/>        {ReasonReact.string("City")}<br class="title-page-name"/>        &lt;input type_="text" defaultValue={self.state.customer.address.city} /&gt;<br class="title-page-name"/>      &lt;/label&gt;<br class="title-page-name"/>      &lt;label&gt;<br class="title-page-name"/>        {ReasonReact.string("State")}<br class="title-page-name"/>        &lt;input type_="text" defaultValue={self.state.customer.address.state} /&gt;<br class="title-page-name"/>      &lt;/label&gt;<br class="title-page-name"/>      &lt;label&gt;<br class="title-page-name"/>        {ReasonReact.string("Zip")}<br class="title-page-name"/>        &lt;input type_="text" defaultValue={self.state.customer.address.zip} /&gt;<br class="title-page-name"/>      &lt;/label&gt;<br class="title-page-name"/>      &lt;label&gt;<br class="title-page-name"/>        {ReasonReact.string("Phone")}<br class="title-page-name"/>        &lt;input type_="text" defaultValue={self.state.customer.phone} /&gt;<br class="title-page-name"/>      &lt;/label&gt;<br class="title-page-name"/>      &lt;label&gt;<br class="title-page-name"/>        {ReasonReact.string("Email")}<br class="title-page-name"/>        &lt;input type_="text" defaultValue={self.state.customer.email} /&gt;<br class="title-page-name"/>      &lt;/label&gt;<br class="title-page-name"/>      &lt;input<br class="title-page-name"/>        type_="submit"<br class="title-page-name"/>        value={<br class="title-page-name"/>          switch (self.state.mode) {<br class="title-page-name"/>          | Create =&gt; "Create"<br class="title-page-name"/>          | Update =&gt; "Update"<br class="title-page-name"/>          }<br class="title-page-name"/>        }<br class="title-page-name"/>      /&gt;<br class="title-page-name"/>    &lt;/form&gt;,<br class="title-page-name"/>};</pre>
<p class="mce-root">The <kbd class="calibre11">Save</kbd> action doesn't yet save to <kbd class="calibre11">localStorage</kbd>. The form is empty when navigating to <kbd class="calibre11">/customers/create</kbd> and populated when navigating to, for example, <kbd class="calibre11">/customers/1</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating with localStorage</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's create a separate module to interact with the data layer, which we'll call <kbd class="calibre11">DataPureReason.re</kbd>. Here, we expose bindings to <kbd class="calibre11">localStorage.getItem</kbd> and <kbd class="calibre11">localStorage.setItem</kbd>, and a parsing function to parse JSON strings into the <kbd class="calibre11">CustomerType.t</kbd> record defined earlier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Populating localStorage</h1>
                </header>
            
            <article>
                
<p class="mce-root">You'll find some initial data in <kbd class="calibre11">Chapter07/app-end/src/customers/data.json</kbd>. Please run <kbd class="calibre11">localStorage.setItem("customers", JSON.stringify(/* paste JSON data here */))</kbd> in your browser's console to populate <kbd class="calibre11">localStorage</kbd> with this initial data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DataPureReason.re</h1>
                </header>
            
            <article>
                
<p class="mce-root">Remember when BuckleScript bindings felt kind of obscure? Hopefully, they're now starting to feel a bit more straightforward:</p>
<pre class="calibre16">[@bs.val] [@bs.scope "localStorage"] external getItem: string =&gt; string = "";<br class="title-page-name"/>[@bs.val] [@bs.scope "localStorage"]<br class="title-page-name"/>external setItem: (string, string) =&gt; unit = "";</pre>
<p class="mce-root">To parse the JSON, we'll use the <kbd class="calibre11">Js.Json</kbd> module.</p>
<div class="packt_infobox">The Js.Json documentation can be found at the following URL:<br class="title-page-name"/>
<br class="title-page-name"/>
<a href="https://bucklescript.github.io/bucklescript/api/Js_json.html" class="calibre17">https://bucklescript.github.io/bucklescript/api/Js_json.html</a></div>
<p class="mce-root">Soon, you'll see one way to use the <kbd class="calibre11">Js.Json</kbd> module to parse JSON strings. One caveat, though: it's a bit tedious. But it's important to understand what is going on and why we need to do this for typed languages such as Reason. At a high level, we will validate the JSON string to ensure that it's valid JSON, and if so use the <kbd class="calibre11">Js.Json.classify</kbd> function to convert the JSON string (<kbd class="calibre11">Js.Json.t</kbd>) into a tagged type (<kbd class="calibre11">Js.Json.tagged_t</kbd>). The available tags are as follows:</p>
<pre class="calibre16">type tagged_t =<br class="title-page-name"/>  | JSONFalse<br class="title-page-name"/>  | JSONTrue<br class="title-page-name"/>  | JSONNull<br class="title-page-name"/>  | JSONString(string)<br class="title-page-name"/>  | JSONNumber(float)<br class="title-page-name"/>  | JSONObject(Js_dict.t(t))<br class="title-page-name"/>  | JSONArray(array(t));</pre>
<p class="mce-root">This way, we can convert JSON strings into typed Reason data structures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validating JSON strings </h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd class="calibre11">getItem</kbd> binding defined in the previous section will return a string:</p>
<pre class="calibre16">let unvalidated = DataPureReason.getItem("customers");</pre>
<p class="mce-root">We can validate the JSON string like so:</p>
<pre class="calibre16">let validated =<br class="title-page-name"/>  try (Js.Json.parseExn(unvalidated)) {<br class="title-page-name"/>  | _ =&gt; failwith("Error parsing JSON string")<br class="title-page-name"/>  };</pre>
<p class="mce-root">If the JSON is not valid, it will generate a runtime error. At the end of the chapter, we'll learn how GraphQL can help improve this situation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Js.Json.classify</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's assume that we've validated the following JSON (it's an array of objects):</p>
<pre class="calibre16">[<br class="title-page-name"/>  {<br class="title-page-name"/>    "id": 1,<br class="title-page-name"/>    "name": "Christina Langworth",<br class="title-page-name"/>    "address": {<br class="title-page-name"/>      "street": "81 Casey Stravenue",<br class="title-page-name"/>      "city": "Beattyview",<br class="title-page-name"/>      "state": "TX",<br class="title-page-name"/>      "zip": "57918"<br class="title-page-name"/>    },<br class="title-page-name"/>    "phone": "877-549-1362",<br class="title-page-name"/>    "email": "Christina.Langworth@gmail.com"<br class="title-page-name"/>  },<br class="title-page-name"/>  {<br class="title-page-name"/>    "id": 2,<br class="title-page-name"/>    "name": "Victor Tillman",<br class="title-page-name"/>    "address": {<br class="title-page-name"/>      "street": "2811 Toby Gardens",<br class="title-page-name"/>      "city": "West Enrique",<br class="title-page-name"/>      "state": "NV",<br class="title-page-name"/>      "zip": "40465"<br class="title-page-name"/>    },<br class="title-page-name"/>    "phone": "(502) 091-2292",<br class="title-page-name"/>    "email": "Victor.Tillman30@gmail.com"<br class="title-page-name"/>  }<br class="title-page-name"/>]</pre>
<p class="mce-root"><span class="calibre5">Now that we have validated the JSON, we're ready to classify it:</span></p>
<pre class="calibre16">switch (Js.Json.classify(validated)) {<br class="title-page-name"/>| Js.Json.JSONArray(array) =&gt;<br class="title-page-name"/>  Belt.Array.map(array, customer =&gt; ...)<br class="title-page-name"/>| _ =&gt; failwith("Expected an array")<br class="title-page-name"/>};</pre>
<p class="mce-root">We pattern-match on the possible tags for <kbd class="calibre11">Js.Json.tagged_t</kbd>. If it's an array, we then map over it using <kbd class="calibre11">Belt.Array.map</kbd> (or <kbd class="calibre11">Js.Array.map</kbd>). Otherwise, we get a runtime error in the context of our application.</p>
<p class="mce-root">The <kbd class="calibre11">map</kbd> function is passed a reference to each object in the array. But Reason doesn't yet know that each element is an object. <span class="calibre5">Inside the <kbd class="calibre11">map</kbd>, we once again classify each element of the array. After classifying, Reason now knows that each element is, in fact, an object. We'll define a custom helper function called <kbd class="calibre11">parseCustomer</kbd> for use with the <kbd class="calibre11">map</kbd> function:</span></p>
<pre class="calibre16">switch (Js.Json.classify(validated)) {<br class="title-page-name"/>| Js.Json.JSONArray(array) =&gt;<br class="title-page-name"/>  Belt.Array.map(array, customer =&gt; <strong class="calibre1">parseCustomer(customer)</strong>)<br class="title-page-name"/>| _ =&gt; failwith("Expected an array")<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>let <strong class="calibre1">parseCustomer</strong> = json =&gt;<br class="title-page-name"/>  switch (Js.Json.classify(json)) {<br class="title-page-name"/>  | Js.Json.JSONObject(json) =&gt; (<br class="title-page-name"/>      ...<br class="title-page-name"/>    )<br class="title-page-name"/>  | _ =&gt; failwith("Expected an object")<br class="title-page-name"/>  };</pre>
<p class="mce-root">Now, if each element of the array is an object, we want to return a new record. This record will be of type <kbd class="calibre11">CustomerType.t</kbd>. Otherwise, we get a runtime error:</p>
<pre class="calibre16">let parseCustomer = json =&gt;<br class="title-page-name"/>  switch (Js.Json.classify(json)) {<br class="title-page-name"/>  | Js.Json.JSONObject(json) =&gt; (<br class="title-page-name"/>      {<br class="title-page-name"/>        id: ...,<br class="title-page-name"/>        name: ...,<br class="title-page-name"/>        address: ...,<br class="title-page-name"/>        phone: ...,<br class="title-page-name"/>        email: ...,<br class="title-page-name"/>      }: <strong class="calibre1">CustomerType.t</strong><br class="title-page-name"/>    )<br class="title-page-name"/>  | _ =&gt; failwith("Expected an object")<br class="title-page-name"/>  };</pre>
<p class="mce-root">Now, for each field (that is, <kbd class="calibre11">id</kbd>, <kbd class="calibre11">name</kbd>, <kbd class="calibre11">address</kbd>, and so on), we use <kbd class="calibre11">Js.Dict.get</kbd> to get and classify each field:</p>
<div class="packt_infobox">The <kbd class="calibre20">Js.Dict</kbd> documentation can be found at the following URL:<br class="title-page-name"/>
<br class="title-page-name"/>
<a href="https://bucklescript.github.io/bucklescript/api/Js.Dict.html" class="calibre17">https://bucklescript.github.io/bucklescript/api/Js.Dict.html</a></div>
<pre class="calibre16">let parseCustomer = json =&gt;<br class="title-page-name"/>  switch (Js.Json.classify(json)) {<br class="title-page-name"/>  | Js.Json.JSONObject(json) =&gt; (<br class="title-page-name"/>      {<br class="title-page-name"/>        id:<br class="title-page-name"/>          switch (Js.Dict.get(json, "id")) {<br class="title-page-name"/>          | Some(id) =&gt;<br class="title-page-name"/>            switch (Js.Json.classify(id)) {<br class="title-page-name"/>            | Js.Json.JSONNumber(id) =&gt; int_of_float(id)<br class="title-page-name"/>            | _ =&gt; failwith("Field 'id' should be a number")<br class="title-page-name"/>            }<br class="title-page-name"/>          | None =&gt; failwith("Missing field: id")<br class="title-page-name"/>          },<br class="title-page-name"/>        name:<br class="title-page-name"/>          switch (Js.Dict.get(json, "name")) {<br class="title-page-name"/>          | Some(name) =&gt;<br class="title-page-name"/>            switch (Js.Json.classify(name)) {<br class="title-page-name"/>            | Js.Json.JSONString(name) =&gt; name<br class="title-page-name"/>            | _ =&gt; failwith("Field 'name' should be a string")<br class="title-page-name"/>            }<br class="title-page-name"/>          | None =&gt; failwith("Missing field: name")<br class="title-page-name"/>          },<br class="title-page-name"/>        address:<br class="title-page-name"/>          switch (Js.Dict.get(json, "address")) {<br class="title-page-name"/>          | Some(address) =&gt;<br class="title-page-name"/>            switch (Js.Json.classify(address)) {<br class="title-page-name"/>            | Js.Json.JSONObject(address) =&gt; {<br class="title-page-name"/>                street:<br class="title-page-name"/>                  switch (Js.Dict.get(address, "street")) {<br class="title-page-name"/>                  | Some(street) =&gt;<br class="title-page-name"/>                    switch (Js.Json.classify(street)) {<br class="title-page-name"/>                    | Js.Json.JSONString(street) =&gt; street<br class="title-page-name"/>                    | _ =&gt; failwith("Field 'street' should be a string")<br class="title-page-name"/>                    }<br class="title-page-name"/>                  | None =&gt; failwith("Missing field: street")<br class="title-page-name"/>                  },<br class="title-page-name"/>                city: ...,<br class="title-page-name"/>                state: ...,<br class="title-page-name"/>                zip: ...,<br class="title-page-name"/>              }<br class="title-page-name"/>            | _ =&gt; failwith("Field 'address' should be a object")<br class="title-page-name"/>            }<br class="title-page-name"/>          | None =&gt; failwith("Missing field: address")<br class="title-page-name"/>          },<br class="title-page-name"/>        phone: ...,<br class="title-page-name"/>        email: ...,<br class="title-page-name"/>      }: CustomerType.t<br class="title-page-name"/>    )<br class="title-page-name"/>  | _ =&gt; failwith("Expected an object")<br class="title-page-name"/>  };</pre>
<div class="packt_infobox">See <kbd class="calibre20">src/customers/DataPureReason.re</kbd> for the full implementation. <kbd class="calibre20">DataPureReason.rei</kbd> hides implementation details and only exposes the <kbd class="calibre20">localStorage</kbd> bindings and a parse function.</div>
<p class="mce-root">Phew, that was a bit tedious, wasn't it? Now that it's done though, we can replace the hardcoded customer array in both <kbd class="calibre11">CustomerList.re</kbd> and <kbd class="calibre11">Customer.re</kbd> with the following:</p>
<pre class="calibre16">let customers =<br class="title-page-name"/>  DataBsJson.(parse(getItem("customers")));</pre>
<p class="mce-root">So far, so good! The JSON data is being pulled in dynamically, and parsed, and now works the same as it did when hardcoded.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing to localStorage</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's now add the functionality to create and update customers. To do this, we'll need to convert our Reason data structure to JSON. In the interface file, <kbd class="calibre11">DataPureReason.rei</kbd>, we'll expose a <kbd class="calibre11">toJson</kbd> function:</p>
<pre class="calibre16">/* DataPureReason.rei */<br class="title-page-name"/>let parse: string =&gt; array(CustomerType.t);<br class="title-page-name"/>let toJson: array(CustomerType.t) =&gt; string;</pre>
<p class="mce-root">And then we'll implement it:</p>
<pre class="calibre16">/* DataPureReason.re */<br class="title-page-name"/>let customerToJson = (customer: CustomerType.t) =&gt; {<br class="title-page-name"/>  let id = customer.id;<br class="title-page-name"/>  let name = customer.name;<br class="title-page-name"/>  let street = customer.address.street;<br class="title-page-name"/>  let city = customer.address.city;<br class="title-page-name"/>  let state = customer.address.state;<br class="title-page-name"/>  let zip = customer.address.zip;<br class="title-page-name"/>  let phone = customer.phone;<br class="title-page-name"/>  let email = customer.email;<br class="title-page-name"/><br class="title-page-name"/>  {j|<br class="title-page-name"/>    {<br class="title-page-name"/>      "id": $id,<br class="title-page-name"/>      "name": "$name",<br class="title-page-name"/>      "address": {<br class="title-page-name"/>        "street": "$street",<br class="title-page-name"/>        "city": "$city",<br class="title-page-name"/>        "state": "$state",<br class="title-page-name"/>        "zip": "$zip"<br class="title-page-name"/>      },<br class="title-page-name"/>      "phone": "$phone",<br class="title-page-name"/>      "email": "$email"<br class="title-page-name"/>    }<br class="title-page-name"/>  |j};<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>let toJson = (customers: array(CustomerType.t)) =&gt;<br class="title-page-name"/>  Belt.Array.map(customers, customer =&gt; customerToJson(customer))<br class="title-page-name"/>  -&gt;Belt.Array.reduce("[", (acc, customer) =&gt; acc ++ customer ++ ",")<br class="title-page-name"/>  -&gt;Js.String.replaceByRe([%bs.re "/,$/"], "", _)<br class="title-page-name"/>  ++ "]"<br class="title-page-name"/>     -&gt;Js.String.split("/n", _)<br class="title-page-name"/>     -&gt;Js.Array.map(line =&gt; Js.String.trim(line), _)<br class="title-page-name"/>     -&gt;Js.Array.joinWith("", _);</pre>
<p class="mce-root">And then we'll use the <kbd class="calibre11">toJson</kbd> function in the <kbd class="calibre11">Customer.re</kbd> reducer:</p>
<pre class="calibre16">reducer: (action, state) =&gt;<br class="title-page-name"/>  switch (action) {<br class="title-page-name"/>  | Save(event) =&gt;<br class="title-page-name"/>    let getInputValue: string =&gt; string = [%raw<br class="title-page-name"/>      (selector =&gt; "return document.querySelector(selector).value")<br class="title-page-name"/>    ];<br class="title-page-name"/>    ReactEvent.Form.preventDefault(event);<br class="title-page-name"/>    ReasonReact.UpdateWithSideEffects(<br class="title-page-name"/>      {<br class="title-page-name"/>        ...state,<br class="title-page-name"/>        customer: {<br class="title-page-name"/>          id: state.customer.id,<br class="title-page-name"/>          name: getInputValue("input[name=name]"),<br class="title-page-name"/>          address: {<br class="title-page-name"/>            street: getInputValue("input[name=street]"),<br class="title-page-name"/>            city: getInputValue("input[name=city]"),<br class="title-page-name"/>            state: getInputValue("input[name=state]"),<br class="title-page-name"/>            zip: getInputValue("input[name=zip]"),<br class="title-page-name"/>          },<br class="title-page-name"/>          phone: getInputValue("input[name=phone]"),<br class="title-page-name"/>          email: getInputValue("input[name=email]"),<br class="title-page-name"/>        },<br class="title-page-name"/>      },<br class="title-page-name"/>      (<br class="title-page-name"/>        self =&gt; {<br class="title-page-name"/>          let customers =<br class="title-page-name"/>            switch (self.state.mode) {<br class="title-page-name"/>            | Create =&gt;<br class="title-page-name"/>              Belt.Array.concat(customers, [|self.state.customer|])<br class="title-page-name"/>            | Update =&gt;<br class="title-page-name"/>              Belt.Array.setExn(<br class="title-page-name"/>                customers,<br class="title-page-name"/>                Js.Array.findIndex(<br class="title-page-name"/>                  customer =&gt;<br class="title-page-name"/>                    customer.CustomerType.id == self.state.customer.id,<br class="title-page-name"/>                  customers,<br class="title-page-name"/>                ),<br class="title-page-name"/>                self.state.customer,<br class="title-page-name"/>              );<br class="title-page-name"/>              customers;<br class="title-page-name"/>            };<br class="title-page-name"/><br class="title-page-name"/>          let json = customers-&gt;DataPureReason.toJson;<br class="title-page-name"/>          DataPureReason.setItem("customers", json);<br class="title-page-name"/>        }<br class="title-page-name"/>      ),<br class="title-page-name"/>    );<br class="title-page-name"/>  },</pre>
<p class="mce-root">In the reducer, we update <kbd class="calibre11">self.state.customer</kbd> with values from the DOM, and then call a function that updates <kbd class="calibre11">localStorage</kbd>. Now, we're able to write to <kbd class="calibre11">localStorage</kbd> by creating or updating customers. Navigate to <kbd class="calibre11">/customers/create</kbd> to create a new customer, and then navigate back to <kbd class="calibre11">/customers</kbd> to see your newly added customer. Click on a customer to navigate to the update view, update the customer, click the <span class="calibre5">Update</span> button, and refresh the page.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using bs-json</h1>
                </header>
            
            <article>
                
<p class="mce-root">Now that we understand exactly how to convert JSON strings into typed Reason data structures, we notice that the process is a bit tedious. It's more lines of code than one would expect coming from a dynamic language such as JavaScript. Also, there is quite a bit of repetitive code. As an alternative, many in the Reason community have adopted <kbd class="calibre11">bs-json</kbd> as an "official" solution for encoding and decoding JSON.</p>
<p class="mce-root">Let's create a new module called <kbd class="calibre11">DataBsJson.re</kbd> and a new interface file, <kbd class="calibre11">DataBsJson.rei</kbd>. We'll copy the exact same interface as we had in <kbd class="calibre11">DataPureReason.rei</kbd> so that we know that, once we're done, we'll be able to replace all references to <kbd class="calibre11">DataPureReason</kbd> with <kbd class="calibre11">DataBsJson</kbd> and everything should work the same.</p>
<p class="mce-root">The exposed interface is as follows:</p>
<pre class="calibre16">/* DataBsJson.rei */<br class="title-page-name"/>[@bs.val] [@bs.scope "localStorage"] external getItem: string =&gt; string = "";<br class="title-page-name"/>[@bs.val] [@bs.scope "localStorage"]<br class="title-page-name"/>external setItem: (string, string) =&gt; unit = "";<br class="title-page-name"/><br class="title-page-name"/>let parse: string =&gt; array(CustomerType.t);<br class="title-page-name"/>let toJson: array(CustomerType.t) =&gt; string;</pre>
<p class="mce-root">Let's focus on the <kbd class="calibre11">parse</kbd> function:</p>
<pre class="calibre16">let parse = json =&gt;<br class="title-page-name"/>  json |&gt; Json.parseOrRaise |&gt; Json.Decode.array(customerDecoder);</pre>
<p class="mce-root">Here, we are accepting the same JSON string as before, validating it, converting it to a <kbd class="calibre11">Js.Json.t</kbd> (via <kbd class="calibre11">Json.parseOrRaise</kbd>), and then passing the result into this new <kbd class="calibre11">Json.Decode.array(customerDecoder)</kbd> function. <kbd class="calibre11">Json.Decode.array</kbd> will attempt to decode the JSON string into an array, and decode each element of the array with a custom function called <kbd class="calibre11">customerDecoder</kbd>—which we'll see next:</p>
<pre class="calibre16">let customerDecoder = json =&gt;<br class="title-page-name"/>  Json.Decode.(<br class="title-page-name"/>    (<br class="title-page-name"/>      {<br class="title-page-name"/>        id: json |&gt; field("id", int),<br class="title-page-name"/>        name: json |&gt; field("name", string),<br class="title-page-name"/>        address: json |&gt; field("address", <strong class="calibre1">addressDecoder</strong>),<br class="title-page-name"/>        phone: json |&gt; field("phone", string),<br class="title-page-name"/>        email: json |&gt; field("email", string),<br class="title-page-name"/>      }: <strong class="calibre1">CustomerType.t</strong><br class="title-page-name"/>    )<br class="title-page-name"/>  );</pre>
<p class="mce-root">The <kbd class="calibre11">customerDecoder</kbd> function accepts the JSON associated with each element of the array and tries to decode that into a record of type <kbd class="calibre11">CustomerType.t</kbd>. This is pretty much exactly the same as what we did previously, but it's much less verbose and much easier to read. As you can see, we have another customer decoder, called <kbd class="calibre11">addressDecoder</kbd>, which is used to decode the <kbd class="calibre11">CustomerType.address</kbd> type:</p>
<pre class="calibre16">let addressDecoder = json =&gt;<br class="title-page-name"/>  Json.Decode.(<br class="title-page-name"/>    (<br class="title-page-name"/>      {<br class="title-page-name"/>        street: json |&gt; field("street", string),<br class="title-page-name"/>        city: json |&gt; field("city", string),<br class="title-page-name"/>        state: json |&gt; field("state", string),<br class="title-page-name"/>        zip: json |&gt; field("zip", string),<br class="title-page-name"/>      }: <strong class="calibre1">CustomerType.address</strong><br class="title-page-name"/>    )<br class="title-page-name"/>  );</pre>
<p class="mce-root">Notice how the custom decoders are easily composed. Each record field is decoded by calling <kbd class="calibre11">Json.Decode.field</kbd>, passing the name of the field (on the JSON side), and passing in a <kbd class="calibre11">Json.Decode</kbd> function that ultimately converts the JSON field to a type Reason can understand.</p>
<p class="mce-root">Encoding works similarly, but in the reverse order:</p>
<pre class="calibre16">let toJson = (customers: array(CustomerType.t)) =&gt;<br class="title-page-name"/>  customers-&gt;Belt.Array.map(customer =&gt;<br class="title-page-name"/>    Json.Encode.(<br class="title-page-name"/>      object_([<br class="title-page-name"/>        ("id", int(customer.id)),<br class="title-page-name"/>        ("name", string(customer.name)),<br class="title-page-name"/>        (<br class="title-page-name"/>          "address",<br class="title-page-name"/>          object_([<br class="title-page-name"/>            ("street", string(customer.address.street)),<br class="title-page-name"/>            ("city", string(customer.address.city)),<br class="title-page-name"/>            ("state", string(customer.address.state)),<br class="title-page-name"/>            ("zip", string(customer.address.zip)),<br class="title-page-name"/>          ]),<br class="title-page-name"/>        ),<br class="title-page-name"/>        ("phone", string(customer.phone)),<br class="title-page-name"/>        ("email", string(customer.email)),<br class="title-page-name"/>      ])<br class="title-page-name"/>    )<br class="title-page-name"/>  )<br class="title-page-name"/>  |&gt; Json.Encode.jsonArray<br class="title-page-name"/>  |&gt; Json.stringify;</pre>
<p class="mce-root">The array of customers is mapped and each customer is encoded to a JSON object. The result is an array of JSON objects, which then gets encoded to JSON, and stringified. Much better than our previous implementation.</p>
<p class="mce-root">After copying over the same <kbd class="calibre11">localStorage</kbd> bindings from <kbd class="calibre11">DataPureReason.re</kbd>, our interface is now implemented. After replacing all references to <kbd class="calibre11">DataPureReason</kbd> with <kbd class="calibre11">DataBsJson</kbd>, we see that our app is working just the same.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using GraphQL</h1>
                </header>
            
            <article>
                
<p class="mce-root">At ReactiveConf 2018, there was an amazing talk by Sean Grove on Reason and GraphQL titled <em class="calibre15">ReactiveMeetups w/ Sean Grove | ReasonML GraphQL.</em> The following is an excerpt from this talk that nicely summarizes the problems and solution for using JSON in Reason:</p>
<div class="packt_quote">So I would argue that, in typed languages, like Reason, there are three really, really big problems when you want to interact with the real world. The first is all the boilerplate that it takes to get data into and out of your type system.<br class="title-page-name"/>
The second is, even if you can program your way out of the boilerplate, you are still worried about the accuracy, the safety of conversion.<br class="title-page-name"/>
And then finally, even if you if you get all of this and you're absolutely sure you've caught all the variation, someone can still change it from underneath you without you knowing.<br class="title-page-name"/>
<br class="title-page-name"/>
How many times do we get a changelog whenever the server changes fields? In an ideal world, we would. But most of the time we don't. We get to reverse-engineer what our server changed.<br class="title-page-name"/>
<br class="title-page-name"/>
So I would argue that, in order to solve this in a broadly applicable way, we want four things:<br class="title-page-name"/>
<br class="title-page-name"/>
1) Access to all of the data types that an API can provide to us in a programmatic way.<br class="title-page-name"/>
2) Automatic conversions that are guaranteed to be safe.<br class="title-page-name"/>
3) And we want to have a contract. We want the server to guarantee if it said a field is not nullable, they will never give us null. If they change the field name, then we immediately know and that they know.<br class="title-page-name"/>
4) And we want all of that in a programmatic way.<br class="title-page-name"/>
<br class="title-page-name"/>
And that's GraphQL.</div>
<div class="packt_quote1">-Sean Grove</div>
<div class="packt_infobox">You can find the video of <em class="calibre19">ReactiveMeetups w/ Sean Grove | ReasonML GraphQL</em> at the following URL:<br class="title-page-name"/>
<a href="https://youtu.be/t9a-_VnNilE" class="calibre17">https://youtu.be/t9a-_VnNilE</a><br class="title-page-name"/>
<br class="title-page-name"/>
And, here is ReactiveConf's Youtube channel: <br class="title-page-name"/>
<a href="https://www.youtube.com/channel/UCBHdUnixTWymmXBIw12Y8Qg" class="calibre17">https://www.youtube.com/channel/UCBHdUnixTWymmXBIw12Y8Qg</a></div>
<p class="mce-root">It's beyond the scope of this book to go too deeply into GraphQL, but a high-level introduction seems fitting given that we're discussing using JSON in Reason.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is GraphQL?</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you're part of the ReactJS community, then you've likely already heard of GraphQL. GraphQL is a query language and a runtime we can use to fulfill those queries and was also created by Facebook. With GraphQL, ReactJS components can include GraphQL fragments for data that a component requires—this means that a component can couple HTML, CSS, JavaScript, and its external data all in one file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">When using GraphQL, do I need to create JSON decoders?</h1>
                </header>
            
            <article>
                
<p class="mce-root">Since GraphQL knows your application's external data intimately, the GraphQL client (<kbd class="calibre11">reason-apollo</kbd>) will generate the decoders for you automatically. Of course, the decoders would have to be automatically generated so we're confident that they reflect the current shape of the external data. This is just another reason to consider using GraphQL with your Reason application when you need to handle external data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">As long as we're working within Reason, the type system will prevent you from running into runtime type errors. However, when interacting with the outside world—whether it be JavaScript or external data—we lose those guarantees. To be able to preserve these guarantees within Reason's boundaries, we need to help out the type system when using things outside Reason. We previously learned how to use external JavaScript in Reason, and in this chapter we've learned how to use external data in Reason. Although writing decoders and encoders is more challenging, it's quite similar to writing JavaScript bindings. In the end, we're simply telling Reason the type of something external to Reason. With GraphQL, we can extend the boundaries of Reason to include external data. There are trade-offs, and nothing is perfect, but it's definitely worth giving GraphQL a shot.</p>
<p class="mce-root">In the next chapter, we'll explore testing in the context of Reason. What tests should we write? What tests should we avoid? We'll also explore how unit testing can help us improve the code we wrote in this chapter.</p>


            </article>

            
        </section>
    </body></html>