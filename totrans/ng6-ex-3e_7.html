<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing Personal Trainer</h1>
                
            
            <article>
                
<p class="calibre3">Unless you are a superhero who codes perfectly, you need to test what you build. Also, unless you have loads of free time to test your application again and again, you need some test automation.</p>
<p class="calibre3">When we say Angular was built with testability in mind, we really mean it. It has a strong <strong class="calibre5">Dependency Injection</strong> (<strong class="calibre5">DI</strong>) framework, some good mock constructs, and awesome tools that make testing in an Angular app a fruitful endeavor.</p>
<p class="calibre3">This chapter is all about testing and is dedicated to testing what we have built over the course of this book. We test everything from components to pipes, services, and our app directives.</p>
<p class="calibre3">The topics we cover in this chapter include:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Understanding the big picture</strong>: We will try to understand how testing fits into the overall context of Angular app development. We will also discuss the types of testing Angular supports, including unit and <strong class="calibre1">end-to-end</strong> (<strong class="calibre1">E2E</strong>) testing.</li>
<li class="calibre12"><strong class="calibre1">Overview of tools and frameworks</strong>: We will cover the tools and frameworks that help in both unit and end-to-end testing with Angular. These include <strong class="calibre1">Karma</strong> and <strong class="calibre1">Protractor</strong>.</li>
<li class="calibre12"><strong class="calibre1">Writing unit tests</strong>: You will learn how to do unit testing with Angular using <strong class="calibre1">Jasmine</strong> and <strong class="calibre1">Karma</strong> inside a browser. We will unit test what we have built in the last few chapters. This section also teaches us how to unit-test various Angular constructs, including pipes, components, services, and directives.</li>
<li class="calibre12"><strong class="calibre1">Creating end-to-end tests</strong>: Automated end-to-end tests work by mimicking the behavior of the actual user through browser automation. You will learn how to use Protractor combined with WebDriver to perform end-to-end testing.</li>
</ul>
<p class="calibre3">Let the testing begin!</p>
<div class="packt_infobox">
<p class="calibre20">As you start reading this chapter, we suggest that you download the code for <kbd class="calibre24">checkpoint 7.1</kbd>. It is available on GitHub (<a href="https://github.com/chandermani/angular6byexample" class="calibre21">https://github.com/chandermani/angular6byexample</a>) for everyone to download. Checkpoints are implemented as branches in GitHub. If you are not using Git, download the snapshot of <kbd class="calibre24">checkpoint7.1</kbd> (a ZIP file) from this GitHub location: <span class="calibre22"><a href="https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip" class="calibre21">https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip</a></span>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time.</p>
<p class="calibre20"><span class="calibre22">This checkpoint contains the tests that were generated by the Angular CLI as we created components, services, pipes, and directives in the earlier chapters. We have made minor changes in these tests so that they all pass. For the most part these are basic "Hello World" tests that confirm the creation of a component or other Angular construct. We will not be covering these tests in this chapter, but encourage you to review them. </span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The need for automation</h1>
                
            
            <article>
                
<p class="calibre3">The size and complexity of apps being built for the web are growing with each passing day. The plethora of options that we now have to build web apps is just mind-boggling. Add to this the fact that the release cycles for products/apps have shrunk drastically from months to days, or even multiple releases per day! This puts a lot of burden on software testing. There is too much to be tested. Multiple browsers, multiple clients and screen sizes (desktop and mobile), multiple resolution, and so on.</p>
<p class="calibre3">To be effective in such a diverse landscape, automation is the key. <em class="calibre17">Automate everything that can be automated</em> should be our mantra.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing in Angular</h1>
                
            
            <article>
                
<p class="calibre3">The Angular team realized the importance of testability and hence created a framework that allowed easy testing (automated) for apps built on it. The design choice of using DI constructs to inject dependencies everywhere has helped. This will become clear as the chapter progresses and we build a number of tests for our apps. However, before that, let's understand the types of testing that we target when building apps on this platform.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Types of testing</h1>
                
            
            <article>
                
<p class="calibre3">There are broadly two forms of testing that we do for a typical Angular app:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Unit testing</strong>: Unit testing is all about testing a component in isolation to verify the correctness of its behavior. Most of the dependencies of the component under test need to be replaced with mock implementations to make sure that the unit tests do not fail due to failure in a dependent component.</li>
<li class="calibre12"><strong class="calibre1">End-to-end testing</strong>: This type of testing is all about executing the application like a real end user and verifying the behavior of the application. Unlike unit testing, components are not tested in isolation. Tests are done against a running system in real browsers, and assertions are done based on the state of the user interface and the content displayed.</li>
</ul>
<p class="calibre3">Unit testing is the first line of defense against bugs, and we should be able to iron out most issues with code during unit testing. But unless E2E is done, we cannot confirm that the software is working correctly. Only when all the components within a system interact in the desired manner can we confirm that the software works; hence, E2E testing becomes a necessity.</p>
<p class="calibre3">You can view these two types of testing like a pyramid with E2E testing on the top and unit testing on the bottom. The pyramid indicates that the number of unit tests you write should substantially exceed the number of E2E tests. The reason is that with unit tests you are breaking your application down into small testable units, whereas with integration tests you are spanning multiple components from the UI through to the backend. Also setting up E2E tests tends to be more complicated than unit tests.</p>
<p class="calibre3">Who writes unit and E2E tests and when are they written are important questions to answer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing – who does it and when?</h1>
                
            
            <article>
                
<p class="calibre3">Traditionally, E2E testing was done by the <strong class="calibre5">Quality Assurance</strong> (<strong class="calibre5">QA</strong>) team and developers were responsible for unit-testing their code before submitting. Developers did some amount of E2E testing too, but overall the E2E testing process was manual.</p>
<p class="calibre3">With the changing landscape, modern testing tools, especially on the web front, have allowed developers to write automated E2E tests themselves and execute them against any deployment setup (such as development/stage/production). Tools such as Selenium, together with WebDrivers, allow easy browser automation, thus making it easy to write and execute E2E tests against real web browsers.</p>
<p class="calibre3">A good time to write E2E scenario tests is when the development is complete and ready to be deployed.</p>
<p class="calibre3">When it comes to unit testing, there are different schools of thought around when a test should be written. A <em class="calibre17">Test Driven Developer</em> writes tests before the functionality is implemented. Others write tests when the implementation is complete to confirm the behavior. Some write while developing the component itself. Choose a style that suits you, keeping in mind that the earlier you write your tests, the better.</p>
<div class="packt_infobox">
<p class="calibre20">We are not going to give any recommendations, nor are we going to get into an argument over which one is better. Any amount of unit tests is better than nothing. Our personal preference is to use the <em class="calibre25">middle approach</em>. With TDD, we feel that the test creation effort at times is lost as the specifications/requirements change. Tests written at the start are prone to constant fixes as the requirement changes. The problem with writing unit tests at the end is that our target is to create tests that pass according to the current implementation. The tests that are written are retrofitted to test the implementation where they should test the specifications. Adding tests somewhere in the middle works best for us.</p>
</div>
<p class="calibre3">Let's now try to understand the tooling and technology landscape available for Angular testing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Angular testing ecosystem</h1>
                
            
            <article>
                
<p class="calibre3">Look at the following diagram to understand the tools and frameworks that support Angular testing:</p>
<div class="packt_figure"><img src="../images/00070.jpeg" class="calibre69"/></div>
<div class="packt_figref">The tools and frameworks that support Angular testing</div>
<p class="calibre3">As we can see, we write our tests using unit testing libraries such as <strong class="calibre5">Jasmine</strong> or <strong class="calibre5">Mocha</strong>.</p>
<div class="packt_infobox">
<p class="calibre20">At the moment, the Angular testing library works by default with <em class="calibre25">Jasmine</em>. However, the Angular team has indicated that they have made the framework more generic so that you can use other testing libraries such as Mocha with it. The Angular documentation has not yet been updated to include how to do this. For a discussion of using Mocha with the Angular CLI testing commands see <a href="https://github.com/angular/angular-cli/issues/4071" target="_blank" class="calibre21">https://github.com/angular/angular-cli/issues/4071</a>.</p>
</div>
<p class="calibre3">These tests are executed by either Karma or Protractor depending on whether we are writing unit or integration tests. These test runners in turn run our tests in a browser such as Chrome, Firefox, IE, or headless browsers such as PhantomJS. It is important to highlight that not only E2E, but also unit tests are executed in a real browser.</p>
<div class="packt_infobox">
<p class="calibre20">All the tests in this chapter are written using Jasmine (both unit and integration tests). Karma will be our test runner for unit tests and Protractor for E2E tests.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting started with unit testing</h1>
                
            
            <article>
                
<p class="calibre3">The ultimate aim of unit testing is to test a specific piece of code/component in isolation to make sure that the components work according to the specification. This reduces the chances of failures/bugs in the component when integrated with other parts of the software. Before we start writing tests, there are some guidelines that can help us write good and maintainable tests:</p>
<ul class="calibre11">
<li class="calibre12">One unit should test one behavior. For obvious reasons, testing one behavior per unit test makes sense. A failing unit test should clearly highlight the problem area. If multiple behaviors are tested together, a failed test requires more probing to assert what behavior was violated.</li>
<li class="calibre12">Dependencies in a unit test should be mocked away using test doubles such as fakes, mocks, or st. Unit testing, as the name suggests, should test the unit and not its dependencies.</li>
<li class="calibre12">Unit tests should not change the state of the component being tested permanently. If it does happen, other tests may get affected.</li>
<li class="calibre12">The order of execution of unit tests should be immaterial. One unit test should not be dependent on another unit test to execute before it. This is a sign of a brittle unit test. It may also mean that the dependencies are not mocked.</li>
<li class="calibre12">Unit tests should be fast. If they are not fast enough, developers will not run them. This is a good reason to mock all dependencies such as database access, remote web service call, and others in a unit test.</li>
<li class="calibre12">Unit tests should try to cover all code paths. Code coverage is a metric that can help us assess the effectiveness of unit tests. If we have covered all positive and negative scenarios during testing, the coverage will indeed be higher. A word of caution here: high code coverage does not imply that the code is bug-free, but low coverage clearly highlights a lack of areas covered in unit tests.</li>
<li class="calibre12">Unit tests should test both positive and negative scenarios. Just don't concentrate on positive test cases; all software can fail, and hence unit testing failure scenarios are as important to test as success scenarios.</li>
</ul>
<p class="calibre3">These guidelines are not framework-specific, but give us enough ammunition for writing good tests. Let's begin the process of unit testing by setting up the components required for it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up Karma and Jasmine for unit testing</h1>
                
            
            <article>
                
<p class="calibre3">When we created our project using the Angular CLI, the CLI configured the setup for unit testing our code with Karma and Jasmine. It did so by adding several Karma and Jasmine modules to our project. It also added a Karma configuration file—<kbd class="calibre13">karma.config.js</kbd>—to the root directory of our application—<kbd class="calibre13">trainer/</kbd>—and a file called <kbd class="calibre13">tests.ts</kbd> in the <kbd class="calibre13">trainer/src</kbd> directory. The CLI makes use of these files at runtime to create the configuration for executing our tests. This means that we can run our tests by simply using the following command:</p>
<pre class="calibre19"><strong class="calibre1">ng test</strong></pre>
<p class="calibre3">And the CLI will also watch our tests for changes and automatically rerun them.</p>
<div class="packt_infobox">
<p class="calibre20">We will not be covering the configuration files in detail here. The out-of-the-box settings will be fine for our purposes. <span class="calibre22">Refer to the Karma documentation (</span><span class="calibre22"><a href="http://karma-runner.github.io/1.0/config/configuration-file.html" class="calibre21">http://karma-runner.github.io/1.0/config/configuration-file.html</a></span><span class="calibre22">) to understand more about the various Karma configuration options.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Organization and naming of our test files</h1>
                
            
            <article>
                
<p class="calibre3">To unit test our app, we should have one test (such as <kbd class="calibre13">workout-runner.spec.ts</kbd>) file for each TypeScript file that we plan to test in our project. And this is what the Angular CLI does for us. When we create a component, service, pipe, or directive using the CLI, the CLI will generate a corresponding test and place it in the same file directory. </p>
<div class="packt_infobox">
<p class="calibre20">Naming the test files with the name of the file under test plus <kbd class="calibre24">.spec</kbd> is a convention that is used by developers who test with Jasmine. It is also used to facilitate the mapping of files to tests in the configuration steps that we outlined previously.</p>
</div>
<p class="calibre3">This test file contains the unit test specification for the corresponding component, as shown in the following screenshot (taken in the Karma debugger when running our unit tests):</p>
<div class="packt_figure"><img src="../images/00071.jpeg" class="calibre28"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unit-testing Angular applications</h1>
                
            
            <article>
                
<p class="calibre3">Over the course of this book, we have built components that cover every construct available in Angular. We have built components, pipes, a few services, and finally some directives too. All of these are testable in unit tests.</p>
<div class="packt_infobox">
<p class="calibre20"><span class="calibre22">The code for the rest of this chapter can be found in </span><kbd class="calibre24">checkpoint 7.2</kbd><span class="calibre22">. It is available on GitHub (</span><a href="https://github.com/chandermani/angular6byexample" class="calibre21">https://github.com/chandermani/angular6byexample</a><span class="calibre22">) for everyone to download. Checkpoints are implemented as branches in GitHub. If you are not using Git, download the snapshot of </span><kbd class="calibre24">checkpoint7.2</kbd><span class="calibre22"> (a ZIP file) from this GitHub location: </span><span class="calibre22"><a href="https://github.com/chandermani/angular2byexample/archive/checkpoint7.1.zip" class="calibre21">https://github.com/chandermani/angular2byexample/archive/checkpoint7.2.zip</a></span><span class="calibre22">. Refer to the </span><kbd class="calibre24">README.md</kbd><span class="calibre22"> file in the </span><kbd class="calibre24">trainer</kbd><span class="calibre22"> folder when setting up the snapshot for the first time.</span></p>
</div>
<p class="calibre3">Just to get the hang of unit testing with Jasmine, let's test the smallest and easiest component first: the pipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unit-testing pipes</h1>
                
            
            <article>
                
<p class="calibre3">Pipes are the easiest to test as they have minimum or zero dependencies on other constructs. The <kbd class="calibre13">SecondsToTimePipe</kbd> that we created for <em class="calibre17">Workout Runner</em> (the <em class="calibre17">7 Minute Workout</em> app) has no dependencies and can be easily unit-tested.</p>
<div class="packt_infobox">
<p class="calibre20">Look at the Jasmine framework documentation to understand how to write unit tests using Jasmine. The CLI is using Jasmine 2.6 for our unit tests (<a href="http://jasmine.github.io/2.0/introduction.html" class="calibre21">http://jasmine.github.io/2.6/introduction.html</a>). Jasmine has some of the best documentations available and the overall framework is very intuitive to use. We strongly recommend that you head over to the Jasmine site and get yourself familiar with the framework before you proceed.</p>
</div>
<p class="calibre3">Open the  <kbd class="calibre13">seconds-to-time.pipe.spec.ts</kbd> file in the <kbd class="calibre13"><span>trainer</span><span>/src/app/sha</span>red<span> </span></kbd> folder and update the unit test in there as follows:</p>
<pre class="calibre19">import { SecondsToTimePipe } from './seconds-to-time.pipe';<br class="title-page-name"/>describe('SecondsToTimePipe', () =&gt; {<br class="title-page-name"/>  const pipe = new SecondsToTimePipe();<br class="title-page-name"/>  it('should convert integer to time format', () =&gt; {<br class="title-page-name"/>      expect(pipe.transform(5)).toEqual('00:00:05');<br class="title-page-name"/>      expect(pipe.transform(65)).toEqual('00:01:05');<br class="title-page-name"/>      expect(pipe.transform(3610)).toEqual('01:00:10');<br class="title-page-name"/>  });<br class="title-page-name"/>});</pre>
<p class="calibre3">Let's take a look at what we are doing here in our test file.</p>
<p class="calibre3"><span class="calibre6">Not</span> surprisingly, we import <kbd class="calibre13">SecondsToTimePipe</kbd>, which we are going to test. This is just like the imports we have used elsewhere in our TypeScript classes. Notice that we use a relative path to the file in which it is located <kbd class="calibre13">'./seconds-to-time.pipe'</kbd>. In Angular, this means to look for the component to test in the same directory as the test itself. As you recall, this is the way we set up our file structure: putting our tests in the same directory as the file under test.</p>
<p class="calibre3">In the next line, we start using Jasmine syntax. First, we wrap the test in a <kbd class="calibre13">describe</kbd> function that identifies the test. The first parameter of this function is a user-friendly description of the test; in this case, it is <kbd class="calibre13">SecondsToTimePipe</kbd>. For the second parameter, we pass a lambda (fat arrow) function that will contain our test. After setting up a local variable to hold the pipe, we call Jasmine's <kbd class="calibre13">beforeEach</kbd> function and use this to inject an instance of our pipe.</p>
<div class="packt_infobox">
<p class="calibre20"><span class="calibre22">Since the</span> <kbd class="calibre24">beforeEach</kbd> <span class="calibre22">function runs before every test that is in our</span> <kbd class="calibre24">describe</kbd> <span class="calibre22">function, we can use it for common code that will run in each of our tests. In this case, it is not strictly necessary since there is only one test in our</span> <kbd class="calibre24">describe</kbd> <span class="calibre22">function. But it is a good idea to get into the habit of using it for common setup scenarios, as we will see going forward.</span></p>
</div>
<p class="calibre3">Next, we call Jasmine's <kbd class="calibre13">it</kbd> function and pass it a title, along with three calls to Jasmine's <kbd class="calibre13">expect</kbd> function (Jasmine's name for assertions). These are all self-explanatory.</p>
<div class="packt_infobox">
<p class="calibre20">It is not necessary to explicitly import these Jasmine functions in our test.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Running our test files</h1>
                
            
            <article>
                
<p class="calibre3">Now it's time to run our tests using the following command:</p>
<pre class="calibre19"><strong class="calibre1">ng test</strong></pre>
<p class="calibre3">The Angular CLI will transpile our TypeScript files to JavaScript and then watch for changes in these files.</p>
<p class="calibre3">We should then see this output in the Terminal window (the total number of tests may be different for you):</p>
<div class="packt_figure"><img src="../images/00072.jpeg" class="calibre28"/></div>
<p class="calibre3">The last line shows that our test passed successfully (along with all our other tests).</p>
<p class="calibre3">You can also view the test results in the browser window that Karma will launch when it runs our tests:</p>
<div class="packt_figure"><img src="../images/00073.jpeg" class="calibre70"/></div>
<div class="packt_figure"/>
<p class="calibre3">You'll notice here that Karma displays the <kbd class="calibre13">describe</kbd> statement (<span class="calibre6">SecondsToTimePipe</span>) that is used for our pipe tests and nests under it under the <kbd class="calibre13">it</kbd> statement (<span class="calibre6">should convert integer to time format</span>) for the test we have created in order to show us the expected results for our test. Reading the results as they are displayed makes it very easy to understand the outcome of our test.</p>
<p class="calibre3">To make sure that it is reporting the correct pass/fail results, let's make a change in the test to cause one of the expectations to fail. Change the time in the first expectation to six seconds rather than five, like so:</p>
<pre class="calibre19">expect(pipe.transform(5, [])).toEqual('00:00:06'); </pre>
<p class="calibre3">We get the following error message:</p>
<div class="packt_figure"><img src="../images/00074.jpeg" class="calibre28"/></div>
<p class="calibre3">What's nice about this error message is that it combines the <kbd class="calibre13">describe</kbd> and <kbd class="calibre13">it</kbd> descriptions into a complete sentence that provides a clear summary of the error. This shows how Jasmine allows us to write readable tests so that someone who is new to our code can quickly understand any problems that may arise in it. The next line shows us which expectation was not met, what was expected, and what the actual results were that did not meet this expectation.</p>
<p class="calibre3">We also get a stack trace below this message and a final line that shows the overall results of our tests:</p>
<div class="packt_figure"><img src="../images/00075.jpeg" class="calibre71"/></div>
<p class="calibre3">And in the browser, we see the following:</p>
<div class="packt_figure"><img src="../images/00076.jpeg" class="calibre72"/></div>
<p class="calibre3">One thing you'll notice is that when we make the change to our test, we do not have to rerun Karma. Instead, it watches for any changes in our files and related tests and immediately reports success or failure whenever we make a change.</p>
<p class="calibre3">Pretty cool! Let's undo the last change that we made and put the test back into a passing state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unit-testing components</h1>
                
            
            <article>
                
<p class="calibre3">Testing Angular components is more complicated than testing simple pipes or services. That is because Angular components are associated with views and also usually have more dependencies than services, filters, or directives.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular testing utilities</h1>
                
            
            <article>
                
<p class="calibre3">Because of their complexity, Angular has introduced utilities that enable us to test our components more easily. These testing utilities include the <kbd class="calibre13">TestBed</kbd> class (which we previously used to initialize our tests) and several helper functions in <kbd class="calibre13">@angular/core/testing</kbd>.</p>
<p class="calibre3"><kbd class="calibre13">TestBed</kbd> has a <kbd class="calibre13">createComponent</kbd> method that returns a <kbd class="calibre13">ComponentFixture</kbd> containing several members and methods, including:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">debugElement</kbd>: For debugging a component</li>
<li class="calibre12"><kbd class="calibre13">componentInstance</kbd>: For accessing the component properties and methods</li>
<li class="calibre12"><kbd class="calibre13">nativeElement</kbd>: For accessing the view's markup and other DOM elements</li>
<li class="calibre12"><kbd class="calibre13">detectChanges</kbd>: For triggering the component's change detection cycle</li>
</ul>
<p class="calibre3"><kbd class="calibre13">ComnponentFixture</kbd> also contains methods for overriding the view, directives, bindings, and providers of a component. Going forward, we will be using <kbd class="calibre13">TestBed</kbd> throughout the rest of our tests.</p>
<p class="calibre3"><kbd class="calibre13">TestBed</kbd> has a method called <kbd class="calibre13">configureTestingModule</kbd> that we can use to set up our testing as its own module. This means we can bypass the initial bootstrap process and compile our components under test within our test files. We can also use <kbd class="calibre13">TestBed</kbd> to specify additional dependencies and identify the providers that we will need.</p>
<div class="packt_infobox">
<p class="calibre20">According to the Angular documentation (https://angular.io/guide/testing#testbed-class-summary), it is important to <em class="calibre25">call TestBed methods within a</em> <kbd class="calibre24">beforeEach</kbd><em class="calibre25"> </em><span class="calibre22"><em class="calibre25">to ensure a fresh start before each individual test</em>.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Managing dependencies in our tests</h1>
                
            
            <article>
                
<p class="calibre3">Components in Angular integrate the view with everything else. Due to this, components normally have more dependencies compared to any of the services, filters, or directives.</p>
<p class="calibre3">Notwithstanding the fact that our unit tests focus on the code within the component itself, we still need to account for these dependencies in our tests or else the tests will fail (we skipped the dependency setup for pipe testing as it did not have external dependencies).</p>
<p class="calibre3">Two approaches exist for handling these dependencies: inject them into our component or create a mock or fake for them that we can use in our tests. If a dependency is simple enough, we can just inject an instance of it into our test class. However, if the dependency is significantly complicated, especially if it has dependencies of its own and/or makes remote server calls, then we should be mocking it. The Angular testing library provides the tools for us to do that.</p>
<p class="calibre3">The component that we plan to test in this section is the <kbd class="calibre13">WorkoutRunner</kbd> component. Located inside <kbd class="calibre13">trainer/src/components/workout-runner/</kbd>, this is the component that runs a specific workout.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unit-testing WorkoutRunnerComponent</h1>
                
            
            <article>
                
<p class="calibre3">With this background, let's get started with unit testing <kbd class="calibre13">WorkoutRunnerComponent</kbd>.</p>
<p class="calibre3">First, open <kbd class="calibre13">workout-runner-component.spec.ts</kbd> and update the imports to the following:</p>
<pre class="calibre19">import { inject, fakeAsync, async, tick, TestBed, discardPeriodicTasks } from '@angular/core/testing';<br class="title-page-name"/>import { NO_ERRORS_SCHEMA } from '@angular/core';<br class="title-page-name"/>import { Router } from '@angular/router';<br class="title-page-name"/>import { of } from 'rxjs/observable/of';<br class="title-page-name"/><br class="title-page-name"/>import { WorkoutPlan, ExercisePlan, Exercise } from '../core/model';<br class="title-page-name"/>import { WorkoutRunnerComponent } from './workout-runner.component';<br class="title-page-name"/>import { SecondsToTimePipe } from '../shared/seconds-to-time.pipe';<br class="title-page-name"/>import { WorkoutService } from '../core/workout.service';<br class="title-page-name"/>import { WorkoutHistoryTrackerService } from '../core/workout-history-tracker.service';</pre>
<p class="calibre3">These imports identify the test utilities (and things such as <kbd class="calibre13">Router</kbd> and <kbd class="calibre13">of</kbd> from <kbd class="calibre13">RxJS</kbd>) that we will be using in our tests along with the types and dependencies that our component requires. We'll discuss these dependencies in a moment. One import that looks different from the others is the one that imports <kbd class="calibre13">NO_ERRORS_SCHEMA</kbd> from <kbd class="calibre13">@angular/core</kbd>. We will use this import to ignore elements in the component that we will not be testing. Again, we will discuss that further in a moment.</p>
<p class="calibre3">One more thing to note with the imports is that <kbd class="calibre13">@angular/core/testing</kbd> is a part of the core module and not in a separate testing module. This is a common pattern with imports for Angular testing. For example, when we get to testing HTTP, you will see that we are importing from <kbd class="calibre13">@angular/http/testing</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up component dependencies</h1>
                
            
            <article>
                
<p class="calibre3">Next, we need to establish our component's dependencies and determine whether we need to inject or mock them. If we look at the code for the <kbd class="calibre13">WorkoutRunner</kbd> component, we see that there are three dependencies being injected into our component:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">WorkoutHistoryTracker</kbd>: This is a component that has some behavior attached to it. So we definitely want to mock it.</li>
<li class="calibre12"><kbd class="calibre13">Router</kbd>: We'll have to mock this too in order to isolate <kbd class="calibre13">WorkoutRunner</kbd> from the rest of the application and prevent our test from trying to navigate away from the <kbd class="calibre13">WorkoutRunner</kbd> view.</li>
<li class="calibre12"><kbd class="calibre13">WorkoutService:</kbd> This is a service that we will use to make an HTTP call to retrieve our workouts. We will mock this service as well since we don't want to be making a call to an external system within our test.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mocking dependencies - workout history tracker</h1>
                
            
            <article>
                
<p class="calibre3">Angular allows us to mock our dependencies in a straightforward manner using simple classes. Let's start with mocking <kbd class="calibre13">WorkoutHistoryTracker</kbd>. To do that, add the following class just after the imports:</p>
<pre class="calibre19">class MockWorkoutHistoryTracker { 
    startTracking() {} 
    endTracking() {} 
    exerciseComplete() {} 
} </pre>
<p class="calibre3">We do not need to mock the entire <kbd class="calibre13">WorkoutHistoryTracker</kbd> class, but only the methods that <kbd class="calibre13">WorkoutRunner</kbd> will be calling. In this case, those methods are <kbd class="calibre13">startTracking()</kbd>, <kbd class="calibre13">endTracking()</kbd>, and <kbd class="calibre13">exerciseComplete()</kbd>. We have made these methods empty because we do not need anything returned from them in order to test <kbd class="calibre13">WorkoutRunner</kbd>. Now we can inject this dummy implementation into <kbd class="calibre13">WorkoutRunner</kbd> wherever it is looking for <kbd class="calibre13">WorkoutHistoryTracker</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mocking dependencies – workout service</h1>
                
            
            <article>
                
<p class="calibre3">In <a href="" class="calibre10">Chapter 5</a>, <em class="calibre17">Supporting Server Data Persistence</em>, we extended the workout service to make a remote call to retrieve the data that populates a workout. For unit testing the workout runner, we will want to replace that call with a mock implementation that returns some static data that we can use to run the test. So we will add a third mock class, as follows:</p>
<pre class="calibre19">class MockWorkoutService {<br class="title-page-name"/><br class="title-page-name"/>    sampleWorkout = new WorkoutPlan(<br class="title-page-name"/>         'testworkout',<br class="title-page-name"/>         'Test Workout',<br class="title-page-name"/>          40,<br class="title-page-name"/>          [<br class="title-page-name"/>              new ExercisePlan(new Exercise( 'exercise1', 'Exercise 1', 'Exercise 1 description', <br class="title-page-name"/>                                               '/image1/path', 'audio1/path'), 50),<br class="title-page-name"/>              new ExercisePlan(new Exercise( 'exercise1', 'Exercise 2', 'Exercise 2 description', <br class="title-page-name"/>                                               '/image2/path', 'audio2/path'), 30),<br class="title-page-name"/>              new ExercisePlan(new Exercise( 'exercise1', 'Exercise 3', 'Exercise 3 description', <br class="title-page-name"/>                                               '/image3/path', 'audio3/path'), 20)<br class="title-page-name"/>          ],<br class="title-page-name"/>          'This is a test workout'<br class="title-page-name"/>    );<br class="title-page-name"/><br class="title-page-name"/>    getWorkout(name: string) {<br class="title-page-name"/>        return of(this.sampleWorkout);<br class="title-page-name"/>    }<br class="title-page-name"/>    totalWorkoutDuration() {<br class="title-page-name"/>        return 180;<br class="title-page-name"/>    }<br class="title-page-name"/>} </pre>
<p class="calibre3">Notice that the <kbd class="calibre13">getWorkout</kbd> method is returning an <kbd class="calibre13">Observable</kbd>, as indicated by the use of the <kbd class="calibre13">of</kbd> operator. Otherwise the class is self-explanatory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mocking dependencies - router</h1>
                
            
            <article>
                
<p class="calibre3">As with <kbd class="calibre13">WorkoutHistoryTracker</kbd> and <kbd class="calibre13">WorkoutService</kbd>, we also will be using mocking to handle the dependency that we have on the Angular router. But here we will be taking a slightly different approach. We will assign a Jasmine spy to a <kbd class="calibre13">navigate</kbd> method on our mock:</p>
<pre class="calibre19">export class MockRouter {<br class="title-page-name"/>    navigate = jasmine.createSpy('navigate');<br class="title-page-name"/>}</pre>
<p class="calibre3">This will be sufficient for our purposes because we only want to make sure that the router's <kbd class="calibre13">navigate</kbd> method is being called with the appropriate route (<kbd class="calibre13">finished</kbd>) as a parameter. The Jasmine spy will allow us to do that as we will see later.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuring our test using TestBed</h1>
                
            
            <article>
                
<p class="calibre3">Now that we have our imports and dependencies out of the way, let's get started with the tests themselves. We begin by adding a Jasmine <kbd class="calibre13">describe</kbd> function that will wrap our tests, followed by setting two local variables using <kbd class="calibre13">let</kbd>: one for <kbd class="calibre13">fixture</kbd> and the other for <kbd class="calibre13">runner</kbd>:</p>
<pre class="calibre19">describe('Workout Runner', () =&gt;{ 
    let fixture:any; 
    let runner:any; </pre>
<p class="calibre3">Next we'll add a <kbd class="calibre13">beforeEach</kbd> function that sets up our test configuration:</p>
<pre class="calibre19">beforeEach( async(() =&gt;{ 
    TestBed 
        .configureTestingModule({ 
            declarations: [ WorkoutRunnerComponent, SecondsToTimePipe ], 
            providers: [ 
                {provide: Router, useClass: MockRouter}, 
                {provide: WorkoutHistoryTracker ,useClass: 
                MockWorkoutHistoryTracker}, 
                {provide: WorkoutService ,useClass: MockWorkoutService} 
            ], 
            schemas: [ NO_ERRORS_SCHEMA ] 
        }) 
        .compileComponents() 
        .then(() =&gt; { 
            fixture = TestBed.createComponent(WorkoutRunnerComponent); 
            runner = fixture.componentInstance; 
        }); 
}));  </pre>
<p class="calibre3">The <kbd class="calibre13">beforeEach</kbd> method executes before each test, which means that we will only have to set this up once in our test file. Inside <kbd class="calibre13">beforeEach</kbd>, we add an <kbd class="calibre13">async</kbd> call. This is required because of the asynchronous <kbd class="calibre13">compileComponents</kbd> method that we are calling.</p>
<div class="packt_infobox">
<p class="calibre20">The Angular documentation indicates that the <kbd class="calibre24">async</kbd> function arranges for the tester's code to run in a special <kbd class="calibre24">async</kbd> test zone that hides the mechanics of asynchronous execution, just as it does when passed to an <kbd class="calibre24">it</kbd> test. For more information refer to <kbd class="calibre24">https://angular.io/docs/ts/latest/guide/testing.html#!#async-in-before-each</kbd><span class="calibre22">.</span> We'll discuss this in more detail shortly.</p>
</div>
<p class="calibre3">Let's go through each method call in the order that they are executed. The first method, <kbd class="calibre13">configureTestingModule</kbd>, allows us to build on the base configuration of the testing module and add things such as imports, declarations (of the components, directives, and pipes we will be using in our test), and providers. In the case of our test, we are first adding declarations for the workout runner, our component under test, and the <kbd class="calibre13">SecondsToTimePipe:</kbd></p>
<pre class="calibre19">declarations: [ WorkoutRunnerComponent, SecondsToTimePipe ], </pre>
<p class="calibre3">Then we add three providers for our <kbd class="calibre13">Router</kbd>, <kbd class="calibre13">WorkoutHistoryTracker</kbd>, and <kbd class="calibre13">WorkoutService</kbd>:</p>
<pre class="calibre19">providers: [ 
    {provide: Router, useClass: MockRouter}, 
    {provide: WorkoutHistoryTracker ,useClass: MockWorkoutHistoryTracker}, 
    {provide: WorkoutService ,useClass: MockWorkoutService} 
], </pre>
<p class="calibre3">For each of these providers, we set the <kbd class="calibre13">useClass</kbd> property to our mocks instead of the actual components. Now, anywhere in our test, when the <kbd class="calibre13">WorkoutRunner</kbd> requires any of these components, the mock will be used instead.</p>
<p class="calibre3">The next configuration may seem a bit mysterious:</p>
<pre class="calibre19">schemas: [ NO_ERRORS_SCHEMA ] </pre>
<p class="calibre3">This setting allows us to bypass the errors we would otherwise get regarding the custom elements associated with two components that we are using in the component's template: <kbd class="calibre13">ExerciseDescriptionComponent</kbd> and <kbd class="calibre13">VideoPlayerComponent</kbd>. At this point, we don't want to be testing these components within the test for the <kbd class="calibre13">WorkoutRunnerComponent</kbd>. Instead, we should be testing them separately. One thing to be aware of, however, when you use this setting is that it will suppress all schema errors related to elements and attributes in the template of the component under test; so it may hide other errors that you do want to see.</p>
<p class="calibre3">When you set up a test using <kbd class="calibre13">NO_ERRORS_SCHEMA</kbd>, you are creating what is called a shallow test, one that does not go deeper than the component you are testing. Shallow tests allow you to reduce complexities in the templates within the component you are testing and reduce the need for mocking dependencies.</p>
<p class="calibre3">The final steps in the configuration of our test are to compile and instantiate our components:</p>
<pre class="calibre19">.compileComponents() 
.then(() =&gt; { 
    fixture = TestBed.createComponent(WorkoutRunnerComponent); 
    runner = fixture.componentInstance; 
}); </pre>
<p class="calibre3">As mentioned previously, we are using an <kbd class="calibre13">async</kbd> function in our <kbd class="calibre13">beforeEach</kbd> method because this is required when we call the <kbd class="calibre13">compileComponents</kbd> method. This method call is asynchronous and we need to use it here because our component has an external template that is specified in a <kbd class="calibre13">templateUrl</kbd>. This method compiles that external template and then inlines it so that it can be used by the <kbd class="calibre13">createComponent</kbd> method (which is synchronous) to create our component fixture. This component fixture in turn contains a <kbd class="calibre13">componentInstance</kbd>-<kbd class="calibre13">WorkoutRunner</kbd>. We then assign both the <kbd class="calibre13">fixture</kbd> and the <kbd class="calibre13">componentInstance</kbd> to local variables.</p>
<p class="calibre3">As mentioned previously, the <kbd class="calibre13">async</kbd> function we are using creates a special <kbd class="calibre13">async</kbd> test zone in which our tests will run. You'll notice that this function is simplified from normal <kbd class="calibre13">async</kbd> programming and lets us do things such as using the <kbd class="calibre13">.then</kbd> operator without returning a promise.</p>
<div class="packt_infobox">
<p class="calibre20">You can also compile and instantiate test components inside individual test methods. But the <kbd class="calibre24">beforeEach</kbd> method allows us to do it once for all our tests.</p>
</div>
<p class="calibre3">Now that we have configured our test, let's move on to unit-testing <kbd class="calibre13">WorkoutRunner</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Starting unit testing</h1>
                
            
            <article>
                
<p class="calibre3">Starting from the loading of workout data to transitioning of exercises, pausing workouts, and running exercise videos, there are a number of aspects of the <kbd class="calibre13">WorkoutRunner</kbd> that we can test. The <kbd class="calibre13">workout.spec.ts</kbd> file (available in the <kbd class="calibre13">components/workout-runner</kbd> folder under <kbd class="calibre13">trainer/src</kbd>) contains a number of unit tests that cover the preceding scenarios. We will pick up some of those tests and work through them.</p>
<p class="calibre3">To start with, let's add a test case that verifies that the workout starts running once the component is loaded:</p>
<pre class="calibre19">it('should start the workout', () =&gt; { 
    expect(runner.workoutTimeRemaining).toEqual(runner.workoutPlan.totalWorkoutDuration()); 
    expect(runner.workoutPaused).toBeFalsy(); 
});  </pre>
<p class="calibre3">This test asserts that the total duration of the workout is correct and the workout is in the running state (that is, not paused).</p>
<p class="calibre3">So let's execute the test. It fails (check the Karma console). Strange! All the dependencies have been set up correctly, but still the second <kbd class="calibre13">expect</kbd> function of the <kbd class="calibre13">it</kbd> block fails as it is undefined.</p>
<p class="calibre3">We need to debug this test.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Debugging unit tests in Karma</h1>
                
            
            <article>
                
<p class="calibre3">Debugging unit tests in Karma is easy as the tests are run in the browser. We debug tests as we debug the standard JavaScript code. And since our Karma configuration has added mappings from our TypeScript files to our JavaScript files, we can debug directly in TypeScript.</p>
<p class="calibre3">When Karma starts, it opens a specific browser window to run the tests. To debug any test in Karma, we just need to click on the <span class="calibre6">Debug</span> button available at the top of the browser window.</p>
<div class="packt_infobox">
<p class="calibre20">There is one window opened by Karma and one when we click on <span class="calibre22">Debug</span>; we can use the original window for testing too, but the original window is connected to Karma and does a live reload. Also, the script files in the original window are timestamped, which changes whenever we update the test and hence requires us to put in a breakpoint again to test.</p>
</div>
<p class="calibre3">Once we click on <span class="calibre6">Debug</span>, a new tab/window opens with all the tests and other app scripts loaded for testing. These are scripts that were defined during the Karma configuration setup in the <kbd class="calibre13">karma.conf.js</kbd> files section.</p>
<p class="calibre3">To debug the preceding failure, we need to add breakpoints at two locations. One should be added inside the test itself and the second one inside  <kbd class="calibre13">WorkoutComponent</kbd>, where it loads the workout and assigns the data to the appropriate local variables.</p>
<p class="calibre3">Perform the following steps to add a breakpoint in Google Chrome:</p>
<ol class="calibre14">
<li value="1" class="calibre12">Open the Karma debug window/tab by clicking on the <span>Debug</span> button on the window loaded by Karma when it started.</li>
<li value="2" class="calibre12">Press the <span>F12</span> key to open the developer console.</li>
</ol>
<ol start="3" class="calibre14">
<li value="3" class="calibre12">Go to the <span>Sources</span> tab and the TypeScript files for your application will be located in the <kbd class="calibre13">source</kbd> folder.</li>
<li value="4" class="calibre12">We can now put breakpoints at the required locations just by clicking on the line number. This is the standard mechanism to debug any script. Add breakpoints at the locations highlighted here:</li>
</ol>
<div class="packt_figure"><img src="../images/00077.jpeg" class="calibre28"/></div>
<ol start="5" class="calibre14">
<li value="5" class="calibre12">We refresh the <span>Debug</span> page (the one we opened when we clicked on the <span>Debug</span> button). The breakpoint in <kbd class="calibre13">workout-runner.ts</kbd> is never hit, causing the test to fail.</li>
</ol>
<p class="calibre36">What we overlooked is that the code that we were trying to reach is within the <kbd class="calibre13">start</kbd> method of <kbd class="calibre13">workout-runner</kbd>, and the <kbd class="calibre13">start</kbd> method is not being called in the constructor. Instead it is called in <kbd class="calibre13">ngDoCheck</kbd> after the data for the workout has been loaded through a call to the <kbd class="calibre13">getWorkout</kbd> method in <kbd class="calibre13">ngOnInit</kbd>. Add calls to <kbd class="calibre13">ngOnInit</kbd> and <kbd class="calibre13">ngDoCheck</kbd> in your test, like so:</p>
<pre class="calibre19">        it('should start the workout', () =&gt; { 
<strong class="calibre1">            runner.ngOnInit();</strong><strong class="calibre1">    <br class="title-page-name"/>            runner.ngDoCheck();</strong> 
            expect(runner.workoutTimeRemaining).toEqual(
                   runner.workoutPlan.totalWorkoutDuration()); 
            expect(runner.workoutPaused).toBeFalsy(); 
        }); </pre>
<ol start="6" class="calibre14">
<li value="6" class="calibre12">Save the change and Karma will run the test again. This time it will pass.</li>
</ol>
<div class="packt_infobox">
<p class="calibre20">As the number of tests grows, unit testing may require us to concentrate on a specific test or a specific suite of tests. Karma allows us to target one or more tests by prepending <kbd class="calibre24">f</kbd> to the existing <kbd class="calibre24">it</kbd> block; that is, <kbd class="calibre24">it</kbd> becomes <kbd class="calibre24">fit</kbd>. If Karma finds tests with <kbd class="calibre24">fit</kbd>, it only executes those tests. Similarly, a specific test suite can be targeted by prepending <kbd class="calibre24">f</kbd> to the existing <kbd class="calibre24">describe</kbd> block: <kbd class="calibre24">fdescribe</kbd>. Also, if you prepend <kbd class="calibre24">x</kbd> to an <kbd class="calibre24">it</kbd> <span class="calibre22">block, making it</span> <kbd class="calibre24">xit</kbd>, then that block will be skipped.</p>
</div>
<p class="calibre3">Let's continue unit-testing the component!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unit-testing WorkoutRunner continued...</h1>
                
            
            <article>
                
<p class="calibre3">What other interesting things can we test? We can test whether the first exercise has started. We add this test to <kbd class="calibre13">workout.spec.ts</kbd> after the one we just added:</p>
<pre class="calibre19">it('should start the first exercise', () =&gt; { 
    spyOn(runner, 'startExercise').and.callThrough(); 
    runner.ngOnInit(); 
    runner.ngDoCheck(); 
    expect(runner.currentExerciseIndex).toEqual(0); 
    expect(runner.startExercise).toHaveBeenCalledWith(
    runner.workoutPlan.exercises[runner.currentExerciseIndex]); 
    expect(runner.currentExercise).toEqual(
    runner.workoutPlan.exercises[0]); 
}); </pre>
<p class="calibre3">The second <kbd class="calibre13">expect</kbd> function in this test is interesting. It uses a Jasmine feature: spies. Spies can be used to verify method invocations and dependencies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Jasmine spies to verify method invocations</h1>
                
            
            <article>
                
<p class="calibre3">A spy is an object that intercepts every call to the function it is spying on. Once the call is intercepted, it can either return fixed data or pass the call to the actual function being invoked. It also records the call invocation details that can be used later in <kbd class="calibre13">expect</kbd> as we did in the preceding test.</p>
<div class="packt_infobox">
<p class="calibre20">Spies are very powerful and can be used in a number of ways during unit testing. Look at the documentation on spies at <span class="calibre22"><a href="http://jasmine.github.io/2.0/introduction.html#section-Spies" class="calibre21">http://jasmine.github.io/2.0/introduction.html#section-Spies</a></span> to learn more about them.</p>
</div>
<p class="calibre3">The second <kbd class="calibre13">expect</kbd> function verifies that the <kbd class="calibre13">startExercise</kbd> method was called when the workout started (<kbd class="calibre13">toHaveBeenCalledWith</kbd>). It is also asserting the correctness of the parameters passed to the function. The second <kbd class="calibre13">expect</kbd> statement asserts the behavior using a spy, but we first need to set up the spy to make this assert work.</p>
<p class="calibre3">In this case, we are using the spy to mock a call to the <kbd class="calibre13">startExercise</kbd> method. We can use the spy to determine whether the method has been called and with what parameters, using Jasmine's <kbd class="calibre13">toHaveBeenCalledWith</kbd> function.</p>
<div class="packt_infobox">
<p class="calibre20">Look at the Jasmine documentation for the <kbd class="calibre24">toHaveBeenCalled</kbd> and <kbd class="calibre24">toHaveBeenCalledWith</kbd> functions to learn more about these assert functions.</p>
</div>
<p class="calibre3">Here, the method is being called with the current <kbd class="calibre13">Exercise</kbd> as a parameter. Since the previous <kbd class="calibre13">expect</kbd> confirms that this is the first exercise, this <kbd class="calibre13">expect</kbd> confirms that a call to start that first exercise was executed.</p>
<p class="calibre3">There are a couple of things to note here. First, you have to be careful to put the setup for <kbd class="calibre13">spyOn</kbd> prior to calling <kbd class="calibre13">ngOnInit</kbd>. Otherwise, the spy will not be <em class="calibre17">spying</em> when the <kbd class="calibre13">startExercise</kbd> method is called and the method invocation will not be captured.</p>
<p class="calibre3">Second, since the spy is a mock, we will normally not be able to verify anything within the <kbd class="calibre13">startExercise</kbd> method. This is because the method itself is being mocked. This means that we cannot actually verify that the <kbd class="calibre13">currentExercise</kbd> property has been set, since that is being done inside the mocked method. However, Jasmine allows us to chain the spy with <kbd class="calibre13">and.callThrough</kbd>, which will mean that in addition to tracking the calls to the method, it will delegate to the actual implementation. This then allows us to test that the <kbd class="calibre13">currentExercise</kbd> has also been set correctly inside the <kbd class="calibre13">startExercise</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Jasmine spies to verify dependencies</h1>
                
            
            <article>
                
<p class="calibre3">While we just used a spy to verify the call to a method within our class, Jasmine spies are also useful in mocking calls to external dependencies. But why test calls to our external dependencies at all? After all, we are trying to limit our testing to the component itself!</p>
<p class="calibre3">The answer is that we mock a dependency to make sure that the dependency does not adversely affect the component under test. From a unit testing perspective, we still need to make sure that these dependencies are called by the component being tested at the right time with the correct input. In the Jasmine world, spies help us assert whether dependencies were invoked correctly.</p>
<p class="calibre3">If we look at the <kbd class="calibre13">WorkoutRunner</kbd> implementation, we emit a message with the details of the workout whenever the workout starts. An external dependency, <kbd class="calibre13">WorkoutHistoryTracker</kbd>, subscribes to this message/event. So let's create a spy and confirm that <kbd class="calibre13">WorkoutHistoryTracker</kbd> started when the workout started.</p>
<p class="calibre3">Add this <kbd class="calibre13">it</kbd> block after the preceding one:</p>
<pre class="calibre19">it("should start history tracking", inject([WorkoutHistoryTracker], (tracker: WorkoutHistoryTracker) =&gt; { 
     spyOn(tracker, 'startTracking'); 
     runner.ngOnInit(); 
     runner.ngDoCheck(); 
     expect(tracker.startTracking).toHaveBeenCalled(); 
 })); </pre>
<p class="calibre3">Within the <kbd class="calibre13">it</kbd> block, we add a spy on the <kbd class="calibre13">tracker</kbd>, a local instance of the <kbd class="calibre13">WorkoutHistoryTracker</kbd>. Then we use the spy to verify that the <kbd class="calibre13">startTracking</kbd> method of that dependency has been called. Simple and expressive!</p>
<p class="calibre3">You may recall that we are using <kbd class="calibre13">MockHistoryWorkoutTracker</kbd> here; it contains a mock, a <kbd class="calibre13">startTracking</kbd> method that is empty and returns nothing. That is fine because we are not testing the <kbd class="calibre13">WorkoutHistoryTracker</kbd> itself, but just the method invocation on it being made by the <kbd class="calibre13">WorkoutRunner</kbd>. This test shows how useful it is to be able to combine mocks with spies to fully test the inner workings of the <kbd class="calibre13">WorkoutRunner</kbd>, separately and apart from its dependencies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing event emitters</h1>
                
            
            <article>
                
<p class="calibre3">Examining the code for the <kbd class="calibre13">WorkoutRunner</kbd>, we see that it sets up several event emitters that look like the following one for <kbd class="calibre13">workoutStarted</kbd>:</p>
<pre class="calibre19">@Output() workoutStarted: EventEmitter&lt;WorkoutPlan&gt; = new EventEmitter&lt;WorkoutPlan&gt;(); </pre>
<p class="calibre3">The Angular documentation describes an event emitter as an output property that fires events to which we can subscribe with an event binding. In <a href="" class="calibre10">Chapter 2</a>, <em class="calibre17">Building Our First App - 7 Minute Workout</em>, we described in detail how event emitters are used in Workout Runner. So we have a good understanding of what they do. But how do we unit-test our event emitters and determine that they are firing events in the way we expect?</p>
<p class="calibre3">It's actually pretty easy to do. If we remember that an event emitter is an Observable Subject to which we can subscribe, we realize that we can simply subscribe to it in our unit test. Let's revisit our test that verifies that a workout is starting and add the highlighted code to it:</p>
<pre class="calibre19">it('should start the workout', () =&gt; { 
<strong class="calibre1">    runner.workoutStarted.subscribe((w: any) =&gt; {</strong><strong class="calibre1"> 
      expect(w).toEqual(runner.workoutPlan);</strong><strong class="calibre1">    });</strong> 
    runner.ngOnInit(); 
    runner.ngDoCheck(); 
    expect(runner.workoutTimeRemaining).toEqual(
    runner.workoutPlan.totalWorkoutDuration()); 
    expect(runner.workoutPaused).toBeFalsy(); 
}); </pre>
<p class="calibre3">We injected the <kbd class="calibre13">WorkoutService</kbd> and added a subscription to the <kbd class="calibre13">WorkoutStarted</kbd> event emitter and an expectation that checks to see whether the property is emitting a <kbd class="calibre13">WorkoutPlan</kbd> when the event is triggered. The subscription is placed before <kbd class="calibre13">ngOnInit</kbd> because that is the method that results in the <kbd class="calibre13">workoutStarted</kbd> event being triggered, and we need to have our subscription in place before that happens.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing interval and timeout implementations</h1>
                
            
            <article>
                
<p class="calibre3">One of the interesting challenges for us is to verify that the workout progresses as time elapses. The <kbd class="calibre13">Workout</kbd> component uses <kbd class="calibre13">setInterval</kbd> to move things forward with time. How can we simulate time without actually waiting?</p>
<p class="calibre3">The answer is the Angular testing library's <kbd class="calibre13">fakeAsync</kbd> function, which allows us to run otherwise asynchronous code synchronously. It does this by wrapping the function to be executed in a <kbd class="calibre13">fakeAsync</kbd> zone. It then supports using synchronous timers within that zone and also allows us to simulate the asynchronous passage of time with <kbd class="calibre13">tick()</kbd>.</p>
<div class="packt_infobox">
<p class="calibre20">For more information about <kbd class="calibre24">fakeAsync</kbd>, see the Angular documentation at <span class="calibre22"><a href="https://angular.io/guide/testing#async-test-with-fakeasync" target="_blank" class="calibre21">https://angular.io/guide/testing#async-test-with-fakeasync.</a></span></p>
</div>
<p class="calibre3">Let's see how we can use the <kbd class="calibre13">fakeAsync</kbd> function to test the timeout and interval implementations in our code. Add the following test to <kbd class="calibre13">workout-runner.spec.ts</kbd>:</p>
<pre class="calibre19">    it('should increase current exercise duration with time', fakeAsync(() =&gt; {<br class="title-page-name"/>        runner.ngOnInit();<br class="title-page-name"/>        runner.ngDoCheck();<br class="title-page-name"/>        expect(runner.exerciseRunningDuration).toBe(0);<br class="title-page-name"/>        tick(1000);<br class="title-page-name"/>        expect(runner.exerciseRunningDuration).toBe(1);<br class="title-page-name"/>        tick(1000);<br class="title-page-name"/>        expect(runner.exerciseRunningDuration).toBe(2);<br class="title-page-name"/>        tick(8000);<br class="title-page-name"/>        expect(runner.exerciseRunningDuration).toBe(10);<br class="title-page-name"/>        discardPeriodicTasks();<br class="title-page-name"/>    })); </pre>
<p class="calibre3">In addition to injecting <kbd class="calibre13">WorkoutRunner</kbd>, we first wrap the test in <kbd class="calibre13">fakeAsync</kbd>. Then we add a call to the <kbd class="calibre13">WorkoutRunner</kbd>'s <kbd class="calibre13">ngOnit()</kbd> method. This kicks off the timers for the exercises within <kbd class="calibre13">WorkoutRunner</kbd>. Then within the test, we use the <kbd class="calibre13">tick()</kbd> function set at various durations to test the operation of the timer for an exercise, and make sure that it continues running for the duration that we expected it to run. Using <kbd class="calibre13">tick()</kbd> allows us to fast forward through the code and avoid having to wait for the exercise to complete over several seconds as it would if we ran the code asynchronously.</p>
<p class="calibre3">At the end, we call <kbd class="calibre13"><span>discardPeriodicTasks()</span></kbd> . This method is one of the Angular testing utilities and it can be used with  <kbd class="calibre13">fakeAsync</kbd> <span class="calibre6">to clear any pending timers that may be in the task queue</span>.</p>
<div class="packt_infobox">
<p class="calibre20">More information about these and other Angular testing utilities can be found at <a href="https://angular.io/guide/testing#testing-utility-apis" target="_blank" class="calibre21">https://angular.io/guide/testing#testing-utility-apis</a></p>
</div>
<p class="calibre3">Let's try another similar test. We want to make sure that the <kbd class="calibre13">WorkoutRunner</kbd> is correctly transitioning from one exercise to the next. Add the following test to <kbd class="calibre13">workout-runner.ts</kbd>:</p>
<pre class="calibre19">it("should transition to next exercise on one exercise complete", fakeAsync(() =&gt; { 
    runner.ngOnInit(); 
    runner.ngDoCheck(); 
    let exerciseDuration = runner.workoutPlan.exercises[0].duration; 
    TestHelper.advanceWorkout(exerciseDuration); 
    expect(runner.currentExercise.exercise.name).toBe('rest'); 
    expect(runner.currentExercise.duration).toBe(
    runner.workoutPlan.restBetweenExercise); 
    discardPeriodicTasks();
})); </pre>
<p class="calibre3">Again we wrap the test in <kbd class="calibre13">fakeAsync</kbd> and call <kbd class="calibre13">runner.ngOnInit</kbd> to start the timer. Then we grab the duration of the first exercise and use the <kbd class="calibre13">tick()</kbd> function within the following <kbd class="calibre13">TestHelper</kbd> method to advance the timer one second beyond the duration of that exercise:</p>
<pre class="calibre19">class TestHelper {<br class="title-page-name"/>    static advanceWorkout(duration: number) {<br class="title-page-name"/>        for (let i = 0; i &lt;= duration; i++) {tick(1000);<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">Next, we test the expectation that we are now in the <kbd class="calibre13">rest</kbd> exercise and thus have transitioned from the first exercise.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing workout pause and resume</h1>
                
            
            <article>
                
<p class="calibre3">When we pause a workout, it should stop and the time counter should not lapse. To check this, add the following time test:</p>
<pre class="calibre19">it("should not update workoutTimeRemaining for paused workout on 
    interval lapse", fakeAsync(() =&gt; { 
    runner.ngOnInit(); 
    runner.ngDoCheck(); 
    expect(runner.workoutPaused).toBeFalsy(); 
    tick(1000); 
    expect(runner.workoutTimeRemaining).toBe(
    runner.workoutPlan.totalWorkoutDuration() - 1); 
    runner.pause(); 
    expect(runner.workoutPaused).toBe(true); 
    tick(1000); 
    expect(runner.workoutTimeRemaining).toBe(
    runner.workoutPlan.totalWorkoutDuration() - 1); 
    discardPeriodicTasks();
})); </pre>
<p class="calibre3">The test starts with verifying the state of the workout as not paused, advances the time for one second, pauses it, and then verifies that the time of <kbd class="calibre13">workoutTimeRemaining</kbd> does not change after the pause.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unit-testing services</h1>
                
            
            <article>
                
<p class="calibre3">Unit testing of services is not much different from unit-testing components. Once we get the hang of how to set up a component and its dependencies (mostly using mocks), it becomes a routine affair to apply that learning to testing services. More often than not, the challenge is to set up the dependencies for the services so that testing can be done effectively.</p>
<p class="calibre3">Things are a little different for services that make remote requests (using either <kbd class="calibre13">http</kbd> or <kbd class="calibre13">jsonp</kbd>). There is some setup required before we can test such services in isolation.</p>
<p class="calibre3">We will target <kbd class="calibre13">WorkoutService</kbd> and write some unit tests for it. Since this service makes remote requests to load workout data, we will explore how to test such a service with a mock HTTP backend. Angular provides us with the <span class="calibre6"><kbd class="calibre13">HttpTestingController</kbd></span> <span class="calibre6">for </span>doing that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mocking HTTP request/response with HttpTestingController</h1>
                
            
            <article>
                
<p class="calibre3">When testing services (or, as a matter of fact, any other Angular construct) that make remote requests, we obviously do not want to make actual requests to a backend to check the behavior. That does not even qualify for a unit test. The backend interaction just needs to be mocked away. Angular provides for precisely that. Using <kbd class="calibre13">HttpTestingController</kbd>, we intercept HTTP requests, mock actual responses from the server, and assert endpoints invocation too.</p>
<p class="calibre3">Open <kbd class="calibre13">workout-service.spec.ts</kbd>  and add the following import statements at the top of the file:</p>
<pre class="calibre19">import { TestBed, inject, async, fakeAsync } from '@angular/core/testing';<br class="title-page-name"/>import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';<br class="title-page-name"/>import { HttpClient, HttpResponse } from '@angular/common/http';<br class="title-page-name"/><br class="title-page-name"/>import { WorkoutService } from './workout.service';<br class="title-page-name"/>import { WorkoutPlan, Exercise } from './model';</pre>
<p class="calibre3">In addition to the imports from the <kbd class="calibre13">core/testing</kbd> module, we are importing both <kbd class="calibre13">HttpClientTestingModule</kbd>  and  <kbd class="calibre13">HttpTestingController</kbd> from the <kbd class="calibre13">http/testing</kbd>  module. We are also importing <kbd class="calibre13">WorkoutService</kbd> and <kbd class="calibre13">WorkoutPlan</kbd> that we will be testing.</p>
<p class="calibre3">Once we have the imports in place, we will begin creating the test with the Jasmine <kbd class="calibre13">describe</kbd>  statement that wraps our tests, and will set several local variables:</p>
<pre class="calibre19">describe('Workout Service', () =&gt; { <br class="title-page-name"/>  const collectionUrl = '...[mongo connnection url]...';<br class="title-page-name"/>  const apiKey = '...[mongo key]...';<br class="title-page-name"/>  const params = '?apiKey=' + apiKey;<br class="title-page-name"/>  let httpClient: HttpClient;<br class="title-page-name"/>  let httpTestingController: HttpTestingController;<br class="title-page-name"/>  let workoutService: WorkoutService;</pre>
<p class="calibre3">In addition to creating local variables for <kbd class="calibre13">HttpClient</kbd>, <kbd class="calibre13">HttpTestingController</kbd>, and <kbd class="calibre13">WorkoutService</kbd>, you'll also notice that we are setting local variables for our Mongo connection. To be clear, we are not setting these variables in order to make a remote call to Mongo, but instead to test that the connection properties are being set properly.</p>
<p class="calibre3">The next step is set up the providers and dependency injection for our tests. To handle the providers, add the following to the test file:</p>
<pre class="calibre19">  beforeEach(() =&gt; {<br class="title-page-name"/>    TestBed.configureTestingModule({<br class="title-page-name"/>      imports: [HttpClientTestingModule],<br class="title-page-name"/>      providers: [ WorkoutService ],<br class="title-page-name"/>    });<br class="title-page-name"/>    httpClient = TestBed.get(HttpClient);<br class="title-page-name"/>    httpTestingController = TestBed.get(HttpTestingController);<br class="title-page-name"/>    workoutService = TestBed.get(WorkoutService);<br class="title-page-name"/>  });</pre>
<p class="calibre3">First, we call <kbd class="calibre13">TestBed.configureTestingModule</kbd>  to import the <kbd class="calibre13">HttpClientTestingModule</kbd> and add the <kbd class="calibre13">WorkoutService</kbd>. According to the Angular documentation (<a href="https://angular.io/api/common/http/testing/HttpClientTestingModule" target="_blank" class="calibre10">https://angular.io/api/common/http/testing/HttpClientTestingModule</a>), <kbd class="calibre13">HttpClientTestingModule</kbd> sets up <kbd class="calibre13">HttpClient</kbd> to use <kbd class="calibre13">HttpClientTestingBackend</kbd> as <kbd class="calibre13">HttpBackend</kbd>. The nice thing here is that this setup is completely hidden from our test setup, so we don't have to write code to wire this up.</p>
<p class="calibre3">Next we use the <kbd class="calibre13">TestBed.get</kbd> method to populate our local variables—<kbd class="calibre13">httpClient</kbd>, <kbd class="calibre13">httpTestingController</kbd>, and <kbd class="calibre13">workoutService</kbd>. We'll also add the following <kbd class="calibre13">afterEach</kbd> method to make sure that after every test completes there are no more pending requests:</p>
<pre class="calibre19"> afterEach(() =&gt; {<br class="title-page-name"/>   httpTestingController.verify();<br class="title-page-name"/> });</pre>
<p class="calibre3">With this setup in place, we are now in a position to create tests for <kbd class="calibre13">WorkoutService</kbd> that avoid us making a remote call. We'll start with a simple test that makes sure that <kbd class="calibre13">workoutService</kbd> loads:</p>
<pre class="calibre19">it('should be created', inject([WorkoutService], (service: WorkoutService) =&gt; {<br class="title-page-name"/>   expect(service).toBeTruthy();<br class="title-page-name"/> }));</pre>
<p class="calibre3">While this test may seem trivial, it is important to place it here because it acts as a check to make sure that we have set up our configuration correctly.</p>
<p class="calibre3">Next, we'll add the following test to make sure that we are able to inject <kbd class="calibre13">HttpClient</kbd> when we instantiate <kbd class="calibre13">WorkoutService</kbd>:</p>
<pre class="calibre19">it('can instantiate service with "new"', inject([HttpClient], (http: HttpClient) =&gt; {<br class="title-page-name"/>    expect(http).not.toBeNull('http should be provided');<br class="title-page-name"/>    const service = new WorkoutService(http);<br class="title-page-name"/>    expect(service instanceof WorkoutService).toBe(true, 'new service should be ok');<br class="title-page-name"/>}));</pre>
<p class="calibre3">Now, we'll move to testing several of the methods in the workout-service. First, we will make sure that it returns all workouts when the <kbd class="calibre13">getWorkouts</kbd> method is called. To do that, add the following test:</p>
<pre class="calibre19">  it('should should return all workout plans', () =&gt; {<br class="title-page-name"/>    let expectedWorkouts: WorkoutPlan[];<br class="title-page-name"/>    let actualWorkouts: WorkoutPlan[];<br class="title-page-name"/><br class="title-page-name"/>    expectedWorkouts = [<br class="title-page-name"/>      { name: 'Workout1', title: 'workout1' },<br class="title-page-name"/>      { name: 'Workout2', title: 'workout2' },<br class="title-page-name"/>      { name: 'Workout3', title: 'workout3' },<br class="title-page-name"/>      { name: 'Workout4', title: 'workout4' }<br class="title-page-name"/>    ] as WorkoutPlan[];<br class="title-page-name"/><br class="title-page-name"/>     workoutService.getWorkouts().subscribe(<br class="title-page-name"/>      workouts =&gt; actualWorkouts = workouts,<br class="title-page-name"/>      fail<br class="title-page-name"/>    );<br class="title-page-name"/>    const req = httpTestingController.expectOne(workoutService.collectionsUrl + '/workouts' + params );<br class="title-page-name"/>    expect(req.request.method).toEqual('GET');<br class="title-page-name"/>    req.flush(expectedWorkouts);<br class="title-page-name"/>    expect(actualWorkouts === expectedWorkouts);<br class="title-page-name"/>  });</pre>
<p class="calibre3">We'll start by declaring two arrays of <kbd class="calibre13">WorkoutPlans</kbd>—<kbd class="calibre13">expectedWorkouts</kbd> and <kbd class="calibre13">actualWorkouts</kbd>. We'll then populate <kbd class="calibre13">expectedWorkouts</kbd> with four  <kbd class="calibre13">WorkoutPlans</kbd>. Because we are testing retrieval of the <kbd class="calibre13">WorkoutPlans</kbd> and not their content, we have made these minimal workouts.</p>
<p class="calibre3">Since the <kbd class="calibre13">Http</kbd> module returns <kbd class="calibre13">RxJS</kbd> Observables, we next use the pattern of subscribing to those Observables. You should be used to seeing this pattern from our coverage of Observables in <a href="" class="calibre10">Chapter 5</a>, <em class="calibre17">Supporting Server Data Persistence</em>. Notice that we use <kbd class="calibre13">fail</kbd> as the second parameter, which will cause the test to fail if there is an issue with subscribing to the Observable.</p>
<p class="calibre3">Next we call a method on the <kbd class="calibre13">HttpTestingController</kbd> named <kbd class="calibre13">expectOne</kbd> passing our request URL. <span class="calibre6">According to the Angular documentation (<a href="https://angular.io/api/common/http/testing/HttpTestingController#expectone" target="_blank" class="calibre10">https://angular.io/api/common/http/testing/HttpTestingController#expectone</a>), this method does two things: it expects</span><em class="calibre17"> </em>that a request has been made that matches the URL provided in the method call and it returns a mock request. In the next line we make sure that the mock request is an HTTP GET. Finally, we flush the request with the <kbd class="calibre13">expectedWorkouts</kbd> and confirm that the <kbd class="calibre13">actualWorkouts</kbd> equal the <kbd class="calibre13">expectedWorkouts</kbd>. </p>
<p class="calibre3">We'll follow the same pattern to build additional tests that confirm that we are able to do the following:</p>
<ul class="calibre11">
<li class="calibre12">Return a <kbd class="calibre13">workout</kbd> plan with a specific name</li>
<li class="calibre12">Map <kbd class="calibre13">exercises</kbd> correctly within the <kbd class="calibre13">getWorkout</kbd> method</li>
</ul>
<p class="calibre3">You can review these tests in the code for <kbd class="calibre13">checkpoint 7.2</kbd>. But one thing to note is that in both these tests we are testing two HTTP calls. For example, here is the code in the second of these two tests:</p>
<pre class="calibre19">const req1 = httpTestingController.expectOne(workoutService.collectionsUrl + '/exercises' + params);<br class="title-page-name"/>expect(req1.request.method).toEqual('GET');<br class="title-page-name"/>req1.flush(allExercises);<br class="title-page-name"/><br class="title-page-name"/>const req2 = httpTestingController.expectOne(workoutService.collectionsUrl + '/workouts/Workout1' + params);<br class="title-page-name"/>expect(req2.request.method).toEqual('GET');<br class="title-page-name"/>req2.flush(expectedWorkout);</pre>
<p class="calibre3">This may seem a little confusing at first until we realize that with the <kbd class="calibre13">getWorkout</kbd> method we are actually making two <kbd class="calibre13">Http</kbd> calls: one to retrieve a  <kbd class="calibre13">workout</kbd> and one to retrieve all  <kbd class="calibre13">exercises</kbd>. As you recall from <a href="" class="calibre10">Chapter 5</a>, <em class="calibre17">Supporting Server Data Persistence</em>, we are doing that in order to create a fuller description of each <kbd class="calibre13">exercise</kbd> that is included within <kbd class="calibre13">workout</kbd>. </p>
<p class="calibre3">With that, we are finished with testing our service.</p>
<p class="calibre3">Next, we need to learn how to test directives. The next section is dedicated to understanding the challenges in directive testing and how to overcome them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unit-testing directives</h1>
                
            
            <article>
                
<p class="calibre3">No other Angular constructs that we have tested so far do not involve any UI interaction. But directives, as we know, are a different beast. Directives are all about enhancing a component's view and extending the behavior of HTML elements. While testing directives, we cannot ignore the UI connections, and hence directive testing may not strictly qualify as unit testing.</p>
<p class="calibre3">The good thing about directive testing is that its setup process is not as elaborate as that for services or components. The pattern to follow while unit-testing directives is as follows:</p>
<ol class="calibre14">
<li value="1" class="calibre12">Take an HTML fragment containing the directive markup</li>
<li value="2" class="calibre12">Compile and link it to a mock component</li>
<li value="3" class="calibre12">Verify that the generated HTML has the required attributes</li>
<li value="4" class="calibre12">Verify if the changes that the directive created changes the state</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The TestBed class</h1>
                
            
            <article>
                
<p class="calibre3">As mentioned previously, Angular provides the <kbd class="calibre13">TestBed</kbd> class to facilitate this kind of UI testing. We can use it to dig into the markup in a component's view and check for DOM changes that are triggered by events. Armed with this tool, let's get started with the testing of our directives. In this section, we are going to test <kbd class="calibre13">remoteValidator</kbd>.</p>
<div class="packt_infobox">
<p class="calibre20">This will be a good time to revisit the directives that we built in the previous chapter. Also, keep the code handy for the tests that we will create in the following sections.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing remote validator</h1>
                
            
            <article>
                
<p class="calibre3">Let's start with unit-testing <kbd class="calibre13">remoteValidatorDirective</kbd>. Just to refresh our memory, <kbd class="calibre13">remoteValidatorDirective</kbd> validates an input against remote rules. It does so by calling a component method that returns a promise. If the promise is resolved with success, the validation passes; otherwise, the validation fails. The <kbd class="calibre13">[validateFunction]</kbd> attribute provides the link between the DOM and the component's method that checks for the duplication.</p>
<p class="calibre3">Similar to our other test files, we have a <kbd class="calibre13">remote-validator.directive.spec.ts</kbd> file in the shared folder. Refer to the file in <kbd class="calibre13">checkpoint 7.2</kbd> for the imports, which we will not cover at this point.</p>
<p class="calibre3">Just below the import statements, add the following component definition:</p>
<pre class="calibre19">@Component({<br class="title-page-name"/>    template: `<br class="title-page-name"/>      &lt;form&gt;<br class="title-page-name"/>      &lt;input type="text" name="workoutName"<br class="title-page-name"/>      id="workout-name" [(ngModel)]="workoutName"<br class="title-page-name"/>      abeRemoteValidator="workoutname" [validateFunction]="validateWorkoutName"&gt;<br class="title-page-name"/>      &lt;/form&gt;<br class="title-page-name"/>    `<br class="title-page-name"/>}) 
export class TestComponent { 
    workoutName: string; 
 
    constructor() { 
        this.workoutName = '7MinWorkout'; 
    } 
    validateWorkoutName = (name: string): Promise&lt;boolean&gt; =&gt; { 
        return Promise.resolve(false); 
    } 
} </pre>
<p class="calibre3">This component looks a lot like the components that we set up in our other tests to mock dependencies. Here, however, it is serving a slightly different purpose; it is acting as a host container for the directive that we will be testing. Using this minimal component, lets us avoid having to load the actual host for this directive, which is the <kbd class="calibre13">Workout</kbd> component.</p>
<p class="calibre3">One thing to notice here is that we have set up a method for <kbd class="calibre13">validateWorkoutName</kbd> that will be called by our directive. It is essentially a stub that just returns a resolved <kbd class="calibre13">Promise</kbd> of <kbd class="calibre13">false</kbd>. Remember that we are not concerned with how this method handles its validation, but with verifying that the directive calls it and returns the correct result, either <kbd class="calibre13">true</kbd> or <kbd class="calibre13">false</kbd>.</p>
<p class="calibre3">Next, we set up the <kbd class="calibre13">describe</kbd> statement for our test suite by adding the following code, which injects  <kbd class="calibre13">RemoteValidatorDirective</kbd> into our tests:</p>
<pre class="calibre19">describe('RemoteValidator', () =&gt; { 
    let fixture: any; 
    let comp: any; 
    let debug: any; 
    let input: any; 
 
    beforeEach(async(() =&gt; { 
        TestBed.configureTestingModule({ 
            imports: [ FormsModule ], 
            declarations: [ TestComponent, RemoteValidatorDirective ] 
        }); 
        fixture = TestBed.createComponent(TestComponent); 
        comp = fixture.componentInstance; 
        debug = fixture.debugElement; 
        input = debug.query(By.css('[name=workoutName]')); 
    }));  </pre>
<p class="calibre3">As you can see, we are setting up local variables for  <kbd class="calibre13">fixture</kbd>, its <kbd class="calibre13">componentInstance</kbd>, and <kbd class="calibre13">debugElement</kbd>. We are also using <kbd class="calibre13">by.css</kbd> (which we will see more of in our end-to-end tests) along with the query method on  <kbd class="calibre13">debugElement</kbd> to extract the <kbd class="calibre13">workoutName</kbd> input from our component. We'll be using these to delve into the rendered HTML in our directive.</p>
<p class="calibre3">Now we are ready to write our individual tests. First, we'll write a test to confirm that we have been able to load  <kbd class="calibre13">RemoteValidatorDirective</kbd>. So add the following code:</p>
<pre class="calibre19">it("should load the directive without error", fakeAsync(() =&gt; {
    expect(input.attributes.a2beRemoteValidator).toBe('workoutname',  'remote validator directive should be loaded.')
}));</pre>
<p class="calibre3">What's interesting about this test is that using the <kbd class="calibre13">debugElement</kbd>, we have been able to drill-down into the attributes of the input tag in our host component and find our validator, confirming that it has indeed been loaded. Also notice the use of <kbd class="calibre13">fakeAsync</kbd>, which we discussed in connection with unit testing. Using it makes it possible for us to write our tests in a synchronous fashion and avoid the complications that would otherwise exist with trying to manage the asynchronous rendering of our host component. Next, we'll write two tests to confirm that our validator is working properly. The first test will make sure that an error is created if remote validation fails (that is, a workout with the same name as the one we are using is found). Add the following code for that test:</p>
<pre class="calibre19">    it('should create error if remote validation fails', fakeAsync(() =&gt; {<br class="title-page-name"/>        spyOn(comp, 'validateWorkoutName').and.callThrough();<br class="title-page-name"/>        fixture.detectChanges();<br class="title-page-name"/>        input.nativeElement.value = '6MinWorkout';<br class="title-page-name"/>        tick();<br class="title-page-name"/><br class="title-page-name"/>        const form: NgForm = debug.children[0].injector.get(NgForm);<br class="title-page-name"/>        const control = form.control.get('workoutName');<br class="title-page-name"/><br class="title-page-name"/>        expect(comp.validateWorkoutName).toHaveBeenCalled();<br class="title-page-name"/>        expect(control.hasError('workoutname')).toBe(true);<br class="title-page-name"/>        expect(control.valid).toBe(false);<br class="title-page-name"/>        expect(form.valid).toEqual(false);<br class="title-page-name"/>        expect(form.control.valid).toEqual(false);<br class="title-page-name"/>        expect(form.control.hasError('workoutname', ['workoutName'])).toEqual(true);<br class="title-page-name"/>    }));</pre>
<p class="calibre3">Again, we are using <kbd class="calibre13">fakeAsync</kbd> to eliminate the challenges that we would otherwise have with the async behavior associated with the rendering and execution of our <kbd class="calibre13">remoteValidatorDirective</kbd>. Next, we add a spy to track the invocation of the <kbd class="calibre13">validateWorkoutName</kbd> method. We also set the spy to call through to our method, because in this case, we are expecting it to return false. The spy is being used to verify that our method has indeed been invoked. Next, we set <kbd class="calibre13">fixture.detectChanges</kbd>, which triggers a change detection cycle. We then set the value of our input and call tick, which will, we hope, trigger the response we are expecting from our remote validator. We then grab the form encapsulating our input tag using the injector that is available from the child element array of the debug element. From there, we extract the form control for our input box. Then we run several expectations that confirm that an error has been added both to our control and to the form and that both are now in an invalid state. The next test is the mirror opposite of this test and it checks for a positive:</p>
<pre class="calibre19">    it('should not create error if remote validation succeeds', fakeAsync(() =&gt; {<br class="title-page-name"/>        spyOn(comp, 'validateWorkoutName').and.returnValue(Promise.resolve(true));<br class="title-page-name"/>        fixture.detectChanges();<br class="title-page-name"/>        input.nativeElement.value = '6MinWorkout';<br class="title-page-name"/>        tick();<br class="title-page-name"/><br class="title-page-name"/>        const form: NgForm = debug.children[0].injector.get(NgForm);<br class="title-page-name"/>        const control = form.control.get('workoutName');<br class="title-page-name"/><br class="title-page-name"/>        expect(comp.validateWorkoutName).toHaveBeenCalled();<br class="title-page-name"/>        expect(control.hasError('workoutname')).toBe(false);<br class="title-page-name"/>        expect(control.valid).toBe(true);<br class="title-page-name"/>        expect(form.control.valid).toEqual(true);<br class="title-page-name"/>        expect(form.valid).toEqual(true);<br class="title-page-name"/>        expect(form.control.hasError('workoutname', ['workoutName'])).toEqual(false);<br class="title-page-name"/>    }));</pre>
<p class="calibre3">Other than changing the expectations, the only change we are making from the previous test is setting up our spy to return a value of <kbd class="calibre13">true</kbd>. Unit-testing our <kbd class="calibre13">remoteValidatorDirective</kbd> shows how powerful the <kbd class="calibre13">TestBed</kbd> utilities are in testing our UI and the elements and behaviors associated with it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting started with E2E testing</h1>
                
            
            <article>
                
<p class="calibre3">Automated <strong class="calibre5">E2E</strong> testing is an invaluable asset if the underlying framework supports it. As the size of an app grows, automated E2E testing can save a lot of manual effort.</p>
<p class="calibre3">Without automation, it's just a never-ending battle to make sure that the app is functional. However, remember that in an E2E setup, not everything can be automated; automation may require a lot of effort. With due diligence, we can offload a sizable amount of manual effort, but not everything.</p>
<p class="calibre3">The process of E2E testing of a web-based application is about running the application in a real browser and asserting the behavior of the application based on the user interface state. This is how an actual user does testing.</p>
<p class="calibre3">Browser automation holds the key here, and modern browsers have become smarter and more capable in terms of supporting automation. Selenium tools for browser automation are the most popular option out there. Selenium has the WebDriver (<span class="calibre6"><a href="https://www.w3.org/TR/webdriver/" class="calibre10">https://www.w3.org/TR/webdriver/</a></span>) API that allows us to control the browser through the automation API that modern browsers natively support.</p>
<p class="calibre3">The reason behind bringing up Selenium WebDriver is that the Angular E2E testing framework/runner <strong class="calibre5">Protractor</strong> also uses <strong class="calibre5">WebDriverJS</strong>, which is a JavaScript binding of WebDriver on Node. These language bindings (like the preceding JavaScript binding) allow us to use the automation API in the language of our choice.</p>
<p class="calibre3">Let's discuss Protractor before we start writing some integration tests for our app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introducting Protractor</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Protractor</strong> is the de facto test runner for E2E testing in Angular. Protractor uses Selenium WebDriver to control a browser and simulate user actions.</p>
<p class="calibre3">A typical Protractor setup has the following components:</p>
<ul class="calibre11">
<li class="calibre12">A test runner (Protractor)</li>
<li class="calibre12">A Selenium server</li>
<li class="calibre12">A browser</li>
</ul>
<p class="calibre3">We write our test in Jasmine and use some objects exposed by Protractors (which is a wrapper over WebDriverJS) to control the browser.</p>
<p class="calibre3">When these tests run, Protractor sends commands to the Selenium server. This interaction happens mostly over HTTP.</p>
<p class="calibre3">The Selenium server, in turn, communicates with the browser using the <em class="calibre17">WebDriver Wire Protocol</em>, and internally the browser interprets the action commands using the browser driver (such as <em class="calibre17">ChromeDriver</em> in the case of Chrome).</p>
<p class="calibre3">It is not that important to understand the technicalities of this communication, but we should be aware of the E2E testing setup. Check out the article from the Protractor documentation at <span class="calibre6"><a href="http://angular.github.io/protractor/#/infrastructure" class="calibre10">http://angular.github.io/protractor/#/infrastructure</a></span> to learn more about this flow.</p>
<p class="calibre3">Another important thing to realize when using Protractor is that the overall interaction with the browser or the browser control flow is asynchronous in nature and promise-based. Any HTML element action, whether <kbd class="calibre13">sendKeys</kbd>, <kbd class="calibre13">getText</kbd>, <kbd class="calibre13">click</kbd>, <kbd class="calibre13">submit</kbd>, or any other, does not execute at the time of invocation; instead the action is queued up in a control flow queue. For this precise reason, the return value of every action statement is a promise that gets resolved when the action completes.</p>
<p class="calibre3">To handle this asynchronicity in Jasmine tests, Protractor patches Jasmine, and therefore assertions like these work:</p>
<pre class="calibre19">expect(element(by.id("start")).getText()).toBe("Select Workout"); </pre>
<p class="calibre3">They work despite the <kbd class="calibre13">getText</kbd> function returning a promise and not the element content.</p>
<p class="calibre3">With this basic understanding of how Protractor works, let's set up Protractor for end-to-end testing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up Protractor for E2E testing</h1>
                
            
            <article>
                
<p class="calibre3">The Angular CLI has already set up our project to allow us to use Protractor. The configurations for that setup can be found in the <kbd class="calibre13">protractor.config.js</kbd> file in the <kbd class="calibre13">trainer</kbd> folder. For the most part, you should be able to use those configurations without change to run your end-to-end tests. We did, however, make one change in that configuration file. We did extend the <kbd class="calibre13">defaultTimeoutInterval</kbd> in that file to <span class="calibre6">60000 milliseconds in order to give our tests that are running the workouts more time to finish:</span></p>
<pre class="calibre19">const { SpecReporter } = require('jasmine-spec-reporter');<br class="title-page-name"/><br class="title-page-name"/>exports.config = {<br class="title-page-name"/>    . . .<br class="title-page-name"/>  jasmineNodeOpts: {<br class="title-page-name"/>    showColors: true,<br class="title-page-name"/>    <strong class="calibre1">defaultTimeoutInterval: 60000</strong>,<br class="title-page-name"/>    print: function() {}<br class="title-page-name"/>  },<br class="title-page-name"/>    . . .<br class="title-page-name"/>};</pre>
<div class="packt_infobox">
<p class="calibre20">The configuration file documentation on the Protractor website (<span class="calibre22"><a href="https://github.com/angular/protractor/blob/master/lib/config.ts" class="calibre21">https://github.com/angular/protractor/blob/master/lib/config.ts</a></span>) contains details on other supported configurations.</p>
</div>
<p class="calibre3">That is enough to start testing with Protractor. In order to run our tests we simply execute the following command in the <kbd class="calibre13">trainer</kbd> folder:</p>
<pre class="calibre19"><strong class="calibre1">ng e2e</strong></pre>
<p class="calibre3">Now, let's get started with writing some end-to-end tests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Writing E2E tests for the app</h1>
                
            
            <article>
                
<p class="calibre3">Let's start in a simple manner and test our app start page (<kbd class="calibre13">#/start</kbd>). This page has some static content, a workout listing section with search capabilities, and the ability to start a workout by clicking on any workout file.</p>
<div class="packt_infobox">
<p class="calibre20">All our E2E tests will be added to the <kbd class="calibre24">e2e</kbd> folder under <kbd class="calibre24">trainer</kbd>.</p>
</div>
<p class="calibre3">Open the file called <kbd class="calibre13">app.e2e-spec.ts</kbd> to the <kbd class="calibre13">e2e</kbd> folder under <kbd class="calibre13">trainer</kbd>, which contains the following code:</p>
<pre class="calibre19">import { AppPage } from './app.po';<br class="title-page-name"/><br class="title-page-name"/>describe('Personal Trainer App', () =&gt; {<br class="title-page-name"/>  let page: AppPage;<br class="title-page-name"/><br class="title-page-name"/>  beforeEach(() =&gt; {<br class="title-page-name"/>    page = new AppPage();<br class="title-page-name"/>  });<br class="title-page-name"/><br class="title-page-name"/>  it('should display welcome message', () =&gt; {<br class="title-page-name"/>    page.navigateTo();<br class="title-page-name"/>    expect(page.getParagraphText()).toEqual('Ready for a Workout?');<br class="title-page-name"/>  });<br class="title-page-name"/>})</pre>
<p class="calibre3">Let's walk through this simple test.</p>
<p class="calibre3">The first interesting piece is the import at the top of the page—<kbd class="calibre13">import { AppPage } from './app.po';</kbd>. This is referring to a file in the same directory that contains what is called a page object.  This page object contains the following:</p>
<pre class="calibre19">import { browser, by, element } from 'protractor';<br class="title-page-name"/><br class="title-page-name"/>export class AppPage {<br class="title-page-name"/>  navigateTo() {<br class="title-page-name"/>    return browser.get('/');<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  getParagraphText() {<br class="title-page-name"/>    return element(by.css('abe-root h1')).getText();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre3">The use of the page object allows us to simplify the code in our test so that it is more readable. So instead of directly calling <kbd class="calibre13">browser.get ('/')</kbd> in our test, we call the <kbd class="calibre13">navigateTo()</kbd> method from our page object. </p>
<div class="packt_infobox">
<p class="calibre20">The browser object referred to in our page object is a global object exposed by Protractor and it is used to control the browser-level actions. Underneath, it is just a wrapper around WebDriver. The <kbd class="calibre24">browser.get("")</kbd> method navigates the browser to start the app page, every time, before the start of the test.</p>
</div>
<p class="calibre3"><span class="calibre6">The same for the </span><kbd class="calibre13">getParagraphText()</kbd><span class="calibre6"> method—it allows us to call that method in our test and look for some text on the screen without having to identify the exact location on the page where that will appear. We'll discuss page objects in more detail as we get into more complicated end-to-end testing. </span>The <span class="calibre6"><kbd class="calibre13">getParagraphText()</kbd></span> in our page object also employs two new globals, <kbd class="calibre13">element</kbd> and <kbd class="calibre13">by</kbd>, which are made available by Protractor:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">element</kbd>: This function returns an <kbd class="calibre13">ElementFinder</kbd> object. The primary job of <kbd class="calibre13">ElementFinder</kbd> is to interact with the selected element. We will be using the <kbd class="calibre13">element</kbd> function to select <kbd class="calibre13">ElementFinder</kbd> extensively in our tests.</li>
</ul>
<div class="packt_infobox">
<p class="calibre20">Refer to the documentation at <kbd class="calibre24"><span class="packt_screen">http://www.protractortest.org/#/locators</span><span class="packt_screen">#actions</span></kbd> to learn more about element manipulation API support. Functions such as <kbd class="calibre24">getText()</kbd> are actually defined on <kbd class="calibre24">WebElement</kbd>, but are always accessed using <kbd class="calibre24">ElementFinder</kbd>. As the documentation suggests, <kbd class="calibre24">ElementFinder</kbd> can be treated as <kbd class="calibre24">WebElement</kbd> for most purposes. For more information, you can refer to <span class="calibre22"><kbd class="calibre24">http://www.protractortest.org/#/locators#behind-the-scenes-elementfinders-versus-webelements</kbd>.</span></p>
</div>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">by</kbd>: This object is there to locate elements. It has functions that create <kbd class="calibre13">locators</kbd>. In the preceding test, a locator is created to search for elements with a css tag equal to <kbd class="calibre13">abe-root h1</kbd> If you are familiar with CSS selectors, you will know that this identifies what we are looking for as an <kbd class="calibre13">h1</kbd> tag inside the custom element <kbd class="calibre13">abe-root</kbd>. There are a number of locators that can be used to search for a specific element. These include by class, by ID, and by css. Refer to the Protractor documentation on locators at <a href="http://angular.github.io/protractor/#/locators" class="calibre10">http://angular.github.io/protractor/#/locators</a> to learn about the supported locators.</li>
</ul>
<div class="packt_infobox">
<p class="calibre20">Just to reiterate what we discussed earlier, <kbd class="calibre24">getText()</kbd> in the page object does not return the actual text, but a Promise; we can still assert on the text value.</p>
</div>
<p class="calibre3"><span class="calibre6">Getting back to the actual test, it uses the methods in the page object to verify that some content ("Ready for a Workout?") is present on the page.</span></p>
<p class="calibre3">This simple test highlights another salient feature of Protractor. It automatically detects when the Angular app is loaded and when data is available for testing. There are no ugly hacks to delay testing (using <kbd class="calibre13">timeouts</kbd>) that may otherwise be required in standard E2E testing scenarios.</p>
<p class="calibre3">Remember, this is an <em class="calibre17">SPA</em>; full-page browser refresh does not happen, so it is not that simple to determine when the page is loaded and when the data that is rendered for AJAX calls is available. Protractor makes it all possible.</p>
<div class="packt_infobox">
<p class="calibre20">Protractor may still time out while trying to assess whether the page is available for testing. If you are hitting timeout errors with Protractor, this article from the Protractor documentation can be really helpful (<span class="calibre22"><a href="http://www.protractortest.org/#/timeouts" class="calibre21">http://www.protractortest.org/#/timeouts</a></span>) for debugging such issues.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up backend data for E2E testing</h1>
                
            
            <article>
                
<p class="calibre3">Setting up backend data for E2E testing is a challenge, irrespective of the E2E framework that we employ for testing. The ultimate aim is to assert the behavior of an application against some data, and unless the data is fixed, we cannot verify the behavior that involves getting or setting data.</p>
<p class="calibre3">One approach to setting up data for E2E tests is to create a test data store specifically for E2E tests with some seed data. Once the E2E tests are over, the data store can be reset to its original state for future testing. For <em class="calibre17">Personal Trainer</em>, we can create a new database in MongoLab dedicated exclusively to E2E testing.</p>
<p class="calibre3">This may seem a lot of effort, but it is necessary. Who said E2E testing is easy! In fact, this challenge is there even if we do manual testing. For a real app, we always have to set up data stores/databases for every environment, whether <em class="calibre17">dev</em>, <em class="calibre17">test</em>, or <em class="calibre17">production</em>.</p>
<p class="calibre3">In this case, we will continue to use our existing backend, but go ahead and add another workout that we will use for testing. Name this workout <kbd class="calibre13">1minworkout</kbd> and give it a title of <kbd class="calibre13">1 Minute Workout</kbd>. Add two exercises to the workout: Jumping Jacks and Wall Sit. Set the duration of each exercise to 15 seconds and the rest time to one second.</p>
<div class="packt_infobox">
<p class="calibre20">We have deliberately kept our new workout short so that we can complete our end-to-end testing of this workout within the normal timeouts provided by Protractor.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">More E2E tests</h1>
                
            
            <article>
                
<p class="calibre3">Let's get back to testing the workout search features on the start page. With the addition of <em class="calibre17">1 Minute Workout</em>, we now have two workouts and we can assert search behaviors against these.</p>
<div class="packt_infobox">
<p class="calibre20">If you have added other workouts to the backend, just adjust the numbers in this test accordingly.</p>
</div>
<p class="calibre3">Add this test after the existing test in <kbd class="calibre13">workout-runner.spec.ts</kbd>:</p>
<pre class="calibre19">it('should search workout with specific name.', () =&gt; {<br class="title-page-name"/>    const filteredWorkouts = element.all(by.css('.workout.tile'));<br class="title-page-name"/>    expect(filteredWorkouts.count()).toEqual(5);<br class="title-page-name"/><br class="title-page-name"/>    const searchInput = element(by.css('.form-control'));<br class="title-page-name"/>    searchInput.sendKeys('1 Minute Workout');<br class="title-page-name"/><br class="title-page-name"/>    expect(filteredWorkouts.count()).toEqual(1);<br class="title-page-name"/>    expect(filteredWorkouts.first().element(by.css('.title')).getText()).toBe('1 Minute Workout');<br class="title-page-name"/>});</pre>
<p class="calibre3">The test uses <kbd class="calibre13">ElementFinder</kbd> and <kbd class="calibre13">Locator API</kbd> to look for elements on the page. Check the second line of the test. We are using the <kbd class="calibre13">element.all</kbd> function together with the <kbd class="calibre13">by.css</kbd> locator to do a multi-element match on all elements on the screen that are using the <kbd class="calibre13">.workout.tile</kbd> CSS class. This gives us a list of workouts against which the next line asserts the element count of 3.</p>
<p class="calibre3">The test then gets hold of the search input using the <kbd class="calibre13">element</kbd> function along with the <kbd class="calibre13">by.css</kbd> locator to do a single element match for an element using the <kbd class="calibre13">.form-contol</kbd> CSS class. We then use the <kbd class="calibre13">sendKeys</kbd> function to simulate data entry in the search input.</p>
<p class="calibre3">The last two expect operations check for the count of elements in our list, which after the search should be 1. Also, they check whether the correct workout is filtered based on a <kbd class="calibre13">div</kbd> tag using the <kbd class="calibre13">title</kbd> CSS class that is a child of the element that contains our workout. This last expect statement highlights how we can chain element filtering and get hold of child elements in HTML.</p>
<p class="calibre3">There is one more test associated with the start page that we should add. It tests the navigation from the start page to the workout runner screen. Add this code for that test:</p>
<pre class="calibre19">it('should navigate to workout runner.', () =&gt; {<br class="title-page-name"/>    const filteredWorkouts = element.all(by.css('.workout.tile'));<br class="title-page-name"/>    filteredWorkouts.first().click();<br class="title-page-name"/>    expect(browser.getCurrentUrl()).toContain('/workout/1minworkout');<br class="title-page-name"/>}) </pre>
<p class="calibre3">This test uses the <kbd class="calibre13">click</kbd>  function to simulate clicking on a workout tile, and then we use the <kbd class="calibre13">browser.getCurrentUrl</kbd> function to confirm that the navigation is correct.</p>
<p class="calibre3">Run the test again (<kbd class="calibre13">protractor tests/protractor.conf.js</kbd>) and once again observe the magic of browser automation as the tests run one after another.</p>
<p class="calibre3">Can we automate E2E testing for <em class="calibre17">Workout Runner</em>? Well, we can try.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing Workout Runner</h1>
                
            
            <article>
                
<p class="calibre3">One of the major challenges with testing Workout Runner is that everything is time-dependent. With unit testing, at least we were able to mock the interval, but not anymore. Testing exercise transitions and workout completion is definitely difficult.</p>
<p class="calibre3">However, before we tackle this problem or try to find an acceptable workaround, let's digress and learn about an important technique to manage E2E testing: page objects!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using page objects to manage E2E testing</h1>
                
            
            <article>
                
<p class="calibre3">We touched on page objects earlier. The concept of page objects is simple. We encapsulate the representation of page elements into an object so that we do not have to litter our E2E test code with <kbd class="calibre13">ElementFinder</kbd> and <kbd class="calibre13">locators</kbd>. If any page element moves, we just need to fix the page object.</p>
<p class="calibre3">Here is how we can represent our Workout Runner page:</p>
<pre class="calibre19">import { browser, by, element } from 'protractor';<br class="title-page-name"/><br class="title-page-name"/>export class WorkoutRunnerPage {<br class="title-page-name"/>  pauseResume: any;<br class="title-page-name"/>  playButton: any;<br class="title-page-name"/>  pauseButton: any;<br class="title-page-name"/>  exerciseTitle: any;<br class="title-page-name"/>  exerciseDescription: any;<br class="title-page-name"/>  exerciseTimeRemaining; any;<br class="title-page-name"/><br class="title-page-name"/>  constructor() {<br class="title-page-name"/>      this.pauseResume = element(by.id('pause-overlay'));<br class="title-page-name"/>      this.playButton = element.all(by.css('.ion-md-play'));<br class="title-page-name"/>      this.pauseButton = element.all(by.css('.ion-md-pause'));<br class="title-page-name"/>      this.exerciseTitle = element(by.id('exercise-pane')).element(by.tagName('h1')).getText();<br class="title-page-name"/>      this.exerciseDescription = element.all(by.className('card-text')).first().getText();<br class="title-page-name"/>      this.exerciseTimeRemaining = element(by.id('exercise-pane')).all(by.tagName('h4')).first().getText();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre3">This page object now encapsulates many of the elements that we want to test. By organizing the element selection code in one place, we increase the readability and hence the maintainability of E2E tests.</p>
<p class="calibre3">Now add the Workout Runner page object to the top of the test file. We'll use it in a test for the workout runner. Add the following new describe block containing the first of our workout runner tests:</p>
<pre class="calibre19">describe('Workout Runner page', () =&gt; {<br class="title-page-name"/>    beforeEach(() =&gt; {<br class="title-page-name"/>        browser.get('/workout/1minworkout');<br class="title-page-name"/>    });<br class="title-page-name"/><br class="title-page-name"/>    it('should load workout data', () =&gt; {<br class="title-page-name"/>        browser.waitForAngularEnabled(false);<br class="title-page-name"/>        const page = new WorkoutRunnerPage();<br class="title-page-name"/>        page.pauseResume.click();<br class="title-page-name"/>        expect(page.exerciseTitle).toBe('Jumping Jacks');<br class="title-page-name"/>        expect(page.exerciseDescription)<br class="title-page-name"/>          .toBe('A jumping jack or star jump, also called side-straddle hop is a physical jumping exercise.');<br class="title-page-name"/>    });</pre>
<p class="calibre3">The test verifies that the workout is loaded and the correct data is shown. We make full use of the page object that we defined earlier. Run the test and verify that it passes.</p>
<p class="calibre3">Let's get back to the challenge of testing code based on <kbd class="calibre13">interval</kbd> or <kbd class="calibre13">timeout</kbd>. Let's add a test that confirms a click event on the screen, when the pause button is pushed:</p>
<pre class="calibre19">it('should pause workout when paused button clicked', () =&gt; {<br class="title-page-name"/>    const page = new WorkoutRunnerPage();<br class="title-page-name"/>    let timeRemaining;<br class="title-page-name"/>    browser.waitForAngularEnabled(false);<br class="title-page-name"/><br class="title-page-name"/>    page.pauseResume.click();<br class="title-page-name"/>    expect(page.playButton.count()).toBe(1);<br class="title-page-name"/>    expect(page.pauseButton.count()).toBe(0);<br class="title-page-name"/><br class="title-page-name"/>    page.exerciseTimeRemaining.then((time) =&gt; {<br class="title-page-name"/>        timeRemaining = time;<br class="title-page-name"/>        browser.sleep(3000);<br class="title-page-name"/>    });<br class="title-page-name"/>    page.exerciseTimeRemaining.then((time) =&gt; {<br class="title-page-name"/>        expect(page.exerciseTimeRemaining).toBe(timeRemaining);<br class="title-page-name"/>    });<br class="title-page-name"/>});</pre>
<p class="calibre3">What is interesting here is that we use the <kbd class="calibre13">browser.sleep</kbd> function within a promise to verify that the exercise time remaining is the same before and after the button is clicked. We are again using our <kbd class="calibre13">WorkoutRunner</kbd> page object to make the test more readable and understandable.</p>
<p class="calibre3">It's now time to wrap up the chapter and summarize our learning.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">We do not need to reiterate how important unit- and E2E-testing are for any application. The way the Angular framework has been designed makes testing the Angular app easy. In this chapter, we covered how to write unit tests and E2E tests using libraries and frameworks that target Angular.</p>
<p class="calibre3">For unit testing, we used Jasmine to write our tests and Karma to execute them. We tested pipes, components, services, and directives from <em class="calibre17">Personal Trainer</em>. In the process, we learned about the challenges and the techniques used to effectively test these types.</p>
<p class="calibre3">For E2E testing, the framework of choice was Protractor. We still wrote out tests in Jasmine, but the test runner this time was Protractor. We learned how Protractor automates E2E testing using Selenium WebDriver, as we did some scenario testing for the <em class="calibre17">Start</em> and <em class="calibre17">Workout Runner</em> pages.</p>
<p class="calibre3">If you have reached this point, you are getting closer to becoming a proficient Angular developer. The next chapter reinforces this with more practical scenarios and implementations built using Angular. We will touch upon important concepts in the last chapter of this book; these include multilingual support, authentication and authorization, communication patterns, performance optimizations, and a few others. You certainly do not want to miss them!</p>


            </article>

            
        </section>
    </body></html>