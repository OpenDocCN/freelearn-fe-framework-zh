<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Time Will Tell"><div class="titlepage" id="aid-1JFUC2"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Time Will Tell</h1></div></div></div><p>Our task-management system is coming into shape. However, we were not concerned about one crucial aspect of managing our projects so far. Time plays a major role in all projects, and this is the thing that is often the most complicated to manage.</p><p>In this chapter, we will add a few features to our task management system that will help our users to manage time more efficiently. Reusing some components that we created earlier, we will be able to provide a consistent user experience to manage time.</p><p>On a higher level, we will develop the following features to enable time management in our application:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Task details</strong></span>: So far, we <a id="id370" class="indexterm"/>did not include a details page of tasks because all the necessary information about tasks could be displayed on the task list of our project page. While our time management will increase the complexity of our tasks quite a bit, we will create a new detail view of project tasks that will also be accessible through routing.</li><li class="listitem"><span class="strong"><strong>Efforts management</strong></span>: We will include some new data on our tasks to manage efforts on <a id="id371" class="indexterm"/>tasks. Efforts are always represented by an estimated duration of time and an effective duration of spent time. We will make both properties of efforts optional so that they can exist independently. We will create new components to enable users to provide time duration input easily.</li><li class="listitem"><span class="strong"><strong>Milestone management</strong></span>: We will include a way to manage project milestones and then map <a id="id372" class="indexterm"/>them to project tasks. This will help us later gain an overview over the project status, and it enables the user to group tasks into smaller chunks of work.</li></ul></div><p>The following topics will be covered in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creating a project task detail component to edit task details and enable a new route</li><li class="listitem">Modifying our tag management system to include task tags</li><li class="listitem">Creating new pipes to deal with formatting time durations</li><li class="listitem">Creating task information components to display task overview information on the existing task components</li><li class="listitem">Creating a time duration use input component that enables users to easily input time durations</li><li class="listitem">Creating an SVG component to display progress on tasks</li><li class="listitem">Creating an autocomplete component to manage milestones on tasks</li></ul></div><div class="section" title="Task details"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Task details</h1></div></div></div><p>So far, our task list <a id="id373" class="indexterm"/>was sufficient enough to display all details of tasks directly in the listing. However, as we will add more details to tasks in this chapter, it's time to provide a detail view where users can edit the task.</p><p>We already laid the groundwork on project navigation using the router in <a class="link" title="Chapter 5. Component-Based Routing" href="part0039.xhtml#aid-1565U1">Chapter 5</a>, <span class="emphasis"><em>Component-Based Routing</em></span>, of this book. Adding a new routable component that we'll use in the context of our projects will be a breeze.</p><p>Let's create a new component class for our project task detail view in the <code class="literal">project/project-task-details/project-task-details.js</code> path:</p><div class="informalexample"><pre class="programlisting">…
@Component({
  selector: 'ngc-project-task-details',
  …
})
export class ProjectTaskDetails {
  …
}</pre></div><p>As this component will never exist without a parent <code class="literal">Project</code> component, we can safely rely on that to obtain the data we use. This component isn't used in pure UI composition cases, so it's not required to create a routable wrapper component like we did for other components in <a class="link" title="Chapter 5. Component-Based Routing" href="part0039.xhtml#aid-1565U1">Chapter 5</a>, <span class="emphasis"><em>Component-Based Routing</em></span>. We can directly rely on route parameters and obtain the relevant data from the parent <code class="literal">Project</code> component.</p><p>First, we use dependency injection in order to get a reference to the parent project component:</p><div class="informalexample"><pre class="programlisting">constructor(<span class="strong"><strong>@Inject(forwardRef(() =&gt; Project)) project) </strong></span>{
<span class="strong"><strong>  this.project = project; </strong></span>
}</pre></div><p>Similarly to our routing wrapper components, we make use of parent component injection to obtain a reference to the parent <code class="literal">Project</code> component.</p><p>Now, we'll use the <code class="literal">OnActivate</code> lifecycle hook of the router again to obtain the task number from the active route segment:</p><div class="informalexample"><pre class="programlisting">  routerOnActivate(currentRouteSegment) {
    const taskNr = currentRouteSegment.getParam('nr');
    this.projectChangeSubscription = this.project.document.change.subscribe((data) =&gt; {
      this.task = data.tasks.find((task) =&gt; task.nr === +taskNr);
      this.projectMilestones = data.milestones || [];
    });
  }</pre></div><p>Finally, we'll create a reactive subscription to the <code class="literal">LiveDocument</code> projects that will extract the task that we are concerned about and store it into the components <code class="literal">task</code> member. In this way, we ensure that our component will always receive the latest task data when the project is updated outside of the current task details view.</p><p>If our component gets <a id="id374" class="indexterm"/>destroyed, we need to make sure that we unsubscribe from the RxJS <code class="literal">Observable</code> that is provided by the <code class="literal">LiveDocument</code> project. Let's implement the <code class="literal">ngOnDestroy</code> lifecycle hook for this purpose:</p><div class="informalexample"><pre class="programlisting">ngOnDestroy() {
<span class="strong"><strong>  this.projectChangeSubscription.unsubscribe();</strong></span>
}</pre></div><p>Alright, let's now take a look at the template of our component, and see how we'll deal with the task data to provide an interface to edit the details. We'll create a <code class="literal">project-task-details.html</code> file in our new <code class="literal">component</code> folder:</p><div class="informalexample"><pre class="programlisting">&lt;h3 class="task-details__title"&gt;
  Task Details of task #<span class="strong"><strong>{{task?.nr}}</strong></span>
&lt;/h3&gt;
&lt;div class="task-details__content"&gt;
  &lt;div class="task-details__label"&gt;Title&lt;/div&gt;
  <span class="strong"><strong>&lt;ngc-editor [content]="task?.title"</strong></span>
<span class="strong"><strong>              [showControls]="true"</strong></span>
<span class="strong"><strong>              (editSaved)="onTitleSaved($event)"&gt;&lt;/ngc-editor&gt;</strong></span>
  &lt;div class="task-details__label"&gt;Description&lt;/div&gt;
  <span class="strong"><strong>&lt;ngc-editor [content]="task?.description"</strong></span>
<span class="strong"><strong>              [showControls]="true"</strong></span>
<span class="strong"><strong>              [enableTags]="true"</strong></span>
<span class="strong"><strong>              (editSaved)="onDescriptionSaved($event)"&gt;</strong></span>
  &lt;/ngc-editor&gt;
&lt;/div&gt;</pre></div><p>Reusing the <code class="literal">Editor</code> component that we created in <a class="link" title="Chapter 4. No Comments, Please!" href="part0036.xhtml#aid-12AK82">Chapter 4</a>, <span class="emphasis"><em>No Comments, Please!</em></span>, of this book, we can rely on simple UI composition to make the title and description of our tasks editable.</p><p>As we stored the task data into the <code class="literal">task</code> member variable on our component, we can reference the <code class="literal">title</code> and <code class="literal">description</code> fields to create a binding to the <code class="literal">content</code> input property of our editor components.</p><p>While the <code class="literal">title</code> should <a id="id375" class="indexterm"/>only consist of plaintext, we can support the tagging functionality that we created in <a class="link" title="Chapter 7. Components for User Experience" href="part0049.xhtml#aid-1ENBI2">Chapter 7</a>, <span class="emphasis"><em>Components for User Experience</em></span>, on the <code class="literal">description</code> field of the task. For this, we simply set the <code class="literal">enableTags</code> input property of the description <code class="literal">Editor</code> component to <code class="literal">true</code>.</p><p>The <code class="literal">Editor</code> component has an <code class="literal">editSaved</code> output property that will emit the updated content once a user saves his edits. Now, all we need to make sure of is that we create a binding to our component that will persist these changes. Let's create the <code class="literal">onTitleSaved</code> and <code class="literal">onDescriptionSaved</code> methods on our <code class="literal">Component</code> class to handle these events:</p><div class="informalexample"><pre class="programlisting">onTitleSaved(title) {
<span class="strong"><strong>  this.task.title = title;</strong></span>
<span class="strong"><strong>  this.project.document.persist();</strong></span>
}

onDescriptionSaved(description) {
<span class="strong"><strong>  this.task.description = description;</strong></span>
<span class="strong"><strong>  this.project.document.persist();</strong></span>
}</pre></div><p>The task member is just a reference to the given task in the <code class="literal">LiveDocument</code> project of the <code class="literal">Project</code> component. This simplifies the way we persist the data that was changed on the task. After updating the given property on the task, we simply call the <code class="literal">persist</code> method on the <code class="literal">LiveDocument</code> projects to store our changes in the data store.</p><p>So far, so good. We created a task details component that makes it easy to edit the title and description of tasks using our <code class="literal">Editor</code> UI component. The only thing left to enable our component is to create a child route on the <code class="literal">Project</code> component. Let's open our <code class="literal">Project</code> component class in <code class="literal">lib/project/project.js</code> to make the necessary modifications:</p><div class="informalexample"><pre class="programlisting">…
<span class="strong"><strong>import {ProjectTaskDetails} from './project-task-details/project-task-details';</strong></span>

…
@Component({
  selector: 'ngc-project',
  …
})
@Routes([
<span class="strong"><strong>  new Route({ path: 'task/:nr', component: ProjectTaskDetails}),</strong></span>
  …
])
export class Project {
  …
}</pre></div><p>We added a new child route on our <code class="literal">Project</code> component, which is responsible for the instantiation of our <code class="literal">ProjectTaskDetails</code> component. By including a <code class="literal">:nr</code> parameter in the route configuration, we can pass the concerned task number into the <code class="literal">ProjectTaskDetails</code> component.</p><p>Our newly-created child route is now accessible in the router and we can access the task detail view using the <code class="literal">/projects/project-1/task/1</code> example URL.</p><p>In order to make our <code class="literal">TaskDetails</code> route navigable, we need to add a navigation link to our <code class="literal">Task</code> component so that <a id="id376" class="indexterm"/>users can navigate to it in the projects task list.</p><p>For this rather simple task, the only thing that we need to do is use the <code class="literal">RouterLink</code> directive and create a new link in the <code class="literal">Task</code> template, <code class="literal">lib/task-list/task/task.html</code>:</p><div class="informalexample"><pre class="programlisting">…
&lt;div class="task__l-box-b"&gt;
  …
<span class="strong"><strong>  &lt;a [routerLink]="['../task', task?.nr]"</strong></span>
<span class="strong"><strong>          class="button button--small"&gt;Details&lt;/a&gt;</strong></span>
&lt;/div&gt;
…</pre></div><p>We use a relative router URL here because we're already on the <code class="literal">/project/tasks</code> route. As our <code class="literal">task/:nr</code> route is part of the project router, we need to navigate one level back to access the <code class="literal">task</code> route:</p><div class="mediaobject"><img src="../Images/image00333.jpeg" alt="Task details"/><div class="caption"><p>Newly created task detail view with editable title and description</p></div></div><p style="clear:both; height: 1em;"> </p></div></div>
<div class="section" title="Enabling tags for tasks" id="aid-1KEEU1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec49"/>Enabling tags for tasks</h1></div></div></div><p>So far, the tag-management <a id="id377" class="indexterm"/>system that we created in <a class="link" title="Chapter 7. Components for User Experience" href="part0049.xhtml#aid-1ENBI2">Chapter 7</a>, <span class="emphasis"><em>Components for User Experience</em></span>, only supports project tags. As we now created a detail <a id="id378" class="indexterm"/>view to tasks, it would be nice to also support task tags directly in our tagging system. Our tagging system is quite flexible, and we can implement new tags with very little effort. On a higher level, we need to make the following changes to enable task tags in our system:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Edit the <code class="literal">generate-tag.js</code> module in order to support the generation of task tags from task and project data</li><li class="listitem">Edit the <code class="literal">TagsService</code> in order to initialize task tags using the <code class="literal">generate-tag.js</code> module and cache</li></ul></div><p>Let's first modify the <code class="literal">lib/tags/generate-tag.js</code> file to enable task tag generation:</p><div class="informalexample"><pre class="programlisting">…
<span class="strong"><strong>export const TAG_TYPE_TASK = 'task';</strong></span>

export function generateTag(subject) {
  if (subject.type === TAG_TYPE_PROJECT) {
    …
  } else if (<span class="strong"><strong>subject.type === TAG_TYPE_TASK</strong></span>) {
    // If we're dealing with a task, we generate the according tag 
    // object
    <span class="strong"><strong>return new Tag(</strong></span>
<span class="strong"><strong>      `#${subject.project._id}-task-${subject.task.nr}`,</strong></span>
<span class="strong"><strong>      `${limitWithEllipsis(subject.task.title, 20)} (${subject.task.done ? 'done' : 'open'})`,</strong></span>
<span class="strong"><strong>     `#/projects/${subject.project._id}/task/${subject.task.nr}`,</strong></span>
<span class="strong"><strong>      TAG_TYPE_TASK</strong></span>
<span class="strong"><strong>    );</strong></span>
  }
}</pre></div><p>As we need to have a reference to project data as well as to the individual task of this project, we expect the <code class="literal">subject</code> parameter to look like the following object:</p><div class="informalexample"><pre class="programlisting">{task: …, project: …, type: TAG_TYPE_TASK}</pre></div><p>From this <code class="literal">subject</code> object, we can then create a new <code class="literal">Tag</code> object. For the <code class="literal">textTag</code> field, we use a construct that includes the project ID as well as the task number. Like this, we can uniquely identify the task using a simple text representation.</p><p>For the <code class="literal">link</code> field, we construct a URL from the project as well as the task number. This string will resolve to a URL required to activate the <code class="literal">TaskDetails</code> route, which we configured in the previous section.</p><p>Our <code class="literal">generateTag</code> <a id="id379" class="indexterm"/>function is now ready to create task tags. Now, the only thing <a id="id380" class="indexterm"/>left to enable task tags in our system is the modification required in the <code class="literal">TagsService</code> class. Let's open the <code class="literal">lib/tags/tags-service.js</code> file and apply our changes:</p><div class="informalexample"><pre class="programlisting">…
import {generateTag<span class="strong"><strong>, TAG_TYPE_TASK</strong></span>} from './generate-tag';
…
@Injectable()
export class TagsService {
  …
  // This method is used internally to initialize all available 
  // tags
  initializeTags() {
    …
    // Let's also create task tags
    <span class="strong"><strong>this.projects.forEach((project) =&gt; {</strong></span>
<span class="strong"><strong>      this.tags = this.tags.concat(project.tasks.map((task) =&gt; {</strong></span>
<span class="strong"><strong>        return {</strong></span>
<span class="strong"><strong>          type: TAG_TYPE_TASK,</strong></span>
<span class="strong"><strong>          project,</strong></span>
<span class="strong"><strong>          task</strong></span>
<span class="strong"><strong>        };</strong></span>
<span class="strong"><strong>      }).map(generateTag));</strong></span>
<span class="strong"><strong>    });</strong></span>
    …
  }
  …
}</pre></div><p>In the <code class="literal">initializeTags</code> method of our <code class="literal">TagsService</code> class, we now add task <code class="literal">Tag</code> objects for all available tasks in projects. First, we map each project task to the required <code class="literal">subject</code> object by the <code class="literal">generateTag</code> function. Then, we can simply map the resulting array using the <code class="literal">generateTag</code> function directly. The result is an array of generated task <code class="literal">Tag</code> objects that we then concatenate into the <code class="literal">tags</code> list of the <code class="literal">TagsService</code> class.</p><p>This wasn't too complicated, right? This relatively simple change results in a huge improvement for our users. They can now reference individual tasks everywhere in our system where we enabled tags:</p><div class="mediaobject"><img src="../Images/image00334.jpeg" alt="Enabling tags for tasks"/><div class="caption"><p>The Editor component displaying newly-added task tags</p></div></div><p style="clear:both; height: 1em;"> </p></div>
<div class="section" title="Managing efforts"><div class="titlepage" id="aid-1LCVG2"><div><div><h1 class="title"><a id="ch08lvl1sec50"/>Managing efforts</h1></div></div></div><p>In this section, we will <a id="id381" class="indexterm"/>create some components that help us keep track of efforts. Primarily, we will use this to manage efforts on tasks, but this could be applied to any part of our application where we need to keep track of time.</p><p>Efforts in our context always consist of two components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Estimated duration</strong></span>: This <a id="id382" class="indexterm"/>is the duration that is initially estimated for the task</li><li class="listitem"><span class="strong"><strong>Effective duration</strong></span>: This is the <a id="id383" class="indexterm"/>duration of time that is spent on a given task</li></ul></div><p>For time durations, we assume some time units and rules that will simplify the processing of time and align to some working standards. The goal here is not to provide a razor sharp time management but something that is accurate enough to bring value. For this purpose, we define the following working time units:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Minute</strong></span>: One minute is a regular 60 seconds</li><li class="listitem"><span class="strong"><strong>Hour</strong></span>: One hour always represents 60 minutes</li><li class="listitem"><span class="strong"><strong>Day</strong></span>: One day represents a regular workday of eight hours</li><li class="listitem"><span class="strong"><strong>Week</strong></span>: One week is equivalent to five working days (5 * 8 hours)</li></ul></div><div class="section" title="The time duration input"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec61"/>The time duration input</h2></div></div></div><p>We can now start to <a id="id384" class="indexterm"/>write a complex user interface component, where <a id="id385" class="indexterm"/>users can enter individual time units in different input element. However, I believe it's much more convenient to treat time duration input with a no-UI approach. Therefore, instead of building a complex user interface, we can simply agree on a textual short form to write durations, and let the user write something, such as <code class="literal">1.5d</code> or <code class="literal">5h 30m</code>, in order to provide input. Sticking to the convention that we previously established, we can build a simple parser that can handle this sort of input.</p><p>This approach has several advantages. Besides that, this is one of the most effective ways to enter time durations, and it's also easy for us to implement. We can simply reuse our <code class="literal">Editor</code> component to gather text input from the user. Then, we use a conversion process to parse the entered time duration.</p><p>Let's spin up a new module <a id="id386" class="indexterm"/>that helps us deal with these conversions. We <a id="id387" class="indexterm"/>create a new module in the <code class="literal">lib/utilities/time-utilities.js</code> file.</p><p>First, we need to have a constant that defines all the units we need for the conversion process:</p><div class="informalexample"><pre class="programlisting">export const UNITS = [{
  short: 'w',
  milliseconds: 5 * 8 * 60 * 60 * 1000
}, {
  short: 'd',
  milliseconds: 8 * 60 * 60 * 1000
}, {
  short: 'h',
  milliseconds: 60 * 60 * 1000
}, {
  short: 'm',
  milliseconds: 60 * 1000
}];</pre></div><p>This is all the units that we need to deal with for now. You can see the milliseconds being calculated at interpretation time. We can also write the milliseconds as constants, but this provides us with some transparency on how we get to these values and we can spear on some comments.</p><p>Let's look at our parsing function, which we can use to parse text input into time durations:</p><div class="informalexample"><pre class="programlisting">export function parseDuration(formattedDuration) {
  const pattern = /[\d\.]+\s*[wdhm]/g;
  let timeSpan = 0;
  let result;
  while (result = pattern.exec(formattedDuration)) {
    const chunk = result[0].replace(/\s/g, '');
    let amount = Number(chunk.slice(0, -1));
    let unitShortName = chunk.slice(-1);
    timeSpan += amount * UNITS.find(
      (unit) =&gt; unit.short === unitShortName
    ).milliseconds;
  }
  return +timeSpan || null;
}</pre></div><p>Let's analyze the preceding code briefly to explain what we do here:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we define a <a id="id388" class="indexterm"/>regular expression that helps us dissect the text representation of a duration. This pattern will extract chunks from the text <a id="id389" class="indexterm"/>input that are important to calculate the duration behind the text representation. These chunks always consist of a number, followed by either <code class="literal">w</code>, <code class="literal">d</code>, <code class="literal">h</code>, or <code class="literal">m</code>. Therefore, the text <code class="literal">10w 3d 2h 30m</code> will be split into the chunks <code class="literal">10w</code>, <code class="literal">3d</code>, <code class="literal">2h</code>, and <code class="literal">30m</code>.</li><li class="listitem">We initialize a <code class="literal">timeSpan</code> variable with <code class="literal">0</code>, so we can add all the milliseconds from discovered chunks together and later return this sum.</li><li class="listitem">For each of the previously-extracted chunks, we now extract the number component into a variable called <code class="literal">amount</code>, and the unit (<code class="literal">w</code>, <code class="literal">d</code>, <code class="literal">h</code>, or <code class="literal">m</code>) into a variable called <code class="literal">unitShortName</code>.</li><li class="listitem">Now, we can look up the data in the <code class="literal">UNITS</code> constant for the unit of the chunk that we will process, multiply the amount of milliseconds of the unit by the amount we extract from the chunk, and then add that result to our <code class="literal">timeSpan</code> variable.</li></ol><div style="height:10px; width: 1px"/></div><p>Well this is quite a neat function we built here. It accepts a formatted time duration string and converts it into milliseconds. This is already half of what we need to deal with textual representation of time durations. The second piece is the opposite of what we have with the <code class="literal">parseDuration</code> function to convert a duration in milliseconds into a formatted duration string:</p><div class="informalexample"><pre class="programlisting">export function formatDuration(timeSpan) {
  return UNITS.reduce((str, unit) =&gt; {
    const amount = timeSpan / unit.milliseconds;
    if (amount &gt;= 1) {
      const fullUnits = Math.floor(amount);
      const formatted = `${str} ${fullUnits}${unit.short}`;
      timeSpan -= fullUnits * unit.milliseconds;
      return formatted;
    } else {
      return str;
    }
  }, '').trim();
}</pre></div><p>Let's also explain briefly what the <code class="literal">formatDuration</code> function does:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">We use the <code class="literal">Array.prototype.reduce</code> function to format a string that contains all time units and their amount. We iterate over all available time units in the <code class="literal">UNITS</code> constant starting with the largest unit for weeks.</li><li class="listitem">We then divide the <code class="literal">timeSpan</code> variable, which is in milliseconds, by the milliseconds of the <a id="id390" class="indexterm"/>unit which gives us the amount of the given unit.</li><li class="listitem">If the amount is greater than or equal to 1, we can add the unit with the given amount and unit short name to our formatted string.</li><li class="listitem">As we could be left <a id="id391" class="indexterm"/>with some fractions after the comma in the amount, which we will need to encode in smaller units, we subtract the floored version of our amount from the <code class="literal">timeSpan</code> before we return to the <code class="literal">reduce</code> function again.</li><li class="listitem">This process is repeated for every unit, where each unit will only provide formatted output if the amount is greater than or equal to 1.</li></ul></div><p>This is all we need to convert back and forth between formatted time duration and time duration represented in milliseconds.</p><p>We'll do one more thing before we create the actual component to enter time durations. We will create a simple pipe that basically just wraps our <code class="literal">formatTime</code> function. For this, we will create a new <code class="literal">lib/pipes/format-duration.js</code> file:</p><div class="informalexample"><pre class="programlisting">import {Pipe, Inject} from '@angular/core';
<span class="strong"><strong>import {formatDuration} from '../utilities/time-utilities';</strong></span>

@Pipe({
  name: 'formatDuration'
})
export class FormatDurationPipe {
  transform(value) {
    if (value == null || typeof value !== 'number') {
      return value;
    }

<span class="strong"><strong>    return formatDuration(value);</strong></span>
  }
}</pre></div><p>Using the <code class="literal">formatTime</code> function of our <code class="literal">time-utilities</code> module, we now have the ability to format durations in millisecond directly from in our templates.</p></div><div class="section" title="Components to manage efforts"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec62"/>Components to manage efforts</h2></div></div></div><p>Okay, this is enough <a id="id392" class="indexterm"/>time math for the moment. Let's now use the elements that we created to shape some components that will help us gather user input.</p><p>In this section, we will create two components to manage efforts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">Duration</code>: The <code class="literal">Duration</code> <a id="id393" class="indexterm"/>component is a simple UI component, enabling user input of time durations using the formatted time strings we dealt with in the previous topics. It uses an <code class="literal">Editor</code> component to enable user input and makes use of the <code class="literal">FormatTimePipe</code> pipe as well as the <code class="literal">parseDuration</code> utility function.</li><li class="listitem"><code class="literal">Efforts</code>: The <a id="id394" class="indexterm"/><code class="literal">Efforts</code> component is just a composition of two <code class="literal">Duration</code> components that represent the estimated effort and the effective effort spent on a given task. Following a strict rule of composition, this component is important for us so that we don't repeat ourselves and instead compose a larger component.</li></ul></div><p>Let's start with the <code class="literal">Duration</code> component class, and create a new <code class="literal">lib/ui/duration/duration.js</code> file:</p><div class="informalexample"><pre class="programlisting">…
<span class="strong"><strong>import {FormatDurationPipe} from '../../pipes/format-duration';</strong></span>
<span class="strong"><strong>import {Editor} from '../../ui/editor/editor';</strong></span>
<span class="strong"><strong>import {parseDuration} from '../../utilities/time-utilities';</strong></span>

@Component({
  selector: 'ngc-duration',
  …
  <span class="strong"><strong>directives: [Editor],</strong></span>
<span class="strong"><strong>  pipes: [FormatDurationPipe]</strong></span>
})
export class Duration {
  <span class="strong"><strong>@Input() duration;</strong></span>
<span class="strong"><strong>  @Output() durationChange = new EventEmitter();</strong></span>

<span class="strong"><strong>  onEditSaved(formattedDuration) {</strong></span>
<span class="strong"><strong>    this.durationChange.next(formattedDuration ? </strong></span>
<span class="strong"><strong>      parseDuration(formattedDuration) : null);</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>There's nothing fancy about this component really because we created the bulk of the logic already and we simply compose a higher component together.</p><p>As the <code class="literal">duration</code> input, we expect a time duration in milliseconds, while the <code class="literal">durationChange</code> output property will emit events when the user provides some input.</p><p>The <code class="literal">onEditSaved</code> method serves in the binding to the <code class="literal">Editor</code> component in our component. Whenever the user saves his edits on the <code class="literal">Editor</code> component, we'll take this input, convert the formatted time duration into milliseconds using the <code class="literal">parseDuration</code> function, and re-emit the converted value using the <code class="literal">durationChange</code> output property.</p><p>Let's look at the template <a id="id395" class="indexterm"/>of our component in the <code class="literal">lib/ui/duration/duration.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;ngc-editor <span class="strong"><strong>[content]="duration | formatDuration"</strong></span>
            [showControls]="true"
            (<span class="strong"><strong>editSaved)="onEditSaved($event)"</strong></span>&gt;&lt;/ngc-editor&gt;</pre></div><p>Surprised with how simple our template is? Well, this is exactly what we should achieve with higher components once we establish a good foundation of base components. Well-organized composition radically simplifies our code. The only thing that we deal with here is our good old <code class="literal">Editor</code> component.</p><p>We bind the <code class="literal">duration</code> input property of our <code class="literal">Duration</code> component to the content input property of the <code class="literal">Editor</code> component. As we'd like to pass the formatted time duration and not the duration in milliseconds, we use the <code class="literal">FormatDurationPipe</code> pipe to convert in the binding expression.</p><p>If the <code class="literal">Editor</code> component notifies us about a saved edit, we call the <code class="literal">onEditSaved</code> method on our <code class="literal">Duration</code> component, which will parse the entered duration and re-emit the resulting value.</p><p>As we initially defined all efforts to consist of an estimated and an effective duration, we would now like to create another component that combines these two durations.</p><p>Let's create a new <code class="literal">Efforts</code> component by starting with a new template on the <code class="literal">lib/efforts/efforts.html</code> path:</p><div class="informalexample"><pre class="programlisting">&lt;div class="efforts__label"&gt;Estimated:&lt;/div&gt;
&lt;ngc-duration <span class="strong"><strong>[duration]="estimated"</strong></span>
<span class="strong"><strong>              (durationChange)="onEstimatedChange($event)"</strong></span>&gt;
&lt;/ngc-duration&gt;
&lt;div class="efforts__label"&gt;Effective:&lt;/div&gt;
&lt;ngc-duration <span class="strong"><strong>[duration]="effective"</strong></span>
<span class="strong"><strong>              (durationChange)="onEffectiveChange($event)"</strong></span>&gt;
&lt;/ngc-duration&gt;
&lt;button class="button button--small" 
        <span class="strong"><strong>(click)="addEffectiveHours(1)"</strong></span>&gt;+1h&lt;/button&gt;
&lt;button class="button button--small" 
        <span class="strong"><strong>(click)="addEffectiveHours(4)"</strong></span>&gt;+4h&lt;/button&gt;
&lt;button class="button button--small" 
        <span class="strong"><strong>(click)="addEffectiveHours(8)"</strong></span>&gt;+1d&lt;/button&gt;</pre></div><p>First, we add two <code class="literal">Duration</code> components labelled, where the first one is used to gather input for the estimated time and the later one for effective time.</p><p>In addition to this, we provide three small buttons to increase the effective duration by a simple click. In this way, the user can quickly add one or four hours (half a working day) or a complete working day (which we defined as eight hours).</p><p>Looking at the <code class="literal">Component</code> <a id="id396" class="indexterm"/>class, there should be no surprises. Let's open the <code class="literal">lib/efforts/efforts.js</code> component class file:</p><div class="informalexample"><pre class="programlisting">…
<span class="strong"><strong>import {Duration} from '../ui/duration/duration'; </strong></span>
<span class="strong"><strong>import {UNITS} from '../utilities/time-utilities';</strong></span>

@Component({
  selector: 'ngc-efforts',
  …
<span class="strong"><strong>  directives: [Duration]</strong></span>
})
export class Efforts {
  <span class="strong"><strong>@Input() estimated;</strong></span>
<span class="strong"><strong>  @Input() effective;</strong></span>
<span class="strong"><strong>  @Output() effortsChange = new EventEmitter();</strong></span>

  onEstimatedChange(estimated) {
    <span class="strong"><strong>this.effortsChange.next({</strong></span>
<span class="strong"><strong>      estimated,</strong></span>
<span class="strong"><strong>      effective: this.effective</strong></span>
<span class="strong"><strong>    });</strong></span>
  }

  onEffectiveChange(effective) {
    <span class="strong"><strong>this.effortsChange.next({</strong></span>
<span class="strong"><strong>      effective,</strong></span>
<span class="strong"><strong>      estimated: this.estimated</strong></span>
<span class="strong"><strong>    });</strong></span>
  }

<span class="strong"><strong>  addEffectiveHours(hours) {</strong></span>
<span class="strong"><strong>    this.effortsChange.next({</strong></span>
<span class="strong"><strong>      effective: (this.effective || 0) + </strong></span>
<span class="strong"><strong>        hours * UNITS.find((unit) =&gt; unit.short === 'h'),</strong></span>
<span class="strong"><strong>      estimated: this.estimated</strong></span>
<span class="strong"><strong>    });</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>The component provides two separate inputs for estimated and effective time duration in milliseconds. If you take a look at the component template again, these input properties are directly bound to the input properties of the <code class="literal">Duration</code> components.</p><p>The <code class="literal">onEstimatedChange</code> and <code class="literal">onEffectiveChange</code> methods are used to create bindings to the <code class="literal">durationChange</code> output properties of the <code class="literal">Duration</code> components. All we do here is emit an aggregated data object that contains the effective and estimated time in milliseconds using the <code class="literal">effortsChange</code> output property.</p><p>In the <code class="literal">addEffectiveHours</code> method, we simply emit an <code class="literal">effortsChange</code> event and update the effective property by the calculated amount of milliseconds. We use our <code class="literal">UNITS</code> constant from the <code class="literal">time-utilities</code> module in order to get the amount of milliseconds for an hour.</p><p>This is all that we need in <a id="id397" class="indexterm"/>order to provide a user input to manage efforts on our tasks. To complete this topic, we will add our newly-created <code class="literal">Efforts</code> component to the <code class="literal">ProjectTaskDetail</code> component in order to manage efforts on tasks.</p><p>Let's first look at the code changes in the <code class="literal">Component</code> class located in <code class="literal">lib/project/project-task-detail/project-task-detail.js</code>:</p><div class="informalexample"><pre class="programlisting">…
<span class="strong"><strong>import {Efforts} from '../../efforts/efforts';</strong></span>

@Component({
  selector: 'ngc-project-task-details',
  …
  directives: [Editor<span class="strong"><strong>, Efforts</strong></span>]
})
export class ProjectTaskDetails {
  …
<span class="strong"><strong>  onEffortsChange(efforts) {</strong></span>
<span class="strong"><strong>    if (!efforts.estimated &amp;&amp; !efforts.effective) {</strong></span>
<span class="strong"><strong>      this.task.efforts = null;</strong></span>
<span class="strong"><strong>    } else {</strong></span>
<span class="strong"><strong>      this.task.efforts = efforts;</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>    this.project.document.persist();</strong></span>
<span class="strong"><strong>  }</strong></span>
  …
}</pre></div><p>Besides providing the <code class="literal">Efforts</code> component to the <code class="literal">directives</code> list of our <code class="literal">ProjectTaskDetail</code> component, we added a new <code class="literal">onEffortsChange</code> method that deals with the output provided by the <code class="literal">Efforts</code> component.</p><p>If both estimated and effective effort isn't set, or set to <code class="literal">0</code>, we'll set the task efforts to <code class="literal">null</code>. Otherwise, we use the output data of the <code class="literal">Efforts</code> component and assign it as our new task efforts.</p><p>After changing the task efforts, we persist the <code class="literal">LiveDocument</code> of the project in the same way that we do for the title and the description updates already.</p><p>Let's check out the <a id="id398" class="indexterm"/>changes in the template of our component located in <code class="literal">lib/project/project-task-detail/project-task-detail.html</code>:</p><div class="informalexample"><pre class="programlisting">…
&lt;div class="task-details__content"&gt;
  …
  &lt;div class="task-details__label"&gt;Efforts&lt;/div&gt;
<span class="strong"><strong>  &lt;ngc-efforts [estimated]="task?.efforts?.estimated"</strong></span>
<span class="strong"><strong>               [effective]="task?.efforts?.effective"</strong></span>
<span class="strong"><strong>               (effortsChange)="onEffortsChange($event)"&gt;</strong></span>
<span class="strong"><strong>  &lt;/ngc-efforts&gt;</strong></span>
&lt;/div&gt;</pre></div><p>We are binding the estimated and effective input properties of the <code class="literal">Efforts</code> component to the task data in the <code class="literal">ProjectTaskDetail</code> component. For the <code class="literal">effortsChange</code> output property we're using an expression that is invoking our <code class="literal">onEffortsChange</code> method that we've just created:</p><div class="mediaobject"><img src="../Images/image00335.jpeg" alt="Components to manage efforts"/><div class="caption"><p>Our new Efforts component that consists of two duration input components</p></div></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="The visual efforts timeline"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec63"/>The visual efforts timeline</h2></div></div></div><p>Although the <a id="id399" class="indexterm"/>components that we created so far to manage efforts provide a <a id="id400" class="indexterm"/>good way to edit and display effort and time durations, we can still improve this with some visual indication.</p><p>In this section, we will create a visual efforts timeline using SVG. This timeline should display the following information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The total estimated duration as a gray background bar</li><li class="listitem">The total effective duration as a green bar that overlays on the total estimated duration bar</li><li class="listitem">A yellow bar that shows any overtime (if the effective duration is greater than the estimated duration)</li></ul></div><p>The following two figures <a id="id401" class="indexterm"/>illustrate the different visual states of our efforts <a id="id402" class="indexterm"/>timeline component:</p><div class="mediaobject"><img src="../Images/image00336.jpeg" alt="The visual efforts timeline"/><div class="caption"><p>The visual state if the estimated duration is greater than the effective duration</p></div></div><p style="clear:both; height: 1em;"> </p><div class="mediaobject"><img src="../Images/image00337.jpeg" alt="The visual efforts timeline"/><div class="caption"><p>The visual state if the effective duration exceeds the estimated duration (the overtime is displayed as a black bar)</p></div></div><p style="clear:both; height: 1em;"> </p><p>Let's start fleshing out our component by creating a new <code class="literal">EffortsTimeline</code> Component class on the <code class="literal">lib/efforts/efforts-timeline/efforts-timeline.js</code> path:</p><div class="informalexample"><pre class="programlisting">…
@Component({
  selector: 'ngc-efforts-timeline',
  …
})
export class EffortsTimeline {
<span class="strong"><strong>  @Input() estimated;</strong></span>
<span class="strong"><strong>  @Input() effective;</strong></span>
<span class="strong"><strong>  @Input() height;</strong></span>

  ngOnChanges(changes) {
<span class="strong"><strong>    this.done = 0;</strong></span>
<span class="strong"><strong>    this.overtime = 0;</strong></span>

    if (!this.estimated &amp;&amp; this.effective || 
        (this.estimated &amp;&amp; this.estimated === this.effective)) {
      // If there's only effective time or if the estimated time 
      // is equal to the effective time we are 100% done
<span class="strong"><strong>      this.done = 100;</strong></span>
    } else if (this.estimated &lt; this.effective) {
      // If we have more effective time than estimated we need to 
      // calculate overtime and done in percentage
<span class="strong"><strong>      this.done = this.estimated / this.effective * 100;</strong></span>
<span class="strong"><strong>      this.overtime = 100 - this.done;</strong></span>
    } else {
      // The regular case where we have less effective time than 
      // estimated
<span class="strong"><strong>      this.done = this.effective / this.estimated * 100;</strong></span>
    }  
  }
}</pre></div><p>Our component <a id="id403" class="indexterm"/>has three input properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">estimated</code>: This is the estimated time duration in milliseconds</li><li class="listitem"><code class="literal">effective</code>: This is the <a id="id404" class="indexterm"/>effective time duration in milliseconds</li><li class="listitem"><code class="literal">height</code>: This is the desired height of the efforts timeline in pixels</li></ul></div><p>In the <code class="literal">OnChanges</code> lifecycle hook, we set two component member fields, which are based on the estimated and effective time:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">done</code>: This contains the width of the green bar in percentage that displays the effective duration without overtime that exceeds the estimated duration</li><li class="listitem"><code class="literal">overtime</code>: This contains the width of the yellow bar in percentage that displays any overtime, which is any time duration that exceeds the estimated duration</li></ul></div><p>Let's look at the template of the <code class="literal">EffortsTimeline</code> component and see how we can now use the <code class="literal">done</code> and <code class="literal">overtime</code> member fields to draw our timeline.</p><p>We will create a new <code class="literal">lib/efforts/efforts-timeline/efforts-timeline.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;svg width="100%" <span class="strong"><strong>[attr.height]="height"</strong></span>&gt;
  &lt;rect <span class="strong"><strong>[attr.height]="height"</strong></span>
        x="0" y="0" width="100%"
        class="efforts-timeline__remaining"&gt;&lt;/rect&gt;
  &lt;rect <span class="strong"><strong>*ngIf="done"</strong></span> x="0" y="0" 
        <span class="strong"><strong>[attr.width]="done + '%'" [attr.height]="height"</strong></span>
        class="efforts-timeline__done"&gt;&lt;/rect&gt;
  &lt;rect <span class="strong"><strong>*ngIf="overtime"</strong></span> <span class="strong"><strong>[attr.x]="done + '%'" y="0"</strong></span>
<span class="strong"><strong>        [attr.width]="overtime + '%'" [attr.height]="height"</strong></span>
        class="efforts-timeline__overtime"&gt;&lt;/rect&gt;
&lt;/svg&gt;</pre></div><p>Our template is SVG-based, and it contains three rectangles for each of the bars that we want to display. The background bar that will be visible if there is remaining effort will always be displayed.</p><p>Above the remaining bar, we conditionally display the done and the overtime bar using the calculated widths from our component class.</p><p>Now, we can go ahead <a id="id405" class="indexterm"/>and include the <code class="literal">EffortsTimeline</code> class in <a id="id406" class="indexterm"/>our <code class="literal">Efforts</code> component. This way our users will have visual feedback when they edit the estimated or effective duration, and it provides them a sense of overview.</p><p>Let's look into the template of the <code class="literal">Efforts</code> component to see how we integrate the timeline:</p><div class="informalexample"><pre class="programlisting">…
&lt;ngc-efforts-timeline <span class="strong"><strong>height="10"</strong></span>
<span class="strong"><strong>                      [estimated]="estimated"</strong></span>
<span class="strong"><strong>                      [effective]="effective"&gt;</strong></span>
&lt;/ngc-efforts-timeline&gt;</pre></div><p>As we have the estimated and effective duration times readily available in our <code class="literal">Efforts</code> component, we can simply create a binding to the <code class="literal">EffortsTimeline</code> component input properties:</p><div class="mediaobject"><img src="../Images/image00338.jpeg" alt="The visual efforts timeline"/><div class="caption"><p>The Efforts component displaying our newly-created efforts timeline component (the overtime of six hours is visualized with the yellow bar)</p></div></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Recapitulating on efforts management"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec64"/>Recapitulating on efforts management</h2></div></div></div><p>In this section, we'll <a id="id407" class="indexterm"/>create components that allow users to manage efforts easily and add a simple but powerful time tracking to our tasks. We've done the following to achieve this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">We implemented some utility functions to deal with the time math in order to convert time durations in milliseconds into formatted time durations and vice versa</li><li class="listitem">We created a pipe to format time durations in milliseconds using our utility functions</li><li class="listitem">We created a <code class="literal">Duration</code> UI component, which wraps an <code class="literal">Editor</code> component and uses our time utilities to provide a no-UI kind of input element to enter durations</li><li class="listitem">We created an <code class="literal">Efforts</code> component that acts as a composition of two <code class="literal">Duration</code> components for estimated and effective time and provides additional buttons to add effective spent time quickly</li><li class="listitem">We integrated the <code class="literal">Efforts</code> component into the <code class="literal">ProjectTaskDetail</code> component in order to manage efforts on tasks</li><li class="listitem">We created a visual <code class="literal">EffortsTimeline</code> component using SVG, which displays the overall progress on a task</li></ul></div></div></div>
<div class="section" title="Setting milestones"><div class="titlepage" id="aid-1MBG22"><div><div><h1 class="title"><a id="ch08lvl1sec51"/>Setting milestones</h1></div></div></div><p>Tracking time is important. I don't know how you feel about time, but I really suck at organizing my time. Although <a id="id408" class="indexterm"/>a lot of people ask me how I manage to do so many things, I believe I'm actually very bad at managing how I get these things done. If I were a better organizer, I could get things done with much less energy involved.</p><p>One thing that always helps me organize myself is to break things down into smaller work packages. Users that organize themselves with our task management application can already do this by creating tasks in projects. While a project is the overall goal, we can create smaller tasks to achieve this goal. However, sometimes we tend to lose sight of the overall goal when we're only focused on tasks.</p><p>Milestones are a perfect glue between projects and tasks. They make sure that we bundle tasks together into larger packages. This will help us a lot in organizing our tasks, and we can look at milestones of the project to see the overall project health. However, we can still focus on tasks when we work in the context of a milestone.</p><p>In this section, we will create the necessary components in order to add basic milestone functionality to our application.</p><p>To implement milestone functionality in our application, we will stick to the following design decisions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Milestones should be stored on the project level, and tasks can contain an optional reference to a project milestone.</li><li class="listitem">To keep things simple, the only interaction point with milestones should be on task level. Therefore, creation of milestones will be done on task level, although the created milestones will be stored on project level.</li><li class="listitem">Milestones currently only consist of a name. There are a lot more to milestones that we can potentially build into our system, such as deadlines, dependencies, and other nice things. However, we will stick to the bare minimum, which is a milestone name.</li></ul></div><div class="section" title="Creating an autocomplete component"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec65"/>Creating an autocomplete component</h2></div></div></div><p>In order to keep the <a id="id409" class="indexterm"/>management of milestones simple, we <a id="id410" class="indexterm"/>will create a new user interface component to deal with the design concerns that we listed. Our new autocomplete component will not only display possible values to select from, but it will also allow us to create new items. We can then simply use this component on our <code class="literal">ProjectTaskDetail</code> component in order to manage milestones.</p><p>Let's look at the <code class="literal">Component</code> class of our new autocomplete component that we will create in the <code class="literal">lib/ui/auto-complete/auto-complete.js</code> file:</p><div class="informalexample"><pre class="programlisting">…
<span class="strong"><strong>import {Editor} from '../editor/editor';</strong></span>

@Component({
  selector: 'ngc-auto-complete',
  …
<span class="strong"><strong>  directives: [Editor]</strong></span>
})
export class AutoComplete {
<span class="strong"><strong>  @Input() items;</strong></span>
<span class="strong"><strong>  @Input() selectedItem;</strong></span>
<span class="strong"><strong>  @Output() selectedItemChange = new EventEmitter();</strong></span>
<span class="strong"><strong>  @Output() itemCreated = new EventEmitter();</strong></span>
  …
}</pre></div><p>Once again, our <code class="literal">Editor</code> <a id="id411" class="indexterm"/>component can be reused <a id="id412" class="indexterm"/>to create this higher component. We're lucky that we created such a nice component, as this saved us a lot of time throughout this project.</p><p>Let's look at the input and output properties of the <code class="literal">AutoComplete</code> component in more detail:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">items</code>: This is where we expect an array of strings. This will be the list of items a user can choose from when typing into the editor.</li><li class="listitem"><code class="literal">selectedItem</code>: This is when we make the selected item an input property to actually make this component pure, and we can rely on the parent component to set this property right.</li><li class="listitem"><code class="literal">selectedItemChange</code>: This output property will emit an event if the selected item was changed. As we create a pure component here, we somehow need to propagate the event of an item that was selected in the autocomplete list.</li><li class="listitem"><code class="literal">itemCreated</code>: This output property will emit an event if a new item was added to the autocomplete list. Updating the list of items and changing the component <code class="literal">items</code> input property will still be the responsibility of the parent component.</li></ul></div><p>Let's add more code to our component. We use an <code class="literal">Editor</code> component as main input source. While our users will type into the editor, we filter the available items using the text input of the editor. Let's create a <code class="literal">filterItems</code> for this purpose:</p><div class="informalexample"><pre class="programlisting">filterItems(filter) {
<span class="strong"><strong>  this.filter = filter || '';</strong></span>
<span class="strong"><strong>  this.filteredItems = this.items</strong></span>
<span class="strong"><strong>    .filter(</strong></span>
<span class="strong"><strong>      (item) =&gt; item</strong></span>
<span class="strong"><strong>        .toLowerCase()</strong></span>
<span class="strong"><strong>        .indexOf(this.filter.toLowerCase().trim()) !== -1)</strong></span>
<span class="strong"><strong>    .slice(0, 10);</strong></span>
  <span class="strong"><strong>this.exactMatch = this.items.includes(this.filter);</strong></span>
}</pre></div><p>The <code class="literal">filterItems</code> <a id="id413" class="indexterm"/>method has a single parameter, which is <a id="id414" class="indexterm"/>the text that we want to use in order to search for relevant items in our list.</p><p>Let's look at the content of the method in more detail:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">For later use in our template, we will set aside the filter query that was used the last time this method was called</li><li class="listitem">In the <code class="literal">filteredItems</code> member variable, we will store a filtered version of the item list by searching for text occurrences of the filter string</li><li class="listitem">As a last step, we also store the information if the search query resulted in an exact match of an item in our list</li></ul></div><p>Now, we need to make sure that if the <code class="literal">items</code> or <code class="literal">selectedItem</code> input properties change, we also execute our filter method again. For this, we simply implement the <code class="literal">ngOnChanges</code> lifecycle hook:</p><div class="informalexample"><pre class="programlisting">ngOnChanges(changes) {
  if (<span class="strong"><strong>this.items &amp;&amp; this.selectedItem</strong></span>) {
<span class="strong"><strong>    this.filterItems(this.selectedItem);</strong></span>
  }
}</pre></div><p>Let's now see how we deal with the events provided by the <code class="literal">Editor</code> component:</p><div class="informalexample"><pre class="programlisting">onEditModeChange(editMode) {
  if (editMode) {
    <span class="strong"><strong>this.showCallout = true;</strong></span>
<span class="strong"><strong>    this.previousSelectedItem = this.selectedItem;</strong></span>
  } else {
<span class="strong"><strong>    this.showCallout = false;</strong></span>
  }
}</pre></div><p>If the editor changes to edit mode, we want to save the previously selected item. We'll need this if the user decides to cancel his edits and switch back to the previous item. Of course, this is also the point where we need to display the autocomplete list to the user.</p><p>On the other hand, if the edit mode is switched back to read mode, we want to hide the autocomplete list again:</p><div class="informalexample"><pre class="programlisting">onEditableInput(content) {
<span class="strong"><strong>  this.filterItems(content);</strong></span>
}</pre></div><p>The <code class="literal">editableInput</code> <a id="id415" class="indexterm"/>event is triggered by our editor on <a id="id416" class="indexterm"/>every editor input change. The event provides us with the text content that was entered by the user. If such an event occurs, we need to execute our filter function again with the updated filter query:</p><div class="informalexample"><pre class="programlisting">onEditSaved(content) {
  if (content === '') {
<span class="strong"><strong>    this.selectedItemChange.next(null);</strong></span>
  } else if (content !== this.selectedItem &amp;&amp; 
             !this.items.includes(content)) {
<span class="strong"><strong>    this.itemCreated.next(content);</strong></span>
  }
}</pre></div><p>When the <code class="literal">editSaved</code> event is triggered by our editor, we need to decide whether we should do either of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Emit an event using the <code class="literal">selectedItemChange</code> output property if the saved content is an empty string to signal the removal of a selected item to the parent component</li><li class="listitem">Emit an event using the <code class="literal">itemCreated</code> output property if valid content is given and our list does not include an item with that name to signal an item creation:<div class="informalexample"><pre class="programlisting">onEditCanceled() {
<span class="strong"><strong>  this.selectedItemChange.next(this.previousSelectedItem);</strong></span>
}</pre></div></li></ul></div><p>On the <code class="literal">editCanceled</code> event of the <code class="literal">Editor</code> component, we want to switch back to the previous selected item. For this, we can simply emit an event using the <code class="literal">selectedItemChange</code> output property and the <code class="literal">previousSelectedItem</code> member that we put aside after the editor was switched into edit mode.</p><p>These are all the binding functions that we will use to wire up our editor and in order to attach the autocomplete functionality to it.</p><p>There are two more rather simple methods that we will create before we take a look at the template of our autocomplete component:</p><div class="informalexample"><pre class="programlisting">selectItem(item) {
<span class="strong"><strong>  this.selectedItemChange.next(item);</strong></span>
}

createItem(item) {
<span class="strong"><strong>  this.itemCreated.next(item);</strong></span>
}</pre></div><p>We will use these two for the click actions in the autocomplete callout from our template. Let's take a look at the template so that you can see all the code that we just created in action:</p><div class="informalexample"><pre class="programlisting">&lt;ngc-editor <span class="strong"><strong>[content]="selectedItem"</strong></span>
            [showControls]="true"
            <span class="strong"><strong>(editModeChange)="onEditModeChange($event)"</strong></span>
<span class="strong"><strong>            (editableInput)="onEditableInput($event)"</strong></span>
<span class="strong"><strong>            (editSaved)="onEditSaved($event)"</strong></span>
<span class="strong"><strong>            (editCanceled)="onEditCanceled($event)"&gt;&lt;/</strong></span>ngc-editor&gt;</pre></div><p>First, the <code class="literal">Editor</code> <a id="id417" class="indexterm"/>component is placed and all necessary <a id="id418" class="indexterm"/>bindings to the handler methods that we created in our <code class="literal">Component</code> class are attached.</p><p>Now, we will create the autocomplete list that will be displayed as a callout to the user right next to the editor input area:</p><div class="informalexample"><pre class="programlisting">&lt;ul <span class="strong"><strong>*ngIf="showCallout"</strong></span> class="auto-complete__callout"&gt;
  &lt;li <span class="strong"><strong>*ngFor="let item of filteredItems"</strong></span>
      <span class="strong"><strong>(click)="selectItem(item)"</strong></span>
      class="auto-complete__item"
      [class.auto-complete__item--selected]="item === selectedItem"&gt;<span class="strong"><strong>{{item}}</strong></span>&lt;/li&gt;
  &lt;li <span class="strong"><strong>*ngIf="filter &amp;&amp; !exactMatch"</strong></span>
      <span class="strong"><strong>(click)="createItem(filter)"</strong></span>
      class="auto-complete__item auto-complete__item--create"&gt;Create "{{filter}}"&lt;/li&gt;
&lt;/ul&gt;</pre></div><p>We rely on the <code class="literal">showCallout</code> member set by the <code class="literal">onEditModeChange</code> method of our <code class="literal">Component</code> class to signal if we should display the autocomplete list or not.</p><p>We then iterate over all filtered items using the <code class="literal">NgFor</code> directive and render the text content of each item. If one of the items gets clicked on, we will call our <code class="literal">selectItem</code> method with the concerned item as the parameter value.</p><p>As the last list element, after the repeated list items, we conditionally display an additional list element in order to create a nonexisting milestone. We only display this button if there's a valid filter already and if there's no exact match of the filter to an existing milestone:</p><div class="mediaobject"><img src="../Images/image00339.jpeg" alt="Creating an autocomplete component"/><div class="caption"><p>Our milestone component plays nicely together with the editor component using a clean composition</p></div></div><p style="clear:both; height: 1em;"> </p><p>Now that we are all done <a id="id419" class="indexterm"/>with our autocomplete component, the <a id="id420" class="indexterm"/>only thing left to do in order to manage project milestones is to make use of it in the <code class="literal">ProjectTaskDetails</code> component.</p><p>Let's open the <code class="literal">Component</code> class located in <code class="literal">lib/project/project-task-details/project-task-details.js</code> and apply the necessary modifications:</p><div class="informalexample"><pre class="programlisting">…
<span class="strong"><strong>import {AutoComplete} from '../../ui/auto-complete/auto-complete';</strong></span>

@Component({
  selector: 'ngc-project-task-details',
  …
  directives: […, <span class="strong"><strong>AutoComplete</strong></span>]
})
export class ProjectTaskDetails {
  constructor(@Inject(forwardRef(() =&gt; Project)) project, {
    …
    this.projectChangeSubscription = this.project.document.change.subscribe((data) =&gt; {
      …
<span class="strong"><strong>      this.projectMilestones = data.milestones || [];</strong></span>
    });
  }
  …
<span class="strong"><strong>  onMilestoneSelected(milestone) {</strong></span>
<span class="strong"><strong>    this.task.milestone = milestone;</strong></span>
<span class="strong"><strong>    this.project.document.persist();</strong></span>
<span class="strong"><strong>  }</strong></span>

<span class="strong"><strong>  onMilestoneCreated(milestone) {</strong></span>
<span class="strong"><strong>    this.project.document.data.milestones = this.project.document.data.milestones || [];</strong></span>
<span class="strong"><strong>    this.project.document.data.milestones.push(milestone);</strong></span>
<span class="strong"><strong>    this.task.milestone = milestone;</strong></span>
<span class="strong"><strong>    this.project.document.persist();</strong></span>
<span class="strong"><strong>  }</strong></span>
  …
}</pre></div><p>In the subscription <a id="id421" class="indexterm"/>to project changes, we now also extract <a id="id422" class="indexterm"/>any preexisting project milestones and store them in a <code class="literal">projectMilestones</code> member variable. This makes it easier to reference in the template.</p><p>The <code class="literal">onMilestoneSelected</code> method will be bound to the <code class="literal">selectItemChange</code> output property of the <code class="literal">AutoComplete</code> component. We use the emitted value of the <code class="literal">AutoComplete</code> component to set our tasks milestone and persist the <code class="literal">LiveDocument</code> project using its <code class="literal">persist</code> method.</p><p>The <code class="literal">onMilestoneCreated</code> method will be bound to the <code class="literal">itemCreated</code> output property of the <code class="literal">AutoComplete</code> component. On such an event, we add the created milestone to the projects milestone list as well as assign the current task to the created milestone. After updating the <code class="literal">LiveDocument</code> data, we use the <code class="literal">persist</code> method to save all changes.</p><p>Let's look into <code class="literal">lib/project/project-task-details/project-task-details.html</code> to see the necessary changes in our template:</p><div class="informalexample"><pre class="programlisting">…
&lt;div class="task-details__content"&gt;
  …
  &lt;ngc-auto-complete <span class="strong"><strong>[items]="projectMilestones"</strong></span>
<span class="strong"><strong>                     [selectedItem]="task?.milestone"</strong></span>
<span class="strong"><strong>               (selectedItemChange)="onMilestoneSelected($event)"</strong></span>
<span class="strong"><strong>               (itemCreated)="onMilestoneCreated($event)"</strong></span>&gt;
  &lt;/ngc-auto-complete&gt;
&lt;/div&gt;</pre></div><p>Besides the output property bindings that you're already aware of, we also create two input bindings for the <code class="literal">items</code> and <code class="literal">selectedItem</code> input properties of the <code class="literal">AutoComplete</code> component.</p><p>This is already it. We created a new UI component that provides autocompletion and used that component to implement milestone management on our tasks.</p><p>Isn't it nice how easy it suddenly seems to implement new functionality when using components with proper encapsulation? The great thing about component-oriented development is that your <a id="id423" class="indexterm"/>development time for new functionality decreased with the amount of reusable components that you already created.</p></div></div>
<div class="section" title="Summary" id="aid-1NA0K1"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec52"/>Summary</h1></div></div></div><p>In this chapter, we implemented some components that help our users keep track of time. They can now log efforts on tasks and manage milestones on projects. We created a new task detail view that can be accessed using a navigation link on our task list.</p><p>Once more, we experienced the power of composition using components, and reusing existing components, we were able to easily implement higher components that provide more complex functionality.</p><p>In the next chapter, we will look at how to use the charting library Chartist and create some wrapper components that allow us to build reusable charts. We will build a dashboard for our task management system, where we will see our chart components in action.</p></div></body></html>