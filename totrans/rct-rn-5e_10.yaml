- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: User Interface Framework Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面框架组件
- en: When you are developing a React application, it’s typical to rely on an existing
    **UI library** rather than building one from scratch. There are lots of React
    UI component libraries available to choose from, and there’s no wrong choice,
    as long as the components make your life simpler.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开发React应用程序时，通常依赖于现有的**UI库**而不是从头开始构建。有许多React UI组件库可供选择，只要组件使你的生活变得更简单，就没有错误的选择。
- en: 'In this chapter, we delve into the **Material UI** React library, a popular
    choice for React development. Material UI stands out due to its comprehensive
    suite of customizable components, adherence to Google’s Material Design principles,
    and extensive documentation, making it an optimal choice for developers seeking
    efficiency and aesthetic coherence in their UI design. Here are the specific topics
    that we’ll cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究Material UI React库，这是React开发的流行选择。Material UI因其全面的定制组件套件、遵循Google的Material
    Design原则以及广泛的文档而脱颖而出，使其成为寻求UI设计效率和美学一致性的开发者的最佳选择。以下是我们将涵盖的具体主题：
- en: Layout and UI organization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局和UI组织
- en: Using **navigation components**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**导航组件**
- en: Collecting user input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集用户输入
- en: Working with **styles** and **themes**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与**样式**和**主题**一起工作
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter09](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter09).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章中存在的代码文件，地址为[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter09](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter09)。
- en: You can also find more information about Material UI components and its API
    at [https://mui.com/material-ui/](https://mui.com/material-ui/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://mui.com/material-ui/](https://mui.com/material-ui/)找到更多关于Material
    UI组件及其API的信息。
- en: Layout and organization
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局和组织
- en: '**Material UI** excels in simplifying the complex process of designing application
    layouts. By offering a robust set of components, specifically **containers** and
    **grids**, it empowers developers to efficiently structure and organize UI elements.
    **Containers** serve as the foundation, providing a flexible way to encapsulate
    and align content within the overall layout. **Grids**, on the other hand, allow
    more granular control, enabling precise placement and alignment of components
    across different screen sizes, ensuring responsiveness and consistency.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**Material UI**在简化应用程序布局的复杂过程中表现出色。通过提供强大的组件集，特别是**容器**和**网格**，它使开发者能够高效地构建和组织UI元素。**容器**作为基础，提供了一种灵活的方式来封装和定位整体布局中的内容。另一方面，**网格**允许更精细的控制，能够精确地放置和对齐不同屏幕尺寸下的组件，确保响应性和一致性。'
- en: This section aims to unpack the functionality of containers and grids within
    Material UI. We’ll explore how these tools can be leveraged to create intuitive
    and aesthetically pleasing layouts, which are crucial for enhancing user experience.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本节旨在解开Material UI中容器和网格的功能。我们将探讨如何利用这些工具创建直观且美观的布局，这对于提升用户体验至关重要。
- en: Using containers
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用容器
- en: 'Aligning components horizontally on a page often presents a significant challenge
    due to the intricate balance required between spacing, alignment, and responsiveness.
    This complexity arises from the need to maintain a visually appealing and functional
    layout across various screen sizes, ensuring that elements are evenly distributed
    and maintain their intended appearance without unintended overlaps or gaps. The
    `Container` component from Material UI is a simple but powerful layout tool. It
    controls the horizontal width of its children. Let’s look at an example to see
    what’s possible:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面上水平对齐组件通常是一个重大挑战，因为这需要在间距、对齐和响应性之间保持复杂的平衡。这种复杂性源于需要在各种屏幕尺寸上保持视觉吸引力和功能性布局的需求，确保元素均匀分布，并保持其预期的外观，避免意外的重叠或间隙。Material
    UI的`Container`组件是一个简单但功能强大的布局工具。它控制其子元素的横向宽度。让我们看看一个例子，看看可能实现什么：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This example has three `Container` components, each of which wraps a `Typography`
    component. The `Typography` component is used to render text in Material UI applications.
    Each `Container` component used in this example takes a `maxWidth` property. It
    accepts a breakpoint string value. These breakpoints represent common screen sizes.
    This example uses small (`sm`), medium (`md`), and large (`lg`). When the screen
    reaches these breakpoint sizes, the container width will stop growing. Here’s
    what the page looks like when the width is smaller than the `sm` breakpoint:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有三个`Container`组件，每个组件都包裹一个`Typography`组件。`Typography`组件用于在Material UI应用程序中渲染文本。在这个例子中使用的每个`Container`组件都包含一个`maxWidth`属性。它接受一个断点字符串值。这些断点代表常见的屏幕尺寸。这个例子使用了小(`sm`)、中(`md`)和大型(`lg`)。当屏幕达到这些断点大小时，容器宽度将停止增长。以下是当宽度小于`sm`断点时页面看起来像什么：
- en: '![](img/B19636_09_01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_09_01.png)'
- en: 'Figure 9.1: The sm breakpoint'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：sm断点
- en: 'Now, if we were to resize the screen so that it was larger than the `md` breakpoint,
    but smaller than the `lg` breakpoint, here is what it would look like:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们调整屏幕大小，使其大于`md`断点，但小于`lg`断点，它看起来会是这样：
- en: '![](img/B19636_09_02.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_09_02.png)'
- en: 'Figure 9.2: The lg breakpoint'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：lg断点
- en: Notice how the first container stays at a fixed width now that we’ve exceeded
    its `maxWidth` breakpoint. The `md` and `lg` containers just keep growing along
    with the screen until their breakpoints have been passed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在我们已经超过了其`maxWidth`断点，第一个容器保持固定宽度。`md`和`lg`容器将继续随着屏幕增长，直到它们的断点被超过。
- en: 'Let’s see what these `Container` components look like when the screen width
    surpasses all breakpoints:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当屏幕宽度超过所有断点时这些`Container`组件看起来像什么：
- en: '![](img/B19636_09_03.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_09_03.png)'
- en: 'Figure 9.3: All breakpoints'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：所有断点
- en: The `Container` component gives you control over how your page elements grow
    horizontally. They’re also responsive, so your layouts will be updated as the
    screen dimensions change.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Container`组件让您控制页面元素如何水平增长。它们也是响应式的，因此当屏幕尺寸变化时，您的布局将得到更新。'
- en: In the next section, we’ll look at using Material UI components to build more
    complex and responsive layouts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨使用Material UI组件构建更复杂和响应式布局。
- en: Building responsive grid layouts
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建响应式网格布局
- en: 'Material UI has a `Grid` component that we can use to compose responsive complex
    layouts. At a high level, a `Grid` component can be either a container or an item
    within a container. By combining these two roles, we can achieve any type of layout
    for our app. To get familiar with Material UI grid layouts, let’s put together
    an example that uses a common layout pattern that we’ll find in many web applications.
    Here is what the result looks like:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Material UI有一个`Grid`组件，我们可以用它来组合响应式复杂布局。从高层次来看，一个`Grid`组件可以是容器或容器内的一个项目。通过结合这两个角色，我们可以为我们的应用程序实现任何类型的布局。为了熟悉Material
    UI网格布局，让我们放在一起一个例子，它使用我们在许多Web应用程序中常见的常见布局模式。这是结果看起来像什么：
- en: '![](img/B19636_09_04.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_09_04.png)'
- en: 'Figure 9.4: A sample responsive grid layout'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：一个示例响应式网格布局
- en: 'As you can see, this layout has familiar sections that are typical in many
    web applications. This is just an example layout; you can use the `Grid` component
    to build any type of layout you can imagine. Let’s look at the code that created
    this layout:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个布局有在许多Web应用程序中常见的熟悉部分。这只是一个示例布局；您可以使用`Grid`组件构建任何您能想象到的布局。让我们看看创建这个布局的代码：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s break down how the sections in this layout are created. We’ll start with
    the header section:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这个布局中的部分是如何创建的。我们将从页眉部分开始：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `xs` breakpoint property value of `12` means that the header will always
    span the entire width of the screen since `12` is the highest value you can use
    here. Next, let’s look at the navigation items:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`xs`断点属性值`12`意味着页眉将始终占据整个屏幕宽度，因为`12`是这里可以使用的最高值。接下来，让我们看看导航项：'
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the navigation section, we have a grid with the `xs="auto"` prop. It matches
    the column’s size with the width of its content. Also, you can see that we use
    a `Stack` component to place components in a vertical direction with spacing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航部分，我们有一个带有`xs="auto"`属性的网格。它使列的大小与其内容的宽度相匹配。此外，您还可以看到我们使用`Stack`组件以垂直方向和间距放置组件。
- en: 'Next, we’ll look at the main content section:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看主要内容部分：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `xs` breakpoint is a true value used to fill all free space after the navigation
    section in the grid.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`xs`断点是一个用于在网格中填充导航部分之后所有空闲空间的真值。'
- en: In this section, you were introduced to what Material UI has to offer in the
    way of layouts. You can use the `Container` component to control the width of
    sections and how they change in response to screen dimension changes. You then
    learned that the `Grid` component is used to put together more complex grid layouts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了Material UI在布局方面能提供什么。你可以使用`Container`组件来控制节宽以及它们如何响应屏幕尺寸变化。然后你了解到`Grid`组件用于组合更复杂的网格布局。
- en: In the following section, we’ll look at some of the navigational components
    found in Material UI.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看Material UI中的一些导航组件。
- en: Using navigation components
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用导航组件
- en: Once we have an idea of how the layout of our application is going to look and
    work, we can start to think about the navigation. This is an important piece of
    our UI because it’s how the user gets around the application, and it will be used
    frequently. In this section, we’ll learn about two of the navigational components
    offered by Material UI.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了我们应用程序布局的外观和工作方式的初步想法，我们就可以开始考虑导航了。这是我们的UI的一个重要部分，因为它是用户在应用程序中导航的方式，并且会被频繁使用。在本节中，我们将了解Material
    UI提供的两个导航组件。
- en: Navigating with drawers
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用抽屉导航
- en: 'The `Drawer` component, just like a physical drawer, slides open to reveal
    content that is easily accessed. When we’re finished, the drawer closes again.
    This works well for navigation because it stays out of the way, allowing more
    space on the screen for the active task that the user is engaged with. Let’s look
    at an example, starting with the `App` component:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Drawer`组件就像一个物理抽屉一样，滑动打开以显示易于访问的内容。当我们完成时，抽屉再次关闭。这对于导航来说效果很好，因为它不会妨碍，允许屏幕上有更多空间用于用户正在参与的活动。让我们看一个例子，从`App`组件开始：'
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s look at what’s happening here. Everything that this component renders
    is within the `BrowserRouter` component because the items in the drawer are links
    to routes:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里发生了什么。这个组件渲染的任何内容都在`BrowserRouter`组件内部，因为抽屉中的项目是路由的链接：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `First`, `Second`, and `Third` components are used to render the main application
    content when the user clicks on a link in the drawer. The drawer itself is opened
    when the `Open Nav` button is clicked. Let’s take a closer look at the state that’s
    used to control this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`First`、`Second`和`Third`组件用于在用户点击抽屉中的链接时渲染主要应用程序内容。当点击`打开导航`按钮时，抽屉本身会打开。让我们更仔细地看看用于控制此状态的变量：'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `open` state controls the visibility of the drawer. The `onClose` property
    of the `Drawer` component calls this function, too, meaning that the drawer closes
    when any of the links within it are activated. Next, let’s look at how the links
    within the drawer are generated:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`open`状态控制抽屉的可见性。`Drawer`组件的`onClose`属性也会调用此函数，这意味着当抽屉内的任何链接被激活时，抽屉会关闭。接下来，让我们看看抽屉内的链接是如何生成的：'
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The items that are displayed in a `Drawer` component are actually list items,
    as you can see here. The `links` property has all the link objects with the `url`
    and `name` properties. Each item in the items array is mapped to the `NavLink`,
    which is used to handle navigation and highlight the active route. Within `NavLink`,
    we have the `ListItemButton` component, which generates the list item with text
    by rendering a `ListItemText` component.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Drawer`组件中显示的项目实际上是列表项，正如你在这里可以看到的。`links`属性包含所有具有`url`和`name`属性的链接对象。items数组中的每个项目都映射到`NavLink`，用于处理导航并突出显示活动路由。在`NavLink`内部，我们有`ListItemButton`组件，它通过渲染`ListItemText`组件来生成带有文本的列表项。
- en: 'Finally, let’s look at the default value for the `links` property:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`links`属性的默认值：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s what the drawer looks like when it’s opened after the screen first loads:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是屏幕首次加载后打开抽屉的样子：
- en: '![](img/B19636_09_05.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_09_05.png)'
- en: 'Figure 9.5: A drawer showing links to our pages'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：显示到我们页面链接的抽屉
- en: 'Try clicking on the `First Page` link. The drawer closes and renders the content
    of the `/first` route. Then, when you open the drawer again, you’ll notice that
    the `First Page` link is rendered as the active link:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试点击`第一页`链接。抽屉关闭并渲染`/first`路由的内容。然后，当你再次打开抽屉时，你会注意到`第一页`链接被渲染为活动链接：
- en: '![](img/B19636_09_06.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_09_06.png)'
- en: 'Figure 9.6: The First Page link is styled as the active link in the drawer'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：在抽屉中，`第一页`链接被样式化为活动链接
- en: In this section, you learned how to use the `Drawer` component as the main navigation
    for your application. In the following section, we’ll look at the `Tabs` component.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何使用`Drawer`组件作为应用程序的主要导航。在下一节中，我们将探讨`Tabs`组件。
- en: Navigating with tabs
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标签导航
- en: 'Tabs are another common navigation pattern found in modern web apps. The Material
    UI `Tabs` component lets us use tabs as links and hook them up to a router. Let’s
    look at an example of how to do this. Here is the `App` component:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是现代网络应用中另一种常见的导航模式。Material UI的`Tabs`组件允许我们使用标签作为链接并将它们连接到路由器。让我们看看如何做到这一点的示例。以下是`App`组件：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the interest of space, I’ve left out the route configuration for `/page2`
    and `/page3`; it follows the same pattern as `/page1`. The `Tabs` and `Tab` components
    from Material UI don’t actually render any content underneath the selected tab.
    It’s up to us to provide the content as the `Tabs` component only looks after
    showing the tabs and marking one of them as selected. This example aims to have
    the `Tab` components use `Link` components that link to content rendered by routes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，我省略了`/page2`和`/page3`的路由配置；它们的模式与`/page1`相同。Material UI中的`Tabs`和`Tab`组件实际上不会在选中的标签下渲染任何内容。这取决于我们提供内容，因为`Tabs`组件只负责显示标签并标记其中一个为选中状态。本例旨在让`Tab`组件使用`Link`组件，这些组件链接到由路由渲染的内容。
- en: 'Let’s now take a closer look at the `RouteLayout` component. Each `Tab` component
    uses the `Link` component so that, when it is clicked, the router is activated
    with the route specified in the `to` property. The `Outlet` component is then
    used as a child of our route content. To match the active tab, we use a simple
    approach to handle the current route using `useRouteMatch`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来仔细看看`RouteLayout`组件。每个`Tab`组件都使用`Link`组件，这样当它被点击时，路由器就会激活`to`属性中指定的路由。然后使用`Outlet`组件作为路由内容的子组件。为了匹配激活的标签，我们使用`useRouteMatch`来处理当前路由的简单方法：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `useRouteMatch` hook uses `useLocation` to get the current `pathname` and
    then check whether it matches our patterns.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRouteMatch`钩子使用`useLocation`获取当前的`pathname`，然后检查它是否与我们的模式匹配。'
- en: 'Here’s what the page looks like when it first loads:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是页面首次加载时的样子：
- en: '![](img/B19636_09_07.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_09_07.png)'
- en: 'Figure 9.7: Tabs with the first item active'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：第一个选项处于激活状态
- en: 'If you click on the **ITEM TWO** tab, the URL will update, the active tab will
    change, and the page content below the tabs will change:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**项目二**标签，URL将更新，激活的标签将改变，标签下面的页面内容也会改变：
- en: '![](img/B19636_09_08.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_09_08.png)'
- en: 'Figure 9.8: Tabs with the second item active'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：第二个选项处于激活状态
- en: By now, you have learned about two of the navigation approaches that you can
    use in your Material UI application. The first is to use a `Drawer` that is only
    displayed when the user needs to access navigational links. The second is to use
    `Tabs` that are always visible. In the following section, you’ll learn about collecting
    input from users.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解了在Material UI应用程序中可以使用的两种导航方法。第一种是使用仅在用户需要访问导航链接时显示的`Drawer`。第二种是使用始终可见的`Tabs`。在下一节中，你将学习如何收集用户输入。
- en: Collecting user input
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集用户输入
- en: Collecting input from users can be difficult. There are many nuanced things
    about every field that we need to consider if we plan on getting the user experience
    right. Thankfully, the `Form` components available in Material UI take care of
    a lot of usability concerns for us. In this section, you’ll get a brief sampling
    of the input controls that you can use.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户那里收集输入可能很困难。如果我们想要提供良好的用户体验，我们需要考虑每个字段许多细微之处。幸运的是，Material UI中可用的`Form`组件为我们处理了许多可用性问题。在本节中，你将简要了解你可以使用的输入控件。
- en: Checkboxes and radio buttons
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复选框和单选按钮
- en: 'Checkboxes are useful for collecting `true/false` answers from users, while
    radio buttons are useful for getting the user to select an option from a short
    number of choices. Let’s take a look at an example of these components in Material
    UI:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 复选框用于从用户那里收集`true/false`答案，而单选按钮用于让用户从少量选项中选择一个。让我们看看Material UI中这些组件的示例：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This example has two pieces of state information. The `checkbox` state controls
    the value of the `Checkbox` component, while the `radio` value controls the state
    of the `RadioGroup` component. The `checkbox` state is passed to the `checked`
    property of the `Checkbox` component, while the radio state is passed to the `value`
    property of the `RadioGroup` component. Both components have `onChange` handlers
    that call their respective state setter functions: `setCheckbox()` and `setRadio()`.
    You’ll notice that many other Material UI components are involved in the display
    of these controls. For example, the label for the `checkbox` is displayed using
    the `FormControlLabel` component, while the radio control uses a `FormControl`
    component and a `FormLabel` component.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例包含两件状态信息。`checkbox`状态控制`Checkbox`组件的值，而`radio`值控制`RadioGroup`组件的状态。`checkbox`状态传递给`Checkbox`组件的`checked`属性，而`radio`状态传递给`RadioGroup`组件的`value`属性。这两个组件都有`onChange`处理程序，它们调用它们各自的状态设置函数：`setCheckbox()`和`setRadio()`。你会注意到许多其他Material
    UI组件都参与了这些控件显示。例如，`checkbox`的标签使用`FormControlLabel`组件显示，而单选控件使用`FormControl`组件和`FormLabel`组件。
- en: 'Here is what the two input controls look like:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这两个输入控件的外观：
- en: '![](img/B19636_09_09.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_09_09.png)'
- en: 'Figure 9.9: A checkbox and a radio group'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：复选框和单选组
- en: The labels for both of these controls are updated to reflect the state of the
    components as they change. The checkbox labels show whether the checkbox is checked,
    and the radio labels show the currently selected value. In the next section, we’ll
    look at text inputs and select components.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个控件标签都更新以反映组件的状态变化。复选框标签显示复选框是否被选中，而单选按钮标签显示当前选定的值。在下一节中，我们将查看文本输入和选择组件。
- en: Text inputs and select inputs
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本输入和选择输入
- en: '**Text fields** allow our users to enter text, while `Select` allows them to
    choose from several options. The difference between selects and radio buttons
    is that selects require less space on the screen since the options are only displayed
    when the user opens the options menu.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**文本字段**允许我们的用户输入文本，而`选择`允许他们从几个选项中进行选择。选择和单选按钮之间的区别在于，由于选项仅在用户打开选项菜单时才显示，因此选择在屏幕上占用的空间更少。'
- en: 'Let’s look at a `Select` component now:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`Select`组件：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The value state used in this example controls the selected value in the `Select`
    component. When the user changes their selection, the `setValue()` function changes
    the value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中使用的值状态控制`Select`组件中的选定值。当用户更改他们的选择时，`setValue()`函数会更改值。
- en: 'The `MenuItem` component is used to specify the available options in the `select`
    field; the `value` property is set as the value state when a given item is selected.
    Here’s what the `select` field looks like when the menu is displayed:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`MenuItem`组件用于指定`select`字段中可用的选项；当选择给定项时，`value`属性设置为值状态。以下是菜单显示时的`select`字段外观：'
- en: '![](img/B19636_09_10.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_09_10.png)'
- en: 'Figure 9.10: A menu with the first item active'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：第一个项目处于活动状态的菜单
- en: 'Next, let’s look at a `TextField` component example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一个`TextField`组件的示例：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The value state controls the value of the text input and changes as the user
    types. Here’s what the `text` field looks like:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 值状态控制文本输入的值，并随着用户的输入而改变。下面是`text`字段的外观：
- en: '![](img/B19636_09_11.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_09_11.png)'
- en: 'Figure 9.11: A text field with user-provided text'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：带有用户提供的文本的文本字段
- en: Unlike other `FormControl` components, the `TextField` component doesn’t require
    several other supporting components. Everything that we need can be specified
    via properties. In the next section, we’ll look at the `Button` component.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他`FormControl`组件不同，`TextField`组件不需要其他几个支持组件。我们所需的一切都可以通过属性来指定。在下一节中，我们将查看`Button`组件。
- en: Working with buttons
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与按钮一起工作
- en: 'Material UI buttons are very similar to HTML button elements. The difference
    is that they’re React components that work well with other aspects of Material
    UI, such as theming and layout. Let’s look at an example that renders different
    styles of buttons:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Material UI按钮与HTML按钮元素非常相似。区别在于它们是React组件，与Material UI的其他方面（如主题和布局）配合得很好。让我们看看一个渲染不同样式按钮的示例：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This example renders four different button styles. We’re using the `Stack` component
    to render the row of buttons. When the buttons are clicked on, the state toggles
    to primary and vice versa.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例渲染了四种不同的按钮样式。我们使用`Stack`组件来渲染按钮行。当按钮被点击时，状态会在主要和次要之间切换。
- en: 'Here’s what the buttons look like when they’re first rendered:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是按钮首次渲染时的样子：
- en: '![](img/B19636_09_12.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_09_12.png)'
- en: 'Figure 9.12: Four styles of Material UI buttons'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：四种Material UI按钮样式
- en: 'Here’s what the buttons look like when they’ve each been clicked on:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每个按钮被点击后的样子：
- en: '![](img/B19636_09_13.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_09_13.png)'
- en: 'Figure 9.13: What the buttons look like after they’ve been clicked on'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13：按钮被点击后的样子
- en: In this section, you learned about some of the user input controls available
    in Material UI. `Checkboxes` and `radio` buttons are useful when the user needs
    to turn something on or off or choose an option. Text inputs are necessary when
    the user needs to type in some text, while `select` fields are useful when you
    have a list of options to choose from but limited space to display those options.
    Finally, you learned that Material UI has several styles of buttons that can be
    used when the user needs to initiate an action. In the following section, we’ll
    look at how styles and themes work in Material UI.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了Material UI中一些可用的用户输入控件。`复选框`和`单选按钮`在用户需要开启或关闭某个功能或选择一个选项时非常有用。当用户需要输入一些文本时，文本输入是必要的，而`选择框`在您有一系列选项可供选择但显示空间有限时非常有用。最后，你了解到Material
    UI有几种按钮样式，当用户需要启动一个动作时可以使用。在下一节中，我们将探讨在Material UI中样式和主题是如何工作的。
- en: Working with styles and themes
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与样式和主题一起工作
- en: Included with Material UI are systems for extending the styles of UI components
    and extending **theme styles** that are applied to all components. In this section,
    you’ll learn about using both of these systems.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Material UI包含用于扩展UI组件样式和扩展应用于所有组件的**主题样式**的系统。在本节中，你将了解如何使用这两个系统。
- en: Making styles
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作样式
- en: Material UI comes with a `styled()` function that can be used to create styled
    components based on JavaScript objects. The return value of this function is a
    new component with the new styles applied.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Material UI自带一个`styled()`函数，可以用来基于JavaScript对象创建样式化组件。这个函数的返回值是一个应用了新样式的新的组件。
- en: 'Let’s take a closer look at this approach:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这种方法：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The names used in this style (`MuiButton-root`, `MuiButton-contained`, and `MuiButton-sizeSmall`)
    aren’t something that we came up with. These are part of the **Button CSS API**.
    The root style is applied to all buttons, so, in this example, all three buttons
    will have the margin value that we’ve applied here. The `contained` style is applied
    to buttons that use the contained variant. The `sizeSmall` style is applied to
    buttons that have a small value for the size property.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个样式中使用的名字（`MuiButton-root`、`MuiButton-contained`和`MuiButton-sizeSmall`）并不是我们想出来的。这些都是**按钮CSS
    API**的一部分。根样式应用于所有按钮，因此在这个例子中，所有三个按钮都将具有我们在这里应用的边距值。`contained`样式应用于使用包含变体的按钮。`sizeSmall`样式应用于具有小尺寸属性值的按钮。
- en: 'Here’s what the custom button styles look like:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是自定义按钮样式的外观：
- en: '![](img/B19636_09_14.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_09_14.png)'
- en: 'Figure 9.14: Buttons using customized styles'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14：使用自定义样式的按钮
- en: Now that you know how to change the look and feel of individual components,
    it’s time to think about customizing the look and feel of the application as a
    whole.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何更改单个组件的外观和感觉，是时候考虑如何自定义整个应用程序的外观和感觉了。
- en: Customizing themes
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义主题
- en: 'Material UI comes with a default theme. We can use this as the starting point
    to create our own theme. There are two main steps to creating a new theme in Material
    UI:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Material UI自带默认主题。我们可以以此为基础创建自己的主题。在Material UI中创建新主题主要有两个步骤：
- en: Use the `createTheme()` function to customize the default theme settings and
    return a new theme object.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`createTheme()`函数来自定义默认主题设置，并返回一个新的主题对象。
- en: Use the `ThemeProvider` component to wrap our application so that the appropriate
    theme is applied.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ThemeProvider`组件包裹我们的应用程序，以便应用适当的主题。
- en: 'Let’s look at how this process works in practice:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个流程在实际中是如何工作的：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The custom theme that we’ve created here does two things:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建的自定义主题做了两件事：
- en: It changes the default font size for all components to `11`.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将所有组件的默认字体大小更改为`11`。
- en: It updates the left and right margin values for the `MenuItem` components.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它更新了`MenuItem`组件的左右边距值。
- en: Many values can be set in a Material UI theme; refer to the customization documentation
    for more. The `components` section is used for component-specific customizations.
    This is useful when you need to style every instance of a component in your application.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Material UI 主题中可以设置许多值；更多自定义信息请参考自定义文档。`components` 部分用于组件特定的自定义。当你需要为应用中每个组件实例设置样式时，这非常有用。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was a very brief introduction to Material UI, the most popular
    React UI framework. We started by looking at the components used to assist with
    the layout of our pages. We then looked at components that can help the user navigate
    around your application. Next, you learned how to collect user input using Material
    UI form components. Finally, you learned how to style your Material UI using styles
    and modifying themes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对 Material UI 的非常简要介绍，它是最受欢迎的 React UI 框架。我们首先查看用于帮助布局我们页面的组件。然后我们查看可以帮助用户在应用中导航的组件。接下来，你学习了如何使用
    Material UI 表单组件收集用户输入。最后，你学习了如何通过样式和修改主题来设置你的 Material UI。
- en: The insights gained from this chapter allow you to build complex interfaces
    without the overhead of developing UI components from scratch, accelerating your
    development process. Furthermore, React application development inherently relies
    on the synergistic use of various auxiliary libraries. A deep understanding of
    the React ecosystem and its key libraries empowers developers to rapidly prototype
    and iterate on their applications, making development effective.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章中获得的认识使你能够在不从头开发 UI 组件的情况下构建复杂界面，从而加速你的开发过程。此外，React 应用开发本质上依赖于各种辅助库的协同使用。对
    React 生态系统及其关键库的深入了解使开发者能够快速原型设计和迭代他们的应用，使开发更有效。
- en: In the next chapter, we’ll look at ways to improve the efficiency of your component
    state updates using the latest functionality available in the latest version of
    React.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用 React 最新版本中提供的最新功能来提高组件状态更新效率的方法。
