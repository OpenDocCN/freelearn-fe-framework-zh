- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling Application State with Grace
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about application state. Understanding and handling
    the state of your application is one of the most essential parts of frontend development.
    If the state of your applications becomes messy, entangled, and hard to understand,
    your development process and the quality of your application will suffer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: To help you better manage your application state, we will talk about the different
    state levels you’ll find within your applications. You will learn how to partition
    and divide your state for maximum efficiency. You will also create a state management
    solution using RxJS and Signals and build a facade service to access your state
    from the component layer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn how to handle more complex states with the NgRx library.
    NgRx is the most commonly used state management library within the Angular community
    and uses the Redux pattern to manage state. Since the introduction of Angular
    Signals, NgRx also provides different approaches to working with Signals while
    using the tools we love from NgRx.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have implemented state management solutions
    using different methods. You’ll have learned how easy it is to change your state
    management solution when using a facade service and seen how Angular Signals has
    changed the way we handle state within Angular applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Understanding application state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling global application state using RxJS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling global application state using Signals
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling global application state with NgRx
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding application state
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In simple terms, **application state** is a snapshot of the current condition
    (or state) of your data, configurations, and views at a specific point in time.
    Application state is the sum of all actions that are performed within your application
    from the moment it is loaded in the browser. The state is a dynamic landscape
    that influences your application’s view, user interactions, data flow, and overall
    functionality.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: It’s essential to have good state management within your application so that
    all your components can display the correct data to the end user and you have
    accurate data to work with within your application code. Good state management
    prevents unintended data changes, resulting in incorrect views and operations
    being performed within your application code that you did not intend to perform.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an idea of what application state is and why you need it,
    let’s dive deeper, starting with the different levels of application state.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Different levels of application state
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the realm of frontend development, we can distinguish between two levels
    of state: global and local state. In this section, we’ll delve into the nuanced
    distinction between global and local application states within the context of
    Angular, shedding light on their roles in crafting robust and maintainable frontend
    applications.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: As their names imply, **local state** is localized to a file, component, or
    element within your application, whereas **global state** is shared through your
    entire application. The global application state serves as the central repository
    for shared information across various components, ensuring coherence and synchronicity
    in the application’s behavior. On the other hand, the local application state
    encapsulates the internal data and configuration specific to individual Angular
    components and services.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如它们的名称所暗示的，**局部状态**是局部化到文件、组件或应用程序中的元素，而**全局状态**是通过整个应用程序共享的。全局应用程序状态作为共享信息在各个组件之间的中央存储库，确保应用程序行为的一致性和同步性。另一方面，局部应用程序状态封装了特定于单个Angular组件和服务的内部数据和配置。
- en: By understanding the dual nature of global and local states, your Angular applications
    can strike a harmonious balance between reusability, encapsulation, and shared
    data integrity. Let’s start by diving a bit deeper into the local application
    state within Angular applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解全局和局部状态的二重性，你的Angular应用程序可以在可重用性、封装性和共享数据完整性之间达到和谐的平衡。让我们先深入了解一下Angular应用程序中的局部应用程序状态。
- en: Local application state
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 局部应用程序状态
- en: When we refer to local state, we’re talking about properties that have been
    localized to a component or service that determine how that component or service
    behaves and presents data to your application’s user.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到局部状态时，我们指的是那些被局部化到组件或服务中的属性，这些属性决定了该组件或服务如何行为以及如何向应用程序的用户展示数据。
- en: 'A simple example of a local state would be a `Counter` component with a `count`
    state:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个局部状态的简单例子是一个具有`count`状态的`Counter`组件：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `count` property is used to display the current count to the user. The declaration
    and update behavior of the `count` property is handled locally within the current
    component.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`属性用于向用户显示当前计数。`count`属性的声明和更新行为在当前组件内部处理。'
- en: Within components, you can consider the state as local when the stateful property
    isn’t shared between multiple smart components and doesn’t need to be persisted
    when you navigate from one page to another.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件内部，你可以将状态视为局部状态，当状态属性不是在多个智能组件之间共享，并且在你从一个页面导航到另一个页面时不需要持久化时。
- en: Within services, the state can be considered local whenever it entails a private
    property that isn’t shared with the outside world, and the property doesn’t have
    to persist longer than the life cycle of the service file. If the property doesn’t
    meet these criteria, you probably need to locate it somewhere within your global
    application state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务内部，当状态涉及一个不与外界共享的私有属性，并且该属性不需要比服务文件的生命周期更长的时间来持久化时，可以将其视为局部状态。如果属性不符合这些标准，你可能需要将其定位在全局应用程序状态中的某个位置。
- en: 'Here are some common examples of local state within Angular applications:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些Angular应用程序中局部状态的常见例子：
- en: Disabled button state
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用按钮状态
- en: Form validity state
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形式有效性状态
- en: Modal visibility
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模态可见性
- en: Sorting and filtering
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序和过滤
- en: Accordion state
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手风琴状态
- en: Selected tab state
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选定的标签页状态
- en: You now have a good understanding of local state. You know what local state
    is, how you can recognize it, and what the preferred tool is to handle local state
    within your Angular applications. You also learned about some common examples
    of local state. Next, you will learn about global application state.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在对局部状态有了很好的理解。你知道什么是局部状态，如何识别它，以及处理Angular应用程序中局部状态的首选工具是什么。你还了解了一些局部状态的常见例子。接下来，你将学习关于全局应用程序状态的内容。
- en: Global application state
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局应用程序状态
- en: In contrast to local state, global application state refers to the data and
    configurations you share across multiple components and services within an Angular
    application. You can think of your global application state as a centralized repository
    for your data. This centralized repository of information is pivotal in ensuring
    consistency, synchronization, and efficient communication between various application
    parts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与局部状态相对，全局应用程序状态指的是在Angular应用程序中跨多个组件和服务共享的数据和配置。你可以将你的全局应用程序状态视为一个数据集中式存储库。这个信息集中式存储库对于确保应用程序各个部分之间的一致性、同步性和高效通信至关重要。
- en: Unlike local state, which is confined to a specific component or service, global
    application state persists throughout the entire application, making it particularly
    useful for scenarios where data needs to be shared and synchronized across different
    components and services, as well as during the whole user session.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与局限于特定组件或服务的局部状态不同，全局应用状态在整个应用程序中持续存在，这使得它在需要在不同组件和服务之间共享和同步数据，以及在整个用户会话期间特别有用。
- en: Within Angular application, global state is commonly handled inside services.
    By creating a service dedicated to managing global state, developers can ensure
    that components have a centralized access point to crucial information. Services
    that contain global application state are often named *stores*. For example, you
    can call the service to store global user state `user.store.ts` with a `UserStore`
    class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular应用程序中，全局状态通常在服务中处理。通过创建一个专门用于管理全局状态的服务，开发者可以确保组件有一个集中的访问点来获取关键信息。包含全局应用状态的服务通常被称为*存储*。例如，您可以使用名为`UserStore`的类调用服务来存储全局用户状态`user.store.ts`。
- en: Within smaller Angular applications, state is commonly managed using `Subjects`.
    More specifically, `BehaviorSubject` stores and distributes stateful properties,
    and the regular `Subject` distributes global events. With the introduction of
    Signals, some `BehaviorSubject` classes can be replaced with Signals. We will
    see this in detail in the *Handling global application state using RxJS* section
    when we start building global state management.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在较小的Angular应用程序中，状态通常使用`Subjects`进行管理。更具体地说，`BehaviorSubject`存储和分发状态属性，而常规的`Subject`分发全局事件。随着Signals的引入，一些`BehaviorSubject`类可以被Signals替换。我们将在开始构建全局状态管理时，在*使用RxJS处理全局应用状态*部分详细看到这一点。
- en: For larger Angular applications, libraries such as NgRx, NgXs, Akita, and Angular
    Query are the preferred methods for handling global state. These libraries enhance
    your capabilities to manage the states gracefully and implement structured and
    battle-tested design patterns for managing and updating the global state in a
    predictable and scalable manner.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较大的Angular应用程序，NgRx、NgXs、Akita和Angular Query等库是处理全局状态的首选方法。这些库增强了您优雅地管理状态的能力，并实现了结构化和经过实战检验的设计模式，以可预测和可扩展的方式管理和更新全局状态。
- en: Understanding when to utilize the global application state is crucial. A global
    state might be more appropriate if a stateful property needs to be shared across
    multiple smart components or persists beyond a single component’s life cycle.
    Now that you know what local and global state are, when to use which, and what
    tools are available to manage both gracefully, let’s learn about some important
    concepts within state management.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 理解何时利用全局应用状态至关重要。如果需要将状态属性在多个智能组件之间共享或超出单个组件的生命周期，则全局状态可能更为合适。现在您已经了解了局部和全局状态是什么，何时使用哪一个，以及有哪些工具可以优雅地管理它们，让我们来学习一些状态管理中的重要概念。
- en: Fundamental concepts within state management
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态管理中的基本概念
- en: To build a robust state management system within your Angular applications,
    you need to understand the fundamental concepts of state management. You need
    to know these concepts, why they are essential, and the dangers of not using them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的Angular应用程序中构建一个健壮的状态管理系统，您需要了解状态管理的基本概念。您需要知道这些概念，为什么它们是必要的，以及不使用它们的危险。
- en: In this section, we will learn about unidirectional data flow, immutability,
    and side effects. Other important fundamentals for state management include reactivity
    and design patterns such as the Redux pattern, but we already discussed both in
    *Chapters 6* and *7*, so we won’t dive deeper into this.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习单向数据流、不可变性和副作用。状态管理的一些其他重要基础包括响应性和设计模式，如Redux模式，但我们已经在第6章和第7章中讨论过，所以我们将不会深入探讨这一点。
- en: Unidirectional data flow
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单向数据流
- en: '**Unidirectional data flow** is the first concept of state management we will
    discuss. As its name suggests, the concept states that data should only flow in
    one direction throughout your application. Changes to the data occur through well-defined
    actions or events, ensuring a clear and predictable flow of information. Unidirectional
    data flow simplifies debugging, makes code more predictable, and enhances maintainability.
    It prevents unexpected side effects by enforcing a clear flow of data through
    the application.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**单向数据流**是我们将要讨论的第一个状态管理概念。正如其名称所暗示的，这个概念表明数据应该在整个应用程序中单向流动。数据的变化通过定义良好的动作或事件发生，确保信息流清晰且可预测。单向数据流简化了调试，使代码更可预测，并提高了可维护性。它通过强制应用程序中的数据清晰流动来防止意外的副作用。'
- en: Without unidirectional data flow, tracing the origin of state changes becomes
    challenging, leading to debugging difficulties and potential issues with data
    consistency. Uncontrolled data flow can result in unpredictable behavior, especially
    in large and complex applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 没有单向数据流，追踪状态变化的原因会变得具有挑战性，导致调试困难以及数据一致性的潜在问题。不受控制的数据流可能导致不可预测的行为，尤其是在大型和复杂的应用程序中。
- en: The concept of unidirectional data flow is important throughout your entire
    application and for both local and global application state. For the global application
    state, I recommend always having a unidirectional data flow. Within the local
    component state, you can sometimes make an exception by using Angular two-way
    data binding.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 单向数据流的概念在整个应用程序中都很重要，无论是局部还是全局应用程序状态。对于全局应用程序状态，我建议始终使用单向数据流。在局部组件状态中，有时你可以通过使用Angular双向数据绑定来做出例外。
- en: 'To help you understand how unidirectional data flow looks in an Angular application,
    here’s an example of flow:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你理解单向数据流在Angular应用程序中的样子，这里有一个流示例：
- en: The state is passed from the store to the facade service.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态从存储传递到外观服务。
- en: The state is passed from the facade service to the smart component.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态从外观服务传递到智能组件。
- en: The smart component passes the data to the (dumb) child components.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 智能组件将数据传递给（无状态的）子组件。
- en: The view is rendered based on the state of the smart component and its child
    components.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图根据智能组件及其子组件的状态进行渲染。
- en: An action can be triggered in the view.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图中可以触发一个动作。
- en: The event of the action and the related data move from the (dumb) child component
    up to the smart component.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动作的事件和相关信息从（无状态的）子组件向上移动到智能组件。
- en: The smart component or facade dispatches an action to the store.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 智能组件或外观向存储派发一个动作。
- en: The store updates the state based on the dispatched action.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储根据派发的动作更新状态。
- en: The state is passed from the store to the facade.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态从存储传递到外观。
- en: As you can see, the data starts in the store and flows in one direction until
    the view can be rendered. When the user triggers an action within the view, the
    data flows in one direction and in a predictable manner back into the store until
    we reach full circle. Now that you know what unidirectional data flow is and why
    it’s important in state management, let’s learn about immutability.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，数据从存储开始，单向流动直到视图可以被渲染。当用户在视图中触发一个动作时，数据会以单向和可预测的方式流回存储，直到形成一个完整的循环。现在你已经了解了单向数据流是什么以及为什么它在状态管理中很重要，让我们来学习不可变性的概念。
- en: Immutability
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变性
- en: '**Immutability** involves the practice of not modifying existing data structures
    directly. Instead, new copies are created with the desired changes, preserving
    the integrity of the original data. Immutability simplifies state management by
    providing a single place to mutate your state. It helps prevent unintended state
    changes and side effects and is particularly valuable when you’re tracking and
    managing complex state in Angular applications.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可变性**涉及不直接修改现有数据结构的实践。相反，会创建带有所需更改的新副本，以保持原始数据的完整性。不可变性通过提供一个单一的位置来修改你的状态，简化了状态管理。它有助于防止意外的状态更改和副作用，在跟踪和管理Angular应用程序中的复杂状态时尤其有价值。'
- en: With immutability, you may find it easier to track state changes and keep your
    state synchronized. Directly modifying state objects can lead to bugs and unexpected
    behavior. Immutability was mainly used within global state management, but with
    the introduction of Signals, it’s now also applied within the local state of Angular
    applications.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不可变性，你可能发现跟踪状态变化和保持状态同步更容易。直接修改状态对象可能导致错误和意外的行为。不可变性主要在全局状态管理中使用，但随着Signals的引入，现在它也应用于Angular应用程序的本地状态。
- en: Side effects
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 副作用
- en: '**Side effects** refer to an operation or changes you perform when a specific
    piece of your state changes. Side effects can include things such as the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**副作用**指的是当你的状态中的某个特定部分发生变化时，你执行的操作或更改。副作用可能包括以下内容：'
- en: Fetching data
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数据
- en: Updating the local storage
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新本地存储
- en: Dispatching additional actions
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发额外的动作
- en: Setting local variables
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置局部变量
- en: By isolating side effects, you can maintain a clear separation of concerns in
    your application. The core application logic (reducers, actions, and selectors)
    remains focused on state changes, while side effects are handled separately. Side
    effects are natively introduced in the Angular framework within the Signals API,
    and they are used in popular state management libraries such as NgRx and NgXs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过隔离副作用，你可以在你的应用程序中保持关注点的清晰分离。核心应用程序逻辑（reducers、actions和selectors）专注于状态变化，而副作用则单独处理。副作用在Angular框架的Signals
    API中自然引入，并在像NgRx和NgXs这样的流行状态管理库中使用。
- en: So, to summarize, there is local and global state within your applications.
    Local state is localized to components or services, whereas global state affects
    the entire application. Some of the fundamental concepts of state management are
    unidirectional data flow, immutability, and side effects. You learned about the
    advantages of these concepts and why they are important for a state management
    solution. You also learned what state management is and why you need it within
    your applications.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，在你的应用程序中存在本地和全局状态。本地状态局限于组件或服务，而全局状态影响整个应用程序。状态管理的一些基本概念包括单向数据流、不可变性和副作用。你了解了这些概念的优势以及为什么它们对于状态管理解决方案很重要。你还了解了状态管理是什么以及为什么你需要在应用程序中使用它。
- en: In the next section, you will start building a global state management solution
    and create a facade service to access the state from within your smart components.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将开始构建一个全局状态管理解决方案，并创建一个门面服务以从你的智能组件内部访问状态。
- en: Handling global application state using RxJS
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RxJS处理全局应用程序状态
- en: In this section, you will create a simple state management solution using RxJS.
    At the core of this state management solution lies the RxJS `BehaviorSubject`
    class. You will also create a facade service to interact with the state management
    solution.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建一个简单的状态管理解决方案，使用RxJS。这个状态管理解决方案的核心是RxJS的`BehaviorSubject`类。你还将创建一个门面服务以与状态管理解决方案交互。
- en: The facade will do all the communication with the state management solution
    and the smart components. This decouples our smart components from the state management
    solution, making it easy to swap our state management implementation when needed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 门面将负责与状态管理解决方案和智能组件的所有通信。这使我们的智能组件与状态管理解决方案解耦，便于在需要时轻松交换我们的状态管理实现。
- en: Once we’ve created the RxJS state management solution and connected it with
    the component layer of the application, we can change the state management and
    facade to use Signals where it is possible and makes sense.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了RxJS状态管理解决方案并将其与应用程序的组件层连接起来，我们就可以将状态管理和门面更改为在可能且合理的地方使用Signals。
- en: By converting the state management solution from RxJS into Signals, you’ll be
    able to understand both concepts and learn about the differences. Building both
    approaches will also serve you best so that you can recognize and work with both
    systems when you encounter them in a project you join. Let’s start by building
    the RxJS state management solution.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将状态管理解决方案从RxJS转换为Signals，你将能够理解这两个概念并了解它们之间的区别。构建这两种方法也将为你提供最佳服务，以便你在加入的项目中遇到它们时能够识别并与之合作。让我们从构建RxJS状态管理解决方案开始。
- en: Building a state management solution using RxJS
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RxJS构建状态管理解决方案
- en: To start building the state management solution, create a folder named `stores`
    in the `data-access` library of the finance domain. The `stores` folder should
    be located inside the `lib` folder, at the same level as the `adapters`, `HTTP`,
    `models`, and `services` folders.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建状态管理解决方案，在财务域的`data-access`库中创建一个名为`stores`的文件夹。`stores`文件夹应位于`lib`文件夹内部，与`adapters`、`HTTP`、`models`和`services`文件夹处于同一级别。
- en: Creating a service
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个服务
- en: First, you can create a service by using the *Nx generator* in the newly created
    `stores` folder. Name the new service `expenses.store`. Because we’re using the
    Nx generator, it will create a file named `expenses.store.service.ts`; you can
    remove the `.service` part manually and do the same for the `spec` file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以通过在新建的`stores`文件夹中使用*Nx生成器*来创建一个服务。将新服务命名为`expenses.store`。因为我们使用的是Nx生成器，它将创建一个名为`expenses.store.service.ts`的文件；你可以手动删除`.service`部分，并对`spec`文件做同样的处理。
- en: 'Next, rename the class `ExpensesStore` instead of `ExpensesStoreService` and
    remove `constructor`; this should be in your file when you’re ready:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将类名从`ExpensesStore`改为`ExpensesStoreService`并移除`constructor`；当你准备好时，这应该在你的文件中：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, you need something that can hold the state for your list of expenses.
    We will use a `BehaviorSubject` class that will emit an array of `ExpenseModel`.
    The `BehaviorSubject` class will be a private property, so you cannot directly
    mutate the state from outside our `ExpensesStore` class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要一个可以保存你支出列表状态的东西。我们将使用一个`BehaviorSubject`类，该类将发出一个`ExpenseModel`数组。`BehaviorSubject`类将是一个私有属性，因此你无法直接从我们的`ExpensesStore`类外部修改状态。
- en: Only the `ExpenseStore` class should be able to mutate the state directly; all
    other parts of the application should mutate it through `ExpenseStore` and, more
    precisely, through the facade, which will call `ExpenseStore`. Allowing the state
    to be directly mutated from other parts of your application can lead to unintended
    state mutations, breaking your application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`ExpenseStore`类应该能够直接修改状态；应用程序的其他部分应该通过`ExpenseStore`以及更精确地说，通过外观（facade），来修改状态。允许应用程序的其他部分直接修改状态可能导致意外的状态修改，破坏你的应用程序。
- en: 'Because the `BehaviorSubject` class is private, you also need a public property
    that exposes the `BehaviorSubject` class to the outside world as an Observable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`BehaviorSubject`类是私有的，你还需要一个公共属性，该属性将`BehaviorSubject`类暴露给外部世界作为一个可观察对象（Observable）：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we first defined the `expenses` `BehaviorSubject` class, and
    we created the public `expenses$` Observable by taking the `expenses` `BehaviorSubject`
    class and calling the `asObservable()` method on the `BehaviorSubject` class.
    We gave the `expenses` `BehaviorSubject` class an empty array as its default value.
    Next, let’s add some logic to fetch and distribute our data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们首先定义了`expenses` `BehaviorSubject`类，并通过在`BehaviorSubject`类上调用`asObservable()`方法创建了公共的`expenses$`可观察对象（Observable）。我们给`expenses`
    `BehaviorSubject`类提供了一个空数组作为其默认值。接下来，让我们添加一些逻辑来获取和分发我们的数据。
- en: Fetching and distributing data in our store
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的存储中获取和分发数据
- en: 'Next, we’ll add some logic to make an API request that retrieves the expenses
    and emits the received expenses through the `BehaviorSubject` class. To achieve
    this, start by injecting the `ExpensesHttpService` class we created in [*Chapter
    6*](B21625_06.xhtml#_idTextAnchor115):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一些逻辑来执行API请求以检索支出，并通过`BehaviorSubject`类发出接收到的支出。为了实现这一点，首先注入我们在[*第6章*](B21625_06.xhtml#_idTextAnchor115)中创建的`ExpensesHttpService`类：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, you need to create a method to make the API request and update the `BehaviorSubject`
    class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建一个方法来执行API请求并更新`BehaviorSubject`类：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we made a method named `fetchExpenses`, and inside this method,
    we used `expensesApi` to make a `get` request. We subscribed to the `get` request
    and handled the `next` and `error` events of the subscription. The `next` error
    is handled when the subscription of the `get` request receives a response, and
    the `error` event is handled whenever the `get` request fails and returns with
    an error status.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们创建了一个名为`fetchExpenses`的方法，并在该方法内部使用`expensesApi`来执行`get`请求。我们订阅了`get`请求并处理了订阅的`next`和`error`事件。当`get`请求的订阅收到响应时，处理`next`事件；当`get`请求失败并返回错误状态时，处理`error`事件。
- en: If the API request responds successfully, we call the `next()` method on the
    `expenses` `BehaviorSubject` class and give it the received `expenses` as a parameter.
    If the API responds with an error, we simply log the error. In a production application,
    you should handle this better and alert the user with a toaster message or something
    similar.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果API请求成功响应，我们在`expenses` `BehaviorSubject`类上调用`next()`方法，并给它传递接收到的`expenses`作为参数。如果API返回错误，我们简单地记录错误。在生产应用程序中，你应该更好地处理这种情况，并使用托盘消息或类似的方式提醒用户。
- en: Adding additional expense methods
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加额外的费用方法
- en: 'Next, you’ll want to add methods to get an expense by ID, as well as update,
    delete, and add expenses. Before you create these methods, `MockInterceptor` must
    be adjusted to handle the `delete` and `getByID` requests. You can modify the
    interceptor yourself or get the adjusted `MockInterceptor` from this book’s GitHub
    repository: [https://github.com/PacktPublishing/Effective-Angular](https://github.com/PacktPublishing/Effective-Angular).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将想要添加通过ID获取费用、更新、删除和添加费用的方法。在创建这些方法之前，必须调整`MockInterceptor`以处理`delete`和`getByID`请求。你可以自己修改拦截器，或者从本书的GitHub仓库中获取调整后的`MockInterceptor`：[https://github.com/PacktPublishing/Effective-Angular](https://github.com/PacktPublishing/Effective-Angular)。
- en: 'After adjusting `MockInterceptor`, you can start to implement the `add`, `delete`,
    `update`, and `getByID` methods in our expenses store. Inside all these methods,
    we need access to the current list of expenses. You can access the current list
    of expenses through the `value` property of the `expenses` `BehaviorSubject` class.
    Let’s create a getter that retrieves the current expenses from our state:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在调整`MockInterceptor`后，你可以在我们的费用存储中实现`add`、`delete`、`update`和`getByID`方法。在这些方法内部，我们需要访问当前的费用列表。你可以通过`expenses`
    `BehaviorSubject`类的`value`属性访问当前的费用列表。让我们创建一个获取器，从我们的状态中检索当前的费用：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we can start adding the methods.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始添加方法。
- en: Adding expenses
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加费用
- en: 'Let’s start by creating a method to add an expense:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个添加费用的方法：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the `addExpense` code takes `expense` as a function parameter.
    This `expense` parameter is used to call the `POST` request on `expenseApi`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`addExpense`代码将`expense`作为函数参数。这个`expense`参数用于在`expenseApi`上调用`POST`请求。
- en: When the API returns with the response, we update the `ID` property (we’re only
    updating the `ID` property because we don’t have an actual backend. Normally,
    `ID` would be populated by the backend). After updating the `ID` property, we
    add the newly created `expense` to the `expenses` state.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当API返回响应时，我们更新`ID`属性（我们只更新`ID`属性，因为我们没有实际的后端。通常，`ID`会由后端填充）。更新`ID`属性后，我们将新创建的`expense`添加到`expenses`状态中。
- en: Deleting expenses
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除费用
- en: 'After creating the `addExpense` method, you can make a method to delete an
    expense:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`addExpense`方法后，你可以创建一个删除费用的方法：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `delete` method is pretty straightforward. We make the API request, and
    when the API responds, we update the `expenses` state with the new list of expenses
    by calling the `next()` method. As a parameter for the `next()` method, we use
    the current list of `expenses` and `filter` out the deleted expenses. If the API
    responds with an error, we log the error, again in a production application, and
    we show some sort of message to the user.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`方法相当直接。我们发起API请求，当API响应时，我们通过调用`next()`方法更新`expenses`状态，以获取新的费用列表。作为`next()`方法的参数，我们使用当前的`expenses`列表并使用`filter`过滤掉已删除的费用。如果API返回错误，我们记录错误，同样在生产应用程序中，我们向用户显示某种消息。'
- en: Fetching, getting, and selecting expenses
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取、获取和选择费用
- en: After adding the `delete` method, we will add the `getExpense`, `selectExpense`,
    and `fetchExpenseById` methods. The `getExpense` and `selectExpense` methods will
    be public methods, while the `fetchExpenseById` will be private. We will also
    create an `expense` `Subject` class and a `selectedExpense` state using a `BehaviorSubject`
    class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加`delete`方法后，我们将添加`getExpense`、`selectExpense`和`fetchExpenseById`方法。`getExpense`和`selectExpense`方法将是公共方法，而`fetchExpenseById`将是私有方法。我们还将创建一个`expense`
    `Subject`类和一个`selectedExpense`状态，使用`BehaviorSubject`类。
- en: 'Let’s start by adding the `Subject` class and the `selectedExpense` state:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加`Subject`类和`selectedExpense`状态：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `expense` `Subject` class and `selectedExpense` state can be used to retrieve
    the selected expense reactively. The `selectedExpense` state is used when you
    need to persist the selection in your global application state. In contrast, the
    `expense Subject` class can be used to emit an expense as an event that is only
    received by Observers who are subscribed when the event is emitted. After adding
    the `expense Subject` class and the `selectedExpense` state, we will continue
    with the private `fetchExpenseById` method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`expense` `Subject` 类和 `selectedExpense` 状态可以用来响应式地检索选定的费用。当您需要将选择持久化到全局应用程序状态时，使用
    `selectedExpense` 状态。相比之下，`expense Subject` 类可以用来发出一个事件，该事件只被在事件发出时订阅的观察者接收。在添加了
    `expense Subject` 类和 `selectedExpense` 状态之后，我们将继续使用私有的 `fetchExpenseById` 方法：'
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `fetchExpenseById` method has `id` and `select` parameters. The `id` parameter
    is required, and the `select` property is optional with a default value of `false`.
    The method starts by making an API call to retrieve an expense by ID. When the
    API responds with an expense, we emit a new value using `expense Subject` or emit
    a value and set the `selectedExpense` state using the `BehaviorSubject` class.
    Depending on the needs of your application, you can also add the fetched expense
    to the `expenses` state, but for our demo application, this isn’t necessary.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchExpenseById` 方法有 `id` 和 `select` 参数。`id` 参数是必需的，而 `select` 属性是可选的，默认值为
    `false`。该方法首先通过 API 调用来通过 ID 获取费用。当 API 响应费用时，我们将使用 `expense Subject` 发出一个新值，或者使用
    `BehaviorSubject` 类发出一个值并设置 `selectedExpense` 状态。根据您应用程序的需求，您还可以将获取的费用添加到 `expenses`
    状态中，但对我们这个演示应用程序来说，这不是必需的。'
- en: 'Now, to finish up the get expense by `id` logic, we need to implement the public
    `getExpense` and `selectExpense` methods:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了完成通过 `id` 获取费用的逻辑，我们需要实现公共的 `getExpense` 和 `selectExpense` 方法：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the `getExpense` and `selectExpense` methods are very similar.
    Both methods receive `id` as a parameter and check if the expense with the provided
    `id` parameter can be found inside the current `expenses` state.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`getExpense` 和 `selectExpense` 方法非常相似。两种方法都接收 `id` 作为参数，并检查提供的 `id` 参数是否可以在当前的
    `expenses` 状态中找到。
- en: When the expense is found in the current state, the `next()` method is called
    on the `expense Subject` class or the `selectedExpense` `BehaviorSubject` class.
    When no expense is found in the current `expenses` state, the `fetchExpenseById`
    method is called to get the expense from the backend; in that case, the `fetchExpenseById`
    method will call the `expense Subject` or `selectedExpense BehaviorSubject` class.
    Now that we’ve added everything to get or select an expense reactively, let’s
    add the `updateExpense` method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当在当前状态中找到费用时，会在 `expense Subject` 类或 `selectedExpense` `BehaviorSubject` 类上调用
    `next()` 方法。当在当前的 `expenses` 状态中没有找到费用时，会调用 `fetchExpenseById` 方法从后端获取费用；在这种情况下，`fetchExpenseById`
    方法将调用 `expense Subject` 或 `selectedExpense BehaviorSubject` 类。既然我们已经添加了获取或选择费用的响应式方法，让我们添加
    `updateExpense` 方法。
- en: Updating expenses
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新费用
- en: 'The `update` method will receive `expense` as a function parameter. Next, it
    will make a `PUT` request using `expensesApi` to update the request in the backend.
    After the API responds successfully, the method will update the `expenses` state:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 方法将接收 `expense` 作为函数参数。接下来，它将使用 `expensesApi` 发起 `PUT` 请求来更新后端中的请求。在
    API 成功响应后，该方法将更新 `expenses` 状态：'
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we make the API request and use the `next()` method on `expenses
    BehaviorSubject` to update the `expenses` state. As an argument for the `next()`
    method, we take the `currentExpenses` getter and use the `map()` function to replace
    the updated expense.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们发起 API 请求并在 `expenses BehaviorSubject` 上使用 `next()` 方法来更新 `expenses`
    状态。作为 `next()` 方法的参数，我们使用 `currentExpenses` 获取器并使用 `map()` 函数来替换更新的费用。
- en: Now that we’ve added the methods to add, update, delete, and get expenses, let’s
    finish up the store with some additional state and methods to reset the state.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了添加、更新、删除和获取费用的方法，让我们通过添加一些额外的状态和重置状态的方法来完成这个存储。
- en: Extending ExpensesStore
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展 ExpensesStore
- en: 'We will start by adding an additional piece of state to manage whether we show
    prices, including or excluding VAT. We can do this by creating a new `BehaviorSubject`
    class and a method to adjust the `BehaviorSubject` class’ value:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加一个额外的状态来管理是否显示价格，包括或排除增值税。我们可以通过创建一个新的 `BehaviorSubject` 类和一个调整 `BehaviorSubject`
    类值的方法来实现这一点：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the VAT state is just a simple Boolean indicating whether we
    show the prices, including or excluding VAT.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we need some logic to reset our application state and clear the selected
    product state. We will create two different methods for this `resetState` to reset
    all the states to the default values. We’ll use a `clearExpenseSelection` method
    to clear the `selectedExpense` state:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This was the last piece of the puzzle for our expense store. You created a simple
    yet effective state management solution to handle the global application state
    of the expenses. You did so using the RxJS `Subject` and `BehaviorSubject` classes.
    This `ExpensesStore` can now be used as the single source of truth for all your
    expense data throughout your application.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: If a component needs the current state of some expense data, it will come from
    this `ExpensesStore`. When your application grows, and you have other entities
    with a state besides the expenses, such as users, reports, or settings, each entity
    will have a store file to manage the state of that entity.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve created a state management solution using RxJS, we will start
    building the facade service and connect the view layer with the store through
    the facade.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Connecting your state management and view layer with a facade service
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have a state management solution in place, it’s time to connect
    it to the view layer of your application. As mentioned several times in this book,
    the best approach is to create a facade service for this. This facade provides
    an additional layer of abstraction, providing a simple interface for your view
    layer to interact with the application state. *Figure 8**.1* provides a visual
    representation of the facade service and how data flows from your state through
    the facade into your components:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Data flow with a facade, components, and state](img/B21625_08_001.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Data flow with a facade, components, and state'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, your components make a simple request to the facade service,
    and the facade will collect the data from your different state services and send
    it back to the component in the format that the component needs. This ensures
    your components only have one dependency and your facade will host all other necessary
    dependencies to retrieve the data you need in your components.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Creating a facade service
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start by creating a `facades` folder inside the `lib` folder of your `expenses`
    `data-access` library. The new `facades` folder will be located in the same folder
    as the `store` folder.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Inside the new `facades` folder, you must create a file named `expenses.facade.ts`
    with an injectable class called `ExpensesFacade`. You can use the Nx generator
    to create a service and rename it or create the facade manually. Also, add an
    export inside the `index.ts` file so that you can consume the facade outside the
    library.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re finished, you should have the following in the `expenses.facade.ts`
    file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating the facade interface
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, create a file next to the `expenses.facade.ts` file named `expensesFacade.interface.ts`.
    In this interface, we will declare the blueprint of our facade. So long as your
    facade implements this interface, you can switch the implementation of the state
    without touching the component layer. If you change the interface, you also need
    to adjust the component layer.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'In the interface file, declare the following interface:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After defining the interface, we can start with the facade service. Start by
    implementing the interface:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, you want to inject `ExpensesStore` inside the facade service:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we’ve injected the store, we will add a method to fetch the expenses.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the facade with the store
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add a simple method to the facade that simply calls the `fetch` method
    inside the store:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we will create a method to get the fetched expenses. But before we do
    this, we will create a new interface called `ExpensesViewModel`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can also adjust `ExpenseModel` a bit and rename the `amountExclVat` property
    to `value`. If you’re using VS Code, you can select the property and press *F2*
    to rename it. When you rename using the *F2* key, the property will be renamed
    in every instance (besides the HTML templates).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve created `ExpensesViewModel` and adjusted `ExpenseModel`, let’s
    create the `getExpenses` method inside the facade:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, there is quite a lot going on in this method. This is one of
    the reasons why using a facade service is beneficial.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'In a large application, the chances are high that you need this `ExpensesViewModel`
    in multiple components. Instead of having to define this chunk of logic in multiple
    component classes, you can define it inside the facade, and inside the component
    layer, you can use a simple function call, keeping your components simple and
    clean. Also, when you need to adjust the logic, you only have to do it in this
    single place instead of in multiple component classes. Now, to better understand
    what we did inside the function, let’s break it down line by line:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: We started by naming the method `getExpenses` and specified that it would return
    an `ExpensesViewModel` Observable.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `getExpenses()` method, we returned an Observable using the `combineLatest()`
    method.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `combineLatest()`, we combined the `expenses$` and `inclVat$` Observables
    from the store and applied the RxJS `pipe()` function to `combineLatest()`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `pipe()` function, we applied two operators, starting with the `distinctUntilChanged()`
    operators, so that we only emitted a new value when the values changed.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we used the `map()` operator to map the two Observable streams into `ExpensesViewModel`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Depending on the state of the `inclVat$` Observable, we returned the expense
    value properties and the total property, including or excluding VAT.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you’ve created the `fetch-` and `getExpenses` methods inside the facade,
    let’s adjust the expenses overview page.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the expenses overview page
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside the page component, start by injecting the facade service:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After injecting the facade, you can fetch the expenses inside the `ngOnInit()`
    method of the page component:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, you can clean up the component. In [*Chapter 7*](B21625_07.xhtml#_idTextAnchor129),
    we used a Signal with mocked data for `expenses`; in this section, we will use
    the expenses we receive from the `getExpenses` method inside the facade. Start
    by reassigning the `expenses` property, like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After reassigning the `expenses` property, you will get some errors inside the
    component and template file of the expenses overview page because you don’t have
    the `expenses` Signal anymore. Go ahead and remove the `totalInclVat` computed
    Signal; you can also remove the Signal effect in the component and clear out the
    logic inside the `onAddExpense` method.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to make some adjustments to the HTML template.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding an `if-else` block around the HTML table:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Inside the `if` block, you will use the `expenses` property with an `async`
    pipe so that you can retrieve `expenses` from the facade and use those values
    within the template.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the `if` block, you need to adjust the `for` block inside the
    HTML template and switch the `expenses` Signal for the `expenses` property you
    retrieved from the facade:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After adjusting the `for` block, you need to adjust the table rows to correctly
    reflect the new model structure and to improve the UI. Do this by rounding the
    value to two decimals, and then adding a `currency` pipe and percentage (`%`)
    sign:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Lastly, you need to switch the `totalInclVat` computed Signal we used inside
    the template for the `total` property on `expensesVm`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we adjusted the text to `total` because we now show the total, including
    or excluding VAT, depending on the global state. After making these adjustments,
    you should see the total amount and expenses inside the table again, only now
    using RxJS and the global state instead of the Signals with mocked `expenses`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Next, you want something to toggle the VAT so that you can see the expenses
    and total amount being automatically updated when the VAT status changes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a new method inside the facade service:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, this is just a simple method calling the `adjustVat` method
    inside the store. This will change the `inclVat` `BehaviorSubject` class inside
    the store. This, in turn, will trigger the `combineLatest()` method we used inside
    the `getExpenses` method inside the facade.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: So, when you change the VAT status, `ExpensesViewModel`, which we retrieved
    through the `getExpenses` method, will automatically be updated and show the total
    and expense amounts, including or excluding VAT, depending on the state.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve added the method to adjust the VAT, you also need something to
    retrieve the `inclVat` status inside the facade. You can simply create a property
    for this and assign it with the `inclVat$` Observable from the store:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After adding the method and property to adjust and retrieve the VAT status,
    let’s add a toggle inside the HTML template of the expenses overview page to adjust
    the VAT state:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: I’ve added the VAT toggle next to the `inclVatSelector$` from the facade combined
    with an `async` pipe to set the `checked` property of the VAT toggle.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also added a `click` event to the `input` value of the toggle to call
    the `adjustVat` method in the facade. If you click on the toggle, you will see
    the expense amounts in the table and the total amount in the table summary change
    to include or exclude the VAT amount, depending on the VAT state.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: As you might have noticed, this is a very reactive approach because everything
    reacts upon the state changes automatically. The code is also very performant
    because the updates are performed in a non-blocking manner, allowing all your
    code to keep running.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve implemented the `getExpenses` method and the VAT status, let’s
    finish up the facade service.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Finishing up the facade service
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For all the other methods exposed by the store, you can add simple methods inside
    the facade service that call them from the store, similar to what we did with
    the `fetchExpenses` and `adjustVat` methods.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `selectedExpense` and `expense` properties inside the store, you need
    to add a selector property inside the facade service. Because we will also map
    the expenses emitted by `selectedExpense` and `expense`, we will abstract the
    mapping behavior into a new function so that we can reuse it:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, you can adjust the mapping of the expenses inside the `getExpenses` method
    like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Lastly, we will add the selector properties for `selectedExpense` and `expense`,
    starting with `expenseSelector$`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, for `expenseSelector$`, we used the `withLatestFrom()` operator
    and didn’t use `combineLatest()`. We did this because `expenseSelector$` will
    only emit a value as an event using the `Subject` class instead of `BehaviorSubject`.
    There is no state here, and we don’t want the selector to emit a new value when
    the VAT toggle changes. We only want it to respond when the `expense` `Subject`
    class emits a value, and when that happens, take the current value of the `inclVat$`
    Observable to map the expense.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'The `selector` property for `selectedExpense` will use the `combineLatest()`
    function to combine the `selectedExpense$` Observable and the `inclVat$` Observable,
    like so:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: For `selectedExpenseSelector$`, we used the `combineLatest()` function because
    the selected expense is stateful and persists in our store. We might use the selected
    expense in our view while we can change the VAT, and because of that, we want
    it to react when the VAT status changes and update the amount in the view. Because
    we want `selectedExpense` to be reactive on the VAT status as well, we used the
    `combineLatest()` operator, which triggers whenever one of the combined Observables
    emits a new value.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: This was the last part of implementing the state management solution using RxJS.
    This approach to state management is commonly used within smaller Angular applications
    where the state isn’t used in many different components and services. The solution
    offers good reactivity and is easy to build and understand.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to convert this state management solution so that it uses
    Signals instead of RxJS. Using Signals will simplify your facade service and component
    layer. It also allows Angular to perform better change detection. If you need
    to combine many data streams with tailored logic and apply modifications to them,
    the RxJS approach will fit your application better.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: That said, using Signals is much simpler for simple state and data streams.
    Even if you need to combine some data streams without needing to have too much
    control over how this happens, the Signal approach will be best suited for you.
    Signals are the way to go for your state if you find yourself only using `combineLatest()`
    and `withLatestFrom()` and some basic operators such as `map()` and `filter()`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Handling global application state using Signals
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To convert your state management solution so that it uses Signals instead of
    RxJS, you must change the `BehaviorSubject` classes in the `ExpensesStore` to
    Signals. You still want to ensure that the state only emits a new value when it’s
    set in the store; you don’t want to be able to set the state outside of the store.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we will create a private `WritableSignal` and a public Signal
    that is read-only. You can change all the `BehaviorSubject` classes to Signals
    using the following syntax:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we declared a private Signal using the `signal()` function. Declaring
    a Signal in this manner will create `WritableSignal`. In the line after, we created
    a public property and assigned it with `WritableSignal` but cast it to a `Signal`
    type with the `as` keyword; here, the `Signal` type is read-only. After adjusting
    all your `BehaviorSubject` classes, you need to change the references you had
    to them inside the store.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by removing the `currentExpenses` getter and change all instances of
    `this.current` **Expenses** to the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, inside the `adjustVat()` function, change `!this.incluVat.value` to the
    following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Lastly, you need to adjust all instances where you used the `next()` method
    on one of your `BehaviorSubject` classes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how to convert the `resetState()` function:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, change all other instances of the `next()` method to the `Subject` class
    and the `set()` method. That’s all we need to do for `ExpensesStore`; you now
    have state management that uses Signals instead of RxJS `BehaviorSubject` classes.
    After adjusting the state, we need to change `ExpensesFacade` so that it can work
    with Signals instead of Observables.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Normally speaking, one of the advantages of a facade service is that it is an
    abstraction layer, and we don’t need to touch the component layer when changing
    the state management solution. But in this situation, we need to adjust both the
    facade service and the component layer; this is because we will be changing the
    interface of the facade service.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: In theory, we could maintain the interface and still return Observables by converting
    the Signals back into Observables in the service; doing so would allow you to
    leave the component layer untouched. However, we want to utilize the full power
    of these Signals and also implement them in our components so that Angular can
    perform better change detection and we can make our templates synchronous. To
    achieve this, we need to return Signals from our facade service instead of Observables,
    changing the interface of the facade.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start changing the facade by changing the interface. Replace the `getExpenses`
    method inside the interface with an `expenses` property and adjust the `selectedExpenseSelector$`
    and `inclVatSelector$` properties like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After making the preceding adjustments in the interface, you can start implementing
    the interface inside the facade service. To implement the changes in the interface,
    remove the `getExpenses` method. Instead of the `getExpenses` method, you must
    create a computed Signal that returns the same value as the `getExpenses` method
    did:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, the computed Signal is very similar to the `getExpenses` method.
    The main difference is that we no longer need the `combineLatest()` and `map()`
    operators. We can now use the `inclVat` and `expenses` Signals inside the computed
    Signals.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: When one of the two Signals receives a new value, the computed Signal will automatically
    compute a new one. The computed Signals can be seen as `combineLatest()` of the
    Signals realm. The equivalent of `withLatestFrom()` would be using a Signal inside
    the computed Signal and wrapping the Signal using the `untracked()` function,
    as we discussed in [*Chapter 7*](B21625_07.xhtml#_idTextAnchor129).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the computed Signal, we need to implement the `inclVat` and `selectedExpense`
    Signals inside the facade service. This is pretty straightforward – you simply
    define the property and assign it with the Signal from `ExpensesStore`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we assign the property with the Signal from the store; we do not call
    the Signal by adding function brackets, `()`. We don’t add these function brackets
    because we want to use the actual Signal inside the component layer, not the `Signal`
    value. If you were to call the Signal here and retrieve the value inside the component
    layer, the update behavior wouldn’t work as expected, and the view wouldn’t be
    updated when your state changes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do is adjust `ExpensesOverviewPageComponent` and its template.
    Inside the component class, you can adjust the `expenses` property and assign
    it with the `expenses Subject` class from the facade instead of the `getExpenses()`
    function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, inside the HTML template, you need to change `inclVatSelector$` to `inclVat()`,
    remove the `async` pipe, and change `expenses` with the `async` pipe to `expenses()`
    without the `async` pipe:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With the preceding changes, you’ve adjusted the component class and the HTML
    template to use Signals instead of Observables. As you can see, using the Signal
    approach is slightly simpler and needs fewer lines of code. It also makes your
    HTML template synchronous and helps Angular to perform better change detection,
    leading to better performance.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The flip side is that you have less control over the data streams, and it’s
    not as easy to modify the stream before it reaches your application logic. Compared
    to RxJS, Signals also offers less control when you want to combine different streams
    of data, so depending on your needs, you can decide whether to use Signals or
    RxJS.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: You can also make a hybrid solution and convert Observables into Signals, giving
    you the best of both worlds. In that case, you can use the RxJS operators you
    need and still consume the values as Signals in your component classes and HTML
    templates.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’ve learned how to create a state management solution using RxJS
    and Signals. You made a facade service as an additional abstraction layer and
    learned when you have to change the component layer and when you only have to
    change the state management layer when working with a facade service.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Both state management solutions we’ve created work well for small applications
    with relatively simple global states. The RxJS method is implemented a lot, and
    with the popularity of Signals, I imagine the Signal approach will be implemented
    a lot as well. But when you have a larger application where the state is used
    in a lot of components and services, you will run into issues with our current
    implementation. In the next section, you will learn about these issues and how
    to resolve them.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The problem with using RxJS or Signals for global state management
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While our current state management solution is used in many applications and
    works well for our current application, there’s a huge problem: our current global
    state management solution isn’t immutable.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: You cannot modify your `BehaviorSubject` classes or Signals from outside the
    store, so in that sense, it is immutable. Also, when using primitive values for
    your state, the state itself is immutable. However, when you’re using reference
    objects as values for your `BehaviorSubject` classes or Signals, the state itself
    isn’t immutable.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: When you use an array or object for your state and retrieve the state through
    `BehaviorSubject` or `Signal`, you can modify the value of the state unintentionally.
    When you adjust the retrieved state object within a component or service class,
    the value of `BehaviorSubject` or `Signal` is also modified!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: This is also the reason why we used the `structuredClone()` function inside
    our `mapExpenses()` function. If you remove `structuredClone()` and toggle the
    VAT a couple of times in the view, you will notice that the amounts keep increasing
    instead of adding and removing the VAT. This happens because we modify the object
    inside `Signal` or `BehaviorSubject` whenever we adjust it inside the facade service.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: The next time we retrieve the state, it still has the adjusted values instead
    of the real state we expect. Relying on developers to always clone the object
    when it’s modified is risky and not how you want it to be.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Allowing your state to be modified outside the store and without calling the
    `next()` or `set()` method on `BehaviorSubject` or `Signal` opens the door for
    unintended state changes, resulting in a corrupted state. When your state is not
    what you expect it to be, you can display incorrect values to the user and perform
    actions within your code that aren’t intended.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: For small applications where the state isn’t used in many places, this might
    be a manageable problem, but when your application grows, your state is used in
    multiple places and often the retrieved state is modified locally, so the problem
    will surface quickly.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'To have a state management system that is truly immutable, reactive, and can
    handle the state of any application no matter how large it becomes, your best
    bet is to go with a good library that focuses on state management. Some popular
    choices within the Angular community are as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: NgRx
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NgXs
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxAngular
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Akita
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular Query
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these libraries have their advantages and disadvantages. My personal
    favorites are RxAngular, NgXs, and NgRx. NgRx is by far the most commonly used
    state management solution within the community and offers support for Observable
    and Signal-based state management. RxAngular is gaining a lot of popularity and
    has a very intuitive approach for reactively managing state with little to no
    boilerplate code; it also enables you to ditch ZoneJS and boost the performance
    of your application.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will convert our state management solution into an NgRx
    state management solution. I’ve picked NgRx because this is the most commonly
    used solution, but I recommend that you investigate some of the other solutions.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Handling global application state with NgRx
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working on enterprise software or an application with extensive or complex
    state management, you should use a battle-tested state management solution that
    provides true immutability, unidirectional data flow, and good tools to perform
    side effects and modify the state securely. The best way forward is to use a battle-tested
    library that focuses on state management.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'The most commonly used library for state management within the Angular community
    is **NgRx**; it has a huge community and all the tools you might need to handle
    even the most complex state. NgRx implements the Redux pattern and consists of
    four main building blocks: actions, reducers, selectors, and effects.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will change our custom-made state management solution so
    that it uses NgRx. We will keep the store file we made in the previous section
    for reference purposes and build the NgRx state management in new files.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: In a production environment, you should remove the old unused store file. Inside
    the facade service, we will simply replace the current implementation with the
    NgRx implementation, and this time, we will not adjust the `IExpensesFacade` interface,
    meaning we do not have to change our component layer. Let’s go over the step-by-step
    process of implementing NgRx state management.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Installing the @ngrx/store and @ngrx/effects packages
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start implementing NgRx state management, you need to install some packages
    by running the following `npm` commands in the root of your *Nx monorepo*:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: After installing the `@ngrx/store` and `@ngrx/effects` packages, you need to
    create some folders and files. There is an Nx generator to create the initial
    setup for your NgRx store, but we will set up everything manually so that you
    get a better understanding of how everything works and what’s needed when using
    NgRx.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a folder named `state` inside the `lib` folder of the expenses
    data-access library (next to the `stores` folder). Inside the newly created `state`
    folder, create another folder named `expenses`. Now, inside the newly created
    `expenses` folder, create these five files:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '`expenses.actions.ts`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expenses.reducers.ts`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expenses.selectors.ts`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expenses.effects.ts`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index.ts`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you’re done creating the folders and files, you can start adding some actions
    inside the `expenses.actions.ts` file.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Defining your first NgRx actions
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`createAction()` function, which the `@ngrx/store` package exposes to you.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: You must provide the `createAction()` function with a description of the action
    and, optionally, with a `props()` function to define the properties you have to
    provide the action with to perform the action.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use the `createActionGroup()` function to create multiple
    events and group them under a single constant. We won’t use the `createActionGroup()`
    function, but you can always read about it yourself in the official NgRx documentation:
    [https://ngrx.io/docs](https://ngrx.io/docs).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with a simple task: defining an action to fetch the expenses from
    the API. You don’t have to provide any argument to fetch the expenses, so the
    action will only contain a description. The descriptions of NgRx actions commonly
    use the following naming conventions:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Inside the `expenses.actions.ts` file, define the action to fetch expenses,
    like so:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Commonly, when defining NgRx actions that include API requests, you also define
    a success and failure action. So, go ahead and define an action for when fetching
    the expenses succeeds or fails:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we declared two actions; both received a description, and the `fetchExpensesSuccess`
    action also received the `props()` function. Inside the arrow brackets, we defined
    the type of the `props()` function – in this case, an object with an `expenses`
    property containing an `ExpenseModel` array. The `fetchExpensesSuccess` action
    needs `expenses` as `props()` because we will use the `fetchExpensesSuccess` action
    to update the state with the expenses that are retrieved from the API request.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve added the `fetchExpenses`, `fetchExpensesSuccess`, and `fetch`
    **ExpensesFailed** actions, let’s update the `index.ts` file inside the `state/expenses`
    folder by defining an export for our expense actions:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After adding the export to the `index.ts` file, we can move on to the next piece
    of the puzzle. The next step is to create an NgRx effect that will make an API
    request to fetch the expenses and dispatch the success of the failed action accordingly.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first NgRx effect
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will create your `expenses.effects.ts` file. Effects allow you to perform
    side effects when an action is dispatched. Effects are commonly used for tasks
    such as fetching data, dispatching other events, or updating local storage. Side
    effects isolate some logic away from your components, allowing you to keep the
    component classes as simple as possible.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: The first effect you will create is the `fetchExpeses$` effect. This effect
    will run whenever the `fetchExpenses` action is dispatched. The effect will then
    make an API request to fetch the expenses and map the result of the API call into
    a newly dispatched action – the `fetchExpensesSuccess` or `fetchExpensesFailed`
    action.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, create an injectable class inside the `expenses.effects.ts`
    file named `ExpensesEffects`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After creating the `ExpensesEffects` class, you need to inject the `Actions`
    class from `@ngrx/effects` and `ExpensesHttpService` inside your `ExpensesEffects`
    class:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, use the `createEffect()` function that’s exposed by `@ngrx/effects` to
    create your first effect:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding code snippet, you created your first effect named `fetchExpenses$`.
    As you can see, there is quite a lot going on there, so let’s break it down line
    by line.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: We started by defining a property named `fetchExpenses$` and assigned it with
    the `createEffect()` function. Inside the `createEffect()` function, we defined
    a `callback` function that returns the `this.actions.pipe()` method. The `this.actions`
    instance refers to the `Actions` class we injected in the previous code block.
    The `Actions` class emits the actions we dispatched and extends the Observable
    class, meaning you can use the RxJS `pipe()` function on the class.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `pipe()` function’s chained-on actions, we defined a couple of operators,
    starting with the `ofType()` operator. The `ofType()` operator is a filter operator
    that filters out actions by the action type. Inside the function brackets of the
    `ofType()` operator, you defined the type of an action. In our case, we provided
    it with the type of our `fetchExpenses` action. Here, `ExpenseAction` is used
    to export and import our actions, `fetchExpenses` is the property name we gave
    our action, and `type` is a property that’s exposed on all the actions we created
    with the `createAction()` function.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the `fetchExpenses` action is dispatched, we will move on to the next
    operator inside the `pipe()` function of our effect. The next operator is the
    `switchMap()` operator, which is used to flatten the additional Observable stream
    that was created by the HTTP request to fetch the expenses.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Inside the callback of the `switchMap()` operator, we made the HTTP request
    and added an additional `pipe()` function to the HTTP request. Inside the `pipe()`
    function of the HTTP request, we used the `map()` operator to map a successful
    HTTP response to the `fetchExpensesSuccess` action, and we provided the `fetchExpensesSuccess`
    action with the expenses that were retrieved from the API response. If the API
    request fails, we use the `catchError` operator to map it to the `fetchExpensesFailed`
    action.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The `createEffect()` function will automatically dispatch the returned action;
    this is why we don’t have to call the `dispatch()` function explicitly but simply
    return an Observable with the action we want to dispatch. In our case, this is
    the `fetchExpensesSuccess` or `fetchExpensesFailed` action.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, you need to export the effects inside the `index.ts` file inside the
    `state/expenses` folder:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now that we’ve defined the actions and created an effect to handle the `fetchExpenses`
    action and dispatch the `fetchExpensesSuccess` and `fetchExpensesFailed` actions,
    let’s cover the next building block of our NgRx state by creating our state and
    reducer functions.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Creating your initial state and first reducer functions
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve created some actions and your first effect, you need a state
    to perform these actions on and `expenses.reducer.ts` file, you will define your
    initial state object and reducers to adjust the state when actions are dispatched.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new interface for your state object inside the `expenses.interface.ts`
    file:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After creating the interface, you can create your initial state object inside
    the `expenses.reducer.ts` file:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: After defining the interface and initial state object, you can create the reducer
    by using the `createReducer()` function. The `createReducer()` function takes
    in your initial state as a parameter and reduces your state based on dispatched
    actions.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by defining the reducer function and providing it with the initial
    state:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding code snippet, we created a property named `expensesReducer`
    and assigned it to the `createReducer()` function. Inside the arrow brackets,
    we provided the type the reducer will modify; in our case, this is the `ExpensesState`
    interface. Inside the function brackets, we provided the initial state object,
    `initialExpensesState`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to add functions inside the `createReducer()` function to update
    the state when an action is dispatched, starting with the `fetchExpenses` action.
    To update the state, you must define an `on()` function and provide the `on()`
    function with a reference to the action it needs to react on, as well as a `callback`
    function to modify the state:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we’ve added an `on()` function underneath the initial state object inside
    the `createReducer()` function. We provided the `on()` function with `ExpenseActions.fetchExpenses`
    so that it reacts when `fetchExpenses` actions are dispatched.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: After the reference to the action, we declare a `callback` function to modify
    the state. Inside the function brackets of the `callback` function, you can define
    a parameter that will be populated with the current state object for you; it’s
    the convention to name this parameter `state`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we return a new state object by spreading the current state into the
    object and setting the state properties we want to change. In the case of the
    `fetchExpenses` action, we only want to set the `isLoading` state property to
    `true`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can add the reducer function for the `fetchExpensesSuccess` and `fetch`
    **ExpensesFailed** actions underneath the `reducer` function for the `fetchExpenses`
    action:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we’ve declared two more `on()` functions and provided them with the `fetchExpensesSuccess`
    and `fetchExpensesFailed` actions. Inside the function brackets of the `callback`
    function of the `fetchExpensesSuccess` action reducer, we used destructuring to
    extract the `expenses` object from the dispatched action. As you might remember,
    you defined the `fetchExpensesSuccess` action to take the expenses that were fetched
    from the API request as a parameter.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Next, inside the `callback` function, we updated the `expenses` property of
    the state, set `isLoading` to `false`, and set `error` to `null`. If we fetch
    the `expenses` property successfully, there will be no errors to show to the user.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: For `fetchExpensesFailed`, we don’t provide parameters when we dispatch the
    action, so we only provide the state object in the callback, just like we did
    with the `fetchExpenses` action reducer. Inside the callback of the `fetchExpensesFailed`
    reducer, we set `isLoading` to `false` and set an error message.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’ve created your initial state and a `reducer` function for each
    of the actions you defined. When the `fetchExpenses` action is dispatched, you
    use a `reducer` function to set the `isLoading` state to `true`. When you’re done
    fetching, and the `fetchExpensesSuccess` or `fetchExpensesFailed` action is dispatched,
    you use a `reducer` function to set the `isLoading` state to `false` and update
    the `expenses` or `error` state accordingly. You can use the `isLoading` state
    to show a spinner, the `error` state to show an error message, and `expenses`
    to display your list of expenses.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, underneath `expensesReducer`, you need to define a unique key for the
    expenses state:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As a last step, you need to add the reducer file inside the `index.ts` file:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After exporting the file inside the `index.ts` file, your reducer file is ready.
    Before moving on to the last building block of NgRx state management, which is
    selectors, we will add our reducer to the `ApplicationConfig` object of our `expenses-registration`
    app. Inside the `app.config.ts` file, add the following inside the `providers`
    array:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the preceding code, we added the `provideStore()` function and the `provideState()`
    function inside the `providers` array. Inside the `provideState()` function, we
    added an object with a name and a `reducer` property. The name receives the unique
    key we provided inside the reducer file and the `reducer` property receives the
    `expensesReducer` function.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve created the reducer and added the configuration inside the
    `ApplicationConfig` object, it’s time to move on to the last part of our NgRx
    state: selectors.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Defining NgRx selectors
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`expenses` state:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here, we used a `createFeatureSelector()` function and provided it with the
    key we declared inside the `expenses.reducer.ts` file. Next, we can define additional
    selectors with the `createSelector()` function to retrieve specific parts of the
    `expenses` state:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the preceding code snippet, we declared three additional selectors – one
    to retrieve the `expenses` state, one to retrieve the `error` state, and one to
    retrieve the `isLoading` state. To finish the selectors, let’s export the file
    inside the `index.ts` file:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'After adding this `export`, also export the `index.ts` file from your `state`
    folder; this can be found in the `index.ts` file of the `data-access` library:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now that we have all the parts of our NgRx state management system in place,
    it’s time to adjust the facade services.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the facade service so that they use NgRx state management
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will adjust the `fetchExpenses` method and the `expenses` Signal inside
    the facade service. We haven’t created actions, effects, reducers, and selectors
    for all the other properties yet. To convert the facade service, we need to start
    by injecting the `Store` class, which is exposed to you by the `@``ngrx/store`
    package:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'After injecting the `Store` class, we can adjust the `fetchExpenses` function
    in the facade service. Simply remove `this.expensesStore.fetchExpenses()` inside
    the `fetchExpenses` function and dispatch the `fetchExpenses` action:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, you used the `Store` class and called the `dispatch()` function on it
    to dispatch an action. After adjusting the `fetchExpenses()` method, it’s time
    to adjust the `expenses` computed Signal.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Inside this computed Signal, we’re using the `expenses` `Subject` class from
    the store. We need to change this for a Signal based on `expenses` from your NgRx
    state.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: To adjust the `expenses` computed Signal, you need to create a new property
    to retrieve the `expenses` state from the NgRx state and transform it into a Signal.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'We can retrieve `expenses` from the NgRx state through the `selectExpenses`
    selector using the `select()` method on the `Store` class. Using the `select()`
    method on the `Store` class combined with our selector will return the `expenses`
    state as an Observable, so we need to use the `toSignal()` function to transform
    it into a Signal:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now that we have the `expenses` state from the NgRx state as a Signal inside
    the facade service, we can adjust the `expenses` computed Signal so that it uses
    `expenses` from the NgRx state instead of `expenses` from the store. Simply replace
    the `this.expensesStore.expenses()` instances inside the computed Signal with
    `this.expensesSignal()` and that’s it.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’ve changed everything you need to change and are fetching and
    retrieving the `expenses` state through the NgRx actions and state. Before moving
    on, let’s add one more piece of NgRx state together so that you can understand
    everything that’s going on in NgRx state management.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Adding additional actions, effects, reducers, and selectors
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get a better grasp of the NgRx state management we’ve built, let’s extend
    it a bit with additional actions, effects, reducers, and selectors.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: We will start by adding an action to adjust the `inclVat` state, just like we
    did before, by adding an action. Because the `inclVat` state only entails a state
    change and no HTTP request, you only need an action to adjust the `inclVat` state
    and no success and failed actions because you aren’t making an HTTP request that
    can succeed or fail. The action to adjust the `inclVat` state also doesn’t need
    a parameter because we will simply change the state to what it currently isn’t.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'You can simply create an action and provide it with a description:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: No effect is needed for the `inclVat` state change because you don’t perform
    an HTTP request or need to dispatch additional actions. However, you do need a
    new reducer function inside the `expensesReducer` to adjust the state object.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `createReducer()` function of `expensesReducer`, add an additional
    `on()` function to change the `inclVat` state when the `adjustVat` action is dispatched:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As you can see, upon dispatching the `adjustVat` action, we will change the
    `inclVat` state to what it currently isn’t. After adding the `reducer` function,
    you need to add a selector to retrieve the `inclVat` property from the state object:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now, the only thing that is left to do is adjust the facade service and use
    the `inclVat` property from the NgRx state instead of the Signal in `expenses.store.ts`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'To adjust the facade service, start by adding an `inclVat` property and use
    the `toSignal()` function to convert the `selectInclVat` selector into a Signal:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: After adding the `inclVat` property, all you have to do is change `this.expensesStore.inclVat()`
    to `this.inclVat()` inside the `expenses` computed Signal.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, you need to adjust the `adjustVat()` function inside the facade service.
    Remove what is currently in the function and replace it with a dispatch of the
    `adjustVat` action:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: After adding the preceding code, you’ve made all necessary changes and you’re
    now using the `inclVat` property from the NgRx state instead of the Signal from
    `expenses.store.ts`. Now, all you need to do is add the rest of the actions, effects,
    reducers, and selectors so that you can remove the store from the facade service
    entirely and use the NgRx state for everything.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'As an exercise, you can try to add the additional actions, effects, reducers,
    and selectors yourself based on what we did for the list of expenses. After adding
    the additional actions, effects, reducers, and selectors, you should be able to
    fully adjust the expenses facade and remove the store implementation completely.
    If you get stuck or simply want to copy the code, you can get it from this book’s
    GitHub repository: [https://github.com/PacktPublishing/Effective-Angular](https://github.com/PacktPublishing/Effective-Angular).'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you explored NgRx and learned how to use it to manage the state
    of your application. We discussed the default NgRx implementation to manage the
    state. Note that the library has more solutions and packages to offer, but this
    is outside the scope of this book.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Some of the other things NgRx has to offer are `signalStore` and `signalState`,
    two solutions that you can use to manage your state using NgRx and signals without
    having to convert Observables using `toSignal()`, which is what we did in this
    section. There are useful RxJS operators in the NgRx library. We only used the
    `ofType()` operators, but NgRx offers more utility operators, such as `concatLatestFrom()`
    and `tapResponse()`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: NgRx also offers solutions to manage component state and to dispatch actions
    of access state on route changes. I highly recommend exploring NgRx and other
    state management libraries on your own.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve learned a lot in this chapter and brought everything we learned in [*Chapter
    7*](B21625_07.xhtml#_idTextAnchor129) together. You learned what state management
    is and why you need a good state management solution. You also learned about immutability,
    unidirectional data flow, and side effects. After some theory, you started building
    a state management solution using RxJS’s `BehaviorSubject` and `Subject` classes.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: When you finished building the state management solution using RxJS, you created
    a facade service that connects your component layer to the data-access and state
    management layers of your application. To end your custom state management solution,
    you converted the RxJS state implementation into a Signals implementation, further
    simplifying your component layer and facade service.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned about the shortcomings of using RxJS and Signals for your
    state management solution and replaced them with an NgRx implementation that uses
    actions, effects, reducers, and selectors.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn how to improve the performance and security
    of your Angular applications.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Part 3:Getting Ready for Production with Automated Tests, Performance, Security,
    and Accessibility
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last part, you’ll learn how to improve the performance of your Angular
    applications and make them more secure and accessible for everyone. Starting with
    performance, you’ll do a deep dive into Angular’s change detection mechanism,
    learning how Angular detects changes and what actions you can take to reduce the
    number of change detection cycles. When you know how change detection works in
    detail, you’ll learn how to prevent other factors from impacting the performance
    of your Angular applications. Then, you will explore some common security risks
    when developing Angular applications and how to mitigate them. Furthermore, you’ll
    dive into accessibility, making your application content translatable using Transloco
    and learning how to develop applications accessible to users from different locations
    and abilities. Additionally, you’ll learn how to write and run unit tests using
    Jest, and end-to-end tests using Cypress, giving you the confidence to deploy
    your changes without breaking anything. Finally, you’ll make some final improvements,
    learn how to analyze and optimize your bundle sizes, and automate your deployment
    process.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21625_09.xhtml#_idTextAnchor170), *Enhancing the Performance
    and Security of Angular Applications*'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B21625_10.xhtml#_idTextAnchor185), *Internationalization, Localization,
    and Accessibility of Angular Applications*'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21625_11.xhtml#_idTextAnchor200), *Testing Angular Applications*'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B21625_12.xhtml#_idTextAnchor219), *Deploying Angular Applications*'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
