- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Enhancing Your Applications with Directives, Pipes, and Animations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指令、管道和动画增强您的应用程序
- en: When building frontend applications, we often need to enhance, transform, add,
    remove, or replace DOM elements and values within HTML templates. The Angular
    framework facilitates this through the use of directives, pipes, and animations.
    This chapter will explain how to create and use directives, pipes, and animations
    within Angular. By the end of this chapter, you will know all the ins and outs
    of directives, from directive composition to creating directives with powerful
    selectors. You will also learn about making custom pipes and using the built-in
    pipes effectively. Lastly, we will explore how to build and reuse animations within
    applications built using Angular.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建前端应用程序时，我们经常需要在 HTML 模板中增强、转换、添加、删除或替换 DOM 元素和值。Angular 框架通过使用指令、管道和动画来简化这一过程。本章将解释如何在
    Angular 中创建和使用指令、管道和动画。到本章结束时，您将了解指令的所有细节，从指令组合到使用强大选择器创建指令。您还将了解如何创建自定义管道并有效地使用内置管道。最后，我们将探讨如何在使用
    Angular 构建的应用程序中构建和重用动画。
- en: 'This chapter will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Using and creating Angular directives
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用和创建 Angular 指令
- en: Transforming values using Angular pipes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular 管道转换值
- en: Creating and reusing stunning animations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和重用惊人的动画
- en: Using and creating Angular directives
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用和创建 Angular 指令
- en: 'Directives come in two different types: **attribute directives** and **structural
    directives**. Angular has a list of built-in directives and allows you to create
    your own directive to cover your personal use cases. Since Angular 15, a new feature
    was introduced: **directive composition**. Directive composition allows you to
    assign directives inside component decorators instead of their template. Directive
    composition can also be used to declare directives inside the decorator of other
    directives, resulting in a directive that applies multiple directives simultaneously.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 指令分为两种不同类型：**属性指令**和**结构指令**。Angular 有一个内置指令列表，并允许您创建自己的指令以覆盖您的个人用例。自 Angular
    15 以来，引入了一个新功能：**指令组合**。指令组合允许您在组件装饰器内部分配指令，而不是在它们的模板中。指令组合还可以用于在其它指令的装饰器内部声明指令，从而实现同时应用多个指令的指令。
- en: When you want to use a directive in a standalone component, you need to add
    the directive to the `imports` array of the component. If it’s a built-in directive,
    you can also import `CommonModule`, as `CommonModule` contains all built-in directives.
    When you generate a component using the built-in Nx generator, `CommonModule`
    is added by default. This section will teach you everything about directives,
    starting with attribute directives.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想在独立组件中使用指令时，需要将指令添加到组件的 `imports` 数组中。如果是内置指令，您还可以导入 `CommonModule`，因为 `CommonModule`
    包含所有内置指令。当您使用内置的 Nx 生成器生成组件时，默认会添加 `CommonModule`。本节将向您介绍有关指令的所有内容，从属性指令开始。
- en: Angular attribute directives
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 属性指令
- en: '**Attribute directives** serve as tools for modifying DOM elements’ attributes,
    behavior, or appearance. The directive makes modifications based on logic defined
    in a class decorated with a directive decorator. Attribute directives are assigned
    by adding the selector of the attribute directive to the HTML tag like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性指令**作为修改 DOM 元素属性、行为或外观的工具。指令根据装饰有指令装饰器的类中定义的逻辑进行修改。属性指令通过将属性指令的选择器添加到
    HTML 标签中分配，如下所示：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<div [ngClass]="useRedStyles ? ''red'' : ''blue''">Click</div>'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '<div [ngClass]="useRedStyles ? ''red'' : ''blue''">点击</div>'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: export * from './lib/highlight.directive';
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: export * from './lib/highlight.directive';
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '@Directive({'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '@Directive({'
- en: 'selector: ‹[btLibsUiHighlight]›,'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 'selector: ‹[btLibsUiHighlight]›,'
- en: 'standalone: true,'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 'standalone: true,'
- en: '}) export class HighlightDirective {}'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '}) export class HighlightDirective {}'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: export class HighlightDirective implements OnInit {
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 导出类 HighlightDirective 实现 OnInit 接口 {
- en: private el = inject(ElementRef).nativeElement;
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: private el = inject(ElementRef).nativeElement;
- en: 'ngOnInit() { ElementRef by using constructor injection instead of the inject
    function and then add the background color and text color inside the function
    brackets of the constructor. Alternatively, if you only want to set a style, CSS
    class, or attribute on the host element, you can use the @HostBinding() decorator:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ngOnInit() { ElementRef 通过使用构造函数注入代替 inject 函数，然后在构造函数的功能括号内添加背景颜色和文字颜色。或者，如果您只想在宿主元素上设置样式、CSS
    类或属性，可以使用 @HostBinding() 装饰器：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, to apply this directive, you need to import it in a standalone component
    or NgModule and use the selector on an HTML element like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要应用这个指令，你需要在独立组件或NgModule中导入它，并在HTML元素上使用选择器，如下所示：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '@Input() btLibsUiHighlight!: string;'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '@Input() btLibsUiHighlight!: string;'
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: this.el.style.backgroundColor = this.btLibsUiHighlight;
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: this.el.style.backgroundColor = this.btLibsUiHighlight;
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <div [btLibsUiHighlight]="'orange'">I'm highlighted</div>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div [btLibsUiHighlight]="''orange''">我被高亮显示</div>'
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '@Input(''btLibsUiHighlight'') background!: string;'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '@Input(''btLibsUiHighlight'') background!: string;'
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '@Input() textColor = ''white'';'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '@Input() textColor = ''white'';'
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<div [btLibsUiHighlight]="''orange''" btLibsUiHighlight input is required;
    the additional inputs are optional, but remember to give them a default value;
    otherwise, you might run into errors or unwanted UI behavior. You can make both
    inputs optional with default values; you have to rename the inputs so that no
    input has the same name as the directive selector:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div [btLibsUiHighlight]="''orange''" btLibsUiHighlight输入是必需的；额外的输入是可选的，但请记住为它们提供一个默认值；否则，你可能会遇到错误或不受欢迎的UI行为。你可以将两个输入都设置为可选的，并带有默认值；你必须重命名输入，以便没有输入与指令选择器同名：'
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, you change the directive on the HTML element by removing the square brackets
    and adding the additional inputs only if you want to overwrite the default value:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你通过移除方括号并添加额外的输入来更改HTML元素上的指令，仅当你想要覆盖默认值时：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: private el = inject(ElementRef).nativeElement;
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: private el = inject(ElementRef).nativeElement;
- en: private originalColor = 'black';
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: private originalColor = 'black';
- en: private originalBackground = 'white';
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: private originalBackground = 'white';
- en: '@HostListener(''mouseenter'') onMouseEnter() {'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '@HostListener(''mouseenter'') onMouseEnter() {'
- en: this.originalColor = this.el.style.color;
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: this.originalColor = this.el.style.color;
- en: this.originalBackground = this.el.style.backgroundColor;
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: this.originalBackground = this.el.style.backgroundColor;
- en: this.el.style.backgroundColor = this.background;
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: this.el.style.backgroundColor = this.background;
- en: this.el.style.color = this.textColor;
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: this.el.style.color = this.textColor;
- en: '}'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@HostListener(''mouseleave'') onMouseLeave() {'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '@HostListener(''mouseleave'') onMouseLeave() {'
- en: this.el.style.backgroundColor = this.originalBackground;
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: this.el.style.backgroundColor = this.originalBackground;
- en: this.el.style.color = this.originalColor;
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: this.el.style.color = this.originalColor;
- en: '}'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<div *ngFor directive; as you can see, it’s prefixed with an asterisk. This
    asterisk is typical for structural directives and helps you to distinguish them
    from attribute directives in your HTML templates. Another difference between structural
    and attribute directives is that you can declare multiple attribute directives
    on a DOM element but only one structural directive. If you want to apply multiple
    structural directives, you need to wrap the DOM element with an ng-container tag
    and add the additional directive to the ng-container tag:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div *ngFor>`指令；正如你所见，它以一个星号开头。这个星号是结构指令的典型前缀，有助于你在HTML模板中区分它们和属性指令。结构和属性指令之间的另一个区别是，你可以在DOM元素上声明多个属性指令，但只能有一个结构指令。如果你想应用多个结构指令，你需要用ng-container标签包裹DOM元素，并将额外的指令添加到ng-container标签中：'
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Angular exposes built-in directives and allows you to create your own. First,
    let’s look at some common built-in structural directives
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了内置指令，并允许你创建自己的。首先，让我们看看一些常见的内置结构指令
- en: Common built-in structural directives
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的内置结构指令
- en: 'The most commonly used built-in structural directives are the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的内置结构指令如下：
- en: '`*ngIf`: This is used to conditionally show or hide DOM elements (alternatively
    (to the directive), you can use the new `@if` control flow syntax, as shown in
    [*Chapter 2*](B21625_02.xhtml#_idTextAnchor033)).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*ngIf`：这个指令用于有条件地显示或隐藏DOM元素（或者（相对于指令），你可以使用新的`@if`控制流语法，如[第2章](B21625_02.xhtml#_idTextAnchor033)所示）。'
- en: '`*ngFor`: This is used to create a for loop in your HTML template and output
    a DOM element for each item in an array (alternatively (to the directive), you
    can use the new `@for` control flow syntax, as shown in [*Chapter 2*](B21625_02.xhtml#_idTextAnchor033)).'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*ngFor`：这个指令用于在HTML模板中创建for循环，并为数组中的每个项目输出一个DOM元素（或者（相对于指令），你可以使用新的`@for`控制流语法，如[第2章](B21625_02.xhtml#_idTextAnchor033)所示）。'
- en: '`*ngSwitch`: This is used to create a switch case in your HTML template and
    display the DOM elements for the matching switch case (alternatively (to the directive),
    you can use the new `@switch` control flow syntax, as shown in [*Chapter 2*](B21625_02.xhtml#_idTextAnchor033)).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*ngSwitch`：这个指令用于在HTML模板中创建switch case，并显示匹配的switch case的DOM元素（或者（相对于指令），你可以使用新的`@switch`控制流语法，如[第2章](B21625_02.xhtml#_idTextAnchor033)所示）。'
- en: If you ever worked on an Angular application, you have most likely seen and
    used all of these structural directives before, as they are really common. Still,
    the `*ngIf` and `*ngFor` directives have some additional, lesser-known properties
    that I want to explain and showcase. After that, we will create a custom structural
    directive.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经开发过 Angular 应用程序，你很可能已经见过并使用过所有这些结构指令，因为它们真的很常见。尽管如此，`*ngIf` 和 `*ngFor`
    指令还有一些额外的、不太为人所知的属性，我想解释并展示一下。之后，我们将创建一个自定义结构指令。
- en: Using *ngIf to its fullest extent
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 充分利用 *ngIf
- en: 'The `*ngIf` directive is used to display DOM elements conditionally. The DOM
    elements do not render unless the property or statement is evaluated as `true`.
    Often, you need to display one block of HTML if the condition is `true` and another
    if it’s `false`. A common solution to this is to use two `*ngIf` directives with
    an opposing statement like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`*ngIf` 指令用于有条件地显示 DOM 元素。DOM 元素不会渲染，除非属性或语句评估为 `true`。通常，当条件为 `true` 时，你需要显示一个
    HTML 块，而当条件为 `false` 时，则显示另一个。一个常见的解决方案是使用两个 `*ngIf` 指令和一个相反的语句，如下所示：'
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is perfectly valid and very readable syntax, but `*ngIf` also allows you
    to create an `if-else` statement. You can do this with the following syntax:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全有效且非常易读的语法，但 `*ngIf` 也允许你创建一个 `if-else` 语句。你可以使用以下语法来做这件事：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, this is a bit bulky in the HTML template because you need to
    use the `ng-template` tag for the content shown when the `else` statement is triggered.
    What syntax you want to use is up to you; there is no better or worse way; it’s
    more about preference.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这在 HTML 模板中略显笨重，因为你需要使用 `ng-template` 标签来显示当 `else` 语句被触发时的内容。你想要使用什么语法完全取决于你；没有更好的或更差的方法；这更多的是关于个人喜好。
- en: Using *ngFor effectively
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有效使用 *ngFor
- en: 'When using `*ngFor`, you can add many properties to enhance the usage of the
    directive. The `*ngFor` directive outputs DOM elements for each item in a list.
    Often, when you output DOM elements for a list, you want to know the current index,
    if something is the first or last element, or if it’s an odd or even index. Based
    on these values, you might want to add some styling classes or use specific properties
    in the template. The `*ngFor` directive allows you to detect these values like
    this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `*ngFor` 时，你可以添加许多属性来增强指令的使用。`*ngFor` 指令为列表中的每个项目输出 DOM 元素。通常，当你为列表输出 DOM
    元素时，你想要知道当前索引，如果某个元素是第一个或最后一个元素，或者它是一个奇数或偶数索引。基于这些值，你可能想要添加一些样式类或在使用模板时使用特定的属性。`*ngFor`
    指令允许你检测这些值，如下所示：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, you can add variables to the `HTML` tag that defines the `*ngFor`
    directive to access values such as `index`, `first`, `last`, `odd`, and `even`.
    If our `list` would be the following array: `[0, 1, 2, 3]`, then the preceding
    code snippet would output the following result in the browser:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以在定义 `*ngFor` 指令的 `HTML` 标签中添加变量来访问 `index`、`first`、`last`、`odd` 和 `even`
    等值。如果我们 `list` 是以下数组：`[0, 1, 2, 3]`，那么前面的代码片段将在浏览器中输出以下结果：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Besides the `index`, `first`, `last`, `odd`, and `even` properties, `*ngFor`
    also has something else to improve its performance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `index`、`first`、`last`、`odd` 和 `even` 属性外，`*ngFor` 还有一些其他属性可以用来提高其性能。
- en: 'By default, when you render something with `*ngFor` and something changes in
    the list, Angular will re-render the entire list. As you can imagine, this affects
    your performance negatively. You can add the `trackBy` function to improve this.
    When you use the `trackBy` function, Angular will identify each item by using
    the `index` or an `ID`. By doing so, it will only re-render things that change.
    It’s recommended that you use the `trackBy` function as much as possible. In the
    template, you can define the `trackBy` function like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你使用 `*ngFor` 渲染某些内容并且列表中发生变化时，Angular 会重新渲染整个列表。正如你可以想象的那样，这会对你性能产生负面影响。你可以添加
    `trackBy` 函数来改善这一点。当你使用 `trackBy` 函数时，Angular 会通过 `index` 或 `ID` 来识别每个项目。通过这样做，它只会重新渲染发生变化的内容。建议你尽可能多地使用
    `trackBy` 函数。在模板中，你可以这样定义 `trackBy` 函数：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In your component class, you can define the `trackBy` function like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的组件类中，你可以这样定义 `trackBy` 函数：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that you know about the hidden features of `*ngIf` and `*ngFor`, let’s see
    how you can create custom structural directives.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 `*ngIf` 和 `*ngFor` 的隐藏功能，让我们看看你如何可以创建自定义结构指令。
- en: Creating custom structural directives
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义结构指令
- en: Creating your own structural directives is similar to creating attribute directives,
    but the directive class has some critical differences. In addition, the use cases
    are different. Custom attribute directives are useful for things such as auto-focusing
    on elements, applying different themes to specific elements, highlights, text
    resizing, tooltips, and popovers, as well as adding CSS classes, aria attributes,
    or IDs. Custom structural directives are used to remove or add DOM elements; some
    good use cases are an `if false` directive, a `"repeat x number of times"` function,
    and showing or hiding elements based on permissions or specific window sizes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自己的结构化指令与创建属性指令类似，但指令类有一些关键的区别。此外，使用场景也不同。自定义属性指令对于诸如自动聚焦元素、将不同主题应用于特定元素、突出显示、文本缩放、工具提示和弹出窗口，以及添加CSS类、aria属性或ID等很有用。自定义结构化指令用于删除或添加DOM元素；一些好的用例包括`if
    false`指令、`"重复x次"`函数，以及根据权限或特定窗口大小显示或隐藏元素。
- en: We will create a custom directive that shows an element when a condition is
    false, which is basically the opposite of the `*ngIf` directive. Start by generating
    the directive using the same steps we used for generating the custom attribute
    directive (see the *Creating custom attribute directives* section). The only difference
    will be the name; this time, name the directive `ifFalse`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个自定义指令，当条件为假时显示一个元素，这基本上是`*ngIf`指令的相反。首先，使用与生成自定义属性指令相同的步骤生成该指令（参见*创建自定义属性指令*部分）。唯一的区别将是名称；这次，将指令命名为`ifFalse`。
- en: 'When your directive class is generated, you can start to add the logic for
    your structural directive. In the attribute directive, you injected `ElementRef`;
    for the structural directive, you must inject `TemplateRef` and `ViewContainerRef`.
    When you add a structural directive to an HTML element, Angular will convert it
    into an embedded template using the `ng-template` tags like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的指令类生成后，你可以开始添加你的结构化指令的逻辑。在属性指令中，你注入了`ElementRef`；对于结构化指令，你必须注入`TemplateRef`和`ViewContainerRef`。当你将结构化指令添加到HTML元素时，Angular会将其转换为嵌入式模板，使用类似于这样的`ng-template`标签：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The embedded template created by Angular is what you access with `TemplateRef`.
    The embedded template is not rendered unless the structural directives adds it
    to the view container using `ViewContainerRef`. `ViewContainerRef` gives you access
    to the view where the host element with the directive is defined.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Angular创建的嵌入式模板是使用`TemplateRef`访问的。嵌入式模板在没有结构化指令使用`ViewContainerRef`将其添加到视图容器之前不会渲染。`ViewContainerRef`为你提供了访问定义指令宿主元素的视图。
- en: 'Let’s start by adding `TemplateRef` and `ViewContainerRef` to your directive
    class. You can inject `TemplateRef` and `ViewContainerRef` by using constructor
    injection or the `inject` function; I will use the `inject` function like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向你的指令类添加`TemplateRef`和`ViewContainerRef`开始。你可以通过构造函数注入或使用`inject`函数来注入`TemplateRef`和`ViewContainerRef`；我将像这样使用`inject`函数：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We must also track if we already added the embedded view to the view container.
    To do this, add another private property to the directive class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须跟踪是否已经将嵌入式视图添加到视图容器中。为此，在指令类中添加另一个私有属性：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we need an `@Input()` for our `if false` directive so we can give it
    a condition to assess. We will use an `@Input()` setter, so each time, it receives
    a new value; we can perform the logic to add or remove the embedded template to
    the view when the condition is evaluated. The `@Input()` setter needs to have
    the same name as the directive selector:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为我们的`if false`指令提供一个`@Input()`，这样我们就可以给它一个条件来评估。我们将使用`@Input()`设置器，因此每次它都会接收到一个新的值；当条件评估时，我们可以执行添加或删除嵌入式模板到视图的逻辑。`@Input()`设置器需要与指令选择器具有相同的名称：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inside the `@Input()` setter, we will add the embedded template as an embedded
    view of the view container if the condition evaluates as `false` and if we have
    not already added it to the embedded template. In the case of an `if false` directive,
    when the condition evaluates to true, and considering we have already added the
    embedded template, we want to clear the view container so that the previously
    added embedded view is removed and Angular renders the original HTML again without
    the additional embedded template added to it. To achieve this, you can change
    `@Input()` as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@Input()`设置器内部，如果条件评估为`false`并且我们尚未将其添加到嵌入式模板中，我们将添加嵌入式模板作为视图容器的嵌入式视图。在`if
    false`指令的情况下，当条件评估为真，并且考虑到我们已经添加了嵌入式模板，我们希望清除视图容器，以便移除之前添加的嵌入式视图，并且Angular再次渲染原始HTML，而不添加额外的嵌入式模板。为了实现这一点，你可以按如下方式更改`@Input()`：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, we add `TemplateRef` as an embedded view when our check passes;
    otherwise, we clear the view container, given that we already added `TemplateRef`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，当我们的检查通过时，我们会将`TemplateRef`作为一个嵌入式视图添加；否则，我们会清除视图容器，因为我们已经添加了`TemplateRef`。
- en: 'We can now use our custom structural directive like any other directive by
    using the directive selector with an asterisk in front of it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用我们的自定义结构指令，就像使用其他任何指令一样，通过使用带有前缀星号的指令选择器：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that you know how to use built-in and create custom attribute and structural
    directives, let’s learn what you can do with directive selectors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何使用内置指令、创建自定义属性和结构指令，让我们学习一下你可以使用指令选择器做什么。
- en: Directive selectors
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 指令选择器
- en: '`btLibsUiHighlight` directive and change the selector so that it will be applied
    to all span elements by default:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`btLibsUiHighlight`指令并更改选择器，以便它默认应用于所有`span`元素：'
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When you use the preceding example as a selector, the directive will automatically
    be applied to all span elements, and you can add it to other elements using the
    `btLibsUiHighlight` selector. Now, let’s say you need an option to exclude some
    span elements, so by default, all span elements receive the highlight directive,
    but when you want to opt-out, you can. To achieve this, you can add the `:not`
    syntax to the selector like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用前面的示例作为选择器时，指令将自动应用于所有`span`元素，并且你可以使用`btLibsUiHighlight`选择器将其添加到其他元素。现在，假设你需要一个选项来排除一些`span`元素，那么默认情况下，所有`span`元素都会收到高亮指令，但当你想要退出时，你可以这样做。为了实现这一点，你可以在选择器中添加`:not`语法，如下所示：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, all span elements will have the highlight directive applied unless you
    add `noHighlight` to a span element. For all other elements, you still need to
    add `btLibsUiHighlight` to apply the directive:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有`span`元素都将应用高亮指令，除非你将`noHighlight`添加到`span`元素中。对于所有其他元素，你仍然需要添加`btLibsUiHighlight`以应用指令：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you want to exclude HTML elements, you can achieve this using your selector
    by using the `:not` syntax like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要排除HTML元素，你可以使用`:not`语法来实现，如下所示：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When you use the preceding selector, you can add the `btLibsUiHighlight` directive
    to all elements but the `label` element. When you try to add the directive to
    a `label` element, the compiler will throw up an error.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用前面的选择器时，你可以将`btLibsUiHighlight`指令添加到所有元素，但不能添加到`label`元素。当你尝试将指令添加到`label`元素时，编译器将抛出错误。
- en: 'You can also make selectors that apply directives to HTML elements with a specific
    ID, data attribute, or CSS class applied to the HTML element. Here is an example
    for all three of these options:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建选择器，将指令应用于具有特定ID、数据属性或应用于HTML元素的CSS类的HTML元素。以下是这三个选项的示例：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now that you know everything you need to know about built-in directives, custom
    directives, and directive selectors, let’s move on and learn about directive composition.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了关于内置指令、自定义指令和指令选择器的所有内容，让我们继续学习指令组合。
- en: Angular directive composition
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Angular指令组合
- en: '**Directive composition** is a relatively new concept that was introduced in
    Angular version 15\. As the word indicates, directive composition lets you compose
    different directives on components and directives. It lets you declare directives
    in component and directive class decorators instead of adding them using HTML
    templates. You can use directive composition to automatically apply directives
    to components, just like directive selectors. Directive composition can also be
    used to create directives that apply multiple directives using a single selector.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**指令组合**是一个相对较新的概念，它在 Angular 15 版本中被引入。正如其词义所示，指令组合允许你在组件和指令上组合不同的指令。它允许你在组件和指令类装饰器中声明指令，而不是使用
    HTML 模板添加它们。你可以使用指令组合来自动将指令应用于组件，就像指令选择器一样。指令组合还可以用来创建使用单个选择器应用多个指令的指令。'
- en: 'Let’s say we have a tag and button component and a type and size directive,
    allowing you to set a type (primary or secondary) and size (small, medium, or
    large), which applies a specific CSS class to the host element. If you want to
    automatically apply these two directives to all your buttons and tags, you can
    use directive composition to achieve this. Add a `hostDirectives` array inside
    the component decorator to add the directives to the component. In the `hostDirectives`
    array, you can add objects with the directive and the inputs for the decorator.
    If the decorator has no inputs, you can add the decorator class to the `hostDirectives`
    array. If you always want to use the input’s default value (given the input has
    a default value), you don’t have to declare the input in the `hostDirectives`
    array:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个标签和按钮组件以及一个类型和大小指令，允许你设置类型（主要或次要）和大小（小、中或大），这将为宿主元素应用特定的 CSS 类。如果你想自动将这两个指令应用于所有的按钮和标签，你可以使用指令组合来实现这一点。在组件装饰器内部添加一个
    `hostDirectives` 数组以将指令添加到组件中。在 `hostDirectives` 数组中，你可以添加包含指令和装饰器输入的对象。如果装饰器没有输入，你可以将装饰器类添加到
    `hostDirectives` 数组中。如果你总是想使用输入的默认值（假设输入有默认值），你不需要在 `hostDirectives` 数组中声明输入：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After defining the objects in the `hostDirectives` array, the two directives
    will be applied automatically when you declare the button or tag component in
    a template. When using directive composition, you can also alias the input values
    of the directive:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 `hostDirectives` 数组中的对象之后，当你在一个模板中声明按钮或标签组件时，这两个指令将自动应用。当使用指令组合时，你还可以为指令的输入值设置别名：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, in your HTML templates, if you want to supply a value for the `btLibsUiType`
    input of `TypeDirective`, you can use the following syntax:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的 HTML 模板中，如果你想为 `TypeDirective` 的 `btLibsUiType` 输入提供一个值，你可以使用以下语法：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using directive composition inside directives works the same as in components.
    Let’s say we have `backgroundColorDirective` and `textColorDirective`; we can
    declare `textColorDirective` inside the `hostDirectives` array of `backgroundColorDirective`.
    Now, when you use `backgroundColorDirective`, both directives will be applied,
    and the inputs of both directives will be exposed, given that you defined the
    inputs of `textColorDirective` in the `hostDirectives` array of `backgroundColorDirective`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在指令内部使用指令组合与在组件中相同。假设我们有一个 `backgroundColorDirective` 和 `textColorDirective`；我们可以在
    `backgroundColorDirective` 的 `hostDirectives` 数组中声明 `textColorDirective`。现在，当你使用
    `backgroundColorDirective` 时，这两个指令都将应用，并且两个指令的输入都将暴露出来，前提是你已经在 `backgroundColorDirective`
    的 `hostDirectives` 数组中定义了 `textColorDirective` 的输入。
- en: When using directive composition, you need to use standalone directives. Otherwise,
    it will not work. Also, each time a component is created, a new instance of all
    the directives declared in the `hostDirectives` array will be created. Because
    a new instance of each directive is created for each instance of the host component,
    you must be careful when using directive composition. When you put too many directives
    inside commonly used components, your memory usage will blow up and negatively
    affect the performance of your application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用指令组合时，你需要使用独立的指令。否则，它将不会工作。此外，每次创建一个组件时，`hostDirectives` 数组中声明的所有指令都会创建一个新的实例。因为每个指令实例都是为宿主组件的每个实例创建的，所以在使用指令组合时必须小心。当你将太多指令放入常用组件内部时，你的内存使用量将会激增，并会负面影响你应用程序的性能。
- en: In this section, you learned about attribute directives, structural directives,
    directive selectors, and directive composition. We will now move on to the next
    section of this chapter and start to learn more about transforming values by using
    Angular pipes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了属性指令、结构指令、指令选择器和指令组合。现在我们将继续学习本章的下一部分，开始了解如何使用 Angular 管道来转换值。
- en: Transforming values using Angular pipes
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular 管道转换值
- en: 'In Angular, **pipes** are used to transform values. Angular offers a lot of
    useful built-in pipes and allows you to create your own. Let’s first list the
    most powerful and commonly used built-in pipes and briefly explain what they are
    used for:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，**管道**用于转换值。Angular 提供了许多有用的内置管道，并允许你创建自己的管道。让我们首先列出最强大和最常用的内置管道，并简要说明它们的使用目的：
- en: '`AsyncPipe`: `AsyncPipe` is used to handle asynchronous values in your templates.
    It automatically subscribes to an `AsyncPipe` unsubscribe automatically because
    this prevents memory leaks. It’s recommended to use `AsyncPipe` as much as possible.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncPipe`：`AsyncPipe`用于处理模板中的异步值。它自动订阅并自动取消订阅，以防止内存泄漏。建议尽可能多地使用`AsyncPipe`。'
- en: '`UpperCasePipe`: This pipe is used to transform a text value into all uppercase
    characters.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpperCasePipe`：此管道用于将文本值转换为全部大写字母。'
- en: '`LowerCasePipe`: This pipe is used to transform a text value into all lowercase
    characters.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LowerCasePipe`：此管道用于将文本值转换为全部小写字母。'
- en: '`TitleCasePipe`: This pipe is used to capitalize the first letter of each word.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TitleCasePipe`：此管道用于将每个单词的首字母大写。'
- en: '`CurrencyPipe`: This pipe is used to transform a number value into a currency
    value with a currency symbol. You can also control the decimal formatting.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrencyPipe`：此管道用于将数值转换为带有货币符号的货币值。你还可以控制小数格式。'
- en: '`DatePipe`: This is used to format date values based on the format you specify.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DatePipe`：此管道用于根据你指定的格式格式化日期值。'
- en: 'If you want to explore all the built-in pipes, you can find a complete list
    at this URL: [https://angular.io/guide/pipes](https://angular.io/guide/pipes).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要探索所有内置管道，你可以在这个网址找到完整的列表：[https://angular.io/guide/pipes](https://angular.io/guide/pipes)。
- en: Now that you know about the most commonly used built-in pipes, let’s see how
    you can use pipes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了最常用的内置管道，让我们看看如何使用管道。
- en: Using pipes in HTML templates and TypeScript files
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 模板和 TypeScript 文件中使用管道
- en: 'Pipes are commonly used in HTML templates, but you can also use them in your
    TypeScript files. To use pipes in HTML templates, you can use the following syntax:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 管道通常用于 HTML 模板，但你也可以在 TypeScript 文件中使用它们。要在 HTML 模板中使用管道，你可以使用以下语法：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'On the left side, you have a property or value; then, you indicate that you’re
    going to use a pipe with the vertical bar (pipe symbol: `|`), and on the right
    side of the pipe symbol, you declare the name of the pipe you want to use; in
    our example, it is `date`. If your pipe takes a parameter, you supply the parameter
    by adding a colon and the value like so:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，你有一个属性或值；然后，你通过使用垂直线（管道符号：`|`）来指示你将使用一个管道；在管道符号的右侧，你声明你想要使用的管道的名称；在我们的例子中，它是`date`。如果你的管道需要参数，你可以通过添加冒号并提供值来提供参数：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When a pipe takes more than one parameter, you can chain them together by adding
    another colon and append the value after the colon like so:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当管道需要多个参数时，你可以通过添加另一个冒号并将值附加到冒号之后来将它们链接在一起，如下所示：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can chain multiple pipes to a value if you need to apply them. When you
    chain pipes, they will be executed one by one, from left to right. Chaining pipes
    is done using the following syntax:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要应用多个管道，你可以将它们链接到一个值上。当你链式调用管道时，它们将按从左到右的顺序依次执行。链式调用管道使用以下语法：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As mentioned before, you can also use pipes inside your TypeScript files. Although
    pipes are mostly used inside HTML templates, they can also be useful inside your
    TypeScript files. You can add pipes to the providers array of your component and
    then inject the pipes using dependency injection. After injecting the pipe, you
    can use it in your component class by calling the `transform` method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你还可以在 TypeScript 文件中使用管道。尽管管道主要用于 HTML 模板，但它们在 TypeScript 文件中也非常有用。你可以在组件的提供者数组中添加管道，然后通过依赖注入注入管道。注入管道后，你可以在组件类中通过调用`transform`方法来使用它：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When using standalone components (as we are doing), you need to import the pipe
    into the component before you can use the pipe. You can either import `CommonModule`,
    which contains all the pipes, or import the specific pipe if it’s a simple component
    and you don’t need `CommonModule` for other purposes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用独立组件（正如我们正在做的那样）时，在可以使用管道之前，你需要将管道导入到组件中。你可以导入包含所有管道的`CommonModule`，或者如果你是一个简单的组件并且不需要`CommonModule`用于其他目的，你可以导入特定的管道。
- en: Now that you know how to use pipes in your HTML templates and TypeScript files,
    let’s learn about pure and impure pipes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何在HTML模板和TypeScript文件中使用管道，让我们来学习纯管道和不纯管道。
- en: Is it pure or impure?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它是纯的还是不纯的？
- en: 'Angular pipes come in two flavors: `pure false` flag. The difference between
    pure and impure pipes lies in their update behavior and how Angular runs change
    detection on them.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Angular管道有两种类型：带有`pure false`标志。纯管道和不纯管道之间的区别在于它们的更新行为以及Angular如何对它们运行变更检测。
- en: You need to use a pure transform function when creating a pure pipe. A **pure
    function** is a function that always returns the same output when given the same
    input.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建纯管道时，你需要使用纯转换函数。**纯函数**是一个在给定相同输入时总是返回相同输出的函数。
- en: Angular only runs a pure pipe when a pure change in the input value is detected.
    Pure changes are changes to a primitive value (number, string, Boolean, bigint,
    symbol, undefined, and null) or when a new reference object is supplied (date,
    array, function, or object). Changes to a reference object are not seen as pure
    changes. So, if you have a pure pipe that takes an array as a value, updating
    the array will not trigger the pipe because this is an impure change. When you
    assign the property using a new array, the pipe will run because it receives a
    new reference object instead, which is a pure change.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Angular仅在检测到输入值的纯变化时才运行纯管道。纯变化是指对原始值（数字、字符串、布尔值、bigint、symbol、undefined和null）的更改，或者当提供一个新引用对象（日期、数组、函数或对象）时。对引用对象的更改不被视为纯变化。因此，如果你有一个接受数组作为值的纯管道，更新数组将不会触发管道，因为这是一种不纯的变化。当你使用新数组分配属性时，管道将运行，因为它接收到了一个新的引用对象，这被视为纯变化。
- en: Angular skips updates of reference objects when running pure pipes because detecting
    pure changes is much faster than performing deep checks on objects; because of
    this, Angular can quickly determine if your pipes need to be executed again or
    if the pipe can be skipped. If Angular had to do a deep check or run your pipes
    on each change detection cycle, it would hugely impact the performance of your
    application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行纯管道时，Angular会跳过对引用对象的更新，因为检测纯变化比在对象上执行深度检查要快得多；正因为如此，Angular可以快速确定你的管道是否需要再次执行，或者管道是否可以跳过。如果Angular必须在每个变更检测周期中执行深度检查或运行你的管道，这将极大地影响应用程序的性能。
- en: 'So, remember that when you use pure pipes with reference objects, you might
    not always get what you expect unless you know what you’re doing. For example,
    suppose that you have a dashboard array and a pipe that filters the array only
    to include active dashboards like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，记住当你使用带有引用对象的纯管道时，除非你知道自己在做什么，否则你并不总是能得到你期望的结果。例如，假设你有一个仪表盘数组和一个管道，它只过滤数组以包括像这样的活动仪表盘：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, when updating the dashboard array with `push`, the pipe will not run because
    the reference of the dashboard array did not change. If you assign a dashboard’s
    property using a new array, the reference changes and Angular’s change detection
    will trigger the active pipe and filter the results as expected.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当使用`push`更新仪表盘数组时，管道将不会运行，因为仪表盘数组的引用没有改变。如果你使用新数组分配仪表盘的属性，引用将改变，Angular的变更检测将触发活动管道并按预期过滤结果。
- en: When using an impure pipe, Angular will execute the pipe each time it detects
    a change. This means Angular will run the pipe upon each keystroke or mouse movement.
    Impure pipes can be useful and will update reference objects as expected, but
    be careful when using impure pipes, as they can dramatically slow down your application.
    When you use impure pipes, you want to set the change detection strategy of your
    component to `OnPush` so that your pipes will not be executed too often. When
    the component change detection is set to `OnPush`, change detection will only
    run when the component receives new input values or when you trigger it manually.
    It’s good practice to set your change detection strategy to `OnPush` as much as
    possible, as it will help improve your application’s performance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用不纯的管道时，Angular 会每次检测到变化时执行管道。这意味着 Angular 会每次按键或鼠标移动时运行管道。不纯的管道可能很有用，并且会按预期更新引用对象，但使用不纯管道时要小心，因为它们可能会显著减慢您的应用程序。当您使用不纯的管道时，您希望将组件的变更检测策略设置为
    `OnPush`，这样您的管道就不会被频繁执行。当组件的变更检测设置为 `OnPush` 时，变更检测仅在组件接收到新的输入值或您手动触发时才会运行。尽可能地将变更检测策略设置为
    `OnPush` 是一个好习惯，因为它将有助于提高您应用程序的性能。
- en: Now that you understand the difference between pure and impure pipes, let’s
    learn more about `AsyncPipe`, as it is the most important built-in pipe Angular
    provides us with. After learning about `AsyncPipe`, we will learn how to create
    custom pipes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了纯管道和不纯管道之间的区别，让我们更多地了解 `AsyncPipe`，因为它是 Angular 提供给我们最重要的内置管道。在了解 `AsyncPipe`
    之后，我们将学习如何创建自定义管道。
- en: Using AsyncPipe
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AsyncPipe
- en: The most powerful built-in pipe is `AsyncPipe`. Even though `AsyncPipe` is an
    impure pipe, it’s recommended to use it as much as possible to handle the observable
    and promise results used in your templates. Using `AsyncPipe` offers advantages
    over handling observables with subscriptions in your component class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最强大的内置管道是 `AsyncPipe`。尽管 `AsyncPipe` 是一个不纯的管道，但建议尽可能多地使用它来处理在模板中使用的可观察对象和承诺结果。使用
    `AsyncPipe` 相比在组件类中使用订阅处理可观察对象具有优势。
- en: First, `AsyncPipe` subscribes and, more importantly, unsubscribes to observables
    automatically. This is very important because it prevents memory leaks. If you
    don’t clean up a subscription correctly, you will end up with memory leaks, and
    your application will start to slow down and show unexpected behavior up to the
    point of crashing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`AsyncPipe` 会自动订阅和取消订阅可观察对象，更重要的是，它会自动取消订阅。这一点非常重要，因为它可以防止内存泄漏。如果您没有正确清理订阅，最终会导致内存泄漏，您的应用程序将开始变慢，并显示出意外的行为，甚至可能崩溃。
- en: 'To demonstrate `AsyncPipe`, we will create an observable in the component class
    using the RxJS `interval` operator like so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 `AsyncPipe`，我们将在组件类中使用 RxJS 的 `interval` 操作符创建一个可观察对象，如下所示：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This `interval` observable will emit the next index every 2 seconds, starting
    at `0`. So, after 2 seconds, the observable emits `0`, and after another 2 seconds,
    the observable emits `1`, and so on.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `interval` 可观察对象将每2秒发出下一个索引，从 `0` 开始。因此，2秒后，可观察对象发出 `0`，再过2秒，可观察对象发出 `1`，依此类推。
- en: 'We can subscribe to the `interval` observable inside the component class and
    assign the result to a component property that we display inside the template:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在组件类内部订阅 `interval` 可观察对象，并将结果分配给我们在模板中显示的组件属性：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, you can use the `count` property inside your template:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以在模板中使用 `count` 属性：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you’re using `OnPush` change detection for your component, you need to call
    a change detection manually each time the observable receives a new value. Otherwise,
    the `count` property will not be updated in your template. When using the aforementioned
    approach, you must also add logic to unsubscribe from your observable when the
    component is destroyed or when the observable property is assigned to another
    observable. Now, let’s see how we can use the interval observable in our HTML
    template using `AsyncPipe`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为组件使用 `OnPush` 变更检测，您需要每次可观察对象接收到新值时手动调用变更检测。否则，模板中的 `count` 属性将不会更新。在上述方法中，您还必须添加逻辑，在组件销毁或可观察属性分配给另一个可观察对象时取消订阅您的可观察对象。现在，让我们看看如何使用
    `AsyncPipe` 在我们的 HTML 模板中利用间隔可观察对象：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, using `AsyncPipe` is simple. You declare the property assigned
    using the observable (in our case, it’s named `timer`) and add `AsyncPipe` next
    to it. Each time the interval observable emits a new value, it will be reflected
    in our template. There is no need for an extra property to save the observable
    result, no need to unsubscribe, and there is no risk of memory leaks! Even when
    you assign the `timer` property using a new observable, the async pipe will automatically
    unsubscribe from the old observable and subscribe to the new observable.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用`AsyncPipe`很简单。你声明使用可观察者分配的属性（在我们的例子中，它被命名为`timer`），并在其旁边添加`AsyncPipe`。每当间隔可观察者发射新的值时，它都会反映在我们的模板中。不需要额外的属性来保存可观察者的结果，不需要取消订阅，也没有内存泄漏的风险！即使你使用新的可观察者分配`timer`属性，异步管道也会自动取消订阅旧的可观察者并订阅新的可观察者。
- en: When using the async pipe, using `OnPush` change detection is recommended because
    `AsyncPipe` is impure. Another advantage of `AsyncPipe` is that it automatically
    marks the component template that needs to be checked for changes when the pipe
    receives a new value. This is useful when you set your change detection strategy
    to `OnPush`. When using a regular observable subscription, the HTML template is
    not marketed to be checked for changes if you use the `OnPush` strategy, meaning
    you have to trigger the change detection manually after your subscription receives
    a new value.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用异步管道时，建议使用`OnPush`变更检测，因为`AsyncPipe`是非纯的。`AsyncPipe`的另一个优点是，当管道接收到新值时，它会自动标记需要检查更改的组件模板。当你将变更检测策略设置为`OnPush`时，这很有用。当使用常规的可观察者订阅时，如果你使用`OnPush`策略，HTML模板不会被标记为检查更改，这意味着你必须在订阅接收到新值后手动触发变更检测。
- en: Now you know more about `AsyncPipe` and why it’s such a powerful tool, let’s
    explore how you can create your own pipes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对`AsyncPipe`以及为什么它是一个如此强大的工具有了更多的了解，让我们来探索如何创建你自己的管道。
- en: Building your own pipes
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 构建你自己的管道
- en: 'When creating pipes in our Nx monorepo, we will do so in a `util` library.
    For our example, we will create a simple pipe that will multiply a number using
    a specified factor. The correct place to create this pipe is in a library under
    the shared domain and the `util` type. Use our custom generator to create a new
    library with the name: `common-pipes` and select **shared** as its domain and
    **util** as its type.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Nx单仓库中创建管道时，我们将在`util`库中这样做。在我们的例子中，我们将创建一个简单的管道，该管道将使用指定的因子乘以一个数字。创建此管道的正确位置是在共享域下的一个库中，并且是`util`类型。使用我们的自定义生成器创建一个名为`common-pipes`的新库，并选择**shared**作为其域，**util**作为其类型。
- en: 'When your new library is generated, follow these steps to generate the custom
    pipe:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的新库生成后，按照以下步骤生成自定义管道：
- en: Close and reopen VSCode so that your new library is included in the Nx schematics.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭并重新打开VSCode，以确保你的新库包含在Nx图示中。
- en: 'Right-click on the folder at this location: `libs\shared\util\common-pipes\src\lib`,
    and select **Nx generate**.'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击此位置的文件夹：`libs\shared\util\common-pipes\src\lib`，并选择**Nx生成**。
- en: Type `pipe` and click on **@nx/angular –** **pipe**.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`pipe`并点击**@nx/angular –** **pipe**。
- en: Enter `multiply` for the **name*** field.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**名称**字段中输入`multiply`。
- en: Click on **Show** **all options**.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**显示** **所有选项**。
- en: Check the **standalone** checkbox.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**独立**复选框。
- en: Click on **Generate** in the top right.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角点击**生成**。
- en: 'After the component is generated, add the following to the `index.ts` file
    in the library:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当组件生成后，将以下内容添加到库中的`index.ts`文件：
- en: '[PRE45]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: After that, you can use your pipe, but before using it, let’s add some logic.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你可以使用你的管道，但在使用之前，让我们添加一些逻辑。
- en: When you open the `multiply.pipe.ts` file, you’ll see that Nx generated a `MultiplyPipe`
    class, which implements the `PipeTransform` interface. The class is also decorated
    with the `@Pipe()` decorator, where the standalone flag is set to `true` and the
    pipe name `multiply` is defined. Inside this decorator, you can add the pure flag;
    your pipe is pure by default. You only have to add the pure flag with a `false`
    value when you want to create an impure pipe. In our example, we will create a
    simple, pure pipe, so there is no need to add the pure flag to the decorator.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开`multiply.pipe.ts`文件时，你会看到Nx生成了一个`MultiplyPipe`类，该类实现了`PipeTransform`接口。该类还装饰了`@Pipe()`装饰器，其中独立标志设置为`true`，管道名称`multiply`被定义。在这个装饰器内部，你可以添加纯标志；你的管道默认是纯的。只有当你想创建一个非纯管道时，你才需要添加纯标志并设置为`false`。在我们的例子中，我们将创建一个简单、纯的管道，因此不需要将纯标志添加到装饰器中。
- en: 'Nx also added a transform function to the class to adhere to the `PipeTransform`
    interface. The transform function is the “hard” of your pipe, where you add your
    transformation logic. You can adjust the transform function to this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Nx 还向类中添加了一个转换函数，以符合`PipeTransform`接口。转换函数是管道的“难点”，在这里你添加你的转换逻辑。你可以调整转换函数如下：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see, we have a value and a multiplier function parameter. The value
    parameter is what we declare on the left side of the pipe in our HTML templates.
    `multiplier` is the parameter we supply after the colon. We gave `multiplier`
    a default value of `2`, so it’s optional when declaring the pipe in your templates.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有一个值和一个乘数函数参数。值参数是我们在我们HTML模板的管道左侧声明的。`multiplier`是我们冒号后面的参数。我们给`multiplier`赋予了一个默认值`2`，所以在模板中声明管道时它是可选的。
- en: 'When you want to use the pipe, you first need to import it; if you work with
    NgModules, the pipe needs to be imported in an NgModules instance; if you work
    with standalone components, like we are doing here, you have to import the pipe
    into the components you want to use it in. After you import the pipe into a standalone
    component, you can use it in the template like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想使用管道时，首先需要导入它；如果你使用NgModules，管道需要在NgModules实例中导入；如果你使用独立组件，就像我们在这里做的那样，你必须将管道导入到你想要使用它的组件中。在你将管道导入到独立组件后，你可以在模板中使用它，如下所示：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you want to supply the pipe with a custom multiplier value, you can use
    the following syntax:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为管道提供一个自定义的乘数值，你可以使用以下语法：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you want to add more parameters to your pipe, you can do so by adding more
    parameters inside your transform function. Let’s say you want another multiplier
    in your `multiply` pipe. You can add it as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在管道中添加更多参数，你可以在你的转换函数中添加更多参数来实现。假设你想在`multiply`管道中添加另一个乘数。你可以按照以下方式添加：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, you can use the following syntax inside your HTML templates:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在你的HTML模板中使用以下语法：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Our example pipe is simple, but you can add any logic you want inside your
    transform function. Just make sure you use a pure function when creating a pure
    pipe, that is, a function that returns the same value when given the same input
    and doesn’t affect any other code. When you create an impure pipe, make sure not
    to add time-consuming or resource-intensive code, as it will impact the performance
    of your application negatively. Here is an example of how you make a pipe impure:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例管道很简单，但你可以在你的转换函数中添加任何你想要的逻辑。只需确保在创建纯管道时使用纯函数，即当给定相同的输入时返回相同值且不影响任何其他代码的函数。当你创建不纯的管道时，确保不要添加耗时或资源密集型的代码，因为这会负面影响你的应用程序性能。以下是如何创建不纯管道的示例：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now you know that pipes are used to transform values. Angular offers built-in
    pipes for common transformations and to handle asynchronous values. You know the
    difference between pure and impure pipes, and you can create your own custom pipes.
    To finish this chapter, we will learn about Angular animations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道管道用于转换值。Angular提供了内置的管道用于常见的转换和处理异步值。你知道纯管道和不纯管道之间的区别，并且可以创建你自己的自定义管道。为了完成本章，我们将学习关于Angular动画的内容。
- en: Creating and reusing stunning animations
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和重用令人惊叹的动画
- en: In the previous sections, you’ve seen how to manipulate DOM elements using directives
    and how to transform template values using pipes; in this section, you will learn
    how to create animations for your HTML elements and components using the built-in
    animation module.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你已经看到了如何使用指令操作DOM元素，以及如何使用管道转换模板值；在本节中，你将学习如何使用内置的动画模块为你的HTML元素和组件创建动画。
- en: 'To start, you have to enable the animation module. To do this, go to `app.config.ts`
    in your applications under the *expenses-registration application* in your Nx
    monorepo. Inside `app.config.ts`, you’ll find the `appConfig` object used in your
    `main.ts` inside the `bootstrapApplication` function. To enable the animation
    module, add the `provideAnimations()` function inside the providers array of the
    `appConfig` object like so:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须启用动画模块。为此，请转到你的Nx单仓库中`expenses-registration application`应用程序下的`app.config.ts`。在`app.config.ts`中，你会在`bootstrapApplication`函数内的`main.ts`中找到`appConfig`对象。要启用动画模块，请在`appConfig`对象的提供者数组中添加`provideAnimations()`函数，如下所示：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If you’re using an NgModule-based application, you need to import `BrowserAnimationsModule`
    inside the NgModule where you want to use animations. After adding either the
    `provideAnimations` function or `BrowserAnimationsModule`, you can start adding
    animations inside your components. To demonstrate animations, let’s create a selectable
    label component inside our `common-components` library. Use the Nx generator to
    create a component, name it `selectable-label`, choose the `common-components`
    library for the project, check the `OnPush`. When the component is generated,
    add the following export in the `index.ts` of the `common-components` library:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用基于 NgModule 的应用程序，你需要在想要使用动画的 NgModule 中导入 `BrowserAnimationsModule`。在添加了
    `provideAnimations` 函数或 `BrowserAnimationsModule` 之后，你可以在组件内部开始添加动画。为了演示动画，让我们在
    `common-components` 库中创建一个可选择的标签组件。使用 Nx 生成器创建一个组件，命名为 `selectable-label`，为项目选择
    `common-components` 库，勾选 `OnPush`。当组件生成后，在 `common-components` 库的 `index.ts` 中添加以下导出：
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, add the following code to the `component` class:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到 `component` 类中：
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add the following CSS to the SCSS file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下 CSS 添加到 SCSS 文件中：
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add the following HTML to the HTML file:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下 HTML 添加到 HTML 文件中：
- en: '[PRE56]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now that we have a simple label component, let’s create our animation. Start
    by adding the `animations` array inside your component decorator like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个简单的标签组件，让我们创建我们的动画。首先，在组件装饰器内部添加 `animations` 数组，如下所示：
- en: '[PRE57]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Animations for the component are added inside this `animations` array. Add
    the following animation inside the array:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `animations` 数组内部添加组件的动画。在数组中添加以下动画：
- en: '[PRE58]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is a simple animation that changes the background color from the hex color
    `#382632` to `#455b66` and takes 2 seconds to perform the transition. Now let’s
    examine what we added line by line.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的动画，将背景颜色从十六进制颜色 `#382632` 变换到 `#455b66`，并需要 2 秒来完成过渡。现在让我们逐行检查我们添加的内容。
- en: Animation trigger
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 动画触发器
- en: 'Our animation starts with a trigger:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们动画的起始触发器：
- en: '[PRE59]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'state(''selected'', style({ backgroundColor: ''#382632'' })),'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 'state(''selected'', style({ backgroundColor: ''#382632'' })),'
- en: 'state(''deselected'', style({ backgroundColor: ''#455b66''})),'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 'state(''deselected'', style({ backgroundColor: ''#455b66''})),'
- en: '[PRE60]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: transition('selected <=> deselected', [animate('2s')])
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: transition('selected <=> deselected', [animate('2s')])
- en: '[PRE61]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'animate(''2s'', style({ color: ''red'' })),'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'animate(''2s'', style({ color: ''red'' })),'
- en: '[PRE62]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: animate('2s', keyframes([
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: animate('2s', keyframes([
- en: 'style({ backgroundColor: ‹blue›, offset: 0}),'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 'style({ backgroundColor: ‹blue›, offset: 0}),'
- en: 'style({ backgroundColor: ‹red›, offset: 0.8}),'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 'style({ backgroundColor: ‹red›, offset: 0.8}),'
- en: 'style({ backgroundColor: ‹#754600›, offset: 1.0})])),'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 'style({ backgroundColor: ‹#754600›, offset: 1.0})])),'
- en: '[PRE63]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: sequence([
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: sequence([
- en: 'animate(‹2s›, style({ backgroundColor: ‹#382632› })),'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'animate(‹2s›, style({ backgroundColor: ‹#382632› })),'
- en: 'animate(‹2s›, style({ color: ‹orange› }))'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'animate(‹2s›, style({ color: ‹orange› }))'
- en: '])'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '])'
- en: '[PRE64]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: group([
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: group([
- en: 'animate(‹2s›, style({ color: ‹white› })),'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'animate(‹2s›, style({ color: ‹white› })),'
- en: 'animate(‹2s›, style({ backgroundColor: ‹#455b66› })),'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 'animate(‹2s›, style({ backgroundColor: ‹#455b66› })),'
- en: '])'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '])'
- en: group([
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: group([
- en: 'animate(‹2s›, style({ fontSize: ‹24px› })),'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 'animate(‹2s›, style({ fontSize: ‹24px› })),'
- en: 'animate(‹2s›, style({ opacity: ‹0.5› })),'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 'animate(‹2s›, style({ opacity: ‹0.5› })),'
- en: '])'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '])'
- en: '[PRE65]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[@selectedState]="animationState"'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[@selectedState]="animationState"'
- en: '[PRE66]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: (@selectedState.start)="onAnimationEvent($event)"
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: (@selectedState.start)="onAnimationEvent($event)"
- en: (@selectedState.done)="onAnimationEvent($event)"
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: (@selectedState.done)="onAnimationEvent($event)"
- en: '[PRE67]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: <div [@.disabled]="isDisabled"> ……… </div>
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: <div [@.disabled]="isDisabled"> ……… </div>
- en: '[PRE68]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'export function selectedAnimation(): AnimationTriggerMetadata {'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'export function selectedAnimation(): AnimationTriggerMetadata {'
- en: return trigger('selectedState', [
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: return trigger('selectedState', [
- en: 'state(‹selected›, style({ backgroundColor: ‹#382632› })),'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 'state(‹selected›, style({ backgroundColor: ‹#382632› })),'
- en: 'state(‹deselected›, style({ backgroundColor: ‹#455b66›})),'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 'state(‹deselected›, style({ backgroundColor: ‹#455b66›})),'
- en: transition(‹selected <=> deselected›,[animate(‹2s›)]),])
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: transition(‹selected <=> deselected›,[animate(‹2s›)]),])
- en: '}'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE69]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '@Component({'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '@Component({'
- en: ………
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ………
- en: 'animations: [selectedAnimation()],'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 'animations: [selectedAnimation()],'
- en: '})'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '})'
- en: '[PRE70]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
