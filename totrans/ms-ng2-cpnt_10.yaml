- en: Chapter 10. Making Things Pluggable
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 使事物可插件化
- en: I'm a huge fan of plugin architectures. Besides their tremendously positive
    effect on your application and scope management, they are also a lot of fun to
    develop. I'd recommend integrating a plugin architecture in their library or application
    to anyone who asks me. A good plugin architecture allows you to write a concise
    application core and provide additional functionality via plugins.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜爱插件架构。除了它们对应用程序和范围管理产生的巨大积极影响外，它们在开发过程中也非常有趣。我建议任何向我询问的人都将插件架构集成到他们的库或应用程序中。一个好的插件架构允许你编写简洁的应用程序核心，并通过插件提供额外的功能。
- en: Designing your whole application in a way that it allows you to build a plugin
    architecture has a great effect on the extensibility of your system. This is because
    you're making your application open for extensibility but closing it for modification.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以一种允许你构建插件架构的方式设计整个应用程序，这对系统的可扩展性有很大影响。这是因为你使应用程序易于扩展，但关闭了修改。
- en: While authoring my open source projects, I also experienced that a plugin architecture
    helps you manage the scope of your project. Sometimes, a requested feature is
    really nice and helpful, but it will still bloat the library core. Instead of
    bloating your whole application or library with such features, you can simply
    write a plugin to get the job done.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我的开源项目时，我也发现插件架构有助于你管理项目的范围。有时，请求的功能非常好且非常有用，但它仍然会使库核心膨胀。与其用这样的功能使整个应用程序或库膨胀，你不如简单地编写一个插件来完成这项工作。
- en: In this chapter, we will create our own plugin architecture that will help us
    extend the features of our application without bloating its core. We'll first
    build the plugin API in the core of our application and then use the API to implement
    a nice little agile plugin, which helps us to estimate tasks using story points.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建自己的插件架构，这将帮助我们扩展应用程序的功能，而不会使其核心膨胀。我们首先将在应用程序的核心中构建插件API，然后使用该API实现一个小巧的敏捷插件，帮助我们使用故事点来估算任务。
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Designing a plugin architecture, based on the Angular ecosystem
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Angular生态系统的插件架构设计
- en: Implementing a decorator-based plugin API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基于装饰器的插件API
- en: Using `ComponentResolver` and `ViewContainerRef` to instantiate plugin components
    into predefined slots in our application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ComponentResolver`和`ViewContainerRef`将插件组件实例化到我们应用程序中预定义的槽位
- en: Implementing a plugin-loading mechanism using SystemJS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SystemJS实现插件加载机制
- en: Using a reactive approach in our plugin architecture to enable plug and play
    style plugins
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的插件架构中使用响应式方法以实现即插即用风格的插件
- en: Implementing an agile plugin to record story points using the new plugin API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的插件API实现一个敏捷插件来记录故事点
- en: Plugin architecture
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件架构
- en: 'At a higher level, a plugin architecture should fulfil at least the following
    requirements:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高层次上，插件架构应至少满足以下要求：
- en: '**Extensibility**: The main idea behind plugins is to allow the extension of
    the core functionality using isolated bundles of code. A great plugin architecture
    allows you to extend the core seamlessly and without noticeable performance losses.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：插件背后的主要思想是允许使用隔离的代码包扩展核心功能。一个出色的插件架构允许你无缝地扩展核心，而不会引起明显的性能损失。'
- en: '**Portability**: Plugins should be isolated enough so that they can be plugged
    into the system during runtime. There shouldn''t be a necessity to rebuild a system
    to enable plugins. Ideally, plugins can even be loaded at any time during runtime.
    They can be deactivated and activated and should not cause the system to run into
    an inconsistent state.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：插件应足够隔离，以便在运行时将其插入到系统中。不应有必要重建系统以启用插件。理想情况下，插件甚至可以在运行时任何时候加载。它们可以被停用和激活，并且不应导致系统运行到不一致的状态。'
- en: '**Composability**: A plugin system should allow the use of many plugins in
    parallel and allow an extension of the system by compositing multiple plugins
    together. Ideally, the system also includes dependency management, plugin version
    management, and plugin intercommunication.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可组合性**：插件系统应允许并行使用多个插件，并允许通过组合多个插件来扩展系统。理想情况下，系统还应包括依赖管理、插件版本管理和插件间通信。'
- en: There are a lot of different approaches on how to implement a plugin architecture.
    Although these approaches can vary a lot, there's almost always a mechanism in
    place that provides unified extension points. Without this, it will be hard to
    extend a system uniformly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实现插件架构的方法有很多。尽管这些方法可能差异很大，但几乎总是有一个机制在位，提供统一的扩展点。没有这个机制，统一扩展系统将会很困难。
- en: 'I''ve worked with some plugin architectures in the past, and besides using
    existing plugin mechanisms, I''ve also enjoyed designing some of them myself.
    The following list should provide an idea about some of the approaches that you
    can use when designing a plugin system:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我过去曾与一些插件架构合作过，除了使用现有的插件机制外，我还享受自己设计一些插件。以下列表应该能提供一个关于在设计插件系统时可以采用的一些方法的思路：
- en: '**DSL**: Using domain-specific languages is one way to implement a pluggable
    architecture. After you''ve implemented the core of your application, you can
    develop an API or even a scripting language that allows you to develop further
    features using this DSL. A lot of video game engines and CG applications rely
    on this approach. Although this approach is very flexible, it can also lead to
    performance issues quickly, and it''s prone to introducing complexity. Mostly,
    the prerequisites to implement such an architecture are to expose very low-level
    core operations (such as adding UI elements, configuring process flows, and so
    on) into the DSL, which does not provide clear boundaries and extension points
    but is extremely flexible. Some examples of DSL-based plugin systems are most
    of Adobe''s CG applications, 3D Studio Max, and Maya, but also game engines, such
    as Unreal Engine or the Real Virtuality Engine from Bohemia Interactive Studio.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域特定语言（DSL）**：使用领域特定语言是实现可插拔架构的一种方式。在你实现了应用程序的核心之后，你可以开发一个API，甚至是一种脚本语言，允许你使用这种DSL进一步开发功能。许多视频游戏引擎和CG应用程序都依赖于这种方法。尽管这种方法非常灵活，但它也可能迅速导致性能问题，并容易引入复杂性。通常，实现这种架构的先决条件是将非常低级别的核心操作（如添加UI元素、配置流程等）暴露到DSL中，这并不提供清晰的边界和扩展点，但非常灵活。基于DSL的插件系统的一些例子包括Adobe的大部分CG应用程序、3D
    Studio Max和Maya，以及游戏引擎，如Epic Games的Unreal Engine或Bohemia Interactive Studio的Real
    Virtuality Engine。'
- en: '**The core is the plugin system**: Another approach is to build such a sophisticated
    plugin architecture that it fulfils all the outlined requirements in the previous
    listing (extensibility, portability, and composability) and even some more sophisticated
    requirements on top. The core of your application is one large plugin system.
    Then, you start to implement everything as a plugin. Even the core concerns of
    your application will be implemented as plugins. A perfect example of this approach
    is the Eclipse IDE with its Equinox core. The problem with this approach is that
    you''re likely to run into performance problems as your application grows. As
    everything is a plugin, optimization is quite tricky, and plugin compatibility
    can make the application unstable.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心是插件系统**：另一种方法是构建一个复杂的插件架构，使其满足前面列表中概述的所有要求（可扩展性、可移植性和可组合性），甚至还有一些更复杂的要求。应用程序的核心是一个庞大的插件系统。然后，你开始将一切作为插件来实现。甚至应用程序的核心关注点也将作为插件实现。这种方法的一个完美例子是Eclipse
    IDE及其Equinox核心。这种方法的缺点是，随着应用程序的增长，你可能会遇到性能问题。由于一切都是插件，优化相当困难，插件兼容性可能会使应用程序变得不稳定。'
- en: '**Event-based extension points**: Also, a great way to provide extensibility
    of a system is by opening up the pipeline of your system to input from outside.
    Imagine that for every important step in your application, you notify the outside
    world about the step and allow interception before the application continues with
    processing. In this manner, a plugin will just be an adapter that listens for
    these pipeline events of your application and then modifies the behavior as required.
    A plugin itself can also emit events, which then can be processed by other plugins
    again. This architecture is really flexible, as it allows you to change the behavior
    of your core functionality without introducing too much complexity. It''s also
    fairly easy to implement this approach even after you''ve finished your core without
    any thoughts about a plugin system. I''ve been following this approach in my open
    source project Chartist and, so far, I''ve had very good results with it.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于事件的扩展点**：另外，提供系统扩展性的一个很好的方法是通过向系统开放外部输入的管道。想象一下，对于你应用程序中的每一个重要步骤，你都会通知外部世界这个步骤，并在应用程序继续处理之前允许拦截。以这种方式，插件将仅仅是一个适配器，它监听应用程序的这些管道事件，并根据需要修改行为。插件本身也可以发出事件，然后可以被其他插件再次处理。这种架构非常灵活，因为它允许你在不引入太多复杂性的情况下更改核心功能的行为。即使在完成核心功能后没有考虑插件系统，这种方法也相当容易实现。我在我的开源项目Chartist中一直遵循这种方法，到目前为止，我取得了非常好的效果。'
- en: '**Plugin interfaces**: An application can expose a set of interfaces that define
    certain extension points. This approach is heavily used in the Java framework
    where it''s known as **Service Provider Interface** (**SPI**). Providers implement
    a certain contract, which allows the core system to rely on an interface rather
    than an implementation. These providers can then be cycled back into the system
    where they are made available to the framework and other providers. Although this
    is probably the safest way to provide extensibility in terms of uniformness, it''s
    also the most rigid one. A plugin will never be allowed to do anything else that
    was specified in the contract of the interfaces.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件接口**：一个应用程序可以公开一组接口，这些接口定义了某些扩展点。这种方法在Java框架中得到了广泛的应用，被称为**服务提供者接口**（**SPI**）。提供者实现一定的合同，允许核心系统依赖于接口而不是实现。然后，这些提供者可以循环回到系统中，在那里它们被提供给框架和其他提供者。尽管这可能是在统一性方面提供扩展性的最安全方式，但它也是最僵化的。插件永远不会被允许执行合同中未指定的任何其他操作。'
- en: You can see that all four approaches vary a lot. From the top-most, which provides
    extreme flexibility at the cost of complexity and stability, to the bottom-most,
    which is very robust but also rigid.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，所有四种方法差异很大。从最顶层的，它以复杂性和稳定性为代价提供了极端的灵活性，到最底层的，它非常健壮但也非常僵化。
- en: The approach that you choose when implementing a plugin system heavily depends
    on the requirements for your application. If you do not plan on building an application
    that comes bundled in various flavors and where multiple versions for completely
    different concerns should exist, the approaches to the bottom of the preceding
    listing are probably more likely the ones that you should follow.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实现插件系统时选择的方法在很大程度上取决于你应用程序的需求。如果你不打算构建一个包含各种风味的应用程序，其中应该存在针对完全不同关注点的多个版本，那么前面列表中的方法可能更可能是你应该遵循的方法。
- en: Pluggable UI components
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可插入的UI组件
- en: 'The system that we''re going to build in this chapter borrows a lot of mechanisms
    that are already present in the Angular framework. In order to implement extensibility
    using plugins, we rely on the following core concepts:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们将要构建的系统借鉴了Angular框架中已经存在的许多机制。为了使用插件实现扩展性，我们依赖于以下核心概念：
- en: We use directives to indicate extension points in the UI, which we call plugin
    slots. These plugin slot directives will be responsible for the dynamic instantiation
    of plugin components and will insert them into the application UI at the given
    position.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用指令来指示UI中的扩展点，我们称之为插件槽。这些插件槽指令将负责动态实例化插件组件，并将它们插入到应用程序UI的指定位置。
- en: Plugins expose components using a concept that we call plugin placements. Plugin
    placements declare what components of a plugin should be placed into which plugin
    slots in the application. We also use plugin placements to decide the order in
    which components from different plugins should be inserted into the plugin slots.
    For this, we'll use a property called **priority**.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件通过我们称之为插件放置的概念来公开组件。插件放置声明了插件中的哪些组件应该放置到应用程序中的哪个插件槽位中。我们还使用插件放置来决定来自不同插件的组件应按何种顺序插入到插件槽位中。为此，我们将使用一个名为**优先级**的属性。
- en: We use the dependency injection of Angular to provide the instantiated plugin
    information into the plugin components. As the plugin components will be placed
    in a spot where there's already an injector present, they will be able to inject
    surrounding components and dependencies in order to connect to the application.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用Angular的依赖注入来提供已实例化的插件信息到插件组件中。由于插件组件将被放置在一个已经存在注入器的地方，因此它们将能够注入周围的组件和依赖项，以便连接到应用程序。
- en: 'Let''s look at the following illustration to picture the architecture of our
    plugin system before we start implementing it:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现它之前，让我们看一下以下插图，以了解我们插件系统的架构：
- en: '![Pluggable UI components](img/image00349.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![可插拔UI组件](img/image00349.jpeg)'
- en: The plugin architecture that we'll implement in this chapter using some basic
    UML and cardinality annotations
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用一些基本的UML和基数注释来实现插件架构
- en: 'Let''s look at the different entities in this diagram and quickly explain what
    they do:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看这个图中的不同实体，并简要解释它们的作用：
- en: '`PluginConfig`: This ES7 decorator is the key element when implementing a plugin.
    By annotating a plugin class using this decorator, we can store meta-information
    about the plugin, which will be used later by our plugin system. The metadata
    includes the plugin name, a description, and the placement information.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PluginConfig`：这是一个ES7装饰器，在实现插件时是关键元素。通过使用此装饰器注释插件类，我们可以存储有关插件元信息，这些信息将在以后由我们的插件系统使用。元数据包括插件名称、描述和位置信息。'
- en: '`PluginData`: This is an aggregation class that is used by the plugin system
    to couple the information about an instantiated plugin with the placement information
    (where plugin components should be instantiated). This entity is exposed in dependency
    injection once a plugin component is created. Any plugin component can make use
    of this entity to gather information about the instantiation or to gain access
    to the plugin instance.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PluginData`：这是一个聚合类，由插件系统用于将关于已实例化插件的详细信息与位置信息（插件组件应实例化的位置）耦合。一旦创建插件组件，该实体就会在依赖注入中公开。任何插件组件都可以使用这个实体来收集有关实例化的信息或获取对插件实例的访问权限。'
- en: '`PluginService`: This is the service used to glue our plugin system together.
    It''s mainly used to load plugins, remove plugins, or used by the `PluginSlot`
    directive to gather plugin components together that are relevant for creation
    in the plugin slot.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PluginService`：这是用于将我们的插件系统粘合在一起的服务。它主要用于加载插件、删除插件，或由`PluginSlot`指令用于收集与插件槽位创建相关的插件组件。'
- en: '`PluginSlot`: This directive is used to mark UI extension points in our application.
    Wherever we''d like to make it possible for plugins to hook into our application
    user interface, we''ll place this directive. Plugin slots need to be named, and
    plugins use placement information to reference slots by their name. This way a
    plugin can provide different components for different slots in our application.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PluginSlot`：这个指令用于标记我们应用程序中的UI扩展点。无论我们希望在哪个位置使插件能够钩入我们的应用程序用户界面，我们都会放置这个指令。插件槽位需要命名，插件使用位置信息通过名称引用槽位。这样，一个插件可以为我们的应用程序中的不同槽位提供不同的组件。'
- en: '`PluginComponent`: These are regular Angular components that come bundled with
    a plugin implementation. A plugin can provide multiple components configured on
    the plugin using a `PluginPlacement` object.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PluginComponent`：这些是随插件实现捆绑的常规Angular组件。一个插件可以通过使用`PluginPlacement`对象在插件上配置多个组件。'
- en: '`PluginPlacement`: This is used in the plugin configuration where a plugin
    can have multiple placement configurations. Each placement entity consist of a
    reference to a component, the name of the slot where the component should be instantiated,
    and a priority number that helps the plugin system to order plugin components
    correctly when multiple components get instantiated in the same slot.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PluginPlacement`：在插件配置中使用，当一个插件可以有多个放置配置时。每个放置实体包括对一个组件的引用、组件应实例化的槽位名称以及一个优先级数字，这有助于插件系统在多个组件在同一个槽位中实例化时正确地排序插件组件。'
- en: '`Plugin`: This is the actual plugin class when implementing a plugin. The class
    contains the plugin configuration annotated using the `PluginConfig` decorator.
    The plugin class is instantiated once in the application and is also shared across
    the plugin components using the dependency injection of Angular. Therefore, this
    class is also a good place to share data between plugin components.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Plugin`：这是实现插件时的实际插件类。该类包含使用`PluginConfig`装饰器注解的插件配置。插件类在应用程序中仅实例化一次，并且通过Angular的依赖注入与插件组件共享。因此，这个类也是插件组件之间共享数据的好地方。'
- en: Now, we have an overview of what we're going to build on a higher level. Our
    plugin system is very rudimentary, but it will support things such as hot loading
    plugins (plug and play style) and other nice features. In the next topic, we'll
    start by implementing the plugin API core components.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对将要构建的内容有一个更高层次的概述。我们的插件系统非常基础，但它将支持诸如热加载插件（即插即用风格）和其他优秀功能。在下一个主题中，我们将开始实现插件API的核心组件。
- en: Implementing the plugin API
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现插件API
- en: 'Let''s start with the less complex entities of our plugin API. We create a
    new `lib/plugin/plugin.js` file to create the `PluginConfig` decorator and the
    `PluginPlacement` class, which stores the information where plugin components
    should be placed. We also create the `PluginData` class in this file, which is
    used to inject plugin runtime information into plugin components:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们插件API中较简单的实体开始。我们在`lib/plugin/plugin.js`文件中创建一个新的文件来创建`PluginConfig`装饰器和`PluginPlacement`类，这些类存储了插件组件应放置的信息。我们还在这个文件中创建了`PluginData`类，该类用于将插件运行时信息注入到插件组件中：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `PluginConfig` decorator contains the very simple logic of accepting a
    configuration parameter, which will then be stored on the annotated class (the
    constructor function) on the `_pluginConfig` property. If you need a refresher
    on how decorators work, it''s maybe a good time to read the decorator topic in
    [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Component-Based User Interfaces"),
    *Component-Based User Interfaces*, again:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`PluginConfig`装饰器包含接受配置参数的非常简单的逻辑，然后该参数将被存储在注解的类（构造函数）上的`_pluginConfig`属性中。如果你需要复习装饰器的工作原理，现在可能是阅读[第1章](part0014.xhtml#aid-DB7S1
    "第1章. 组件化用户界面")中关于装饰器的主题，即*组件化用户界面*的好时机：'
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `PluginPlacement` class represents the configuration object to expose plugin
    components into different plugin slots in the application UI:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`PluginPlacement`类代表配置对象，用于将插件组件暴露到应用程序UI中的不同插件槽位：'
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `PluginData` class represents the plugin runtime information that was created
    during instantiation of the plugin as well as one `PluginPlacement` object. This
    class will be used by the `PluginService` to convey information about plugin components
    to the plugin slots in the application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`PluginData`类代表在插件实例化期间创建的插件运行时信息以及一个`PluginPlacement`对象。这个类将由`PluginService`使用，以将有关插件组件的信息传达给应用程序中的插件槽位。'
- en: These three classes are the main interaction points when implementing a plugin.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个类是实现插件时的主要交互点。
- en: 'Let''s look at a simple example plugin, to get a picture of how we can use
    the `PluginConfig` decorator and the `PluginPlacement` class to configure a plugin:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的插件示例，以了解我们如何使用`PluginConfig`装饰器和`PluginPlacement`类来配置一个插件：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the `PluginConfig` decorator, implementing a new plugin is a breeze. We
    decide the name, description, and where we'd like to place plugin components in
    the application at design time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PluginConfig`装饰器，实现一个新的插件变得非常简单。我们在设计时决定名称、描述以及我们希望在应用程序中放置插件组件的位置。
- en: Our plugin system uses named `PluginSlot` directives to indicate extension points
    in our application component tree. In the `PluginPlacement` objects, we reference
    the Angular components built into the plugin and indicate in which slot they should
    be placed by referencing the plugin slot name. The priority of the placement will
    tell the plugin slot how to order the plugin component when created. This gets
    important when components of different plugins get created in the same plugin
    slot.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的插件系统使用命名的 `PluginSlot` 指令来指示我们应用程序组件树中的扩展点。在 `PluginPlacement` 对象中，我们引用插件中内置的
    Angular 组件，并通过引用插件槽名称来指示它们应在哪个槽中放置。放置的优先级将告诉插件槽在创建时如何对插件组件进行排序。当不同插件的组件在同一个插件槽中创建时，这一点变得很重要。
- en: 'Okay, let''s dive right into the core of our plugin architecture by implementing
    the plugin service. We''ll create a new `lib/plugin/plugin-service.js` file and
    create a new `PluginService` class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们直接深入到我们的插件架构的核心，通过实现插件服务。我们将创建一个新的 `lib/plugin/plugin-service.js` 文件并创建一个新的
    `PluginService` 类：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we will create an injectable service, we'll annotate our `PluginService`
    class using the `@Injectable` annotation. We use the RxJS `ReplaySubject` type
    in order to emit events on any changes of the activated plugins.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将创建一个可注入的服务，我们将使用 `@Injectable` 注解来注释我们的 `PluginService` 类。我们使用 RxJS 的 `ReplaySubject`
    类型来在激活插件的任何更改上发出事件。
- en: 'Let''s look at the constructor of our service:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们服务的构造函数：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we initialize a new empty `plugins` array. This will be the list of active
    plugins, which contains runtime plugin data such as the URL where the plugin was
    loaded from, the plugin type (constructor of the class), a shortcut to the configuration
    stored on the plugin (created by the `PluginConfig` decorator) and finally, the
    instance of the plugin class itself.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化一个新的空 `plugins` 数组。这将是我们活动插件的列表，它包含运行时插件数据，例如插件加载的 URL、插件类型（类的构造函数）、指向存储在插件上的配置的快捷方式（由
    `PluginConfig` 装饰器创建）以及最后，插件类的实例本身。
- en: We also add a `change` member that we initialize with a new RxJS `ReplaySubject`.
    We'll use this subject in order to emit the list of active plugins once it changes.
    This allows us to build our plugin system in a reactive way and enable plug and
    play style plugins.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个 `change` 成员，我们使用新的 RxJS `ReplaySubject` 进行初始化。我们将使用此主题在它改变时发出活动插件的列表。这允许我们以响应式的方式构建插件系统，并启用即插即用风格的插件。
- en: 'As a last action in the constructor, we call the `loadPlugins` method of the
    service. This will perform the initial loading with the registered plugins:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为构造函数中的最后一个操作，我们调用服务的 `loadPlugins` 方法。这将执行带有已注册插件的初始加载：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `loadPlugins` method asynchronously loads a file with the name `plugins.js`
    from the root path of our application using SystemJS. The `plugins.js` file is
    expected to default export an array, which contains preconfigured paths to plugins
    that should be loaded with the application startup. This allows us to configure
    the plugins that we're already aware of and which should be present by default.
    Using a separate and asynchronously loaded file for this configuration gives us
    a better separation from the main application. We can run the same application
    code but using a different `plugins.js` file and control what plugins should be
    present by default.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadPlugins` 方法异步地从我们应用程序的根路径使用 SystemJS 加载名为 `plugins.js` 的文件。期望 `plugins.js`
    文件默认导出一个数组，该数组包含预配置的插件路径，这些插件应在应用程序启动时加载。这允许我们配置我们已知并希望默认存在的插件。使用单独的异步加载文件进行此配置使我们能够更好地从主应用程序中分离出来。我们可以运行相同的应用程序代码，但使用不同的
    `plugins.js` 文件，并通过控制默认应存在的插件来控制。'
- en: 'The `loadPlugins` method then loads each plugin using the URL present in the
    `plugins.js` file by calling the `loadPlugin` method:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`loadPlugins` 方法通过调用 `loadPlugin` 方法使用 `plugins.js` 文件中存在的 URL 加载每个插件：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `loadPlugin` method is responsible for the loading and instantiation of
    individual plugin modules. It will take the URL of a plugin module as parameter
    and uses `System.import` to dynamically load the plugin module. The benefits we
    get from using `System.import` for this job is that we can load both, already
    existing modules in the bundled application as well as remote URL's using HTTP
    requests. This makes our plugin system very portable, and we can even load modules
    during runtime from a different server, from NPM or even GitHub. Of course, SystemJS
    also supports different module formats, such as ES6 modules or CommonJS modules,
    as well as different transpilers if the modules are not already transpiled.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadPlugin` 方法负责加载和实例化单个插件模块。它将插件模块的 URL 作为参数，并使用 `System.import` 动态加载插件模块。使用
    `System.import` 来完成这项工作的好处是，我们可以加载已存在于捆绑应用程序中的模块，以及通过 HTTP 请求加载远程 URL。这使得我们的插件系统非常便携，我们甚至可以在运行时从不同的服务器、NPM
    或甚至 GitHub 加载模块。当然，SystemJS 也支持不同的模块格式，如 ES6 模块或 CommonJS 模块，如果模块尚未转换，还支持不同的转换器。'
- en: After the plugin module is successfully loaded, we bundle all information about
    the loaded plugin together into a `pluginData` object. We can then add this information
    to our `plugins` array and emit a new event on our `ReplaySubject` to notify interested
    parties about the change.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在插件模块成功加载后，我们将有关加载的插件的所有信息捆绑到一个 `pluginData` 对象中。然后我们可以将此信息添加到我们的 `plugins`
    数组中，并在我们的 `ReplaySubject` 上发出一个新事件，以通知感兴趣的各方关于更改的消息。
- en: 'Finally, we''ll need a method to gather the `PluginPlacement` data from all
    our plugins and filter them by a slot name. This gets important when our plugin
    slots need to know which components they should instantiate. Plugins can expose
    any number of components into any number of application plugin slots. This function
    will be used by our plugin slots when they need to know which of the exposed Angular
    components are relevant to them:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个方法来收集所有插件中的 `PluginPlacement` 数据，并按槽位名称进行过滤。当我们的插件槽位需要知道它们应该实例化哪些组件时，这一点很重要。插件可以将任意数量的组件暴露到任意数量的应用程序插件槽位中。当插件槽位需要知道哪些暴露的
    Angular 组件与它们相关时，将使用此函数：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is already it for the `PluginService` class so far, and we created the
    core of our plugin system. In the next chapter, we will deal with the plugin slots
    and look at how we can instantiate plugin components dynamically.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`PluginService` 类已经完成了，我们创建了插件系统的核心。在下一章中，我们将处理插件槽位，并看看我们如何可以动态实例化插件组件。
- en: Instantiating plugin components
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化插件组件
- en: Now, it's time to look at the second major piece of our plugin architecture,
    which is the `PluginSlot` directive that is responsible for the instantiation
    of plugin components in the right spots.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看我们插件架构的第二大主要部分了，那就是负责在正确位置实例化插件组件的 `PluginSlot` 指令。
- en: Before we get to implement the directive though, let's look at how we can instantiate
    a component dynamically in Angular. We already covered instantiating views that
    can contain components in [Chapter 7](part0049.xhtml#aid-1ENBI2 "Chapter 7. Components
    for User Experience"), *Components for User Experience*. In the infinite scroll
    directive, we used the `ViewContainerRef` to instantiate template elements. However,
    we have a different use case here. We'd like to instantiate a single component
    into an existing view.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现指令之前，让我们看看如何在 Angular 中动态实例化组件。我们已经在 [第 7 章](part0049.xhtml#aid-1ENBI2
    "第 7 章。用户体验组件") *用户体验组件* 中介绍了可以包含组件的实例化视图。在无限滚动指令中，我们使用了 `ViewContainerRef` 来实例化模板元素。然而，这里有一个不同的用例。我们希望将单个组件实例化到现有的视图中。
- en: 'The `ViewContainerRef` object also provides us with a solution to this problem.
    Let''s look at a very basic example on how to use the `ViewContainerRef` object
    to instantiate a component. In the following example, we make use of four new
    concepts:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewContainerRef` 对象也为我们提供了这个问题的解决方案。让我们看看如何使用 `ViewContainerRef` 对象来实例化组件的一个非常基础的例子。在下面的例子中，我们使用了四个新的概念：'
- en: 'Using `@ViewChild` with `read` options set to `{read: ViewContainerRef}` to
    query for view container instead of the element'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 `@ViewChild` 并将 `read` 选项设置为 `{read: ViewContainerRef}` 来查询视图容器而不是元素'
- en: Using the `ComponentResolver` instance to obtain the factory of the component,
    which we want to instantiate dynamically
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ComponentResolver` 实例来获取我们想要动态实例化的组件的工厂
- en: Using `ReflectiveInjector` to create a new child injector that is used for our
    instantiated component
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ReflectiveInjector` 创建一个新的子注入器，用于我们的实例化组件
- en: Using `ViewContainerRef.createComponent` to instantiate a component and attach
    it to the underlying view of the view container.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ViewContainerRef.createComponent` 实例化一个组件并将其附加到视图容器的底层视图。
- en: The following code example shows how we can dynamically create a component using
    the `ViewContainerRef` instance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了我们如何使用 `ViewContainerRef` 实例动态创建一个组件。
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Injected into the constructor of the `App` component, we can later use `ComponentResolver`
    to resolve the `HelloWorld` component. We use the `@ViewChild` decorator to query
    for the heading element in the `App` component. Usually, this would give us the
    `ElementRef` object that is associated with the view element. However, as we need
    the view container associated with the element, we can use the `{read: ViewContainerRef}`
    options to obtain the `ViewContainerRef` object instead.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '注入到 `App` 组件的构造函数中，我们稍后可以使用 `ComponentResolver` 解决 `HelloWorld` 组件。我们使用 `@ViewChild`
    装饰器在 `App` 组件中查询标题元素。通常，这将给我们一个与视图元素关联的 `ElementRef` 对象。然而，由于我们需要与元素关联的视图容器，我们可以使用
    `{read: ViewContainerRef}` 选项来获取 `ViewContainerRef` 对象。'
- en: In the `AfterViewInit` lifecycle hook, we first call the `resolveComponent`
    method on the `ComponentResolver` instance. This call returns a promise, which
    resolves to an object of the `ComponentFactory` type. Angular uses component factories
    internally in order to create components.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AfterViewInit` 生命周期钩子中，我们首先在 `ComponentResolver` 实例上调用 `resolveComponent`
    方法。此调用返回一个承诺，该承诺解决为 `ComponentFactory` 类型的对象。Angular 在内部使用组件工厂来创建组件。
- en: After the promise has been resolved, we can now use the `createComponent` method
    on the view container of our heading element to create our `HelloWorld` component.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在承诺解决后，我们现在可以使用我们标题元素的视图容器上的 `createComponent` 方法来创建我们的 `HelloWorld` 组件。
- en: 'Let''s look at the `createComponent` method of the `ViewContainerRef` object
    in more detail:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看 `ViewContainerRef` 对象的 `createComponent` 方法：
- en: '| Method | Description |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ViewContainerRef.createComponent` | This method will create a component
    that is based on the component factory provided in the `componentFactory` parameter.
    The compiled component will then be attached to the view container at a specific
    position provided by the `index` parameter.The following are the parameters:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '| `ViewContainerRef.createComponent` | 此方法将创建一个基于在 `componentFactory` 参数中提供的组件工厂的组件。编译后的组件将随后附加到由
    `index` 参数提供的特定位置上的视图容器。以下参数：'
- en: '`componentFactory`: This is the component factory, which will be used to create
    a new component.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componentFactory`：这是组件工厂，将用于创建新的组件。'
- en: '`Index`: This is the optional parameter to specify the position in the view
    container at which the created component should be inserted. If this parameter
    is not specified, the component will be inserted at the last position in the view
    container.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Index`：这是一个可选参数，用于指定创建的组件应在视图容器中插入的位置。如果没有指定此参数，组件将插入到视图容器的最后一个位置。'
- en: '`Injector`: This is an optional parameter that allows you to specify a custom
    injector for the created component. This allows you to provide additional dependencies
    for the created component.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Injector`：这是一个可选参数，允许您为创建的组件指定自定义注入器。这允许您为创建的组件提供额外的依赖项。'
- en: '`projectableNodes`: This is an optional parameter to specify nodes for content
    projection.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`projectableNodes`：这是一个可选参数，用于指定内容投影的节点。'
- en: This method returns a promise that is resolved when the instantiated component
    is compiled. The `Promise` resolves to a `ComponentRef` object, which can also
    be used to destroy the component again later on. |
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个在实例化组件编译完成后解决的承诺。`Promise` 解决为一个 `ComponentRef` 对象，该对象也可以用于稍后再次销毁组件。|
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: By default, a component created with the `ViewContainerRef.createComponent`
    method will inherit the injector from the parent component, which makes this process
    context aware. However, the `injector` parameter of the `createComponent` method
    is especially useful when you want to provide additional dependencies into the
    component that are not present on any parent injector.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用 `ViewContainerRef.createComponent` 方法创建的组件将从父组件继承注入器，这使得此过程具有上下文感知性。然而，`createComponent`
    方法的 `injector` 参数在您想要向组件提供不在任何父注入器上存在的额外依赖项时特别有用。
- en: Let's go back to our `PluginSlot` directive that is responsible for the instantiation
    of relevant plugin components.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`PluginSlot`指令，它负责相关插件组件的实例化。
- en: 'First, let''s think about the high-level requirements of our `PluginSlot` directive
    before we dive into the code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们深入代码之前，让我们思考一下我们的`PluginSlot`指令的高级需求：
- en: The plugin slot should contain a name input property so that this name can be
    referenced from plugins that want to provide components for the slot.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件槽应该包含一个名称输入属性，这样这个名称就可以被想要为插槽提供组件的插件所引用。
- en: The directive needs to react on changes of the `PluginService` and re-evaluate
    what plugin components need to be placed.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令需要响应`PluginService`的变化，并重新评估需要放置哪些插件组件。
- en: In the initialization of the plugin slot, we need to obtain a list of the `PluginData`
    objects that are relevant to this particular slot. We should consult the `getPluginData`
    method of `PluginService` in order to get this list.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在插件槽的初始化过程中，我们需要获取与这个特定插槽相关的`PluginData`对象列表。我们应该咨询`PluginService`的`getPluginData`方法来获取这个列表。
- en: Using the obtained list of the relevant `PluginData` objects, we'll be able
    to instantiate components that are associated with the placement information using
    the `ViewContainerRef` object of our directive.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用获取的相关`PluginData`对象列表，我们将能够使用我们的指令的`ViewContainerRef`对象实例化与放置信息关联的组件。
- en: 'Let''s create our `PluginSlot` directive on the `lib/plugin/plugin-slot.js`
    path:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`lib/plugin/plugin-slot.js`路径上创建我们的`PluginSlot`指令：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `name` input in our directive is very important for our plugin mechanism.
    By providing a name to the directive, we can define named extension points in
    our UI and later use this name in the `PluginPlacement` data of the plugin configurations:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的指令中，`name`输入对于我们的插件机制非常重要。通过向指令提供名称，我们可以在我们的UI中定义命名的扩展点，并在稍后使用这个名称在插件配置的`PluginPlacement`数据中：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the constructor, we first inject the `ViewContainerRef` object, which is
    a reference to the view container of the directive. As we want to use the view
    container of the directive directly, there's no need to use `@ViewChild` here.
    If we want the view container of the current directive, we can simply use injection.
    We'll use this reference while we're instantiating components using the `ViewContainerRef.createComponent`
    method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们首先注入`ViewContainerRef`对象，这是一个指向指令视图容器的引用。由于我们想直接使用指令的视图容器，这里不需要使用`@ViewChild`。如果我们想获取当前指令的视图容器，我们可以简单地使用注入。当我们使用`ViewContainerRef.createComponent`方法实例化组件时，我们将使用这个引用。
- en: In order to resolve components and their factory, we inject the `ComponentResolver`
    instance.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析组件及其工厂，我们注入`ComponentResolver`实例。
- en: The `PluginService` is injected for two reasons. First, we'd like to subscribe
    to any changes on the list of active plugins, and secondly, we use it to obtain
    relevant `PluginData` objects for this slot.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`PluginService`被注入有两个原因。首先，我们希望订阅活动插件列表上的任何变化，其次，我们使用它来获取这个插槽的相关`PluginData`对象。'
- en: We use the `componentRefs` member to keep track of already instantiated plugin
    components. This will help us destroy them later on when a plugin gets deactivated.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`componentRefs`成员来跟踪已经实例化的插件组件。这将帮助我们稍后当插件被停用时销毁它们。
- en: 'Finally, we create a new subscription to `PluginService` and store the subscription
    into the `pluginChangeSubscription` member field. On any changes of the activated
    plugin list, we execute the `initialize` method on our component:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为`PluginService`创建一个新的订阅，并将订阅存储到`pluginChangeSubscription`成员字段中。在激活的插件列表发生任何变化时，我们在我们的组件上执行`initialize`方法：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s look at the four parts of the initialize method in detail:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看`initialize`方法的四个部分：
- en: First, we check whether this plugin slot already contains instantiated plugin
    components in the `componentRefs` member. If this is the case, we use the detach
    method of the `ComponentRef` objects to remove all existing instances. After this,
    we initialize the `componentRefs` member with an empty array.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们检查这个插件槽是否已经在`componentRefs`成员中包含实例化的插件组件。如果是这种情况，我们使用`ComponentRef`对象的detach方法移除所有现有实例。之后，我们将`componentRefs`成员初始化为一个空数组。
- en: We use the `getPluginData` method of `PluginService` to obtain a list of the
    `PluginData` objects that are relevant for this particular slot. We pass the name
    of this slot to the method, so the `PluginService` will already provide us with
    a filtered list of plugin components that are interested to be placed in our slot.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`PluginService`的`getPluginData`方法来获取与这个特定槽位相关的`PluginData`对象列表。我们将此槽位的名称传递给该方法，这样`PluginService`就会提前为我们提供一个感兴趣的插件组件列表，这些组件希望放置在我们的槽位中。
- en: As there could be many plugins queueing for placement in our slot, we are using
    the priority property of the `PluginPlacement` objects to sort the list of the
    `PluginData` objects. This will ensure that plugin components with higher priority
    will be placed before the ones with a lower priority. This is a nice extra feature
    that will come in handy when we deal with a lot of plugins fighting for space.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于可能有多个插件排队等待在我们的槽位中放置，我们正在使用`PluginPlacement`对象的优先级属性来对`PluginData`对象列表进行排序。这将确保具有更高优先级的插件组件将排在具有较低优先级的组件之前。这是一个很好的额外功能，当我们要处理许多争夺空间的插件时，这个功能将非常有用。
- en: The last code part in our `initialize` method calls the `instantiatePluginComponent`
    method for each `PluginData` object in our list.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的`initialize`方法的最后一段代码中，我们为列表中的每个`PluginData`对象调用`instantiatePluginComponent`方法。
- en: 'Now, let''s create the `instantiatePluginComponent` method, which is called
    as a last step in the `initialize` method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建`instantiatePluginComponent`方法，该方法在`initialize`方法的最后一步被调用：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This method is responsible for the instantiation of an individual plugin component.
    Now, we can use the knowledge that we gained in this topic about the `ViewContainerRef.createComponent`
    method and the `ComponentResolver` object to instantiate components dynamically.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法负责创建单个插件组件。现在，我们可以使用我们在本主题中关于`ViewContainerRef.createComponent`方法和`ComponentResolver`对象所获得的知识来动态创建组件。
- en: In addition to the inherited providers from the component where this plugin
    slot is placed, we'd like to provide `PluginData` to the injector of the instantiated
    plugin component. Using Angular's `provide` function, we can specify `pluginData`
    to resolve for any injection on the `PluginData` type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从放置此插件槽位的组件继承的提供者之外，我们还想将`PluginData`提供给已实例化的插件组件的注入器。使用Angular的`provide`函数，我们可以指定`pluginData`以解决对`PluginData`类型的任何注入。
- en: The `ReflectiveInjector` class provides us with some static methods that are
    used to create injectors. We can use the `parentInjector` member on our view container
    to obtain the injector that is present in the plugin slot context. Then, we use
    the static `resolveAndCreate` method on the `ReflectiveInjector` class in order
    to create a new child injector.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReflectiveInjector`类为我们提供了一些静态方法，用于创建注入器。我们可以使用我们的视图容器上的`parentInjector`成员来获取插件槽位上下文中的注入器。然后，我们使用`ReflectiveInjector`类上的静态`resolveAndCreate`方法来创建一个新的子注入器。'
- en: In the first parameter of the `resolveAndCreate` method, we can provide a list
    of providers. Those providers will be resolved and made available in our new child
    injector. The second parameter of the `resolveAndCreate` method accepts the parent
    injector of the newly-created child injector.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`resolveAndCreate`方法的第一个参数中，我们可以提供一个提供者列表。这些提供者将被解决并可供我们的新子注入器使用。`resolveAndCreate`方法的第二个参数接受新创建的子注入器的父注入器。
- en: Finally, we use the `createComponent` method of the `ViewContainerRef` object
    to instantiate the plugin component. As a second parameter to the `createComponent`
    method call, we need to pass the position in the view container. Here, we make
    use of the `length` property of our view container in order to place it at the
    very end. In the third parameter, we override the default injector of the component
    with our custom child injector. On success, we add the created `ComponentRef`
    object to our list of instantiated components.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`ViewContainerRef`对象的`createComponent`方法来实例化插件组件。作为`createComponent`方法调用的第二个参数，我们需要传递视图容器中的位置。在这里，我们利用我们的视图容器的`length`属性将其放置在最后。在第三个参数中，我们用我们的自定义子注入器覆盖组件的默认注入器。成功后，我们将创建的`ComponentRef`对象添加到我们的已实例化组件列表中。
- en: Finalizing our plugin architecture
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成我们的插件架构
- en: Congratulations, you've just built your own plugin architecture using Angular!
    We created a plugin API that can be used to create new plugins using the `PluginConfig`
    decorator. `PluginService` manages the whole plugin loading and provides the `PluginData`
    objects to the slots in our application using custom injectors. The `PluginSlot`
    directive can be used in the task management application to mark extension points
    in the user interface. Using the inheriting nature of the dependency injection
    in Angular, plugin components will be able to access whatever they require from
    their environment.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经使用Angular构建了自己的插件架构！我们创建了一个插件API，可以使用`PluginConfig`装饰器来创建新的插件。`PluginService`管理整个插件加载，并使用自定义注入器将`PluginData`对象提供给应用中的插槽。`PluginSlot`指令可以在任务管理应用中使用，以在用户界面中标记扩展点。利用Angular中依赖注入的继承特性，插件组件将能够访问它们环境中所需的一切。
- en: In the next section, we will create our first plugin using the plugin architecture
    that we just created.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用我们刚刚创建的插件架构来创建我们的第一个插件。
- en: Building an Agile plugin
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建敏捷插件
- en: In the previous section, we created a simple but effective plugin architecture,
    and we will now use this plugin API to build our first plugin in the task management
    application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个简单但有效的插件架构，现在我们将使用这个插件API在任务管理应用中构建我们的第一个插件。
- en: 'Before we get into the plugin details, we should first agree on where to make
    our application extensible. Our plugin system is based on the `PluginSlot` directives,
    which should be placed somewhere in our component tree so that plugins can expose
    components to these slots. For now, we decide to make two spots in our application
    extensible:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入插件细节之前，我们首先应该就我们的应用的可扩展性达成一致。我们的插件系统基于`PluginSlot`指令，这些指令应该放置在我们的组件树中的某个位置，以便插件可以暴露组件到这些插槽。目前，我们决定在我们的应用中设置两个可扩展的位置：
- en: '`TaskInfo`: In the list of tasks displayed in a project, we currently render
    `Task` components. Besides the title of the task, the `Task` component displays
    additional information such as the task number, the date of creation, and milestones,
    as well as efforts information where applicable. This additional information is
    rendered on the `Task` component using the `TaskInfos` subcomponent. This is a
    good spot to provide extensibility for plugins so that they can add additional
    task information, which will be displayed on the task list overview.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TaskInfo`：在项目中显示的任务列表中，我们目前渲染`Task`组件。除了任务的标题外，`Task`组件还显示其他信息，如任务编号、创建日期、里程碑以及适用的情况下的努力信息。这些附加信息是通过`TaskInfos`子组件在`Task`组件上渲染的。这是一个为插件提供可扩展性的好位置，以便它们可以添加额外的任务信息，这些信息将在任务列表概览中显示。'
- en: '`TaskDetail`: Another great spot to provide extensibility is the `ProjectTaskDetails`
    component. This is where we can edit the details of a task, which makes it a great
    component to open up for extension by plugins.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TaskDetail`：另一个提供可扩展性的绝佳位置是`ProjectTaskDetails`组件。这是我们编辑任务详情的地方，这使得它成为插件扩展的绝佳组件。'
- en: 'Besides adding the `PluginSlot` directive to the directives list of the `TaskInfos`
    component, we modify the template located at `lib/task-list/task/task-infos/task-infos.html`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将`PluginSlot`指令添加到`TaskInfos`组件的指令列表中，我们还修改了位于`lib/task-list/task/task-infos/task-infos.html`的模板：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After including the `PluginSlot` directive and by setting the name input property
    to `task-info`, we provide an extension point for plugins where they can provide
    additional components.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含`PluginSlot`指令并将名称输入属性设置为`task-info`之后，我们为插件提供了一个扩展点，它们可以在其中提供额外的组件。
- en: 'Let''s apply the same changes to the `ProjectTaskDetails` component template
    in `lib/project/project-task-details/project-task-details.html`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将相同的更改应用到`lib/project/project-task-details/project-task-details.html`中的`ProjectTaskDetails`组件模板：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Right before the end of the task details content element, we include another
    plugin slot with the name `task-detail`. By providing components for this slot,
    plugins can hook into the edit view of tasks.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务详情内容元素的末尾之前，我们包含另一个名为`task-detail`的插件插槽。通过为这个插槽提供组件，插件可以钩入任务的编辑视图。
- en: Okay, so our extension points are set up for plugins to provide additional components
    on a task level. You can see that preparing these spots using the `PluginSlot`
    directive is really a piece of cake.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们的扩展点已经设置好了，插件可以在任务级别提供额外的组件。你可以看到，使用`PluginSlot`指令准备这些位置真的是小菜一碟。
- en: Now, we can look into the implementation of our Agile plugin, which will make
    use of the extension points that we just exposed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以查看我们的敏捷插件的实现，它将利用我们刚刚暴露的扩展点。
- en: The agile plugin that we will create will provide functionality to log story
    points on tasks. Story points are commonly used in Agile project management. They
    should provide a sense for complexity, and they are relative to a so-called reference
    story. If you want to know more about Agile project management and how to estimate
    using story points, I really recommend the book, *Agile Estimating and Planning*
    by Mike Cohn.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的敏捷插件将提供在任务上记录故事点的功能。故事点在敏捷项目管理中常用。它们应该提供对复杂性的感知，并且相对于所谓的参考故事而言。如果你想了解更多关于敏捷项目管理以及如何使用故事点进行估算的信息，我强烈推荐迈克·科恩的书籍，《敏捷估算与规划》。
- en: Let's start with our plugin class and the necessary configuration. We create
    the plugin outside our regular `lib` folder, just to indicate the portable nature
    of plugins.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的插件类和必要的配置开始。我们创建插件在常规 `lib` 文件夹之外，只是为了表明插件的便携性。
- en: 'We create a new `AgilePlugin` class on the `plugins/agile/agile.js` path:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `plugins/agile/agile.js` 路径上创建一个新的 `AgilePlugin` 类：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The plugin class forms the central entry point of our plugin. We use the `PluginConfig`
    decorator, which we created as part of our plugin API. Besides the name and description,
    we also need to configure any placements where we map plugin components to application
    plugin slots. However, as we haven't got any plugin component yet to expose, our
    list remains empty for the moment.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 插件类构成了我们插件的核心入口点。我们使用 `PluginConfig` 装饰器，这是我们作为插件 API 的一部分创建的。除了名称和描述之外，我们还需要配置任何放置，其中我们将插件组件映射到应用程序插件槽位。然而，由于我们还没有任何插件组件要暴露，我们的列表目前仍然是空的。
- en: It's also important to note that a plugin module always needs to default export
    the plugin class. This is just how we've implemented the plugin-loading mechanisms
    in our `PluginService` class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，插件模块始终需要默认导出插件类。这正是我们在 `PluginService` 类中实现插件加载机制的方式。
- en: 'Looking back at these two lines in the `loadPlugin` method of `PluginService`
    shows you that we rely on the default export of plugin modules:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾 `PluginService` 的 `loadPlugin` 方法中的这两行，可以看出我们依赖于插件模块的默认导出：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the plugin module is successfully loaded, we obtain the default export
    by referencing the `default` property on the module.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当插件模块成功加载时，我们通过引用模块上的 `default` 属性来获取默认导出。
- en: So far, we created our plugin entry module. This acts as a plugin configuration
    container, and it is not related to Angular in any way. Using the placements configuration,
    we can then expose our plugin Angular components once we've created them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了我们的插件入口模块。这充当了一个插件配置容器，并且与 Angular 没有任何关系。使用放置配置，一旦我们创建了插件，我们就可以暴露我们的插件
    Angular 组件。
- en: Agile task info component
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敏捷任务信息组件
- en: Let's move on to the first Agile plugin component that we want to expose. First,
    we create the component, which will be exposed into the slot with the name `task-info`.
    Below the task title on the task list, our Agile information component should
    display the stored story points.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到我们想要暴露的第一个敏捷插件组件。首先，我们创建一个组件，它将被暴露到名为 `task-info` 的槽位中。在任务列表下的任务标题下方，我们的敏捷信息组件应该显示存储的故事点。
- en: 'We create a new `Component` class on the `plugins/agile/agile-task-info/agile-task-info.js`
    path:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `plugins/agile/agile-task-info/agile-task-info.js` 路径上创建一个新的 `Component`
    类：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see that we implemented a regular component here. There's nothing special
    about this component at all.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们在这里实现了一个常规组件。这个组件没有任何特别之处。
- en: We import the `Task` component to get the type information to inject it in our
    constructor. As the plugin slot is placed inside of the `TaskInfos` component,
    which, in fact, is always a child of a `Task` component, this is a safe injection.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 `Task` 组件以获取类型信息，并将其注入到我们的构造函数中。由于插件槽位于 `TaskInfos` 组件内部，而实际上 `TaskInfos`
    组件始终是 `Task` 组件的子组件，这是一个安全的注入。
- en: In the constructor, we then take the injected `Task` component and extract the
    task data into a local `task` member.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们首先获取注入的 `Task` 组件，并将任务数据提取到本地的 `task` 成员变量中。
- en: We also borrow the `task-infos__info` class of the `TaskInfos` component in
    order to get the same look like other task information that is already present
    on the task.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还借用 `TaskInfos` 组件的 `task-infos__info` 类，以便获得与其他已存在于任务上的任务信息相同的样式。
- en: 'Let''s take a look at the template of the `AgileTaskInfo` component that is
    located in the same path in the `agile-task-info.html` file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看位于同一路径的`agile-task-info.html`文件中的`AgileTaskInfo`组件的模板：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Following the same mark-up that we used in the `TaskInfo` component, we display
    the `storyPoints` tasks if present.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们在`TaskInfo`组件中使用的相同标记，如果存在，我们显示`storyPoints`任务。
- en: 'Alright, now we can expose the plugin component in the plugin configuration
    using a `PluginPlacement` object. Let''s make the necessary modification to our
    `agile.js` module file:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们可以使用`PluginPlacement`对象在插件配置中公开插件组件。让我们对我们的`agile.js`模块文件进行必要的修改：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we include a new `PluginPlacement` object in our plugin configuration,
    which maps our `AgileTaskInfo` component to be exposed into the application plugin
    slot with the name `task-info`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在插件配置中包含一个新的`PluginPlacement`对象，它将我们的`AgileTaskInfo`组件映射到名为`task-info`的应用程序插件插槽中：
- en: '![Agile task info component](img/image00350.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![灵活任务信息组件](img/image00350.jpeg)'
- en: Task info displaying additional information that is provided by our Agile plugin
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 显示由我们的敏捷插件提供的额外信息的任务信息
- en: This would already be enough for the plugin to work. However, as we don't have
    any data filled as `storyPoints` on our tasks, this plugin wouldn't really show
    us anything at the moment.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于插件工作来说已经足够了。然而，由于我们的任务上没有填充任何`storyPoints`数据，这个插件目前实际上不会显示任何内容。
- en: Agile task details component
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灵活任务详情组件
- en: 'Let''s create another plugin component, which can be used to enter story points.
    For this, we will create a new `AgileTaskDetail` component on the `plugins/agile/agile-task-detail/agile-task-detail.js`
    path:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个插件组件，它可以用来输入故事点。为此，我们将在`plugins/agile/agile-task-detail/agile-task-detail.js`路径上创建一个新的`AgileTaskDetail`组件：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There's nothing really fancy with this component either. Our target slot is
    the `task-detail` plugin slot, which is placed inside the `ProjectTaskDetails`
    component. Therefore, it's safe for both the `ProjectTaskDetails` and `Project`
    components to be injected into our plugin component. The `ProjectTaskDetails`
    component is used to obtain the task data in context. We use `LiveDocument` that
    is stored on the `Project` component to persist any changes that we make to the
    task data of the project.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件也没有什么特别之处。我们的目标插槽是`task-detail`插件插槽，它位于`ProjectTaskDetails`组件内部。因此，将`ProjectTaskDetails`和`Project`组件注入到我们的插件组件中是安全的。`ProjectTaskDetails`组件用于获取上下文中的任务数据。我们使用存储在`Project`组件上的`LiveDocument`来持久化我们对项目任务数据的任何更改。
- en: We reuse an `Editor` component to obtain user input and store the input data
    in the `onStoryPointsSaved` call-back. This is the same mechanism we know from
    other areas where we use the `Editor` component. When the story points get edited,
    we first update the task data model that is stored in the `ProjectTaskDetails`
    component. After this, we can use the `LiveDocument` `persist` method to save
    the changes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重用`Editor`组件来获取用户输入，并在`onStoryPointsSaved`回调中存储输入数据。这是我们从前面的区域所了解的相同机制，在那里我们使用了`Editor`组件。当故事点被编辑时，我们首先更新存储在`ProjectTaskDetails`组件中的任务数据模型。之后，我们可以使用`LiveDocument`的`persist`方法来保存更改。
- en: 'Let''s look at the template of our `AgileTaskDetail` component in the `plugins/agile/agile-task-detail/agile-task-detail.html`
    file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看位于`plugins/agile/agile-task-detail/agile-task-detail.html`文件中的我们的`AgileTaskDetail`组件的模板：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We create a direct binding from the `content` input property of our editor to
    the `storyPoints` property of the task data.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从编辑器的`content`输入属性直接绑定到任务数据的`storyPoints`属性。
- en: 'When an edit is saved, we call the `onStoryPointsSaved` callback with the updated
    value:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当编辑被保存时，我们使用更新后的值调用`onStoryPointsSaved`回调：
- en: '![Agile task details component](img/image00351.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![灵活任务详情组件](img/image00351.jpeg)'
- en: Task details displaying the new Agile story points that are exposed by our Agile
    plugin
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 显示由我们的敏捷插件公开的新敏捷故事点的任务详情
- en: 'Before we expose our newly-created plugin component using a new `PluginPlacement`
    object on the plugin configuration, we''ll enhance the component one more time.
    This would be nice if we provide two buttons on the component that allows the
    user to increase or decrease the story points to the next common story point value
    in range. As we already stored the list of common story points on the `Agile`
    plugin class, let''s see how we can make use of this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用新的`PluginPlacement`对象在插件配置中公开我们新创建的插件组件之前，我们将进一步增强组件。如果我们在组件上提供两个按钮，允许用户将故事点增加到或减少到下一个常见故事点值，这将很好。因为我们已经在`Agile`插件类上存储了常见故事点的列表，让我们看看我们如何利用这一点：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While we previously injected the `Project` and `ProjectTaskDetails` components
    that are provided by the component level injectors, we now make use of the providers
    that we added during instantiation in our `PluginSlot` directive. Here, we provided
    `PluginData`, which we can now use to get a reference back to the plugin component.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们之前注入了由组件级别注入器提供的`Project`和`ProjectTaskDetails`组件时，我们现在利用了在`PluginSlot`指令实例化期间添加的提供者。在这里，我们提供了`PluginData`，我们现在可以使用它来获取对插件组件的引用。
- en: The next higher or lower story point value is found by `increaseStoryPoints`
    and `decreaseStoryPoints`. This is done by searching the list of common story
    points that are stored on our `AgilePlugin` class. Using the plugin class instance
    that is present on the injected `PluginData`, we can easily access this list.
    After storing the modified story points, we then use the `LiveDocument` instance
    of the project component to persist the adjusted story points.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个更高或更低的用户故事点值是通过`increaseStoryPoints`和`decreaseStoryPoints`找到的。这是通过搜索存储在我们`AgilePlugin`类上的常见故事点列表来完成的。使用注入的`PluginData`上的插件类实例，我们可以轻松访问此列表。在存储修改后的故事点后，我们然后使用项目组件的`LiveDocument`实例来持久化调整后的故事点。
- en: 'In the template of our `AgileTaskDetail` component, we simply add two buttons
    that allow the user to increase or decrease the story points that are based on
    our newly-created methods:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`AgileTaskDetail`组件模板中，我们简单地添加了两个按钮，允许用户增加或减少基于我们新创建方法的用户故事点：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Okay, let''s now add the `AgileTaskDetail` component to the plugin configuration
    using a new `PluginPlacement` object, which references the `task-detail` plugin
    slot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们使用一个新的`PluginPlacement`对象将`AgileTaskDetail`组件添加到插件配置中，该对象引用`task-detail`插件槽位：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Isn't this great? You created a fully-portable plugin that enables the management
    of Agile story points on tasks.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很好吗？您创建了一个完全可移植的插件，该插件可以管理任务上的敏捷故事点。
- en: '![Agile task details component](img/image00352.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![敏捷任务详情组件](img/image00352.jpeg)'
- en: The task details view with story points and additional increase/decrease buttons
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 带有故事点和额外增加/减少按钮的任务详情视图
- en: 'The only thing that is left is to add the plugin to the list of plugins that
    should be loaded initially by the `PluginService` directive. For this, we''ll
    create a `plugins.js` file on the root of our application and add the following
    content:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情是将插件添加到`PluginService`指令最初应加载的插件列表中。为此，我们将在应用程序的根目录下创建一个`plugins.js`文件，并添加以下内容：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, if we launch our application, the plugin will be loaded by the `PluginService`
    and `PluginSlot` directives will instantiate the Agile plugin components where
    appropriate.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们启动我们的应用程序，插件将由`PluginService`加载，并且`PluginSlot`指令将在适当的位置实例化敏捷插件组件。
- en: Recapitulating on our first plugin
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾我们的第一个插件
- en: Well done! You successfully implemented your first plugin! In this section,
    we used the API of our plugin architecture to create a plugin to manage Agile
    story points. We used the `PluginPlacement` class to map our plugin components
    to different slots in the UI of our application. We also made use of the `PluginData`
    object that is provided to each instantiated component in the plugin slot in order
    to access the plugin instance.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！您成功实现了您的第一个插件！在本节中，我们使用插件架构的API创建了一个用于管理敏捷故事点的插件。我们使用了`PluginPlacement`类将我们的插件组件映射到应用程序UI的不同槽位中。我们还利用了提供给插件槽位中每个实例化组件的`PluginData`对象，以便访问插件实例。
- en: The advantage of implementing functionality like this inside a plugin should
    be obvious. We added an additional feature to our application without building
    up additional dependencies. Our Agile feature is completely portable. Third-party
    developers can write independent plugins, and they can be loaded by our system.
    This is a big advantage, and it helps us keep our core slim while providing great
    extensibility.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在插件内部实现此类功能的优势应该是显而易见的。我们没有建立额外的依赖关系就为我们的应用程序添加了一个新功能。我们的 Agile 功能是完全可移植的。第三方开发者可以编写独立的插件，并且它们可以被我们的系统加载。这是一个很大的优势，它帮助我们保持核心精简的同时提供出色的可扩展性。
- en: Managing plugins
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理插件
- en: We already built the core of the plugin architecture and a first plugin that
    runs in this system. We can use the `plugins.js` file on the root of our application
    to register plugins. The system is actually fully functional already. However,
    it would be nice to provide a way to manage our plugins during runtime.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了插件架构的核心以及在这个系统中运行的第一个插件。我们可以使用应用根目录下的 `plugins.js` 文件来注册插件。系统实际上已经完全可用。然而，提供一个在运行时管理我们插件的方法会更好。
- en: In this section, we will build a new routable component, which will list all
    active plugins in the system. After we've done this, we'll also add some elements
    which allow users to unload active plugins as well as load new plugins during
    runtime. Due to the reactive nature of our plugin system, the browser does not
    need to be refreshed in order for newly-loaded plugins to become active. The moment
    a plugin is loaded, it will immediately be made available to relevant plugin slots.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个新的可路由组件，该组件将列出系统中的所有活动插件。完成此操作后，我们还将添加一些元素，允许用户在运行时卸载活动插件以及加载新插件。由于我们的插件系统的响应式特性，浏览器无需刷新即可使新加载的插件变为活动状态。插件加载的瞬间，它将立即对相关的插件槽位可用。
- en: 'Let''s start with a new `ManagePlugins` component class on the `lib/manage-plugins/manage-plugins.js`
    path:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `lib/manage-plugins/manage-plugins.js` 路径上的一个新的 `ManagePlugins` 组件类开始：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Our `ManagePlugins` component is quite simple. We inject the `PluginService`
    into the constructor of the component and set the member field plugins to point
    to the change observable of `PluginService`. As we'll always get the latest plugin
    list emitted by this observable, we can then simply use the `async` pipe in the
    view to subscribe to the observable.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `ManagePlugins` 组件相当简单。我们在组件构造函数中注入 `PluginService`，并将成员字段 plugins 指向 `PluginService`
    的变化可观察对象。由于我们总会得到这个可观察对象发出的最新插件列表，我们可以在视图中简单地使用 `async` 管道来订阅这个可观察对象。
- en: 'Let''s look at the template of our new component in `lib/manage-plugins/manage-plugins.html`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们新组件的模板 `lib/manage-plugins/manage-plugins.html`：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We use an HTML table to display the list of active plugins. On the table body
    rows, we use the `NgFor` directive to iterate over the list of active plugins,
    which we subscribe to using the `async` pipe.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 HTML 表格来显示活动插件的列表。在表格体行中，我们使用 `NgFor` 指令遍历活动插件的列表，我们使用 `async` 管道来订阅这些插件。
- en: In the plugin objects, we got everything worth displaying already present. By
    iterating over the `PluginPlacement` objects that are stored on the `config` property
    on the plugin data, we can even display the slot names where our plugins provide
    components.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在插件对象中，我们已经有了所有值得显示的内容。通过遍历存储在插件数据 `config` 属性上的 `PluginPlacement` 对象，我们甚至可以显示我们的插件提供组件的槽位名称。
- en: 'Now, the only thing left to do to enable our new component is to make it routable
    and to add it to the navigation of our application. Let''s make the necessary
    modification in the `lib/app.js` module for this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要启用我们的新组件，我们唯一要做的就是使其可路由，并将其添加到我们应用程序的导航中。让我们在 `lib/app.js` 模块中进行必要的修改：
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We added a new route, so let''s add it to our navigation in `lib/app.html`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的路由，所以让我们将它添加到 `lib/app.html` 中的导航中：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In a new `Admin` navigation section, we add a new `navigation-item` that links
    to the newly-created "plugins" route:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 `Admin` 导航部分，我们添加了一个新的 `navigation-item`，该链接指向新创建的 "plugins" 路由：
- en: '![Managing plugins](img/image00353.jpeg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![管理插件](img/image00353.jpeg)'
- en: Our new ManagePlugins component displaying a table of active plugins and their
    exposed placements
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新 `ManagePlugins` 组件显示活动插件及其暴露的位置的表格
- en: Loading new plugins at runtime
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在运行时加载新插件
- en: We already have everything in place to provide a page to see all active plugins.
    However, we said that it would be nice to be able to manage this list. A user
    should be able to remove active plugins as well as manually load additional plugins.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好提供一个页面来查看所有活动插件。然而，我们说能够管理这个列表会很好。用户应该能够移除活动插件以及手动加载额外的插件。
- en: 'Let''s add these capabilities to our `ManagePlugins` component. Before we can
    do this, we''ll need an additional method on our `PluginService` class, which
    is the part responsible for the loading of plugins. So far, we didn''t consider
    the functionality to remove active plugins. Let''s open `PluginService` in `lib/plugin/plugin-service.js`
    to add this functionality:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`ManagePlugins`组件中添加这些功能。在我们能够这样做之前，我们将在`PluginService`类上需要一个额外的方法，这是负责加载插件的部分。到目前为止，我们没有考虑移除活动插件的功能。让我们在`lib/plugin/plugin-service.js`中打开`PluginService`以添加此功能：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Well, this was easy! We provide a new `removePlugin` method, which takes a plugin
    name as parameter. We then look up the plugin in the `plugins` array, and if a
    plugin was found with this name, we remove it from the list. Additionally, after
    we've removed the plugin, we emit a `change` event with the updated list. As all
    plugin slots in the application are subscribed to this change observable, they
    will update and reinitialize relevant plugin components automatically.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这很简单！我们提供了一个新的`removePlugin`方法，它接受一个插件名称作为参数。然后我们在`plugins`数组中查找插件，如果找到了具有此名称的插件，我们就从列表中删除它。此外，在我们删除插件后，我们发出一个带有更新列表的`change`事件。由于应用程序中所有插件槽都订阅了这个更改可观察对象，它们将自动更新和重新初始化相关的插件组件。
- en: 'Let''s now apply the necessary changes to our `ManagePlugins` component class
    in order to not only remove plugins but also to load additional plugins:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要对`ManagePlugins`组件类应用必要的更改，以便不仅能够移除插件，还能加载额外的插件：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, we also store the `PluginService` on our component. In the `removePlugin`
    and the `loadPlugin` functions, we delegate to the `PluginService` to take the
    necessary actions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们也存储了`PluginService`在我们的组件上。在`removePlugin`和`loadPlugin`函数中，我们将委托给`PluginService`以采取必要的行动。
- en: The `loadPlugin` method will receive an `ElementRef` object that points to the
    input field, where the user enters the URL from which we load a new plugin. We
    can pass the value of the input field to the `loadPlugin` method of `PluginService`,
    which deals with the rest. We also set the input field value to an empty string
    once we've submitted this call.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadPlugin`方法将接收一个指向输入字段的`ElementRef`对象，用户在此输入字段中输入从其中加载新插件的URL。我们可以将输入字段的值传递给`PluginService`的`loadPlugin`方法，它负责处理其余部分。一旦我们提交了这个调用，我们也将输入字段的值设置为空字符串。'
- en: 'Let''s open the template at `lib/manage-plugins/manage-plugins.html` to apply
    the required changes in the view of our component:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`lib/manage-plugins/manage-plugins.html`中的模板，以在我们的组件视图中应用所需的更改：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We added an additional button for every listed plugin in the table, which contains
    a binding expression that calls the `removePlugin` method with the currently iterated
    plugin name.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在表格中为每个列出的插件添加了一个额外的按钮，该按钮包含一个绑定表达式，它调用带有当前迭代的插件名称的`removePlugin`方法。
- en: 'We also added a new section after the listed plugins to load new plugins. In
    this section, we use an input field to enter the plugin URL as well as a button
    to execute the loading. Using a `loadUrlRef` local view reference, we can pass
    a reference to the input DOM element to the `loadPlugin` method on our component:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在插件列表之后添加了一个新部分来加载新插件。在这个部分中，我们使用一个输入字段来输入插件URL，以及一个按钮来执行加载。使用一个`loadUrlRef`本地视图引用，我们可以将输入DOM元素的引用传递给组件上的`loadPlugin`方法：
- en: '![Loading new plugins at runtime](img/image00354.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![在运行时加载新插件](img/image00354.jpeg)'
- en: A completed ManagePlugins component with the ability to remove and load plugin
    modules at runtime
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完成的`ManagePlugins`组件，具有在运行时移除和加载插件模块的能力
- en: Now, we have everything in place to manage our plugins. Plugins initially loaded
    from URLs present in the root `plugins.js` file can now be unloaded using the
    REMOVE button in the plugins listing. New plugins can be loaded and activated
    by entering the URL of a plugin, which could be a local URL, bundled and mapped
    module, or even a remote URL on a different server.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好管理我们的插件了。最初从根`plugins.js`文件中的URL加载的插件现在可以通过插件列表中的删除按钮来卸载。可以通过输入插件URL来加载和激活新插件，这个URL可以是本地URL、捆绑并映射的模块，甚至是不同服务器上的远程URL。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at different approaches on how to implement a plugin
    architecture. We then created our own design for a plugin architecture that leverages
    some Angular mechanisms and works on the concept of UI extension points that we
    call slots.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何实现插件架构的不同方法。然后，我们为插件架构设计了自己的方案，该方案利用了一些Angular机制，并基于我们称之为槽位的UI扩展点概念。
- en: We implemented a plugin API that provides great developer experience by leveraging
    ES7 decorators to make the configuration of new plugins a piece of cake. We implemented
    the core of our plugin system using a service to load and unload plugins that
    are based on the SystemJS module loader. This allowed us to make use of the advanced
    loading possibilities that are provided by SystemJS. Plugins can be transpiled
    in real time, can be located on a local URL, remote URL, or even be bundled into
    the main application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个插件API，通过利用ES7装饰器使新插件的配置变得轻而易举，从而提供了极佳的开发者体验。我们使用服务来加载和卸载基于SystemJS模块加载器的插件，实现了插件系统的核心。这使得我们能够利用SystemJS提供的先进加载可能性。插件可以实时转换，可以位于本地URL、远程URL，甚至可以捆绑到主应用程序中。
- en: We implemented our first plugin, which provides some components to manage Agile
    story points on our tasks. The plugin was created outside our regular project
    `lib` folder, which should underline the portable nature of our plugin system.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了我们的第一个插件，该插件提供了一些组件来管理任务上的敏捷故事点。该插件是在我们的常规项目`lib`文件夹之外创建的，这应该强调了我们的插件系统的可移植性。
- en: Finally, we created a new routable component to manage plugins at runtime. Due
    to the reactive nature of our plugin system, plugins can be loaded and unloaded
    during application runtime without any unwanted side-effects.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个新的可路由组件来管理运行时的插件。由于我们的插件系统具有反应性，插件可以在应用程序运行时加载和卸载，而不会产生任何不希望出现的副作用。
- en: When you're playing with the source code of this chapter, I highly recommend
    that you play with the loading mechanism of our plugin architecture. The flexibility
    that we achieved with very little effort is fantastic. You can unload the Agile
    plugin and load it again by providing the URL to the plugin main module. You can
    even try to place the whole plugins folder onto a remote server and load the plugin
    from there. Just make sure that you consider the necessary **Cross-Origin Resource
    Sharing** (**CORS**) headers.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在玩本章的源代码时，我强烈建议您尝试我们的插件架构的加载机制。我们几乎不费吹灰之力就实现了灵活性，这真是太棒了。您可以通过提供插件主模块的URL来卸载敏捷插件并重新加载它。您甚至可以尝试将整个插件文件夹放置在远程服务器上，并从那里加载插件。只需确保您考虑了必要的**跨源资源共享**（**CORS**）头信息。
- en: The whole code for this chapter can be found in the ZIP file of the book resources
    that you can download from Packt Publishing. You can refer to the *Downloading
    the example code* section in the *Preface* of the book.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的全部代码可以在书籍资源的ZIP文件中找到，您可以从Packt Publishing下载。您可以在书的**前言**中的**下载示例代码**部分进行参考。
- en: In the next and last chapter of this book, we'll look at how we can test the
    components that we've created so far. So, stay tuned for this overdue topic!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章和最后一章中，我们将探讨如何测试我们迄今为止创建的组件。所以，请关注这个迟到的主题！
