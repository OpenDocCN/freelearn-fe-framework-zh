- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we saw how to build reasonably complex Vue.js applications.
    This chapter is about testing them to maintain code quality and prevent defects.
    We will look at approaches to unit testing Vue.js applications in order to improve
    the quality and speed of delivery of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at using tests to drive development using **Test-Driven Development**
    (**TDD**). As we proceed, we will gain an understanding of why code needs to be
    tested and what kinds of testing can be employed on different parts of a Vue.js
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding testing and the need to test code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your first test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing state management with Pinia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snapshot testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are no technical requirements for this chapter outside of the `git` CLI,
    which you will have already used by now. You can find this chapter’s source code
    here: [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding testing and the need to test code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Testing** is a crucial process for ensuring that the code does what it’s
    meant to do. Quality production software is empirically correct. That means that
    for the enumerated cases that developers and testers have found, the application
    behaves as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: This lies in contrast with software that has been proven to be correct, which
    is a very time-consuming endeavor and is usually part of academic research projects.
    We are still at the point where correct software (proven) is still being built
    to show what kinds of systems are possible to build with this constraint of correctness.
  prefs: []
  type: TYPE_NORMAL
- en: Testing prevents the introduction of defects such as bugs and regressions (that
    is, when a feature stops working as expected). In the next section, we will learn
    about the various types of testing.
  prefs: []
  type: TYPE_NORMAL
- en: Different types of testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The testing spectrum spans from **end-to-end testing** (by manipulating the
    user interface) to **integration tests**, and finally to **unit tests**.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: End-to-end tests test everything, including the user interface, the underlying
    HTTP services, and even database interactions; nothing is mocked. If you’ve got
    an e-commerce application, an end-to-end test might actually place a real order
    with a real credit card, or it might place a test order with a test credit card.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end tests are costly to run and maintain. They require the use of full-blown
    browsers controlled through programmatic drivers such as Selenium, WebdriverIO,
    or Cypress. This type of test platform is costly to run, and small changes in
    the application code can cause end-to-end tests to start failing.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Integration or system-level tests ensure that a set of systems is working as
    expected. This will usually involve deciding on a limit as to where the system
    under test lies and allowing it to run, usually against mocked or stubbed upstream
    services and systems (which are therefore not under test).
  prefs: []
  type: TYPE_NORMAL
- en: Since external data access is stubbed, a whole host of issues, such as timeouts
    and flakes, can be reduced (when compared to end-to-end tests). Integration test
    suites are usually fast enough to run as a continuous integration step, but the
    full test suite tends not to be run locally by engineers.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unit tests are great at providing fast feedback during development. Unit testing
    paired with TDD is part of extreme programming practice. Unit tests are great
    at testing complicated logic or building a system from its expected output. Unit
    tests are usually fast enough to run a developer’s code against before sending
    their code for review and continuous integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is an interpretation of the pyramid of testing. It can
    be interpreted to mean that you should have a high number of cheap and fast unit
    tests, a reasonable number of system tests, and just a few end-to-end UI tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Pyramid of testing diagram](img/Figure_11.01_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Pyramid of testing diagram
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at why we should be testing applications, let’s start
    writing some tests.
  prefs: []
  type: TYPE_NORMAL
- en: Building your first test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate how quick and easy it is to get started with automated tests in
    a Vue 3 project, we will start by creating a simple test using Vitest ([https://vitest.dev/](https://vitest.dev/)),
    the officially recommended testing framework for Vue 3 and the simplest to begin
    with as the installation steps of a new application let you select it right away.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, you can see the prompt for installing Vitest:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Creating an application and selecting Yes to using Vitest](img/Figure_11.02_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Creating an application and selecting Yes to using Vitest
  prefs: []
  type: TYPE_NORMAL
- en: After the application is scaffolded, you will find it created a `__tests__`
    folder under `components` and created a test already. For now though, delete the
    file (but not the folder) and create a new `__tests__` folder directly under the
    root of you project. Next, create an `App.test.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: We will use `shallowMount` to render the application and test whether it displays
    `The Vue.js Workshop Blog`. `shallowMount` does a *shallow render*, which means
    that only the top level of a component is rendered; all the child components are
    stubbed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is useful for testing a component in isolation since the child components’
    implementations are not run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Save this file, and at the Terminal (ensure you’ve already run `npm install`
    to finish creating a new application), run `npm` `run test:unit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you indicated in the installation prompt that you wanted to include Vitest,
    it added the following script to the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get a report on the test run and its immediate failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – The unit test running and failing](img/Figure_11.03_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – The unit test running and failing
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the test pass, we can edit our `App.vue` file to include the header
    we want (note that we also removed much of the code created by default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and you’ll immediately see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – The test passing!](img/Figure_11.04_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – The test passing!
  prefs: []
  type: TYPE_NORMAL
- en: You have just completed your first piece of TDD. This process started by writing
    a test that failed. This failure was followed by an update to the code under test
    (in this case the `App.vue` component), which made the failing test pass.
  prefs: []
  type: TYPE_NORMAL
- en: The TDD process gives us confidence that our features have been tested properly
    since we can see that tests fail before they pass when we update the code that
    drives our feature.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll show how to take what we’ve learned and apply it
    to Vue components.
  prefs: []
  type: TYPE_NORMAL
- en: Testing components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components are at the core Vue.js applications. Writing unit tests for them
    is straightforward with Vitest. Having tests that exercise the majority of your
    components gives you confidence that they behave as designed. Ideal unit tests
    for components run quickly and are simple.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll carry on building the blog application example. We have now built the
    heading, but a blog usually also needs a list of posts to display.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll create a `PostList` component. For now, it will just render a `div` wrapper
    and support a `posts` `Array` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add some data in the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have some posts, we can pass them as a bound prop to the `PostList`
    component from the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our `PostList` component will render out each post in a `PostListItem` component,
    which we’ll create as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`PostListItem` takes two props: `title` (which is a string) and `description`
    (also a string). It renders them in an `h3` tag and a `p` tag, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to loop through the posts and render out a `PostListItem` component
    with relevant props bound in the `PostList.vue` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the `PostListItem` component, we can do a shallow render with some
    arbitrary title and description props set, and check that they get rendered. Add
    a new file to `src/__tests__` named `PostListItem.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This test can be run individually at the command line by using the `npm run
    test:unit __tests__/PostListItem.test.js` command (as seen in *Figure 11**.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – PostListItem test output](img/Figure_11.05_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – PostListItem test output
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll see one of the pitfalls of shallow rendering. When testing the `PostList`
    component, all we can do is test the number of `PostListItem` components it’s
    rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this test as `__tests__/PostList.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This passes, but we are testing something that the user will not directly interact
    with, the number of `PostListItem` instances rendered in `PostList`, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – PostList test output](img/Figure_11.06_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – PostList test output
  prefs: []
  type: TYPE_NORMAL
- en: A better solution is to use the `mount` function, which renders the full component
    tree, whereas the `shallowMount` function would only render out the children of
    the component being rendered. With `mount`, we can assert that the titles and
    descriptions are rendered to the page.
  prefs: []
  type: TYPE_NORMAL
- en: The drawback of this approach is that we’re testing both the `PostList` component
    and the `PostListItem` component since the `PostList` component doesn’t render
    the title or description; it renders a set of `PostListItem` components that in
    turn render the relevant title and description.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The new tests pass as indicated by the following output of the `npm run test:unit`
    `__tests__/PostList.test.js` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Test run for PostList with both shallow and mounted tests](img/Figure_11.07_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Test run for PostList with both shallow and mounted tests
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to write unit tests for Vue.js with Vitest and `vue-test-utils`.
    These tests can be run often and the test runs complete within seconds, which
    gives us near-immediate feedback while working on new or existing components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.01: Building and unit testing a tag list component'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating the fixture for `posts`, we populated a tags field with `vue`,
    `angularjs`, and `react` but did not display them.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this exercise can be found at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.01)
  prefs: []
  type: TYPE_NORMAL
- en: 'To make tags useful, we will display the tags in the post list:'
  prefs: []
  type: TYPE_NORMAL
- en: We can start by writing a unit test that will explain what we expect a `PostListItem`
    component to do when passed a set of tags as props. It expects that each tag will
    be rendered with a hashtag prepended to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, the `react` tag will be shown as `#react`. In the `__tests__/PostListItem.test.js`
    file, we can add a new test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This test fails when run with the `npm run test:unit __tests__/PostListItem.test.js`
    command, as shown in *Figure 11**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Tag test for PostListItem failing](img/Figure_11.08_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Tag test for PostListItem failing
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we should implement the tag list rendering in `src/components/PostListItem.vue`.
    We’ll add tags as props of the `Array` type and use `v-for` to render out the
    tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the `PostListItem` component implemented, the unit test should now pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – PostListItem unit test passing](img/Figure_11.09_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – PostListItem unit test passing
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the tags are not displayed in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – PostList displaying without tags despite the correct PostListItem
    implementation](img/Figure_11.10_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – PostList displaying without tags despite the correct PostListItem
    implementation
  prefs: []
  type: TYPE_NORMAL
- en: We can write a unit test for `PostList` that would show this behavior. In essence,
    we’ll be passing some tags in our `posts` list and running the same assertions
    as are already present in the `PostListItem.test.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll do this in `__tests__/PostList.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As per our application output shown in *Figure 11**.11*, the test is failing
    when run with the `npm run test:unit` `__tests__/PostList.test.js` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – PostList tags test failing](img/Figure_11.11_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – PostList tags test failing
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fix this test, we can find the issue in `src/components/PostList.vue`,
    where the tags prop for `PostListItem` is not bound. By updating `src/components/PostList.vue`
    to bind the `tags` prop, we can fix the unit test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The failing unit test now passes, as shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – PostList tags test passing](img/Figure_11.12_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – PostList tags test passing
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now seen how we can test rendered component output with both the shallow
    rendering and mounting of components. Let’s briefly understand what each of these
    terms means:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1`, meaning that if children are components, they will just be rendered as
    the component tag; their template will not be run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mounting**: This renders the full component tree in a similar fashion as
    would be rendered in the browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we’ll look at how to test component methods.
  prefs: []
  type: TYPE_NORMAL
- en: Testing component methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous version of Vue, the recommendation would have been to do testing
    on filters and mixins, but typically avoid writing tests for methods as they aren’t
    directly called by users.
  prefs: []
  type: TYPE_NORMAL
- en: In Vue 3, both filters and mixins are deprecated and replaced with *regular*
    methods and computed properties. That being said, finding the methods appropriate
    for tests may require some thought.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a `computed` property that truncates its input to eight characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code sample, `truncated` is defined as a computed property
    based on the `description` value passed as a property. At the end, `defineExpose`
    is used to make the property available for testing. Items that are specified within
    `script setup` are considered *closed* and are not available outside the component
    itself. By using `defineExpose`, we can then write a test against `truncated`.
  prefs: []
  type: TYPE_NORMAL
- en: We can test the logic of the computed property in two ways. First, longer strings
    should be truncated. Secondly, shorter strings should be returned as is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the additional tests added to `PostListItem.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The first new test passes a long value for description and confirms that the
    truncated version is shorter. Note the use of `vm` to access the Vue instance
    of the component and then the `truncated` computed property. The next test confirms
    that if a shorter value is used, truncated will not shorten it.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that a user would not actually call `truncated` directly. As an alternative
    to directly testing the computed property, we could confirm that any template
    usage works properly as well. In that case, using `wrapper.text()` would make
    sense to return the rendered result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.02: Building and testing an ellipsis method'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how to test an arbitrary `truncated` computed method; we will now
    implement an `ellipsis` computed method and test it.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this exercise can be found at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.02](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.02)
  prefs: []
  type: TYPE_NORMAL
- en: We can start by writing a set of tests for the `ellipsis` computed method (which
    will live in `src/components/PostListItem.vue`). One test should check that the
    filter does nothing if the passed value is less than 50 characters; another should
    check whether the passed value is more than 50 characters and if so, truncate
    the value to 50 and appends `…`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will do this in a`__tests__/ellipsis.test.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now implement the logic for `ellipsis` in `src/components/PostListItem.vue`.
    We will add a `computed` object with `ellipsis`, which will use `String#slice`
    if the passed value is longer than 50 characters and do nothing otherwise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, the `ellipsis` computed method works on the description prop
    and handles trimming values longer than 50 characters. The tests now pass as shown
    in *Figure 11**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Ellipsis tests now passing](img/Figure_11.13_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – Ellipsis tests now passing
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen how to test methods and computed properties of a Vue.js component.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to deal with an application that uses Vue.js routing.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Vue routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have currently got an application that renders our blog home page or feed
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we should have post pages. To do this, we will use Vue Router, as covered
    in previous chapters, and ensure that our routing works as designed with unit
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue Router is installed using `npm`, specifically, `npm install vue-router@4`,
    and then wiring it up in the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can create a file to define our routes in `src/router/index.js`. This
    will instantiate the router and define our initial paths. We will begin with a
    root path (`/`) to display the `PostList` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’ve got our initial route, we should update the `App.vue` file to
    leverage the component being rendered by the router. We’ll render `render-view`
    instead of directly using `PostList`. The `posts` binding, however, stays the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our posts in the `App.vue` file are missing a bit of core data to render
    a `SinglePost` component. We need to make sure to have the `slug` and `content`
    properties to render something useful on our `SinglePost` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now start working on a `SinglePost` component. For now, we''ll just
    have some placeholders in the template. Also, `SinglePost` will receive posts
    as a prop, so we can fill that in as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will register `SinglePost` in `router/index.js` with the `/:postId`
    path (which will be available to the component under `this.$route.params.postId`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: If we switch back to implementing the `SinglePost` component, we’ve got access
    to `postId`, which will map to the slug in the `posts` array, and we’ve also got
    access to `posts` since it’s being bound onto `render-view` by `App`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can create a computed property, `post`, which finds posts based on `postId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'From this computed `post` property, we can extract `title` and `content` if
    `post` exists (we have to watch out for posts that don’t exist). So, still in
    `SinglePost`, we can add the following computed properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then replace the placeholders in the template with the value of the
    computed properties. So, our template ends up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s update the application so that we can link to individual posts. In
    `PostList.vue`, pass the slug in as a new property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in `PostListItem`, we will first add a new `slug` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we edit the template to link with the `slug` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '`router-link` is a Vue Router-specific link, which means that on the `PostList`
    page, upon clicking on a post list item, we are taken to the correct post’s URL,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – Post list view displayed in the browser](img/Figure_11.14_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – Post list view displayed in the browser
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking on a title, the right post is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – Single post view displaying in the browser](img/Figure_11.15_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – Single post view displaying in the browser
  prefs: []
  type: TYPE_NORMAL
- en: 'To test `vue-router`, we will need to build our tests to handle the asynchronous
    nature of the router. We’ll begin by testing that clicking on a post properly
    loads just the information for a single post. We can do this by looking for all
    the blog posts on the initial page, and only one particular post when a route
    is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: On top, we import both `mount` and a new utility, `flushPromises`, that we’ll
    use later. We also import our router. In the test, we begin by navigating to the
    root path and as stated earlier, due to the asynchronous nature of the router,
    we wait for it to finish.
  prefs: []
  type: TYPE_NORMAL
- en: We then check for both blog posts. After that, we trigger a click event on the
    first post, wait for it to finish with `flushPromises`, and then check to see
    that only our first post is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should check that navigating directly to a valid post URL will yield the
    correct result. In order to this we’ll use `router.replace(''/'')` to clear any
    state that’s set and then use `router.push()` with a post slug. We will then use
    similar assertions to ensure we’re rendering just one post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Those two tests work as expected when run with the `npm run test:unit __tests__/SinglePost.test.js`
    command. The following screenshot displays the desired output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16 – Routing tests passing for SinglePost](img/Figure_11.16_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.16 – Routing tests passing for SinglePost
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how to test your routes, let’s practice it with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.03: Building a tag page and testing its routing'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much like we built a single-post page, we’ll now build a tag page, which is
    similar to the `PostList` component except only posts with a certain tag are displayed
    and each post is a link to a relevant single-post view.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete code at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.03](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.03)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by creating a new `TagPage` component in `src/components/TagPage.vue`.
    We know it will receive `posts` as a prop and that we want to render a `PostList`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we want to wire the `TagPage` component to the router in `src/router.js`.
    We’ll import it and add it as part of `routes` with the `/``tags/:tagName` path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Back in `TagPage.vue`, we can now use the `tagName` param and create a `tagName`
    computed property as well as a `tagPosts` computed property that filters based
    on the tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have access to `tagPosts` and `tagName`, we can replace the placeholders
    in the template. We will render `#{{ tagName }}` and bind `tagPosts` to the `posts`
    prop of `PostList`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the page displays something like the following if we navigate, for example,
    to `/tags/angularjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – Tag page for angularjs](img/Figure_11.17_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.17 – Tag page for angularjs
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to convert the tag anchors (`a`) in `PostListItem` to `router-link`
    that points to `/tags/${tagName}` (in `src/components/PostListItem.vue`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now it is time to write some tests. We will first check that being on the home
    page and clicking on `angularjs` tag page. We’ll write it as follows in `__tests__/TagPage.test.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should also test that going directly to the tag URL works as expected; that
    is, we do not see irrelevant content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The tests pass since the application is working as expected. Therefore, the
    output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – TagPage routing tests passing on the command line](img/Figure_11.18_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.18 – TagPage routing tests passing on the command line
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going on, however, let’s run *all* our unit tests. You’ll notice that
    while our tests pass, there are now various warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.19 – Warnings about router-link and router-view](img/Figure_11.19_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.19 – Warnings about router-link and router-view
  prefs: []
  type: TYPE_NORMAL
- en: As these warnings don’t fail our tests, we should remove them. We’ve got a few
    options for how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: One way is to simply stub out, or *fake*, the components we don’t need. In this
    case, we want our tests to ignore the router components that we aren’t testing
    at the time. We can address this by using an option supported by both `mount`
    and `shallowMount`, `stubs`. By using the `stubs` option, we tell Vue’s test utilities
    to *stub*, or create an empty component of, a set of tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add this option in a new global argument to either `mount` or `shallowMount`.
    Here’s an example in `ellipsis.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Once added to both tests in `ellipsis.test.js`, those warnings go away. Next,
    we’ll fix `App.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice we stub `router-view` as well. Next, we’ll fix `PostList.test.js` and
    `PostListItem.test.js`. Both of these actually use `router-link` so we can’t stub
    them, but we can provide them as plugins to `mount` and `shallowMount`. In `PostList.test.js`,
    we first import our router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in each of the three tests, pass the router as a plugin in the `global`
    object, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can update `PostListItem.test.js`, but we need to make another change
    here. Previously the test made use of `shallowMount`, but we need to switch to
    `mount` so `router-link` properly renders its output. Here’s the entire test with
    both the plugin change and the switch to `mount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our warnings have been resolved. We’ve now seen how to implement
    and test an application that includes `vue-router`. In the next section, we will
    learn about testing Pinia in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Testing state management with Pinia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To show how to test a component that relies on Pinia (Vue’s official global
    state management solution), we’ll implement and test a newsletter subscription
    banner.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we should create the banner template. The banner will contain
    a **Subscribe to the newsletter** call to action and a close button.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'We can display the `NewsletterBanner` component in the `App.vue` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll then install Pinia with the `npm install –save pinia` command. Once Pinia
    is installed, we can initialize our store in a `store.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Pinia store is also registered in the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to decide whether the newsletter banner should be displayed or not,
    we need to add an initial state to our store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'To close the banner, we need an action that will set `dismissedSubscribeBanner`
    to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the store state and the `dismissSubscribeBanner` action to decide
    whether to show the banner (using `v-if`) and whether to close it (binding to
    a click on the close button):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the banner looks like this in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.20 – Newsletter banner displayed in a browser](img/Figure_11.20_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.20 – Newsletter banner displayed in a browser
  prefs: []
  type: TYPE_NORMAL
- en: Before we write our unit test, it may be a good idea to see if our *existing*
    tests work. (And as you can probably guess, this is leading to something.) If
    you go ahead and run all the tests, you’ll see a whole new set of issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first following figure, note the warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.21 – Test failures related to Pinia](img/Figure_11.21_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.21 – Test failures related to Pinia
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we now have two tests failing due to Pinia. As with the issues
    we saw with Vue Router, we need to do some work to ensure our tests don’t throw
    an error just because we added in Pinia. To begin, we’re going to install some
    Pinia-specific testing utilities via `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the ability to then import a utility to help test Pinia stores,
    as well as helping with the new errors being thrown. In `SinglePost.test.js`,
    import Pinia’s testing utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, much like how we passed Vue Router as a plugin, we’ll also pass a test-specific
    version of Pinia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createSpy` parameter is used to stub action calls and uses `vi.fn`. In
    our first line in the unit test, we can modify the imports from `vitest` like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Update the plugins attribute for all the wrappers in `SinglePost.test.js` and
    repeat the same fixes for `TagPage.test.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next check should be that if the store has `dismissedSubscriberBanner:
    true`, the banner should not be displayed. This is done by using the `initialState`
    feature of `createTestingPinia`. It lets you define initial state values based
    on the ID value of our store.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'The final test we’ll write is to make sure that clicking the banner’s **Close**
    button fires an action to the store. We can do this by checking that it is called
    when clicking the **Close** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests will now pass when run with the `npm run test:unit __tests__/NewsletterBanner.test.js`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.22 – Unit tests for NewsLetterBanner passing on the command line](img/Figure_11.22_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.22 – Unit tests for NewsLetterBanner passing on the command line
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now had a chance to work with Pinia state management and testing, let’s
    now work on an exercise to demonstrate what you’ve learned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.04: Building and testing a cookie disclaimer banner'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll now look at how to implement a cookie disclaimer banner using Pinia and
    how to test it. We will store whether the cookie banner is being shown in Pinia
    (the default is `true`); when the banner is closed, it will update to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete code at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.04](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Exercise11.04)
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a green cookie banner with a `Cookies Disclaimer` title in bold, the
    disclaimer, and an `I agree` button. We will create this in `src/components/CookieBanner.vue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will need to import and render `CookieBanner` below `router-view`
    in `src/App.vue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a state value to control whether to display the cookie banner. In our Pinia
    store, we will initialize `acceptedCookie` to `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also need an `acceptCookie` action to close the banner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will expose the store state as an `accept``edCookie` computed property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use `v-if` to show the banner when cookies have not been accepted yet.
    The **I agree** button will close the banner when it’s clicked by calling the
    store action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE250]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE252]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE253]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now have a cookie banner that is displayed until **I agree** is clicked,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.23 – Cookie banner displayed in the browser](img/Figure_11.23_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.23 – Cookie banner displayed in the browser
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now write a test that checks that `CookieBanner` is displayed by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE255]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE256]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE257]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE258]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE259]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE260]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE261]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE262]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE263]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE264]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE265]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE266]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE267]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE268]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE269]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE270]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE271]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also write a test to check whether `acceptedCookie` is `true` in the
    store, and if so, the cookie banner won’t be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE273]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE274]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE275]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE276]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE277]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE278]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE279]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE280]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE281]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE282]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE283]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE284]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE285]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE286]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE287]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we want to check that when the `acceptCookie` action is triggered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE289]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE290]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE291]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE292]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE293]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE294]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE295]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE296]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE297]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE298]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE299]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The three tests we wrote pass when run with `npm run test:unit __tests__/CookieBanner.test.js`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.24 – Tests for the cookie banner passing](img/Figure_11.24_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.24 – Tests for the cookie banner passing
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how to test components that rely on Pinia for state and updates.
    Next, we’ll look at snapshot testing to see how it simplifies the testing of render
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Snapshot testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Snapshot tests provide a way to write tests for fast-changing pieces of code
    without keeping the assertion data inline with the test. Changes to a snapshot
    reflect changes to the output, which is quite useful for code reviews.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can add a snapshot test to the `PostList.test.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: 'The first time this test is run, a snapshot file will be written to `__tests__/__snapshots__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: This makes it easy to quickly see what the changes mean in terms of concrete
    output.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how to use snapshot tests. Next, we’ll put all the tools we've
    learned about in this chapter together to add a new page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.01: Adding a simple search-by-title page with tests'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already built a post list page, a single-post view page, and a posts-by-tag
    page. A great way to resurface old content on a blog is by implementing good search
    functionality. We will add search functionality to the `PostList` page:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the search form with an input and a button in a new file at `src/components/SearchForm.vue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll now get the form to display by importing and rendering it on `src/App.vue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are now able to search the search form in the application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.25 – The post view with a search form](img/Figure_11.25_B18645.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.25 – The post view with a search form
  prefs: []
  type: TYPE_NORMAL
- en: We’re now ready to add a snapshot test for the search form. In `__tests__/SearchForm.test.js`,
    we should add `SearchForm should match` `expected HTML`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to track the contents of the search form input using `v-model` to two-way
    bind the `searchTerm` instance variable and the contents of the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the search form is submitted, we’ll need to update the URL with the right
    parameter. This can be done with `this.$router.push()`. We will store the search
    in a `q` query parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will want to reflect the state of the `q` query parameter in the search form
    input. We can do this by reading `q` from `this.$route.query` and setting it as
    the initial value for the `searchTerm` data field in the `SearchForm` component
    state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we’ll want to filter the posts passed to `PostList` on the home page.
    We’ll use `route.query.q` in a computed property that filters posts by their title.
    This new computed property will then be used instead of posts in `src/App.vue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we should add a test that changes the search query parameter and check
    that the app shows the right result. To do this, we can import `src/App.vue` and
    `@/router.js`, and render the app with the store and the router. We can then update
    the search field contents. Finally, we can submit the form by clicking the element
    where test ID is `Search` (which is the search button).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found at [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Activity11.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter11/Activity11.01)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ve looked at different approaches to testing different
    types of Vue.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in general is useful for empirically showing that the system is working.
    Unit tests are the cheapest to build and maintain and should be the base of testing
    functionality. System tests are the next level up in the testing pyramid and allow
    you to gain confidence that the majority of features are working as expected.
    End-to-end tests show that the main flows of the full system work.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how to unit test components and methods, as well as testing through
    layers, and testing component output in a black-box fashion instead of inspecting
    component internals to test functionality. Using the Vitest testing library, we
    tested advanced functionality, such as routing and applications, that leverage
    Pinia.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at snapshot testing and saw how it can be an effective way
    to write tests for template-heavy chunks of code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at end-to-end testing techniques that can
    be applied to Vue.js applications.
  prefs: []
  type: TYPE_NORMAL
