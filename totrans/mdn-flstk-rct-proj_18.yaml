- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Frontend to Consume and Send Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After successfully creating a Socket.IO backend in the previous chapter, and
    doing our first experiments with the Socket.IO client, let’s now focus on implementing
    a frontend to connect to the backend and consume and send events.
  prefs: []
  type: TYPE_NORMAL
- en: We are first going to clean up our project by removing files from the previously
    created blog app. Then, we are going to implement a React Context to initialize
    and store our Socket.IO instance, making use of the existing `AuthProvider` to
    provide the token for authenticating with the backend. After that, we are going
    to implement an interface for our chat app and a way to send chat messages, as
    well as displaying received chat messages. Finally, we are going to implement
    chat commands with acknowledgments to show which rooms we are currently in.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the Socket.IO client with React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing chat functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing chat commands with acknowledgments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start, please install all the requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016),
    *Preparing for Full-Stack Development*, and [*Chapter 2*](B19385_02.xhtml#_idTextAnchor028),
    *Getting to Know Node.js* *and MongoDB*.
  prefs: []
  type: TYPE_NORMAL
- en: The versions listed in those chapters are the ones used in the book. While installing
    a newer version should not be an issue, please note that certain steps might work
    differently on a newer version. If you have an issue with the code and steps provided
    in this book, please try using the versions listed in *Chapters 1* and *2.*
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch14](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch14).'
  prefs: []
  type: TYPE_NORMAL
- en: If you cloned the full repository for the book, Husky may not find the `.git`
    directory when running `npm install`. In that case, just run `git init` in the
    root of the corresponding chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/d_TZK6S_XDU](https://youtu.be/d_TZK6S_XDU).'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the Socket.IO client with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start by cleaning up the project and deleting all old files copied over
    from the blog app. Then, we are going to set up a Socket.IO context to make it
    easier to initialize and use Socket.IO in React components. Finally, we are going
    to create our first component that utilizes this context to show the status of
    our Socket.IO connection.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s first delete the folders and files from the blog application we created
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the existing **ch13** folder to a new **ch14** folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the **ch14** folder in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Delete* the following folders and files, as they were only required for the
    blog application backend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**backend/src/__tests__/**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**backend/src/example.js**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**backend/src/db/models/post.js**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**backend/src/routes/posts.js**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**backend/src/services/posts.js**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In **backend/src/app.js**, *remove* the following import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, *remove* **postRoutes**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Delete* the following folders and files, as they were only required for the
    blog application frontend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**src/api/posts.js**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**src/components/CreatePost.jsx**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**src/components/Post.jsx**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**src/components/PostFilter.jsx**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**src/components/PostList.jsx**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**src/components/PostSorting.jsx**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**src/pages/Blog.jsx**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have cleaned up our project, let’s get started with implementing
    a Socket.IO context for our new chat app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Socket.IO context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up until now, we have been initializing the Socket.IO client instance in the
    `src/App.jsx` component. However, doing this has some downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: To access the socket in other components, we would need to pass it down via
    props.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can only have one socket connection for the whole app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not possible to get the token dynamically from **AuthContext**, requiring
    us to store the token in local storage instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our app requires a full refresh to be able to load the new token and connect
    with it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We still try to connect and get an error when not logged in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To solve these issues, we can instead create a Socket.IO context. We can then
    use the provider component to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to Socket.IO only when the token is available in **AuthContext**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the status of the Socket.IO connection and use it within components to,
    for example, only show the chat interface when logged in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the error object and display errors in the user interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how the status of our connection will be tracked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – The different states of the connection](img/B19385_14_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – The different states of the connection
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen, the socket connection is initially waiting for the user to log
    in. Once the token is available, we attempt to establish a socket connection.
    If successful, the status changes to `connected`, otherwise to `error`. If the
    socket disconnects (for example, when the internet connection is lost), the state
    is set to `disconnected`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s get started with creating a Socket.IO context:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **src/contexts/SocketIOContext.jsx** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this file, import the following functions from **react**, **socket.io-client**,
    and **prop-types**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, import the **useAuth** hook from **AuthContext** to get the current
    token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define a React Context with some initial values for **socket**, **status**
    and **error**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, define a provider component, in which we first create state hooks for
    the different values of the context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, use the **useAuth** hook to get the JWT (if available):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an effect hook that checks whether the token is available, and if so,
    attempts to connect to the Socket.IO backend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Just like before, we pass the host, the `query` string, and the `auth` object.
    However, now we get the token from the `useAuth` hook instead of local storage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create handlers for the **connect**, **connect_error**, and **disconnect**
    events and set the **status** string and the **error** object, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the **socket** object and list all necessary dependencies for the effect
    hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can return the provider, passing all values from the state hooks to
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we set **PropTypes** for the context provider component and define
    a **useSocket** hook that will simply return the whole context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have a context to initialize our Socket.IO client, let’s hook it
    up and display the status of the socket connection.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking up the context and displaying the status
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now remove the code to connect to Socket.IO from the `App` component
    and use the provider instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit **src/App.jsx** and *remove* the following import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an import to **SocketIOContextProvider**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, *remove* the following code related to the Socket.IO connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the **App** component, render the context provider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After hooking up the Socket.IO context, let’s move on to creating a `Status`
    component to display the status.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Status component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s create a `Status` component to display the current status of the
    socket:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **src/components/Status.jsx** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside it, import the **useSocket** hook from our **SocketIOContext**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a **Status** component, in which we get the **status** string and **error**
    object from the hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Render the socket status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we have an **error** object, we can additionally display the error message
    now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have a `Status` component, let’s create a `Chat` page component,
    where we render the `Header` and `Status` components.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Chat page component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We previously had a `Blog` page for our blog app, which we deleted earlier
    in this chapter. Let’s now create a new `Chat` page component for our chat app:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **src/pages/Chat.jsx** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside it, import the **Header** component (which we are going to reuse from
    the **Blog** app) and the **Status** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Render a **Chat** component in which we display the **Header** and **Status**
    components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/App.jsx** and locate the following import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Replace* it with an import to the `Chat` component:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, *replace* the **<Blog />** component in the main path in our router
    with the **<Chat />** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Starting and testing our chat app frontend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can now start and test out our chat app frontend:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the frontend, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the backend, as follows (make sure Docker and the database container are
    running!):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now go to **http://localhost:5173/** and you should see the following interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Socket connection waiting for user to be logged in](img/B19385_14_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – Socket connection waiting for user to be logged in
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in (create a new user if you do not have one yet), and the socket should
    connect successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Socket connected after user is logged in](img/B19385_14_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – Socket connected after user is logged in
  prefs: []
  type: TYPE_NORMAL
- en: Disconnecting socket on logout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed that when pressing **Logout**, the socket stays connected.
    Let’s fix that now, by disconnecting the socket when logging out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit **src/components/Header.jsx** and import the **useSocket** hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the socket from the **useSocket** hook, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new **handleLogout** function, which disconnects the socket and resets
    the token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, set the **onClick** handler to the **handleLogout** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when you log out, the socket will be disconnected, as can be seen in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Socket disconnected after logging out](img/B19385_14_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – Socket disconnected after logging out
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Socket.IO client is successfully integrated with our React frontend,
    we can continue by implementing chat functionality in the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing chat functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to implement functionality to send and receive messages in
    our chat app. First, we are going to implement all the components that we need.
    Then, we are going to create a `useChat` hook to implement the logic to interface
    with the socket connection and provide functions to send/receive messages. Lastly,
    we are going to put it all together by creating a chat room.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the chat components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to implement the following chat components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ChatMessage**: To display chat messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EnterMessage**: A field to enter new messages and a button to send them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the ChatMessage component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by implementing the `ChatMessage` component:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **src/components/ChatMessage.jsx** file, which will render a chat
    message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import **PropTypes** and define a new function with **username** and **message**
    props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Render the username in bold and the message next to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the prop types, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implementing the EnterMessage component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s create the `EnterMessage` component, which will allow users to send
    a new chat message:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **src/components/EnterMessage.jsx** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the **useState** hook and **PropTypes**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new **EnterMessage** component, which receives an **onSend** function
    as props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We store the current state of the message entered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define a function to handle sending the request and clearing the field
    afterward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Reminder
  prefs: []
  type: TYPE_NORMAL
- en: Because we are submitting a form using a **submit** button, we need to call
    **e.preventDefault()** to prevent the form from refreshing the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Render a form with an input field to enter the message and a button to send
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the prop types, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implementing a useChat hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To bundle all the logic together, we are going to implement a `useChat` hook,
    which is going to deal with sending and receiving messages, as well as storing
    all current messages in a state hook. Follow these steps to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **src/hooks/** folder. Inside it, create a new **src/hooks/useChat.js**
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the **useState** and **useEffect** hooks from React:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the **useSocket** hook from our context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new **useChat** function, where we get the socket from the **useSocket**
    hook, and define a state hook to store an array of messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, define a **receiveMessage** function, which appends a new message to
    the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create an effect hook, in which we create a listener using **socket.on**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to make sure to remove the listener again using **socket.off** when
    the effect hook unmounts, otherwise we might end up with multiple listeners when
    the component re-renders or unmounts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, receiving messages should work fine. Let’s move on to sending messages.
    To do this, we create a **sendMessage** function, which uses **socket.emit** to
    send the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, return the **messages** array and the **sendMessage** function so that
    we can use them in our components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have successfully implemented the `useChat` hook, let’s use it!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the ChatRoom component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we can put it all together and implement a `ChatRoom` component. Follow
    these steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **src/components/ChatRoom.jsx** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the **useChat** hook and the **EnterMessage** and **ChatMessage** components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a new component, which gets the **messages** array and the **sendMessage**
    function from the **useChat** hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, render the list of messages as **ChatMessage** components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, render the **EnterMessage** component and pass the **sendMessage** function
    as the **onSend** prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit **src/pages/Chat.jsx** and import the **ChatRoom** component and the **useSocket**
    hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the status from the **useSocket** hook in the **Chat** page component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the status is **connected**, we show the **ChatRoom** component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, go to **http://localhost:5173/** in your browser and log in with a username
    and password. The socket connects and the chat room is rendered. Enter a chat
    message and send it by pressing *Return/Enter* or by clicking the **Send** button.
    You will see that the message is received and displayed!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a second browser window and log in with a second user. Send another message
    there. You will see that the message is received by both users, as can be seen
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Sending and receiving messages from different users](img/B19385_14_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – Sending and receiving messages from different users
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic chat app working, let’s explore how we could implement
    chat commands using acknowledgments.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing chat commands with acknowledgments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to sending and receiving messages, chat apps often offer a way
    to send commands to the client and/or server. For example, we could send a `/clear`
    command to clear our local messages list. Or we could send a `/rooms` command
    to get a list of rooms that we are in. Follow these steps to implement chat commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit **src/hooks/useChat.js** and adjust the **sendMessage** function inside
    it. First, let’s make it an **async** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Replace* the contents of the function with the following. We first check whether
    the message starts with a slash (**/**). If so, then we get the command by removing
    the slash and use a **switch** statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the **clear** command, we simply set the array of messages to an empty
    array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the **rooms** command, we get the user info by using **socket.emitWithAck**
    and our own **socket.id**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we get the list of rooms, filtering out our own room (with the name of
    our **socket.id**) that we automatically join in Socket.IO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We reuse the **receiveMessage** function to send a message from the server,
    telling us the rooms that we are in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we are not sending a username here, just a message. We will have to
    adapt the `ChatMessage` component to accommodate that later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we receive any other command, we show an error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Otherwise (if the message did not start with a slash), we simply emit the chat
    message, as before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, edit **src/components/ChatMessage.jsx** and adapt the component to
    render a system message if no username was given:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Do not forget to adjust **PropTypes** to make the username optional (by *removing*
    **.isRequired** from the **username** prop):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go to **http://localhost:5173/** in your browser and try sending a couple messages.
    Then, type **/clear** and you will see all messages were cleared. Next, type **/rooms**
    to get the list of rooms that you are in, as you can see in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.6 – Sending the /rooms command](img/B19385_14_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – Sending the /rooms command
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Joining different rooms currently does not work due to the query parameter getting
    cleared after logging in. In the next chapter, we are going to refactor the chat
    app and implement a **/join** command to join a different room.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented a frontend for our chat app backend. We started
    by integrating the Socket.IO client with React by making a context and a custom
    hook for it. Then, we used `AuthProvider` to get the token to authenticate a user
    when connecting to the socket. After that, we displayed the status of our socket.
    Then, we implemented a chat app interface to send and receive messages. Finally,
    we implemented chat commands by using acknowledgments to get the rooms that we
    are in.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [*Chapter 15*](B19385_15.xhtml#_idTextAnchor276), *Adding
    Persistence to Socket.IO Using MongoDB*, we are going to learn how to store and
    replay previously sent messages using MongoDB with Socket.IO.
  prefs: []
  type: TYPE_NORMAL
