<html><head></head><body>
		<div id="_idContainer024">
			<h1 id="_idParaDest-56"><em class="italic"><a id="_idTextAnchor057"/>Chapter 3</em>: Sourcing and Querying Data (from Anywhere!) </h1>
			<p>In this chapter, you will learn about Gatsby's data layer. You will start by understanding what we mean by data in the context of Gatsby before learning the basics of <strong class="bold">GraphQL</strong>. Once you have this understanding, you will learn how to source and query data from local files. We will then look at sourcing data from a couple of Headless CMSes.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Data in Gatsby</li>
				<li>Introducing GraphQL </li>
				<li>Sourcing and querying data from local files</li>
				<li>Sourcing and querying data from a Headless CMS</li>
			</ul>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor058"/>Technical requirements</h1>
			<p>To complete this chapter, you will need to have completed <a href="B15983_02_ePub_RK.xhtml#_idTextAnchor036"><em class="italic">Chapter 2</em></a>, <em class="italic">Styling Choices and Creating Reusable Layouts</em>. </p>
			<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter03">https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter03</a>.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor059"/>Data in Gatsby</h1>
			<p>Before diving in, I think it's important to establish what we mean by <strong class="bold">data</strong> in the context of this book. When<a id="_idIndexMarker149"/> referring to data, we are referring to any medium of static content that is not <a id="_idIndexMarker150"/>React code. Up until now, we have been adding text within our React components directly. As a developer, this can be a perfectly acceptable way to build a small site but as things scale up, having content mixed into your markup can make it much harder to develop. It also makes it impossible for colleagues without React experience to update or add new content to the site.</p>
			<p>It is a much more <a id="_idIndexMarker151"/>common practice to store data that's separate from our pages and <a id="_idIndexMarker152"/>components, pulling it in as required. There are two ways in which we can store this data: </p>
			<ul>
				<li><strong class="bold">Locally</strong>: Files<a id="_idIndexMarker153"/> stored alongside our source code in the respective repository, such as JSON, CSV, Markdown, or MDX files.</li>
				<li><strong class="bold">Remotely</strong>: Files <a id="_idIndexMarker154"/>stored in another location that we ingest as part of our build processes, such as content from a Headless CMS, database, or API. <p class="callout-heading">Important Note</p><p class="callout">You may have noticed the absence of images being referenced when talking about data and might be wondering how to work with them. Due to their complexity, images have a dedicated chapter in this book – <a href="B15983_05_ePub_RK.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a>, <em class="italic">Working with Images</em>.</p></li>
			</ul>
			<p>Now that we understand what we mean by data in Gatsby, let's learn how we can query it within our application so that we can use it on our site pages.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor060"/>Introducing GraphQL </h1>
			<p><strong class="bold">GraphQL</strong> is<a id="_idIndexMarker155"/> a specification for querying data – general guidelines on how to query data efficiently. This specification was developed by engineers at Facebook in 2012 while working on their mobile application's <strong class="bold">REST</strong> services. They wanted to use their existing REST service<a id="_idIndexMarker156"/> on their mobile platforms, but it was going to require heavy modification and specific logic for mobile platforms in various areas of their APIs. The engineers also noticed that there were lots of data points in the responses to their API requests that they were not using. This meant that people with low network bandwidth were loading data they weren't even using. </p>
			<p>So, the team at Facebook started to work on GraphQL to solve these problems and rethink the way they could fetch data for devices. GraphQL shifted the focus from the backend engineers specifying what data is returned by what request, to the frontend developers specifying what they need. </p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/>GraphQL for Gatsby</h2>
			<p>Gatsby always uses <a id="_idIndexMarker157"/>GraphQL whenever you want to get data from within it. This is a great feature as we have an efficient way of getting data, regardless of its type. Gatsby can call GraphQL APIs directly if you already have a GraphQL server set up. However, a lot of the data we need to use on the web is not already in GraphQL format. </p>
			<p>Luckily, Gatsby's plugin architecture allows you to get non-GraphQL data into Gatsby, then use GraphQL to query it once you have it there. Regardless of whether your data is local or remote, or what format it is in, you can use one of Gatsby's plugins to pull the data. Then, you can use the GraphQL specification to query for that data on our pages. </p>
			<p>This is a great architecture that works with all of our content, no matter where it comes from. When it gets into Gatsby, we always query and retrieve that data in the same way.</p>
			<p>Let's look at a high-level example of what a GraphQL query contains:</p>
			<p class="source-code">query SampleQuery {</p>
			<p class="source-code">  content {</p>
			<p class="source-code">    edges {</p>
			<p class="source-code">      node {</p>
			<p class="source-code">        property</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Here, you can see that we used the word <strong class="source-inline">query</strong>, followed by the name of the query, which, in our case, is <strong class="source-inline">SampleQuery</strong>. Then, inside of the curly braces, we specify what kind of content we want to get – where you see <strong class="source-inline">content</strong> here, this would change to be the source of content you want. <strong class="source-inline">edges</strong> refers to a collection of connected items within that content source that have a relationship returned as an array. Then, when we go a level deeper, we have <strong class="source-inline">node</strong>, which refers to an individual item. Here, you can see that we are querying a single property.</p>
			<p>One of the great things<a id="_idIndexMarker158"/> about GraphQL is that you can be very specific about the data you need and only get that specific content. As shown in the previous example, we are only querying a single property of the node, but what if it contained a hundred properties instead? By pulling out only exactly what we need, we can create a very specific query that only gets us what we need. </p>
			<p>Now, let's look at a Gatsby-specific GraphQL query:</p>
			<p class="source-code">query MySitePages {</p>
			<p class="source-code">  allSitePage {</p>
			<p class="source-code">    edges {</p>
			<p class="source-code">      node {</p>
			<p class="source-code">        path</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Here, we can see that we are naming the query <strong class="source-inline">MySitePages</strong>. The content we are retrieving is from the <strong class="source-inline">allSitePage</strong> source, which is a default collection that contains all the pages that have been created within a Gatsby project. <strong class="source-inline">edges</strong> refers to all the pages, whereas <strong class="source-inline">node</strong> refers to a specific page we want. Inside each page, we are querying for the <strong class="source-inline">path</strong> parameter of that page.</p>
			<p>When running this query in Gatsby, it is going to return JSON. If you run the preceding query within our site and log the result, you would see the following object:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "data": {</p>
			<p class="source-code">    "allSitePage": {</p>
			<p class="source-code">      "edges": [</p>
			<p class="source-code">        {</p>
			<p class="source-code">          "node": {</p>
			<p class="source-code">            "path": "/404/"</p>
			<p class="source-code">          }</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          "node": {</p>
			<p class="source-code">            "path": "/about/"</p>
			<p class="source-code">          }</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          "node": {</p>
			<p class="source-code">            "path": "/"</p>
			<p class="source-code">          }</p>
			<p class="source-code">        }</p>
			<p class="source-code">      ]</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>As you can see, what we<a id="_idIndexMarker159"/> get back is an object with a data property. Within that, you can see our named query and its edges. The edges contain each node and its corresponding path property. Within the result, we can see every page that exists on the site – we have our <strong class="source-inline">404</strong> page, the <strong class="source-inline">about</strong> page, and the <strong class="source-inline">home</strong> page. </p>
			<p>Now, let's learn about filtering and sorting data within GraphQL.</p>
			<h3>Filtering in GraphQL</h3>
			<p>Sometimes, all<a id="_idIndexMarker160"/> the nodes of the returned data are not useful. We may occasionally<a id="_idIndexMarker161"/> want to filter out nodes based on a particular field. Let's take a look at an example where we are filtering out nodes from our <strong class="source-inline">allSitePage</strong> source:</p>
			<p class="source-code">query AllSitePagesExcept404 {</p>
			<p class="source-code">  allSitePage(filter: {path: {ne: "/404/"}}, limit: 1) {</p>
			<p class="source-code">    edges {</p>
			<p class="source-code">      node {</p>
			<p class="source-code">        path</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Here is an example in which we get a single page where the path does not equal (<strong class="source-inline">ne</strong> for short) <strong class="source-inline">/404/</strong>. Filtering is something we will look at in more detail as we start to develop more complex queries for our pages. Right now, it's important just to recognize that it is possible.</p>
			<p>In Gatsby, it is possible to obtain a single node on its own, but it is more common to query a collection. For example, if we wanted to retrieve a single <strong class="source-inline">SitePage</strong> node, we could use the following query:</p>
			<p class="source-code">query ASingleSitePage {</p>
			<p class="source-code">  sitePage {</p>
			<p class="source-code">    path</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>This query will receive the first node that matches the request and return it as an object instead of a larger array.</p>
			<p>Now that we understand how GraphQL queries are constructed, let's take a look at how we can use GraphiQL to explore our data.  </p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor062"/>Using GraphiQL </h2>
			<p>When it <a id="_idIndexMarker162"/>comes to learning GraphQL, it's fortunate that Gatsby ships with a tool called GraphiQL (<a href="https://github.com/graphql/graphiql">https://github.com/graphql/graphiql</a>). This is a web interface that hooks up to all of the GraphQL options in Gatsby and gives us a nice interface for testing and playing around with <a id="_idIndexMarker163"/>queries before we embed them into our code. </p>
			<p>As we know, when developing our site, Gatsby opens up <strong class="source-inline">http://localhost:8000</strong> to preview our site while we are building it. If you navigate to <strong class="source-inline">http://localhost:8000/___graphql</strong>, you will pull up a GraphiQL interface that is connected to your development Gatsby site. When you open this page, you should be presented with something that looks like this:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B15983_03_01.jpg" alt="Figure 3.1 – GraphiQL user interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – GraphiQL user interface</p>
			<p>On the far left, you will see <strong class="bold">Explorer</strong>, which shows all the possible pieces of content we could get using GraphQL inside of Gatsby. You can check the properties within the <strong class="bold">Explorer</strong> area to have GraphiQL automatically build the query for you. In the central left column, we can see the query that we need to use to retrieve the data we want. When you hit the <strong class="bold">Play</strong> button above the query, you will see the result of that query on the central right column, with a JSON object containing the data property and our query's result inside it. On the <a id="_idIndexMarker164"/>far right, you will see the <strong class="bold">Documentation Explorer</strong> area, which you can use as an alternative way to explore your data and identify the different types of data you have available.</p>
			<p>Now, let's learn where we can use queries to retrieve data within our application. </p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor063"/>Using constructed GraphQL queries</h2>
			<p>There are three main places where you can use a GraphQL query in your Gatsby projects: </p>
			<ul>
				<li><strong class="source-inline">Gatsby-node.js</strong>: This<a id="_idIndexMarker165"/> file is one of the places we can create pages programmatically based on dynamic data. If we had a list of blog posts in Markdown and we <a id="_idIndexMarker166"/>wanted to create a page for each one, we would use a query here to retrieve the data from the posts that we need to dynamically create the pages for.</li>
				<li><strong class="bold">Within pages</strong>: We can append queries to single instance pages to make data available within that page. This is how we will be testing the data we source within this chapter. We can also query <a id="_idIndexMarker167"/>inside <strong class="bold">page templates</strong>, something we haven't discussed yet, but it is a key concept we will look at in detail in <a href="B15983_04_ePub_RK.xhtml#_idTextAnchor072"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating Reusable Templates</em>. A page template could take a slug based on the URL and then run a query based on that URL to work out what page to display. In both single-instance pages and templates, the query is run at build time, so the pages that are created are still static.</li>
				<li><strong class="bold">Within any other component</strong>: We can also retrieve GraphQL data within any React component we have created. There is a different method to retrieving data outside of page templates because outside of a page template, you cannot get dynamic content using variables. As such, queries run this way are static. We will see examples of static queries in <a href="B15983_05_ePub_RK.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a>, <em class="italic">Working with Images</em>.</li>
			</ul>
			<p>Now that you understand the basics of GraphQL in Gatsby, let's start ingesting different kinds of data into our GraphQL layer.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor064"/>Sourcing data from local files</h1>
			<p>In this section, we will learn<a id="_idIndexMarker168"/> how to source and query data from local files. As <a id="_idIndexMarker169"/>we mentioned previously, when we say local files, we are referring to files located alongside the code in our repository.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor065"/>Site metadata</h2>
			<p>A great place to store small reusable pieces of data is within the <strong class="source-inline">gatsby-config.js</strong> file. Gatsby exposes the <strong class="source-inline">siteMetadata</strong> property to the data layer so that you can retrieve it throughout your <a id="_idIndexMarker170"/>application. In the context of our website, I would suggest storing your website address, your name, your role, and a short bio here. If this is implemented consistently, whenever any of these pieces of information change, you can change the field once in <strong class="source-inline">siteMetadata</strong> and see the change reflected across your whole site.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout"><strong class="source-inline">gatsby-config.js</strong> is a file that you will often find growing quite large as you expand your Gatsby projects. To try and keep things ordered, try and reserve your <strong class="source-inline">siteMetadata</strong> for a handful of small strings. If you are considering adding a large block of text here, it might be better to add it as a Markdown file.</p>
			<p>Let's create some site metadata and ingest it on our home page:</p>
			<ol>
				<li>First, update <strong class="source-inline">gatsby-config.js</strong> with<a id="_idIndexMarker171"/> the following code: <p class="source-code">module.exports = {</p><p class="source-code">  <strong class="bold">siteMetadata: {</strong></p><p class="source-code"><strong class="bold">    siteUrl: 'https://your.website',</strong></p><p class="source-code"><strong class="bold">    name: 'Your Name',</strong></p><p class="source-code"><strong class="bold">    role: 'Developer at Company',</strong></p><p class="source-code"><strong class="bold">    bio: 'My short bio that I will use to introduce</strong></p><p class="source-code"><strong class="bold">          myself.'</strong></p><p class="source-code"><strong class="bold">  },</strong></p><p class="source-code">  plugins: [</p><p class="source-code">    // your plugins</p><p class="source-code">  ],</p><p class="source-code">};</p><p>The <strong class="source-inline">siteMetadata</strong> key sits next to the plugins we have defined. Here, you can see we have defined the key values I suggested earlier. Keep in mind that these key values are just a suggestion and that if you want to add or remove keys, feel free to do so.</p></li>
				<li>Use the <a id="_idIndexMarker172"/>GraphiQL interface to construct the GraphQL query to retrieve the data. This should look like this:<p class="source-code">query BasicInfo {</p><p class="source-code">  site {</p><p class="source-code">    siteMetadata {</p><p class="source-code">      name</p><p class="source-code">      role</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p>Your site metadata is available within the <strong class="source-inline">site</strong> source. In the preceding query, we are only retrieving <strong class="source-inline">name</strong> and <strong class="source-inline">role</strong>.</p></li>
				<li>Embed your constructed query on your index page:<p class="source-code">import React from "react";</p><p class="source-code">import { Link, <strong class="bold">graphql</strong> } from "gatsby";</p><p class="source-code">import Layout from "../components/layout/Layout";</p><p class="source-code">export default function Index({ <strong class="bold">data</strong> }) {</p><p class="source-code"><strong class="bold">  const {</strong></p><p class="source-code"><strong class="bold">    site: {</strong></p><p class="source-code"><strong class="bold">      siteMetadata: { name, role },</strong></p><p class="source-code"><strong class="bold">    },</strong></p><p class="source-code"><strong class="bold">  } = data;</strong></p><p class="source-code">  return (</p><p class="source-code">    &lt;Layout&gt;</p><p class="source-code">      &lt;div className="max-w-5xl mx-auto py-16 lg:py-</p><p class="source-code">       24"&gt;</p><p class="source-code">        &lt;h1 className="text-4xl md:text-6xl font-bold</p><p class="source-code">         text-black pb-4"&gt;</p><p class="source-code">          <strong class="bold">{name}</strong></p><p class="source-code">        &lt;/h1&gt;</p><p class="source-code">        &lt;p className="mb-4"&gt;<strong class="bold">{role}</strong>&lt;/p&gt;</p><p class="source-code">        &lt;Link to="/about" className="btn"&gt;</p><p class="source-code">          About me</p><p class="source-code">        &lt;/Link&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/Layout&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p class="source-code"><strong class="bold">export const query = graphql'</strong></p><p class="source-code"><strong class="bold">  {</strong></p><p class="source-code"><strong class="bold">    site {</strong></p><p class="source-code"><strong class="bold">      siteMetadata {</strong></p><p class="source-code"><strong class="bold">        name</strong></p><p class="source-code"><strong class="bold">        role</strong></p><p class="source-code"><strong class="bold">      }</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code">';</p><p>Here, you can<a id="_idIndexMarker173"/> see we are importing <strong class="source-inline">graphql</strong> from Gatsby. We are then appending our query from <em class="italic">Step 2</em> to the end of the file, below our page component. The export name isn't important as Gatsby looks for any GraphQL string within your pages, but here, you can see I am calling it <strong class="source-inline">query</strong>. </p><p>When Gatsby builds this page, this query is pulled out of our source code, parsed, and run, and the resultant data is passed into our page component via the data prop you can see on line 5. We can then use the data contained within the query (in our case, <strong class="source-inline">name</strong> and <strong class="source-inline">role</strong> from <strong class="source-inline">siteMetadata</strong>) to populate our site hero.</p><p class="callout-heading">Important Note</p><p class="callout">You can only export one query per component. If you ever need more data on the page, instead of exporting another query, extend your existing query.</p></li>
			</ol>
			<p>Now, let's learn about how we can ingest data from sources that are not included with Gatsby out of the box – starting with Markdown. </p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor066"/>Markdown</h2>
			<p>The <a id="_idIndexMarker174"/>Markdown syntax is a popular way to write content on a Gatsby site. If you have used GitHub or Bitbucket before, chances are you've already encountered this format as they both make use of it in <strong class="source-inline">README</strong> files. Markdown is a great format for longer pieces of writing within your site – documentation, blog posts, or even a long bio. </p>
			<p>To start using Markdown in Gatsby, you only need to create text files – no additional infrastructure is required to implement it. Gatsby also<a id="_idIndexMarker175"/> provides <strong class="bold">core-plugin</strong> (a plugin owned and maintained by the Gatsby team) to process Markdown into content that can be used by our components. Using core-plugin, no code is required to implement Markdown and get set up.</p>
			<p>Let's create a short biography in Markdown and add it to our about page:</p>
			<ol>
				<li value="1">Create a folder to <a id="_idIndexMarker176"/>store our Markdown called <strong class="source-inline">MD</strong> at the root of your project. <p>It's good practice to keep this folder outside of your <strong class="source-inline">src</strong> directory as it does not contain any source code but instead is text content. This makes it much easier for a developer without React experience to modify site content.</p></li>
				<li>Create a folder inside <strong class="source-inline">/MD</strong> to store your bio called <strong class="source-inline">bio</strong>. As we add more Markdown files that serve up different types of content, it's helpful to keep them separated.</li>
				<li>Create a <strong class="source-inline">bio.md</strong> file inside our newly created <strong class="source-inline">bio</strong> folder and add the following code:<p class="source-code">---</p><p class="source-code">type: bio</p><p class="source-code">---</p><p>This is the first part of the file and contains <strong class="bold">YAML</strong> frontmatter. YAML is a human-readable data-serialization language. Here, we are <a id="_idIndexMarker177"/>defining a <strong class="source-inline">type</strong>. This <strong class="source-inline">type</strong> will help us query for this exact file in our GraphQL query.</p></li>
				<li>Create the body of your biography using Markdown syntax:<p class="source-code">---</p><p class="source-code">type: bio</p><p class="source-code">---</p><p class="source-code"><strong class="bold"># A short biography about me</strong></p><p class="source-code"><strong class="bold">This is a very short biography about ***me***. But it could be as long as I want it to be. </strong></p><p>You can use any valid Markdown syntax here; I have kept this example brief by just<a id="_idIndexMarker178"/> including one heading and a paragraph, but feel free to add as much as you like.</p></li>
				<li>Install <strong class="source-inline">gatsby-source-filesystem</strong>:<p class="source-code">npm install gatsby-source-filesystem</p><p>As its name might suggest, this plugin allows Gatsby to read local files.</p></li>
				<li>Install <strong class="source-inline">gatsby-transformer-remark</strong>: <p class="source-code"><strong class="source-inline">npm install gatsby-transformer-remark</strong></p><p>We can use this plugin to recognize Markdown files and read their content. This plugin will read in the syntax and convert it into HTML that we can then embed in our components.</p></li>
				<li>Next, let's configure our new dependencies in <strong class="source-inline">gatsby-config.js</strong>:<p class="source-code">module.exports = {</p><p class="source-code">  siteMetadata: {</p><p class="source-code">    siteUrl: 'https://your.website',</p><p class="source-code">    name: 'Your Name',</p><p class="source-code">    role: 'Developer at Company',</p><p class="source-code">    bio: 'My short bio that I will use to introduce</p><p class="source-code">          myself.',</p><p class="source-code">  },</p><p class="source-code">  plugins: [</p><p class="source-code">    <strong class="bold">{</strong></p><p class="source-code"><strong class="bold">      resolve: 'gatsby-source-filesystem',</strong></p><p class="source-code"><strong class="bold">      options: {</strong></p><p class="source-code"><strong class="bold">        name: 'markdown-bio',</strong></p><p class="source-code"><strong class="bold">        path: '${__dirname}/MD ',</strong></p><p class="source-code"><strong class="bold">      },</strong></p><p class="source-code"><strong class="bold">    },</strong></p><p class="source-code"><strong class="bold">    'gatsby-transformer-remark',</strong></p><p class="source-code">    'gatsby-plugin-postcss',</p><p class="source-code">  ],</p><p class="source-code">};</p><p>Here, we are introducing Gatsby to our new plugins. We are using <strong class="source-inline">gatsby-source-filesystem</strong> to tell Gatsby to read files from the Markdown folder we created previously.</p><p>We also<a id="_idIndexMarker179"/> added <strong class="source-inline">gatsby-transformer-remark</strong> so that Gatsby can read Markdown files into its GraphQL layer.</p></li>
				<li>Start your development server and navigate to your GraphiQL interface. Construct and run the query to retrieve just the <strong class="source-inline">bio</strong> information:<p class="source-code">query Biography {</p><p class="source-code">  markdownRemark(frontmatter: {type: {eq: "bio"}}) {</p><p class="source-code">    html</p><p class="source-code">  }</p><p class="source-code">}</p><p>Here, we have<a id="_idIndexMarker180"/> constructed a query where we are retrieving the HTML from <strong class="source-inline">markdownRemark</strong>. We are filtering the Markdown where the frontmatter type is equal to <strong class="source-inline">bio</strong> and since there is only one such file, we will always retrieve the correct file. By running this query in the GraphiQL interface, you should see something that looks like this:</p><p class="source-code">{</p><p class="source-code">  "data": {</p><p class="source-code">    "markdownRemark": {</p><p class="source-code">      "html": "&lt;h1&gt;A short biography about</p><p class="source-code">        me&lt;/h1&gt;\n&lt;p&gt;This is a very short biography</p><p class="source-code">        about &lt;em&gt;&lt;strong&gt;me&lt;/strong&gt;&lt;/em&gt;. But it</p><p class="source-code">        could be as long as I want it to be.&lt;/p&gt;"</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  "extensions": {}</p><p class="source-code">}</p><p>Here, you can see that the Markdown we wrote in the file has been transformed into HTML that we can now use within our pages.</p></li>
				<li>Embed this query in your <strong class="source-inline">about</strong> page:<p class="source-code">import React from "react";</p><p class="source-code">import { graphql } from "gatsby";</p><p class="source-code">import Layout from "../components/layout/Layout";</p><p class="source-code">export default function About({ <strong class="bold">data</strong> }) {</p><p class="source-code">  <strong class="bold">const {</strong></p><p class="source-code"><strong class="bold">    markdownRemark: { html },</strong></p><p class="source-code"><strong class="bold">  } = data;</strong></p><p class="source-code">  return (</p><p class="source-code">    &lt;Layout&gt;</p><p class="source-code">      &lt;div className="max-w-5xl mx-auto py-16 lg:py-24</p><p class="source-code">        text-center"&gt;</p><p class="source-code">        &lt;div <strong class="bold">dangerouslySetInnerHTML={{ __html: html</strong></p><p class="source-code"><strong class="bold">          }}</strong>&gt;&lt;/div&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/Layout&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p class="source-code"><strong class="bold">export const query = graphql'</strong></p><p class="source-code"><strong class="bold">  {</strong></p><p class="source-code"><strong class="bold">    markdownRemark(frontmatter: { type: { eq: "bio" }</strong></p><p class="source-code"><strong class="bold"> }) {</strong></p><p class="source-code"><strong class="bold">      html</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code"><strong class="bold">';</strong></p><p>Here, we have appended our query to the bottom of the page and retrieved the resultant data via the <strong class="source-inline">data</strong> prop. I'd like to draw your attention to the div with the <strong class="source-inline">dangerouslySetInnerHTML</strong> prop. <strong class="source-inline">dangerouslySetInnerHTML</strong> is React's<a id="_idIndexMarker181"/> replacement for using <strong class="source-inline">innerHTML</strong> in the browser's DOM. </p><p>It's considered <em class="italic">dangerous</em> because if the content can be edited by a user, this can expose users to a <strong class="bold">cross-site scripting attack</strong>. A cross-site scripting attack injects malicious <a id="_idIndexMarker182"/>code into a vulnerable web application. In our case, however, the content is always static and always defined by us, so we have nothing to worry about.</p></li>
			</ol>
			<p>Markdown can be a great option if you want to write long-form articles, but what if you want to make your articles more interactive? Maybe you want a poll in the middle of your post or a prompt for users to sign up to your email between two paragraphs? There are plenty of scenarios like these that simply cannot be achieved elegantly in Markdown. For functionalities such as these, MDX is the answer.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor067"/>MDX</h2>
			<p>MDX<a id="_idIndexMarker183"/> is a format that allows you to enhance your Markdown with JSX. You can import components into your Markdown and embed them in your content.</p>
			<p>Let's make an <a id="_idIndexMarker184"/>enhanced biography on our about page using MDX that contains your employment history:</p>
			<ol>
				<li value="1">Create a folder to store our Markdown called <strong class="source-inline">MDX</strong> at the root of your project. As with Markdown (and for the same reasons), it's good practice to keep this folder outside of <strong class="source-inline">src</strong>, even though it can contain React components. </li>
				<li>Create a folder inside <strong class="source-inline">/MDX</strong> to store your bio called <strong class="source-inline">bio</strong> (as we did with our Markdown).</li>
				<li>Create a folder called <strong class="source-inline">components</strong> within your <strong class="source-inline">/MDX</strong> folder to store React components specifically for use within our MDX files. </li>
				<li>Create an <strong class="source-inline">EmploymentHistory</strong> component in the <strong class="source-inline">components</strong> folder that we can<a id="_idIndexMarker185"/> embed in our <strong class="source-inline">mdx</strong> file:<p class="source-code">import React from "react";</p><p class="source-code">const employment = [</p><p class="source-code">  {</p><p class="source-code">    company: "Company One",</p><p class="source-code">    role: "UX Engineer",</p><p class="source-code">  },</p><p class="source-code">  {</p><p class="source-code">    company: "Company Two",</p><p class="source-code">    role: "Gatsby Developer",</p><p class="source-code">  },</p><p class="source-code">];</p><p class="source-code">const EmploymentHistory = () =&gt; (</p><p class="source-code">  &lt;div className="text-left max-w-xl mx-auto"&gt;</p><p class="source-code">    &lt;div className="grid grid-cols-2 gap-2 mt-5"&gt;</p><p class="source-code">      {employment.map(({ role, company }) =&gt; (</p><p class="source-code">        &lt;&gt;</p><p class="source-code">          &lt;div className="flex justify-end font-</p><p class="source-code">            bold"&gt;&lt;p&gt;{role}&lt;/p&gt;&lt;/div&gt;</p><p class="source-code">          &lt;p&gt;{company}&lt;/p&gt;</p><p class="source-code">        &lt;/&gt;</p><p class="source-code">      ))}</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">);</p><p class="source-code">export default EmploymentHistory;</p><p>I am using employment history as an example here, but this can be any valid React component. In this example, we have defined a small array of employment experiences containing objects, each with a company and role. In <strong class="source-inline">EmploymentHistory</strong>, we map over those roles and lay them out in a grid. We then <a id="_idIndexMarker186"/>export the component as normal.</p></li>
				<li>Create <strong class="source-inline">bio.mdx</strong> in <strong class="source-inline">/MDX/bio</strong>:<p class="source-code">---</p><p class="source-code">type: bio</p><p class="source-code">---</p><p class="source-code"><strong class="bold">import EmploymentHistory from</strong></p><p class="source-code"><strong class="bold">  "../components/EmploymentHistory";</strong></p><p class="source-code"># A short biography about me</p><p class="source-code">This is a very short biography about **_me_**. But it could be as long as I want it to be.</p><p class="source-code">### ***My Employment History***</p><p class="source-code"><strong class="bold">&lt;EmploymentHistory /&gt;</strong></p><p>Like our Markdown, we can include frontmatter in MDX files. Here, we are once again specifying <strong class="source-inline">type</strong> as <strong class="source-inline">bio</strong>. Just below that, you will see we have introduced an <strong class="source-inline">import</strong> statement pointing to our newly created component. We can then use the imported component wherever we like within the body of our content, much like I have on the last line in the preceding example.</p></li>
				<li>Install the <a id="_idIndexMarker187"/>necessary <strong class="source-inline">mdx</strong> dependencies:<p class="source-code">npm install gatsby-plugin-mdx @mdx-js/mdx @mdx-</p><p class="source-code">js/react</p></li>
				<li>Configure <strong class="source-inline">gatsby-config.js</strong> so that it includes the <strong class="source-inline">gatsby-plugin-mdx</strong> plugin:<p class="source-code">module.exports = {</p><p class="source-code">  siteMetadata: {</p><p class="source-code">    siteUrl: 'https://your.website',</p><p class="source-code">    name: 'Your Name',</p><p class="source-code">    role: 'Developer at Company',</p><p class="source-code">    bio: 'My short bio that I will use to introduce</p><p class="source-code">          myself.',</p><p class="source-code">  },</p><p class="source-code">  plugins: [</p><p class="source-code">    {</p><p class="source-code">      resolve: 'gatsby-source-filesystem',</p><p class="source-code">      options: {</p><p class="source-code">        name: 'mdx-bio',</p><p class="source-code">        <strong class="bold">path: '${__dirname}/MDX ',</strong></p><p class="source-code">      },</p><p class="source-code">    },</p><p class="source-code">    <strong class="bold">'gatsby-plugin-mdx'</strong>,</p><p class="source-code">    'gatsby-plugin-postcss',</p><p class="source-code">  ],</p><p class="source-code">};</p><p>We use <strong class="source-inline">gatsby-source-filesystem</strong> to tell Gatsby to read files from the MDX folder we created previously. We have also added <strong class="source-inline">gatsby-plugin-mdx</strong> so that Gatsby can read MDX files into its GraphQL layer.</p></li>
				<li>Start your <a id="_idIndexMarker188"/>development server and navigate to your GraphiQL interface. Construct and run the query to retrieve our updated MDX bio:<p class="source-code">query Biography {</p><p class="source-code">    mdx(frontmatter: { type: { eq: "bio" } }) {</p><p class="source-code">      body</p><p class="source-code">    }</p><p class="source-code">}</p><p>Here, we have constructed a query where we are retrieving the <strong class="source-inline">mdx</strong> body from the <strong class="source-inline">mdx</strong> source, where the frontmatter type is equal to <strong class="source-inline">bio</strong>. </p></li>
				<li>Embed the query in your about page:<p class="source-code">import React from "react";</p><p class="source-code">import { graphql } from "gatsby";</p><p class="source-code">import Layout from "../components/layout/Layout";</p><p class="source-code"><strong class="bold">import { MDXRenderer } from "gatsby-plugin-mdx";</strong></p><p class="source-code">export default function About({ data }) {</p><p class="source-code">  const {</p><p class="source-code">    mdx: { body },</p><p class="source-code">  } = data;</p><p class="source-code">  return (</p><p class="source-code">    &lt;Layout&gt;</p><p class="source-code">      &lt;div className="max-w-5xl mx-auto py-16 lg:py-24</p><p class="source-code">        text-center"&gt;</p><p class="source-code"><strong class="bold">        &lt;MDXRenderer&gt;{body}&lt;/MDXRenderer&gt;</strong></p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/Layout&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p class="source-code">export const query = graphql'</p><p class="source-code">  <strong class="bold">{</strong></p><p class="source-code"><strong class="bold">    mdx(frontmatter: { type: { eq: "bio" } }) {</strong></p><p class="source-code"><strong class="bold">      body</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code">';</p><p>Here, we have <a id="_idIndexMarker189"/>appended our query to the bottom of the page and retrieved the resultant data via the <strong class="source-inline">data</strong> prop. We then used <strong class="source-inline">MDXRenderer</strong> from <strong class="source-inline">gatsby-plugin-mdx</strong> to render the MDX body's content.</p><p class="callout-heading">Important Note</p><p class="callout">Using <strong class="source-inline">MDXRenderer</strong> does increase your bundle size and the time it takes for your JavaScript to be parsed. This is because instead of rendering all the HTML at build time, any pages containing MDX are now being rendered to HTML on the frontend. This is important to keep in mind as it will negatively impact your site's performance.</p></li>
			</ol>
			<p>Now that we understand how to ingest local data, let's look at sourcing data from a remote source – a <strong class="bold">Content Management System (CMS)</strong>!</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor068"/>Sourcing data from a Headless CMS</h1>
			<p>A<a id="_idIndexMarker190"/> Headless CMS is a <a id="_idIndexMarker191"/>CMS that purely focuses on the content itself and <a id="_idIndexMarker192"/>does not care about how it's presented. Traditional CMSes store content in a database and then use a series of HTML templates to control how content gets presented to viewers. In Headless CMSes, however, instead of returning HTML, we return structured data via an API.</p>
			<p>Content creators can still add and edit data via a user interface, but the frontend is stored completely separately. This is perfect for when your content creators are not developers, or when you're out and about and want to write a post on your phone without having to spin up your laptop.</p>
			<p>With Gatsby's vast plugin ecosystem, your site can support many different Headless CMSes with very little effort. You could write a book on how to implement every one of them into your project, so, instead, let's focus on two – GraphCMS and Prismic.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout"><em class="italic">Only implement one of the Headless CMS choices outlined in this chapter</em>. Not only would having two different sources for the same type of data be confusing, but it would also lead to longer site build times as data will need to be retrieved from two sources instead of one.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor069"/>GraphCMS</h2>
			<p>GraphCMS<a id="_idIndexMarker193"/> is a fully-hosted SaaS platform that's used by over 30,000 teams of all sizes across the world. Their queries are cached across 190 edge CDN nodes globally, meaning that wherever you're located, pulling data from GraphCMS into your Gatsby projects should be blazingly fast. Let's introduce ourselves to using GraphCMS by creating a list of hobbies within the tool that we can then ingest within our application:</p>
			<ol>
				<li value="1">Navigate to the GraphCMS <a id="_idIndexMarker194"/>website (<a href="https://graphcms.com">graphcms.com</a>) and log in. </li>
				<li>Create a new blank <a id="_idIndexMarker195"/>project and pick the region you want to host your data in.</li>
				<li>Navigate to your project's <strong class="bold">schema</strong> and create a hobby <strong class="bold">model</strong>. The schema is the blueprint for your data graph. Your schema is built from the models you create, the fields<a id="_idIndexMarker196"/> they contain, and their relationships. Clicking the <strong class="bold">add</strong> button next to <strong class="source-inline">Models</strong> will open the following dialog:<div id="_idContainer015" class="IMG---Figure"><img src="image/B15983_03_02.jpg" alt="Figure 3.2 – Model creation in GraphCMS&#13;&#10;"/></div><p class="figure-caption">Figure 3.2 – Model creation in GraphCMS</p><p>Here, you can see I am creating a model called <strong class="bold">Icebreakers</strong>. You'll notice that you need to provide an <strong class="bold">API ID</strong> and its plural form to make it easier to distinguish between when you are querying a single item versus the whole collection. Upon hitting <strong class="bold">Update Model</strong>, you should see that <strong class="bold">Icebreakers</strong> has been added to the model on the left sidebar. </p></li>
				<li>We can now start to define what type of data is in our Icebreakers model by adding fields. Upon clicking on the Icebreakers model, you will see many field options on the right-hand side. We can use these to explain to GraphCMS what format our data will take. In our case, a hobby consists of one to three words each, so it would be appropriate to use the <strong class="bold">Single Line Text</strong> field option. Selecting this option<a id="_idIndexMarker197"/> will open the following dialog:<div id="_idContainer016" class="IMG---Figure"><img src="image/B15983_03_03.jpg" alt="Figure 3.3 – Field creation in GraphCMS&#13;&#10;"/></div><p class="figure-caption">Figure 3.3 – Field creation in GraphCMS</p><p>Enter an<a id="_idIndexMarker198"/> appropriate display name and API ID, such as <strong class="bold">hobbies</strong>. Write <strong class="bold">Collection of hobbies I have</strong> as the description. I have also checked <strong class="bold">Allow multiple values</strong> so that we can store a list of hobbies instead of one. Click <strong class="bold">Update</strong> to save this configuration.</p></li>
				<li>Navigate to the <a id="_idIndexMarker199"/>content section of the site. Click <strong class="bold">Create item</strong> at the top right of the page. This will open the following window:<div id="_idContainer017" class="IMG---Figure"><img src="image/B15983_03_04.jpg" alt="Figure 3.4 – Populating content in GraphCMS &#13;&#10;"/></div><p class="figure-caption">Figure 3.4 – Populating content in GraphCMS </p><p>We can now start to fill in our hobbies, adding them to the list as we go. Once you've done this, hit <strong class="bold">Save</strong> at the top right.</p></li>
				<li>Returning to the<a id="_idIndexMarker200"/> content window, you will see that your created icebreaker is in <strong class="bold">Draft</strong> mode. This means that we are not happy with the content yet and that we will not be able to retrieve it from the API yet:<div id="_idContainer018" class="IMG---Figure"><img src="image/B15983_03_05.jpg" alt="Figure 3.5 – GraphCMS content and its draft status&#13;&#10;"/></div><p class="figure-caption">Figure 3.5 – GraphCMS content and its draft status</p></li>
				<li>To make the <a id="_idIndexMarker201"/>content live, we need to publish it by selecting the <a id="_idIndexMarker202"/>item and then clicking the <strong class="bold">Publish</strong> button. </li>
				<li>Next, we need to<a id="_idIndexMarker203"/> modify the endpoint settings to allow for public API access. By default, your GraphCMS API is not accessible from outside of their platform. You can change the settings for your public API access or create permanent authentication tokens with access permissions. Often, I lean toward keeping my data public as it is still only retrievable if you know the API's URL. Since it can't be edited by default, all of it will be displayed publicly on my site anyway.<p>Navigate to <strong class="bold">Settings</strong>, then <strong class="bold">API Access</strong>, and modify your public API permissions to the following:</p><div id="_idContainer019" class="IMG---Figure"><img src="image/B15983_03_06.jpg" alt="Figure 3.6 – GraphCMS public API settings&#13;&#10;"/></div><p class="figure-caption">Figure 3.6 – GraphCMS public API settings</p><p>You will see<a id="_idIndexMarker204"/> that I have checked <strong class="bold">Content from stage Published</strong>. By doing so, we can now retrieve data that has been published via the URL endpoint, located at the top of the API's <strong class="bold">Access</strong> page.</p></li>
				<li>Scroll to the top of this page and take note of your master URL endpoint. We will now move over to our Gatsby project and start ingesting data using this URL.</li>
				<li>Open a<a id="_idIndexMarker205"/> terminal at the root of your project and install the necessary dependencies, the official GraphCMS source plugin, and <strong class="source-inline">dot-env</strong>:<p class="source-code">npm install gatsby-source-graphcms gatsby-plugin-image</p><p class="source-code">dotenv</p><p><strong class="source-inline">gatsby-source-graphcms</strong> will allow us to source data from GraphCMS within our application, while <strong class="source-inline">dotenv</strong> is a zero-dependency module that loads environment variables from a <strong class="source-inline">.env</strong> file. We will be storing our API endpoint in the <strong class="source-inline">.env</strong> format. This plugin also requires <strong class="source-inline">gatsby-plugin-image</strong> under the hood, so make sure to install it. We will talk more about <strong class="source-inline">gatsby-plugin-image</strong> in <a href="B15983_05_ePub_RK.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a>, <em class="italic">Working with Images</em>.</p></li>
				<li>Create a <strong class="source-inline">.env</strong> file at<a id="_idIndexMarker206"/> the root of your project and add your master URL endpoint for GraphCMS as a variable:<p class="source-code">GRAPHCMS_ENDPOINT=<strong class="bold">Your-master-endpoint-url-here</strong></p><p>This <strong class="source-inline">.env</strong> file is used to house environment variables. Be sure to replace the highlight with your master URL endpoint from <em class="italic">Step 6</em>. This file should not be committed to source control and, as such, should be added to your <strong class="source-inline">.gitignore</strong>.</p></li>
				<li>Modify <a id="_idIndexMarker207"/>your <strong class="source-inline">gatsby-config.js</strong> file so that it includes <strong class="source-inline">gatsby-plugin-image</strong> and <strong class="source-inline">gatsby-source-graphcms</strong>:<p class="source-code"><strong class="bold">require("dotenv").config()</strong></p><p class="source-code">module.exports = {</p><p class="source-code">  ...</p><p class="source-code">  plugins: [</p><p class="source-code">    ...</p><p class="source-code">    <strong class="bold">'gatsby-plugin-image',</strong></p><p class="source-code">    <strong class="bold">{</strong></p><p class="source-code"><strong class="bold">      resolve: 'gatsby-source-graphcms',</strong></p><p class="source-code"><strong class="bold">      options: {</strong></p><p class="source-code"><strong class="bold">        endpoint: process.env.GRAPHCMS_ENDPOINT,</strong></p><p class="source-code"><strong class="bold">      },</strong></p><p class="source-code">    },</p><p class="source-code">   ...</p><p class="source-code">  ],</p><p class="source-code">};</p><p>Firstly, we use <strong class="source-inline">dotenv</strong> to load in our create <strong class="source-inline">.env</strong> file, and then we use that variable within the plugin configuration of <strong class="source-inline">gatsby-source-graphcms</strong>.</p></li>
				<li>We can now start our development server. You will notice that when the development server starts, a new folder is created called <strong class="source-inline">graphcms-fragments</strong>. This folder is maintained by the plugin and contains fragments that explain the structure of our data to the GraphQL data layer. </li>
				<li>At this <a id="_idIndexMarker208"/>point, we can <a id="_idIndexMarker209"/>query our data as if it were any other source. First, we must construct a query:<p class="source-code">query Hobbies {</p><p class="source-code">  graphCmsIcebreaker {</p><p class="source-code">    hobbies</p><p class="source-code">  }</p><p class="source-code">}</p><p>Here, I have created a query that extracts our hobbies array from the auto-generated <strong class="source-inline">graphCmsIcebreaker</strong> source.</p></li>
				<li>We can now embed this query in our <strong class="source-inline">about</strong> page:<p class="source-code">import React from "react";</p><p class="source-code">import { graphql } from "gatsby";</p><p class="source-code">import Layout from "../components/layout/Layout";</p><p class="source-code">import { MDXRenderer } from "gatsby-plugin-mdx";</p><p class="source-code">export default function About({ data }) {</p><p class="source-code">  const {</p><p class="source-code">    mdx: { body },</p><p class="source-code"><strong class="bold">    graphCmsIcebreaker: { hobbies },</strong></p><p class="source-code">  } = data;</p><p class="source-code">  return (</p><p class="source-code">    &lt;Layout&gt;</p><p class="source-code">      &lt;div className="max-w-5xl mx-auto py-16 lg:py-24</p><p class="source-code">        text-center"&gt;</p><p class="source-code">        &lt;MDXRenderer&gt;{body}&lt;/MDXRenderer&gt;</p><p class="source-code">        &lt;div&gt;</p><p class="source-code"><strong class="bold">          &lt;h2&gt;Hobbies&lt;/h2&gt;</strong></p><p class="source-code"><strong class="bold">          {hobbies.join(", ")}</strong></p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/Layout&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p class="source-code">export const query = graphql'</p><p class="source-code">  {</p><p class="source-code">    mdx(frontmatter: { type: { eq: "bio" } }) {</p><p class="source-code">      body</p><p class="source-code">    }</p><p class="source-code">    <strong class="bold">graphCmsIcebreaker {</strong></p><p class="source-code"><strong class="bold">      hobbies</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">  }</p><p class="source-code">';</p><p>You'll notice that I have just appended the new query to the existing page query, bundled into the same GraphQL string. Gatsby expects to only find one query per page. I then deconstructed the data prop to retrieve the hobbies array.</p></li>
			</ol>
			<p>Now that we understand how GraphCMS works, let's turn our attention to how you would implement one of GraphCMS's competitors, Prismic.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor070"/>Prismic</h2>
			<p>Prismic is <a id="_idIndexMarker210"/>smaller than GraphCMS, with around 5,000 paying customers. One feature that makes it stand out is they offer <strong class="bold">dynamic multi-session previews</strong>, allowing<a id="_idIndexMarker211"/> you to share multiple simultaneous dynamic previews (with shareable links) in Gatsby. This can improve your workflow when you're working with clients and you need to send the client's site content back and forth. Let's learn how to integrate Prismic by adding a list of hobbies within the UI so that we can then ingest them within our Gatsby site:</p>
			<ol>
				<li value="1">Create a folder in <strong class="source-inline">/src</strong> called <strong class="source-inline">schemas</strong>. Unlike GraphCMS, Prismic does not automatically<a id="_idIndexMarker212"/> create the schemas for us; instead, we will retrieve them using the Prismic UI as we create them.</li>
				<li>Navigate to<a id="_idIndexMarker213"/> Prismic's website (<a href="https://prismic.io">prismic.io</a>) and log in. Create a new repository with the free plan (you can always scale up later if you need to).</li>
				<li>Click the <strong class="bold">Create your first custom type</strong> button and select the <strong class="bold">single</strong> type. Name your type <strong class="bold">Icebreaker</strong> and submit.</li>
				<li>Scroll to the <a id="_idIndexMarker214"/>bottom of the build-mode sidebar on the right and drag a group into the central page:<div id="_idContainer020" class="IMG---Figure"><img src="image/B15983_03_07.jpg" alt="Figure 3.7 – Prismic group field options&#13;&#10;"/></div><p class="figure-caption">Figure 3.7 – Prismic group field options</p></li>
				<li>Name <a id="_idIndexMarker215"/>your field <strong class="bold">hobbies</strong>; the corresponding API ID should<a id="_idIndexMarker216"/> populate on its own. Click <strong class="bold">OK</strong> to confirm this.</li>
				<li>Drag a rich text field into this group:<div id="_idContainer021" class="IMG---Figure"><img src="image/B15983_03_08.jpg" alt="Figure 3.8 – Prismic text field configuration&#13;&#10;"/></div><p class="figure-caption">Figure 3.8 – Prismic text field configuration</p><p>This will <a id="_idIndexMarker217"/>open the side panel shown to the left of the preceding screenshot. We will use the rich text field as the type for a single hobby. First, let's give it a name – <strong class="bold">hobby</strong> seems appropriate. Ensure that <strong class="bold">API ID</strong> matches the assigned name. Uncheck the <strong class="bold">Allow multiple paragraphs</strong> box and then ensure that only the paragraph object is highlighted. By doing so, we can ensure that our hobbies are always single lines that only consist of <a id="_idIndexMarker218"/>paragraphs. Submit this using the <strong class="bold">OK</strong> button.</p></li>
				<li>Save the document.</li>
				<li>Now that we have defined our type, navigate to the JSON editor and copy its contents. </li>
				<li>Create a new file inside your <strong class="source-inline">schemas</strong> folder called <strong class="source-inline">icebreaker.json</strong> and paste the JSON you have copied.</li>
				<li>Navigate back home and click on <strong class="bold">Documents. </strong>Then click the <em class="italic">pencil icon</em> button to create a new instance of your Icebreaker type:<div id="_idContainer022" class="IMG---Figure"><img src="image/B15983_03_09.jpg" alt="Figure 3.9 – Prismic collection interface&#13;&#10;"/></div><p class="figure-caption">Figure 3.9 – Prismic collection interface</p><p>You can now <a id="_idIndexMarker219"/>use your hobbies type to create your data. Once<a id="_idIndexMarker220"/> you are happy with your list of hobbies, you can hit <strong class="bold">Save</strong>, followed by <strong class="bold">Publish</strong>.</p></li>
				<li>Return home, navigate to <strong class="bold">Settings</strong>, and click on <strong class="bold">API and security</strong>. Ensure that your repository security is set to <strong class="bold">Public API for Master only</strong>:<div id="_idContainer023" class="IMG---Figure"><img src="image/B15983_03_10.jpg" alt="Figure 3.10 – Repository security&#13;&#10;"/></div><p class="figure-caption">Figure 3.10 – Repository security</p><p>This means<a id="_idIndexMarker221"/> that anyone with your API URL can access what is currently live but not preview future releases. Make a note of your API entry point, which should be located at the top of this page. Now, let's look at our Gatsby project and start ingesting data using that URL.</p></li>
				<li>Install the Gatsby<a id="_idIndexMarker222"/> Prismic source plugin:<p class="source-code">npm install gatsby-source-prismic gatsby-plugin-image</p></li>
				<li>Modify your <strong class="source-inline">gatsby-config.js</strong> file:<p class="source-code">module.exports = {</p><p class="source-code">  ...</p><p class="source-code">  plugins: [</p><p class="source-code">   ...</p><p class="source-code">    'gatsby-plugin-image',</p><p class="source-code">    <strong class="bold">{</strong></p><p class="source-code"><strong class="bold">      resolve: 'gatsby-source-prismic',</strong></p><p class="source-code"><strong class="bold">      options: {</strong></p><p class="source-code"><strong class="bold">        repositoryName: 'elevating-gatsby',</strong></p><p class="source-code"><strong class="bold">        schemas: {</strong></p><p class="source-code"><strong class="bold">          icebreaker:</strong></p><p class="source-code"><strong class="bold">            require('./src/schemas/icebreaker.json'),</strong></p><p class="source-code"><strong class="bold">        },</strong></p><p class="source-code"><strong class="bold">      }</strong></p><p class="source-code"><strong class="bold">    },</strong>    </p><p class="source-code">   ...</p><p class="source-code">  ],</p><p class="source-code">};</p><p>Here, you are adding the source plugin for Prismic to your Gatsby configuration. Be sure to change the repository name to that of your site. If you're unsure what your repository's name is, you can find it in your API URL. We are also directing the plugin to use the schema we have created for our icebreaker. The plugin is also dependent on <strong class="source-inline">gatsby-plugin-image</strong>, so make sure it has been added to your configuration.</p></li>
				<li>We can now start our development server and query our data as normal. Upon opening<a id="_idIndexMarker223"/> GraphiQL, you should see <strong class="source-inline">prismicIcebreaker</strong> as a new source that we can use to query for our hobbies:<p class="source-code">query Hobbies {</p><p class="source-code">  prismicIcebreaker {</p><p class="source-code">    data {</p><p class="source-code">      hobbies {</p><p class="source-code">        hobby {</p><p class="source-code">          text</p><p class="source-code">        }</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p>Here, we are retrieving the text value of every hobby from within the <strong class="source-inline">hobbies</strong> object.</p></li>
				<li>We can <a id="_idIndexMarker224"/>now embed this query in our <strong class="source-inline">about</strong> page:<p class="source-code">import React from "react";</p><p class="source-code">import { graphql } from "gatsby";</p><p class="source-code">import Layout from "../components/layout/Layout";</p><p class="source-code">import { MDXRenderer } from "gatsby-plugin-mdx";</p><p class="source-code">export default function About({ data }) {</p><p class="source-code">  const {</p><p class="source-code">    mdx: { body },</p><p class="source-code"><strong class="bold">    prismicIcebreaker: {</strong></p><p class="source-code"><strong class="bold">      data: { hobbies },</strong></p><p class="source-code"><strong class="bold">    },</strong></p><p class="source-code">  } = data;</p><p class="source-code">  return (</p><p class="source-code">    &lt;Layout&gt;</p><p class="source-code">      &lt;div className="max-w-5xl mx-auto py-16 lg:py-24</p><p class="source-code">        text-center"&gt;</p><p class="source-code">        &lt;MDXRenderer&gt;{body}&lt;/MDXRenderer&gt;</p><p class="source-code">        &lt;div&gt;</p><p class="source-code">          &lt;h2&gt;Hobbies&lt;/h2&gt;</p><p class="source-code">         &lt;ul&gt;</p><p class="source-code"><strong class="bold">          {hobbies.map(({ hobby }) =&gt; (</strong></p><p class="source-code"><strong class="bold">            &lt;li&gt;{hobby.text}&lt;/li&gt;</strong></p><p class="source-code"><strong class="bold">          ))}</strong></p><p class="source-code">          &lt;/ul&gt;</p><p class="source-code">        &lt;/div&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/Layout&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p class="source-code">export const query = graphql'</p><p class="source-code">  {</p><p class="source-code">    mdx(frontmatter: { type: { eq: "bio" } }) {</p><p class="source-code">      body</p><p class="source-code">    }</p><p class="source-code">    <strong class="bold">prismicIcebreaker {</strong></p><p class="source-code"><strong class="bold">      data {</strong></p><p class="source-code"><strong class="bold">        hobbies {</strong></p><p class="source-code"><strong class="bold">          hobby {</strong></p><p class="source-code"><strong class="bold">            text</strong></p><p class="source-code"><strong class="bold">          }</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">      }</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">  }</p><p class="source-code">';</p><p>As we did when we looked at GraphCMS, I have just appended the new query to the existing page query. Our data is then passed in as the <strong class="source-inline">data</strong> prop and is available for us to use in whatever way we wish.</p></li>
			</ol>
			<p>You should be starting to see the power of using GraphQL in Gatsby. As soon as we have ingested data, we can use the same format to query it every time. Using these two as examples, you should feel comfortable sourcing data from another CMS using a source plugin.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor071"/>Summary</h1>
			<p>In this chapter, you learned how to use Gatsby's data layer. You learned about the basics of how to explore your GraphQL data layer via GraphiQL and should now feel comfortable sourcing and ingesting data into your Gatsby project from a multitude of different sources – <strong class="source-inline">siteMetadata</strong>, Markdown, MDX, and CMSes using their plugins. If you are interested in how source plugins are created and how to make your own, check out <a href="B15983_10_ePub_RK.xhtml#_idTextAnchor141"><em class="italic">Chapter 10</em></a>, <em class="italic">Creating Gatsby Plugins</em>.</p>
			<p>In the next chapter, we will create and use reusable templates for pages that appear more than once, such as blog pages. This is great for when you have multiple pieces of data that you want to make use of while using the same layout.</p>
		</div>
	</body></html>