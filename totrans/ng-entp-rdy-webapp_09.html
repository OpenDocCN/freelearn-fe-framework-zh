<html><head></head><body>
  <div id="_idContainer503">
    <h1 class="chapterNumber">9</h1>
    <h1 class="chapterTitle" id="_idParaDest-314">DevOps Using Docker</h1>
    <p class="normal">By the end of <em class="italics">Chapter 8</em>, <em class="italics">Designing Authentication and Authorization</em>, we had a fairly sophisticated app. In <em class="italics">Chapter 4</em>, <em class="italics">Automated Testing, CI, and Release to Production</em>, I emphasized the need to ensure that every code push we create has passing tests, adheres to the coding standards, and is an executable artifact that team members can run tests against as we develop our application. By the end of <em class="italics">Chapter 7</em>, <em class="italics">Creating a Router-First Line-of-Business App</em>, you should have replicated the same CircleCI setup we implemented for the Local Weather app for LemonMart. If not, before we start building more complicated <a id="_idIndexMarker893"/>features for our <strong class="bold">Line-of-Business</strong> (<strong class="bold">LOB</strong>) app, go ahead and do this.</p>
    <p class="normal">We live in an era of moving fast and breaking things. However, the latter part of that statement rarely works in an enterprise. You can choose to live on the edge and adopt the YOLO lifestyle, but this doesn't make good business sense.</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_01.png"/></figure>
    <p class="packt_figref">Figure 9.1: A creative CLI option for a tool</p>
    <p class="normal"><strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) is critical <a id="_idIndexMarker894"/>to ensuring a quality deliverable by building and executing tests on every code push. Setting up a CI environment can be time-consuming and requires specialized knowledge of the tool being used. In <em class="italics">Chapter 4</em>, <em class="italics">Automated Testing, CI, and Release to Production</em>, we implemented GitHub flow with CircleCI integration. However, we manually deployed our app. To move <a id="_idIndexMarker895"/>fast without breaking things, we need to implement <strong class="bold">Continuous Deployment</strong> (<strong class="bold">CD</strong>) using DevOps best practices such as <strong class="bold">Infrastructure-as-Code</strong> (<strong class="bold">IaC</strong>), so we <a id="_idIndexMarker896"/>can verify the correctness of our running code more often.</p>
    <p class="normal">In this chapter, we will go over a Docker-based approach to implement IaC that can be run on most CI services and cloud providers, allowing you to achieve repeatable builds and deployments from any CI environment to any cloud provider. Working with flexible tools, you will avoid overspecializing in one service and keep your configuration management skills relevant across different CI services.</p>
    <div class="packt_tip">
      <p>This book leverages CircleCI as the CI server. Other notable CI servers are Jenkins, Azure DevOps, and the built-in mechanisms within GitLab and GitHub.</p>
    </div>
    <p class="normal">In this chapter, you will learn the following:</p>
    <ul>
      <li class="list">DevOps and IaC</li>
      <li class="list">Containerizing web apps using Docker</li>
      <li class="list">Deploying containerized apps using Google Cloud Run</li>
      <li class="list">CD to multiple cloud providers</li>
      <li class="list">Advanced CI</li>
      <li class="list">Code coverage reports</li>
    </ul>
    <p class="normal">The following software is required to follow along with this chapter:</p>
    <ul>
      <li class="list">Docker Desktop Community version 2+</li>
      <li class="list">Docker Engine CE version 18+</li>
      <li class="list">A Google Cloud Engine account</li>
      <li class="list">A Coveralls account</li>
    </ul>
    <p class="normal">The most up-to-date versions of the sample code for the book are on GitHub at the repository linked in the following list. The repository contains the final and completed version of the code. Each section contains information boxes to help direct you to the correct filename or branch on GitHub so that you can use them to verify your progress.</p>
    <p class="normal">For the <em class="italics">Chapter 9</em> examples <a id="_idIndexMarker897"/>based on <strong class="bold">local-weather-app</strong>, do the following:</p>
    <ol>
      <li class="list">Clone the repo at <a href="https://github.com/duluca/local-weather-app"><span class="url">https://github.com/duluca/local-weather-app</span></a>.</li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">npm install</code> on the root folder to install dependencies.</li>
      <li class="list">Use <code class="Code-In-Text--PACKT-">.circleci/config.ch9.yml</code> to verify your <code class="Code-In-Text--PACKT-">config.yml</code> implementation.</li>
      <li class="list">To run the CircleCI Vercel Now configuration, execute
        <pre class="programlisting"><code class="hljs ebnf"><span class="hljs-attribute">git checkout deploy_Vercelnow</span>
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Refer to the pull request at <a href="https://github.com/duluca/local-weather-app/pull/50"><span class="url">https://github.com/duluca/local-weather-app/pull/50</span></a>.</p>
      </li>
      <li class="list" value="5">To run <a id="_idIndexMarker898"/>the CircleCI GCloud configuration, execute
        <pre class="programlisting"><code class="hljs ebnf"><span class="hljs-attribute">git checkout deploy_cloudrun</span>
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet-End--PACKT-">Refer to the pull request at <a href="https://github.com/duluca/local-weather-app/pull/51"><span class="url">https://github.com/duluca/local-weather-app/pull/51</span></a>.</p>
      </li>
    </ol>
    <div class="packt_tip">
      <p>Note that both <a id="_idIndexMarker899"/>branches leverage modified code to use the <code class="Code-In-Text--PACKT-">projects/ch6</code> code from the <strong class="bold">local-weather-app</strong> repo.</p>
    </div>
    <p class="normal">For the <em class="italics">Chapter 9</em> examples <a id="_idIndexMarker900"/>based on <strong class="bold">lemon-mart</strong>, do the following:</p>
    <ol>
      <li class="list" value="1">Clone <a id="_idIndexMarker901"/>the repo at <a href="https://github.com/duluca/lemon-mart"><span class="url">https://github.com/duluca/lemon-mart</span></a>.</li>
      <li class="list">Use <code class="Code-In-Text--PACKT-">.circleci/config.ch9.yml</code> and <code class="Code-In-Text--PACKT-">config.docker-integration.yml</code> to verify your <code class="Code-In-Text--PACKT-">config.yml</code> implementation.</li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">npm install</code> on the root folder to install dependencies.</li>
      <li class="list" value="4">To run the CircleCI Docker integration configuration, execute
        <pre class="programlisting"><code class="hljs angelscript">git checkout docker-<span class="hljs-built_in">int</span>egration
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet-End--PACKT-">Refer to the pull request at <a href="https://github.com/duluca/lemon-mart/pull/25"><span class="url">https://github.com/duluca/lemon-mart/pull/25</span></a>.</p>
      </li>
    </ol>
    <div class="packt_tip">
      <p>Note that the <code class="Code-In-Text--PACKT-">docker-integration</code> branch is slightly modified to use code from the <code class="Code-In-Text--PACKT-">projects/ch8</code> folder <a id="_idIndexMarker902"/>on the <strong class="bold">lemon-mart</strong> repo.</p>
    </div>
    <div class="note">
      <p class="Information-Box--PACKT-">Beware that there may be slight differences in implementation between the code in the book and what's on GitHub because the ecosystem is ever-evolving. It is natural for the sample code to change over time. Also, on GitHub, expect to find corrections, fixes to support newer versions of libraries, or side-by-side implementations of multiple techniques for the reader to observe. The reader is only expected to implement the ideal solution recommended in the book. If you find errors or have questions, please create an issue or submit a pull request on GitHub for the benefit of all readers.</p>
    </div>
    <div class="packt_tip">
      <p>You can read more about updating Angular in <em class="italics">Appendix C</em>, <em class="italics">Keeping Angular and Tools Evergreen</em>. You can find this appendix online from <a href="https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen."><span class="url">https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf</span></a> or at <a href="https://expertlysimple.io/stay-evergreen"><span class="url">https://expertlysimple.io/stay-evergreen</span></a>.</p>
    </div>
    <p class="normal">Let's start by understanding what DevOps is.</p>
    <h1 class="title" id="_idParaDest-315">DevOps</h1>
    <p class="normal">DevOps is the marriage of development and operations. In development, it is well established <a id="_idIndexMarker903"/>that code repositories like Git track every code change. In operations, there has long been a wide variety of techniques to track changes to environments, including scripts and various tools that aim to automate the provisioning of operating systems and servers.</p>
    <p class="normal">Still, how many times have you heard the saying, "it works on my machine"? Developers often use that line as a joke. Still, it is often the case that software that works perfectly well on a test server ends up running into issues on a production server due to minor differences in configuration.</p>
    <p class="normal">In <em class="italics">Chapter 4</em>, <em class="italics">Automated Testing, CI, and Release to Production</em>, we discussed how GitHub flow can enable us to create a value delivery stream. We always branch from the master before making a change. Enforce that change to go through our CI pipeline, and once we're reasonably sure that our code works, we can merge back to the master branch. See the following diagram:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_02.png"/></figure>
    <p class="packt_figref">Figure 9.2: Branching and merging</p>
    <div class="packt_tip">
      <p>Remember, your master branch should always be deployable, and you should frequently merge your work to the master branch.</p>
    </div>
    <p class="normal">Docker allows us to define the software and the specific configuration parameters that our code depends on in a declarative manner using a special file named a <code class="Code-In-Text--PACKT-">Dockerfile</code>. Similarly, CircleCI allows <a id="_idIndexMarker904"/>us to define the configuration of our CI environment in a <code class="Code-In-Text--PACKT-">config.yml</code> file. By storing our configuration in files, we are able to check the files in alongside our code. We can track changes using Git and enforce them to be verified by our CI pipeline. By storing the definition of our infrastructure in code, we achieve IaC. With IaC, we also achieve repeatable integration, so no matter what environment we run our infrastructure in, we should be able to stand up our full-stack app with a one-line command.</p>
    <p class="normal">You may remember that in <em class="italics">Chapter 1</em>, <em class="italics">Introduction to Angular and Its Concepts</em>, we covered how TypeScript covers the JavaScript Feature Gap. Similar to TypeSript, Docker covers the configuration gap, as demonstrated in the following diagram:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_03.png"/></figure>
    <p class="packt_figref">Figure 9.3: Covering the configuration gap</p>
    <p class="normal">By using Docker, we can be reasonably sure that our code, which worked on our machine during testing, will work exactly the same way when we ship it.</p>
    <p class="normal">In summary, with DevOps, we bring operations closer to development, where it is cheaper to make changes and resolve issues. So, DevOps is primarily a developer's responsibility, but it is also a way of thinking that the operations team must be willing to support. Let's <a id="_idIndexMarker905"/>dive deeper into Docker.</p>
    <h1 class="title" id="_idParaDest-316">Containerizing web apps using Docker</h1>
    <p class="normal">Docker, which <a id="_idIndexMarker906"/>can be found at <a href="https://docker.io"><span class="url">https://docker.io</span></a>, is an open platform for developing, shipping, and running applications. Docker combines a lightweight <a id="_idIndexMarker907"/>container virtualization platform <a id="_idIndexMarker908"/>with workflows and tooling that help manage and deploy applications. The most obvious difference between <strong class="bold">Virtual Machines</strong> (<strong class="bold">VMs</strong>) and <a id="_idIndexMarker909"/>Docker containers is that VMs are usually dozens of gigabytes in size and require gigabytes of memory, whereas containers take up megabytes in terms of disk and memory <a id="_idIndexMarker910"/>size requirements. Furthermore, the Docker platform abstracts away host <strong class="bold">operating system</strong> (<strong class="bold">OS</strong>) - level configuration settings, so every piece of configuration that is needed to successfully run an application is encoded within a human-readable format.</p>
    <h2 class="title" id="_idParaDest-317">Anatomy of a Dockerfile</h2>
    <p class="normal">A <code class="Code-In-Text--PACKT-">Dockerfile</code> consists <a id="_idIndexMarker911"/>of four main parts:</p>
    <ul>
      <li class="list"><strong class="bold">FROM</strong> – where <a id="_idIndexMarker912"/>we can inherit from Docker's minimal "scratch" image or a pre-existing image</li>
      <li class="list"><strong class="bold">SETUP</strong> – where <a id="_idIndexMarker913"/>we configure software dependencies to our requirements</li>
      <li class="list"><strong class="bold">COPY</strong> – where <a id="_idIndexMarker914"/>we copy our built code into the operating environment</li>
      <li class="list"><strong class="bold">CMD</strong> – where <a id="_idIndexMarker915"/>we specify the commands that will bootstrap the operating environment</li>
    </ul>
    <div class="packt_tip">
      <p>Bootstrap refers to a set of initial instructions that describe how a program loads or starts up.</p>
    </div>
    <p class="normal">Consider the following visualization of the anatomy of a <code class="Code-In-Text--PACKT-">Dockerfile</code>:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_04.png"/></figure>
    <p class="packt_figref">Figure 9.4: Anatomy of a Dockerfile</p>
    <p class="normal">A concrete <a id="_idIndexMarker916"/>representation of a <code class="Code-In-Text--PACKT-">Dockerfile</code> is demonstrated in the following code:</p>
    <pre class="programlisting"><code class="hljs dockerfile"><strong>Dockerfile</strong>
<span class="hljs-keyword">FROM</span> duluca/minimal-nginx-web-server:<span class="hljs-number">1</span>-alpine
<span class="hljs-keyword">COPY</span><span class="bash"> /dist/<span class="hljs-built_in">local</span>-weather-app /var/www</span>
<span class="hljs-keyword">CMD</span><span class="bash"> <span class="hljs-string">'nginx'</span></span>
</code></pre>
    <p class="normal">You can map the <code class="Code-In-Text--PACKT-">FROM</code>, <code class="Code-In-Text--PACKT-">COPY</code>, and <code class="Code-In-Text--PACKT-">CMD</code> parts of the script to the visualization. We inherit from the <code class="Code-In-Text--PACKT-">duluca/minimal-nginx-web-server</code> image using the <code class="Code-In-Text--PACKT-">FROM</code> command. Then, we copy the compiled result of our app from our development machine or build environment into the image using the <code class="Code-In-Text--PACKT-">COPY</code> (or, alternatively, the <code class="Code-In-Text--PACKT-">ADD</code>) command. Finally, we instruct the container to execute the nginx web server using the <code class="Code-In-Text--PACKT-">CMD</code> (or, alternatively, the <code class="Code-In-Text--PACKT-">ENTRYPOINT</code>) command.</p>
    <p class="normal">Note that the preceding <code class="Code-In-Text--PACKT-">Dockerfile</code> doesn't have a distinct <code class="Code-In-Text--PACKT-">SETUP</code> part. <code class="Code-In-Text--PACKT-">SETUP</code> doesn't map to an actual <code class="Code-In-Text--PACKT-">Dockerfile</code> command but represents a collection of commands you can execute to set up your container. In this case, all the necessary setup was done by the base image, so there are no additional commands to run.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Common <code class="Code-In-Text--PACKT-">Dockerfile</code> commands are <code class="Code-In-Text--PACKT-">FROM</code>, <code class="Code-In-Text--PACKT-">COPY</code>, <code class="Code-In-Text--PACKT-">ADD</code>, <code class="Code-In-Text--PACKT-">RUN</code>, <code class="Code-In-Text--PACKT-">CMD</code>, <code class="Code-In-Text--PACKT-">ENTRYPOINT</code>, <code class="Code-In-Text--PACKT-">ENV</code>, and <code class="Code-In-Text--PACKT-">EXPOSE</code>. For the full <code class="Code-In-Text--PACKT-">Dockerfile</code> reference, refer to <a href="https://docs.docker.com/engine/reference/builder/"><span class="url">https://docs.docker.com/engine/reference/builder/</span></a>.</p>
    </div>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Dockerfile</code> describes a <a id="_idIndexMarker917"/>new container that inherits from a container named <code class="Code-In-Text--PACKT-">duluca/minimal-nginx-web-server</code>. This is a container that I published on Docker Hub, which inherits from the <code class="Code-In-Text--PACKT-">nginx:alpine</code> image, which itself inherits from the <code class="Code-In-Text--PACKT-">alpine</code> image. The <code class="Code-In-Text--PACKT-">alpine</code> image is a minimal Linux operating <a id="_idIndexMarker918"/>environment that is only 5 MB in size. The <code class="Code-In-Text--PACKT-">alpine</code> image itself inherits from <code class="Code-In-Text--PACKT-">scratch</code>, which is an empty image. See the inheritance hierarchy demonstrated in the following diagram:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_05.png"/></figure>
    <p class="packt_figref">Figure 9.5: Docker inheritance</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Dockerfile</code> then copies the contents of the <code class="Code-In-Text--PACKT-">dist</code> folder from your development environment into the container's <code class="Code-In-Text--PACKT-">www</code> folder, as shown in the following diagram:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_06.png"/></figure>
    <p class="packt_figref">Figure 9.6: Copying code into a containerized web server</p>
    <p class="normal">In this case, the parent <a id="_idIndexMarker919"/>image is configured with an nginx server to act as a web server to serve the content inside the <code class="Code-In-Text--PACKT-">www</code> folder. At this point, our source code is accessible from the internet but lives inside layers of secure environments. Even if our app has a vulnerability of some kind, it would be tough for an attacker to harm the systems we are operating on. The following diagram demonstrates the layers of security that Docker provides:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_07.png"/></figure>
    <p class="packt_figref">Figure 9.7: Docker security</p>
    <p class="normal">In summary, at the base layer we have our host OS, such as Windows or macOS, that runs the Docker runtime, which will be installed in the next section. The Docker runtime is capable of <a id="_idIndexMarker920"/>running self-contained Docker images, which are defined by the aforementioned <code class="Code-In-Text--PACKT-">Dockerfile</code>. <code class="Code-In-Text--PACKT-">duluca/minimal-nginx-web-server</code> is based on the lightweight Linux operating system, Alpine. Alpine is a completely pared-down version of Linux that doesn't come with any GUI, drivers, or even most of the sCLI tools you may expect from a Linux system. As a result, the OS is around only ~5 MB in size. We then inherit from the nginx image, which installs the web server, which itself is around a few megabytes in size. Finally, our custom nginx configuration is layered over the default image, resulting in a tiny ~7 MB image. The nginx server is configured to serve the contents of the <code class="Code-In-Text--PACKT-">/var/www</code> folder. In the <code class="Code-In-Text--PACKT-">Dockerfile</code>, we merely copy the contents of the <code class="Code-In-Text--PACKT-">/dist</code> folder in our development environment and place it into the <code class="Code-In-Text--PACKT-">/var/www</code> folder. We will later build and execute this image, which will run our Nginx web server containing the output of our <code class="Code-In-Text--PACKT-">dist</code> folder. I have published a similar image named <code class="Code-In-Text--PACKT-">duluca/minimal-node-web-server</code>, which clocks in at ~15 MB.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">duluca/minimal-node-web-server</code> can be more straightforward to work with, especially if you're not familiar with Nginx. It relies on an <code class="Code-In-Text--PACKT-">Express.js</code> server to serve static content. Most cloud providers provide concrete examples using Node and Express, which can help you narrow down any errors. In addition, <code class="Code-In-Text--PACKT-">duluca/minimal-node-web-server</code> has HTTPS redirection support baked into it. You can spend a lot of time trying to set up a nginx proxy to do the same thing, when all you need to do is set the environment variable <code class="Code-In-Text--PACKT-">ENFORCE_HTTPS</code> in your <code class="Code-In-Text--PACKT-">Dockerfile</code>. See the following sample Dockerfile:</p>
    <pre class="programlisting"><code class="hljs dockerfile"><strong>Dockerfile</strong>
<span class="hljs-keyword">FROM</span> duluca/minimal-node-web-server:lts-alpine
<span class="hljs-keyword">WORKDIR</span><span class="bash"> /usr/src/app</span>
<span class="hljs-keyword">COPY</span><span class="bash"> dist/<span class="hljs-built_in">local</span>-weather-app public</span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"start"</span> ]</span>
<span class="hljs-keyword">ENV</span> ENFORCE_HTTPS=xProto
</code></pre>
    <div class="note">
      <p class="Information-Box--PACKT-">You can read <a id="_idIndexMarker921"/>more about the options <code class="Code-In-Text--PACKT-">minimal-node-web-server</code> provides at <a href="https://github.com/duluca/minimal-node-web-server"><span class="url">https://github.com/duluca/minimal-node-web-server</span></a>.</p>
    </div>
    <p class="normal">As we've <a id="_idIndexMarker922"/>now seen, the beauty of Docker is that you can navigate to <a href="https://hub.docker.com"><span class="url">https://hub.docker.com</span></a>, search for <code class="Code-In-Text--PACKT-">duluca/minimal-nginx-web-server</code> or <code class="Code-In-Text--PACKT-">duluca/minimal-node-web-server</code>, read its <code class="Code-In-Text--PACKT-">Dockerfile</code>, and trace its origins all the way back to the original base image that is the foundation of the web server. I encourage you to vet every Docker image you use in this manner to understand what exactly it brings to the table for your needs. You may find it either overkill, or that it has features you never knew about that can make your life a lot easier.</p>
    <p class="normal">Note that the <a id="_idIndexMarker923"/>parent images should pull a specific tag of <code class="Code-In-Text--PACKT-">duluca/minimal-nginx-web-server</code>, which is <code class="Code-In-Text--PACKT-">1-alpine</code>. Similarly, <code class="Code-In-Text--PACKT-">duluca/minimal-node-web-server</code> pulls from <code class="Code-In-Text--PACKT-">lts-alpine</code>. These are evergreen base packages that always contain the latest release of version 1 of Nginx and Alpine or an LTS release of Node. I have pipelines set up to automatically update both images when a new base image is published. So, whenever you pull these images, you will get the latest bug fixes and security patches.</p>
    <p class="normal">Having an evergreen dependency tree removes the burden on you as the developer to go hunting down the latest available version of a Docker image. Alternatively, if you specify a version number, your images will not be subject to any potential breaking changes. However, it is better to remember to test your images after a new build, than never update your image and potentially deploy compromised software. After all, the web is ever-changing and will not slow down for you to keep your images up to date.</p>
    <p class="normal">Just like npm packages, Docker can bring great convenience and value, but you must take care to <a id="_idIndexMarker924"/>understand the tools you are working with.</p>
    <p class="normal">In <em class="italics">Chapter 13</em>, <em class="italics">Highly Available Cloud Infrastructure on AWS</em>, we are going to leverage the lower-footprint Docker image based on Nginx, <code class="Code-In-Text--PACKT-">duluca/minimal-nginx-web-server</code>. If you're comfortable configuring nginx, this is the ideal choice.</p>
    <h2 class="title" id="_idParaDest-318">Installing Docker</h2>
    <p class="normal">In order to <a id="_idIndexMarker925"/>be able to build and run containers, you must first install the Docker execution environment on your computer. Refer back to <em class="italics">Chapter 2</em>, <em class="italics">Setting Up Your Development Environment</em>, for instructions on installing Docker.</p>
    <h2 class="title" id="_idParaDest-319">Setting up npm scripts for Docker</h2>
    <p class="normal">Now, let's configure some Docker scripts for your Angular apps that you can use to automate <a id="_idIndexMarker926"/>the building, testing, and publishing of your container. I have <a id="_idIndexMarker927"/>developed a set of scripts called <strong class="bold">npm scripts for Docker</strong> that work on Windows 10 and macOS. You can get the latest version of these scripts and automatically configure them in your project by executing the following code:</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Run the <a id="_idIndexMarker928"/>following <a id="_idIndexMarker929"/>commands on both the <strong class="bold">local-weather-app</strong> and <strong class="bold">lemon-mart</strong> projects now!</p>
    </div>
    <ol>
      <li class="list" value="1">Install the npm scripts for Docker task:
        <pre class="programlisting"><code class="hljs coffeescript">$ <span class="hljs-built_in">npm</span> i -g mrm-task-<span class="hljs-built_in">npm</span>-docker
</code></pre>
      </li>
      <li class="list" value="2">Apply the npm scripts for Docker configuration:
        <pre class="programlisting"><code class="hljs coffeescript">$ npx mrm <span class="hljs-built_in">npm</span>-docker
</code></pre>
      </li>
    </ol>
    <p class="normal">After you execute the <code class="Code-In-Text--PACKT-">mrm</code> scripts, we're ready to take a deep dive into the configuration settings using the Local Weather app as an example.</p>
    <h2 class="title" id="_idParaDest-320">Build and publish an image to Docker Hub</h2>
    <p class="normal">Next, let's <a id="_idIndexMarker930"/>make sure that <a id="_idIndexMarker931"/>your project <a id="_idIndexMarker932"/>is configured correctly so we <a id="_idIndexMarker933"/>can containerize it, build an executable image, and publish it to Docker Hub, thereby allowing us to access it from any build environment. We will <a id="_idIndexMarker934"/>be using the Local Weather app for this section that we last updated in <em class="italics">Chapter 6</em>, <em class="italics">Forms, Observables, and Subjects</em>:</p>
    <div class="note">
      <p class="Information-Box--PACKT-">This section uses the <strong class="bold">local-weather-app</strong> repo.</p>
    </div>
    <ol>
      <li class="list" value="1">Sign <a id="_idIndexMarker935"/>up for a Docker Hub account on <a href="https://hub.docker.com/"><span class="url">https://hub.docker.com/</span></a>.</li>
      <li class="list">Create a public (free) repository for your application.<div class="packt_tip">
          <p>Later in this chapter, we use Google Cloud's container registry as a private repository. Additionally, in <em class="italics">Chapter 13</em>, <em class="italics">Highly Available Cloud Infrastructure on AWS</em>, I cover how <a id="_idIndexMarker936"/>to set up a private container repository using <strong class="bold">AWS Elastic Container Service</strong> (<strong class="bold">AWS ECS</strong>).</p>
        </div>
      </li>
      <li class="list">In <code class="Code-In-Text--PACKT-">package.json</code>, add <a id="_idIndexMarker937"/>or update the <code class="Code-In-Text--PACKT-">config</code> property <a id="_idIndexMarker938"/>with the following configuration properties:
        <pre class="programlisting"><code class="hljs erlang"><strong>package.json</strong>
  ...
  <span class="hljs-string">"config"</span>: {
    <span class="hljs-string">"imageRepo"</span>: <span class="hljs-string">"[namespace]/[repository]"</span>,
    <span class="hljs-string">"imageName"</span>: <span class="hljs-string">"custom_app_name"</span>,
    <span class="hljs-string">"imagePort"</span>: <span class="hljs-string">"0000"</span>,
    <span class="hljs-string">"internalContainerPort"</span>: <span class="hljs-string">"3000"</span>
  },
  ...
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The <code class="Code-In-Text--PACKT-">namespace</code> will be your Docker Hub username. You will define what your repository will be called during creation. An example image <code class="Code-In-Text--PACKT-">repository</code> variable should look like <code class="Code-In-Text--PACKT-">duluca/localcast-weather</code>. The image name is for easy identification of your container while using Docker commands such as <code class="Code-In-Text--PACKT-">docker ps</code>. I will just call mine <code class="Code-In-Text--PACKT-">localcast-weather</code>. The <code class="Code-In-Text--PACKT-">imagePort</code> property will define which port should be used to expose your application from inside the container. Since we use port <code class="Code-In-Text--PACKT-">5000</code> for development, pick a different one, like <code class="Code-In-Text--PACKT-">8080</code>. The <code class="Code-In-Text--PACKT-">internalContainerPort</code> defines the port that your web server is mapped to. For Node servers, this will mostly be port <code class="Code-In-Text--PACKT-">3000</code>, and for Nginx servers, <code class="Code-In-Text--PACKT-">80</code>. Refer to the documentation of the base container you're using.</p>
      </li>
      <li class="list">Let's review <a id="_idIndexMarker939"/>the Docker scripts that were added <a id="_idIndexMarker940"/>to <code class="Code-In-Text--PACKT-">package.json</code> by the <code class="Code-In-Text--PACKT-">mrm</code> task from earlier. The <a id="_idIndexMarker941"/>following snippet is <a id="_idIndexMarker942"/>an annotated version of the scripts that explains each function.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note that with npm scripts, the <code class="Code-In-Text--PACKT-">pre</code> and <code class="Code-In-Text--PACKT-">post</code> keywords are used to execute helper scripts, respectively, before or after the execution of a given script. Scripts are intentionally broken into smaller pieces to make it easier to read and maintain them.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The <code class="Code-In-Text--PACKT-">build</code> script is as follows:</p>
        <div class="packt_tip">
          <p>Note that the following <code class="Code-In-Text--PACKT-">cross-conf-env</code> command ensures that the script executes equally well in macOS, Linux, and Windows environments.</p>
        </div>
        <pre class="programlisting"><code class="hljs routeros"><strong>package.json</strong>
<span class="hljs-built_in">..</span>.
  <span class="hljs-string">"scripts"</span>: {
    <span class="hljs-built_in">..</span>.
    <span class="hljs-string">"predocker:build"</span>: <span class="hljs-string">"npm run build"</span>,
    <span class="hljs-string">"docker:build"</span>: <span class="hljs-string">"cross-conf-env docker image build . -t <span class="hljs-variable">$npm_package_config_imageRepo</span>:<span class="hljs-variable">$npm_package_version</span>"</span>,
    <span class="hljs-string">"postdocker:build"</span>: <span class="hljs-string">"npm run docker:tag"</span>,
    <span class="hljs-built_in">..</span>.
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">npm run docker:build</code> will build your Angular application in the <code class="Code-In-Text--PACKT-">pre</code> script, then build the Docker image using the <code class="Code-In-Text--PACKT-">docker image build</code> command, and tag the image with a version number in the <code class="Code-In-Text--PACKT-">post</code> script:</p>
        <div class="packt_tip">
          <p>In my project, the <code class="Code-In-Text--PACKT-">pre</code> command builds my Angular application in prod mode and also runs a test to make sure that I have an optimized build with no failing tests. </p>
          <p>My pre command looks like:</p>
          <p><code class="Code-In-Text--PACKT-">"predocker:build":</code> <code class="Code-In-Text--PACKT-">"npm run build:prod &amp;&amp; npm test -- --watch=false"</code></p>
        </div>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The <code class="Code-In-Text--PACKT-">tag</code> script is as follows:</p>
        <pre class="programlisting"><code class="hljs routeros"><strong>package.json</strong>
    <span class="hljs-built_in">..</span>.
    <span class="hljs-string">"docker:tag"</span>: <span class="hljs-string">" cross-conf-env docker image tag <span class="hljs-variable">$npm_package_config_imageRepo</span>:<span class="hljs-variable">$npm_package_version</span> <span class="hljs-variable">$npm_package_config_imageRepo</span>:latest"</span>,
    <span class="hljs-built_in">..</span>.
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">npm run docker:tag</code> will tag an already built Docker image using the version number from the <code class="Code-In-Text--PACKT-">version</code> property in <code class="Code-In-Text--PACKT-">package.json</code> and the latest tag.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The <code class="Code-In-Text--PACKT-">stop</code> script is as follows:</p>
        <pre class="programlisting"><code class="hljs routeros"><strong>package.json</strong>
    <span class="hljs-built_in">..</span>.
    <span class="hljs-string">"docker:stop"</span>: <span class="hljs-string">"cross-conf-env docker stop <span class="hljs-variable">$npm_package_config_imageName</span> || true"</span>,
    <span class="hljs-built_in">..</span>.
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">npm run docker:stop</code> will stop the image if it's currently running, so the <code class="Code-In-Text--PACKT-">run</code> script <a id="_idIndexMarker943"/>can execute without <a id="_idIndexMarker944"/>errors.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The <code class="Code-In-Text--PACKT-">run</code> script is as follows:</p>
        <div class="packt_tip">
          <p>Note <a id="_idIndexMarker945"/>that the <code class="Code-In-Text--PACKT-">run-s</code> and <code class="Code-In-Text--PACKT-">run-p</code> commands <a id="_idIndexMarker946"/>ship with the <code class="Code-In-Text--PACKT-">npm-run-all</code> package to synchronize or parallelize the execution of npm scripts.</p>
        </div>
        <pre class="programlisting"><code class="hljs routeros"><strong>package.json</strong>
    <span class="hljs-built_in">..</span>.
    <span class="hljs-string">"docker:run"</span>: <span class="hljs-string">"run-s -c docker:stop docker:runHelper"</span>,
    <span class="hljs-string">"docker:runHelper"</span>: <span class="hljs-string">"cross-conf-env docker run -e NODE_ENV=local --rm --name <span class="hljs-variable">$npm_package_config_imageName</span> -d -p <span class="hljs-variable">$npm_package_config_imagePort</span>:<span class="hljs-variable">$npm_package_config_internalContainerPort</span> <span class="hljs-variable">$npm_package_config_imageRepo</span>"</span>,
    <span class="hljs-built_in">..</span>.
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">npm run docker:run</code> will stop if the image is already running, and then run the newly built version of the image using the <code class="Code-In-Text--PACKT-">docker run</code> command. Note that the <code class="Code-In-Text--PACKT-">imagePort</code> property is used as the external port of the Docker image, which is mapped to the internal port of the image that the Node.js server listens to, port <code class="Code-In-Text--PACKT-">3000</code>.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The <code class="Code-In-Text--PACKT-">publish</code> script is as follows:</p>
        <pre class="programlisting"><code class="hljs routeros"><strong>package.json</strong>
    <span class="hljs-built_in">..</span>.
    <span class="hljs-string">"predocker:publish"</span>: <span class="hljs-string">"echo Attention! Ensure `docker login` is correct."</span>,
    <span class="hljs-string">"docker:publish"</span>: <span class="hljs-string">"cross-conf-env docker image push <span class="hljs-variable">$npm_package_config_imageRepo</span>:<span class="hljs-variable">$npm_package_version</span>"</span>,
    <span class="hljs-string">"postdocker:publish"</span>: <span class="hljs-string">"cross-conf-env docker image push <span class="hljs-variable">$npm_package_config_imageRepo</span>:latest"</span>,
    <span class="hljs-built_in">..</span>.
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">npm run docker:publish</code> will publish a built image to the configured repository, in this case, Docker Hub, using the <code class="Code-In-Text--PACKT-">docker image push</code> command. </p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">First, the <a id="_idIndexMarker947"/>versioned image is published, followed <a id="_idIndexMarker948"/>by one tagged with <code class="Code-In-Text--PACKT-">latest</code> in post. The <code class="Code-In-Text--PACKT-">taillogs</code> script is as follows:</p>
        <pre class="programlisting"><code class="hljs routeros"><strong>package.json</strong>
    <span class="hljs-built_in">..</span>.
    <span class="hljs-string">"docker:taillogs"</span>: <span class="hljs-string">"cross-conf-env docker logs -f <span class="hljs-variable">$npm_package_config_imageName</span>"</span>,
    <span class="hljs-built_in">..</span>.
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">npm run docker:taillogs</code> will display the internal console logs of a running Docker instance using the <code class="Code-In-Text--PACKT-">docker log -f</code> command, a very useful tool <a id="_idIndexMarker949"/>when debugging your Docker instance.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The <code class="Code-In-Text--PACKT-">open</code> script is <a id="_idIndexMarker950"/>as follows:</p>
        <pre class="programlisting"><code class="hljs routeros"><strong>package.json</strong>
    <span class="hljs-built_in">..</span>.
    <span class="hljs-string">"docker:open"</span>: <span class="hljs-string">"sleep 2 &amp;&amp; cross-conf-env open-cli http://localhost:<span class="hljs-variable">$npm_package_config_imagePort</span>"</span>,
    <span class="hljs-built_in">..</span>.
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">npm run docker:open</code> will wait for 2 seconds and then launch the browser with the correct URL for your application using the <code class="Code-In-Text--PACKT-">imagePort</code> property.</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The <code class="Code-In-Text--PACKT-">debug</code> script is as follows:</p>
        <pre class="programlisting"><code class="hljs css"><strong><span class="hljs-selector-tag">package</span><span class="hljs-selector-class">.json</span></strong>
    ...
    "<span class="hljs-selector-tag">predocker</span><span class="hljs-selector-pseudo">:debug"</span>: "<span class="hljs-selector-tag">run-s</span> <span class="hljs-selector-tag">docker</span><span class="hljs-selector-pseudo">:build</span> <span class="hljs-selector-tag">docker</span><span class="hljs-selector-pseudo">:run"</span>,
    "<span class="hljs-selector-tag">docker</span><span class="hljs-selector-pseudo">:debug"</span>: "<span class="hljs-selector-tag">run-s</span> <span class="hljs-selector-tag">-cs</span> <span class="hljs-selector-tag">docker</span><span class="hljs-selector-pseudo">:open</span><span class="hljs-selector-pseudo">:win</span> <span class="hljs-selector-tag">docker</span><span class="hljs-selector-pseudo">:open</span><span class="hljs-selector-pseudo">:mac</span> <span class="hljs-selector-tag">docker</span><span class="hljs-selector-pseudo">:taillogs"</span>
  },
...
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">npm run docker:debug</code> will build your image and run an instance of it in <code class="Code-In-Text--PACKT-">pre</code>, open the browser, and then start displaying the internal logs of the container.</p>
      </li>
      <li class="list">Customize <a id="_idIndexMarker951"/>the pre-build script to build <a id="_idIndexMarker952"/>your angular app in production mode <a id="_idIndexMarker953"/>and execute unit tests before building <a id="_idIndexMarker954"/>the image:
        <pre class="programlisting"><code class="hljs ada"><strong><span class="hljs-keyword">package</span>.json</strong>
    <span class="hljs-string">"build"</span>: <span class="hljs-string">"ng build"</span>,
    <span class="hljs-string">"build:prod"</span>: <span class="hljs-string">"ng build --prod"</span>,
    <span class="hljs-string">"predocker:build"</span>: <span class="hljs-string">"npm run build:prod &amp;&amp; npm test -- --watch=false"</span>,
</code></pre>
        <div class="packt_tip">
          <p>Note that <code class="Code-In-Text--PACKT-">ng build</code> is provided with the <code class="Code-In-Text--PACKT-">--prod</code> argument, which achieves two things: the size <a id="_idIndexMarker955"/>of the app is optimized to be significantly smaller with <strong class="bold">Ahead-of-Time</strong> (<strong class="bold">AOT</strong>) compilation to increase runtime performance, and the configuration items defined in <code class="Code-In-Text--PACKT-">src/environments/environment.prod.ts</code> are used.</p>
        </div>
      </li>
      <li class="list">Update <code class="Code-In-Text--PACKT-">src/environments/environment.prod.ts</code> to look like you're using your own <code class="Code-In-Text--PACKT-">appId</code> from <code class="Code-In-Text--PACKT-">OpenWeather</code>:
        <pre class="programlisting"><code class="hljs dart"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> environment = {   
  production: <span class="hljs-keyword">true</span>,
  appId: <span class="hljs-string">'01ff1xxxxxxxxxxxxxxxxxxxxx'</span>,
  username: <span class="hljs-string">'localcast'</span>,
  baseUrl: <span class="hljs-string">'https://'</span>,
  geonamesApi: <span class="hljs-string">'secure'</span>,
}
</code></pre>
        <div class="packt_tip">
          <p>We are modifying how <code class="Code-In-Text--PACKT-">npm test</code> is executed, so the tests are run only once and the tool stops executing. The <code class="Code-In-Text--PACKT-">--watch=false</code> option is provided to achieve this behavior, as opposed to the development-friendly default continuous execution behavior.</p>
        </div>
      </li>
      <li class="list">Create a new file named <code class="Code-In-Text--PACKT-">Dockerfile</code> with no file extensions in the project root.</li>
      <li class="list">Implement or replace the contents of the <code class="Code-In-Text--PACKT-">Dockerfile</code>, as shown here:
        <pre class="programlisting"><code class="hljs dockerfile"><strong>Dockerfile</strong>
<span class="hljs-keyword">FROM</span> duluca/minimal-node-web-server:lts-alpine 
<span class="hljs-keyword">WORKDIR</span><span class="bash"> /usr/src/app</span>
<span class="hljs-keyword">COPY</span><span class="bash"> dist/<span class="hljs-built_in">local</span>-weather-app public</span>
</code></pre>
        <div class="packt_tip">
          <p>Be sure to inspect the contents of your <code class="Code-In-Text--PACKT-">dist</code> folder to ensure you're copying the correct folder, which contains the <code class="Code-In-Text--PACKT-">index.html</code> file at its root.</p>
        </div>
      </li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">npm run predocker:build</code> and make sure it runs without errors in the Terminal <a id="_idIndexMarker956"/>to ensure that your application <a id="_idIndexMarker957"/>changes have been successful.</li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">npm run docker:build</code> and make sure it runs without errors in the Terminal <a id="_idIndexMarker958"/>to ensure that your image builds <a id="_idIndexMarker959"/>successfully.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">While you can run any of the provided scripts individually, you really only need to remember two of them going forward:</p>
        <ul>
          <li class="Bullet-Within-Bullet--PACKT-"><code class="Code-In-Text--PACKT-">npm run docker:debug</code> will test, build, tag, run, tail, and launch your containerized app in a new browser window for testing.</li>
          <li class="Bullet-Within-Bullet-End--PACKT-"><code class="Code-In-Text--PACKT-">npm run docker:publish</code> will publish the image you just built and test to the online Docker repository.</li>
        </ul>
      </li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">docker:debug</code> in your Terminal:
        <pre class="programlisting"><code class="hljs routeros">$ npm <span class="hljs-builtin-name">run</span> docker:<span class="hljs-builtin-name">debug</span>
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">A successful <code class="Code-In-Text--PACKT-">docker:debug</code> run should result in a new in-focus browser window with your application and the server logs being tailed in the Terminal, as follows:</p>
        <pre class="programlisting"><code class="hljs pgsql"><span class="hljs-keyword">Current</span> Environment: <span class="hljs-keyword">local</span>.
<span class="hljs-keyword">Server</span> listening <span class="hljs-keyword">on</span> port <span class="hljs-number">3000</span> inside the container
Attention: <span class="hljs-keyword">To</span> <span class="hljs-keyword">access</span> <span class="hljs-keyword">server</span>, use http://localhost:EXTERNAL_PORT
EXTERNAL_PORT <span class="hljs-keyword">is</span> specified <span class="hljs-keyword">with</span> <span class="hljs-string">'docker run -p EXTERNAL_PORT:3000'</span>. See <span class="hljs-string">'package.json-&gt;imagePort'</span> <span class="hljs-keyword">for</span> the <span class="hljs-keyword">default</span> port.      
<span class="hljs-keyword">GET</span> / <span class="hljs-number">304</span> <span class="hljs-number">2.194</span> ms - -
<span class="hljs-keyword">GET</span> /runtime-es2015.js <span class="hljs-number">304</span> <span class="hljs-number">0.371</span> ms - -
<span class="hljs-keyword">GET</span> /polyfills-es2015.js <span class="hljs-number">304</span> <span class="hljs-number">0.359</span> ms - -
<span class="hljs-keyword">GET</span> /styles-es2015.js <span class="hljs-number">304</span> <span class="hljs-number">0.839</span> ms - -
<span class="hljs-keyword">GET</span> /vendor-es2015.js <span class="hljs-number">304</span> <span class="hljs-number">0.789</span> ms - -
<span class="hljs-keyword">GET</span> /main-es2015.js <span class="hljs-number">304</span> <span class="hljs-number">0.331</span> ms - -
</code></pre>
        <div class="packt_tip">
          <p>You should always run <code class="Code-In-Text--PACKT-">docker ps</code> to check whether your image is running, when it was last updated, and whether it is clashing with any existing images claiming the same port.</p>
        </div>
      </li>
      <li class="list" value="12">Execute <code class="Code-In-Text--PACKT-">docker:publish</code> in your Terminal:
        <pre class="programlisting"><code class="hljs dockerfile">$ npm <span class="hljs-keyword">run</span><span class="bash"> docker:publish</span>
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">You should observe a successful run in the Terminal window like this:</p>
        <pre class="programlisting"><code class="hljs groovy">The push refers to a repository [docker.io<span class="hljs-regexp">/duluca/</span>localcast- weather]
<span class="hljs-number">60</span><span class="hljs-string">f66aaaaa50:</span> Pushed
...
<span class="hljs-string">latest:</span> <span class="hljs-string">digest:</span> <span class="hljs-string">sha256:</span>b680970d76769cf12cc48f37391d8a542fe226b66d9a6f8a7ac81ad77be4 f58b <span class="hljs-string">size:</span> <span class="hljs-number">2827</span>
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p>Over time, your local <a id="_idIndexMarker960"/>Docker cache may grow to a <a id="_idIndexMarker961"/>significant size; for example, on my laptop, it's reached roughly 40 GB over two years. You can use the <code class="Code-In-Text--PACKT-">docker image prune</code> and <code class="Code-In-Text--PACKT-">docker container prune</code> commands to reduce the size of <a id="_idIndexMarker962"/>your cache. For more detailed information, refer to the documentation at <a href="https://docs.docker.com/config/pruning"><span class="url">https://docs.docker.com/config/pruning</span></a>.</p>
    </div>
    <p class="normal">By <a id="_idIndexMarker963"/>defining a <code class="Code-In-Text--PACKT-">Dockerfile</code> and scripting our use of it, we created <a id="_idIndexMarker964"/>living documentation in our code base. We have achieved DevOps and closed the configuration gap.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Make sure to containerize <strong class="bold">lemon-mart</strong> in the same way you've done with <strong class="bold">local-weather-app</strong> and verify your work by executing <code class="Code-In-Text--PACKT-">npm run docker:debug</code>.</p>
    </div>
    <p class="normal">You may find it confusing to interact with npm scripts in general through the CLI. Let's look at VS Code's npm script support next.</p>
    <h2 class="title" id="_idParaDest-321">NPM scripts in VS Code</h2>
    <p class="normal">VS Code provides <a id="_idIndexMarker965"/>support for npm scripts out of the box. In order to enable npm script explorer, open VS Code settings and ensure <a id="_idIndexMarker966"/>that the <code class="Code-In-Text--PACKT-">"npm.enableScriptExplorer": true</code> property is present. Once you do, you will see an expandable title named <strong class="screen-text">NPM SCRIPTS</strong> in the <strong class="screen-text">Explorer</strong> pane, as highlighted with an arrow in the following screenshot:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_08.png"/></figure>
    <p class="packt_figref">Figure 9.8: NPM scripts in VS Code</p>
    <p class="normal">You can click on any script to launch the line that contains the script in <code class="Code-In-Text--PACKT-">package.json</code> or right-click and select <strong class="screen-text">Run</strong> to execute the script.</p>
    <p class="normal">Let's look at an easier way to interact with Docker next.</p>
    <h2 class="title" id="_idParaDest-322">Docker extensions in VS Code</h2>
    <p class="normal">Another way <a id="_idIndexMarker967"/>to interact with Docker <a id="_idIndexMarker968"/>images and containers is through VS Code. If you have installed the <code class="Code-In-Text--PACKT-">ms-azuretools.vscode-docker</code> Docker extension from Microsoft, as suggested in <em class="italics">Chapter 2</em>, <em class="italics">Setting Up Your Development Environment</em>, you can identify the extension by the Docker logo on the left-hand navigation menu VS Code, as circled in white in the following screenshot:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_09.png"/></figure>
    <p class="packt_figref">Figure 9.9: Docker extension in VS Code</p>
    <p class="normal">Let's go through some of the functionality provided by the extension. Refer to the preceding screenshot and the numbered steps in the following list for a quick explanation:</p>
    <ol>
      <li class="list" value="1"><strong class="screen-text">Images</strong> contain a list of all the container snapshots that exist on your system.</li>
      <li class="list">Right-clicking on a Docker image brings up a context menu to run various operations on it, like <strong class="screen-text">Run</strong>, <strong class="screen-text">Push</strong>, and <strong class="screen-text">Tag</strong><strong class="screen-text">.</strong></li>
      <li class="list"><strong class="screen-text">Containers</strong> list all executable Docker containers that exist on your system, which you can start, stop, or attach to.</li>
      <li class="list" value="4"><strong class="screen-text">Registries</strong> display the registries that you're configured to connect to, such as Docker <a id="_idIndexMarker969"/>Hub or <strong class="bold">AWS Elastic Container Registry</strong> (<strong class="bold">AWS ECR</strong>).</li>
    </ol>
    <p class="normal">While the <a id="_idIndexMarker970"/>extension makes it easier to interact <a id="_idIndexMarker971"/>with Docker, the <strong class="bold">npm scripts for Docker</strong> (which you configured using the <code class="Code-In-Text--PACKT-">mrm</code> task) automate a lot of the chores related <a id="_idIndexMarker972"/>to building, tagging, and testing an image. They are both cross-platform and will work equally well in a CI environment.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">npm run docker:debug</code> script automates a lot of chores to verify that you have a good image build!</p>
    </div>
    <p class="normal">Now let's see how we can deploy our containers to the cloud and later achieve CD.</p>
    <h1 class="title" id="_idParaDest-323">Deploying a Dockerfile to the cloud</h1>
    <p class="normal">One of the advantages of using Docker is that we can deploy it on any number of operating <a id="_idIndexMarker973"/>environments, from personal PCs to servers <a id="_idIndexMarker974"/>and cloud providers. In any case, we would expect our container to function the same way. Let's deploy the LocalCast Weather app to Google Cloud Run.</p>
    <h2 class="title" id="_idParaDest-324">Google Cloud Run</h2>
    <p class="normal">Google Cloud Run allows <a id="_idIndexMarker975"/>you to deploy arbitrary Docker containers and execute them on the Google Cloud Platform without any onerous overhead. Fully managed instances offer some free time; however, there's no free-forever <a id="_idIndexMarker976"/>version here. Please be mindful of any costs you may incur. Refer to <a href="https://cloud.google.com/run/pricing?hl=en_US%20for%20pricing"><span class="url">https://cloud.google.com/run/pricing?hl=en_US%20for%20pricing</span></a>.</p>
    <p class="normal">Refer to <em class="italics">Chapter 2</em>, <em class="italics">Setting Up Your Development Environment</em>, for instructions on how to install glcoud.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">This section uses the <strong class="bold">local-weather-app</strong> repo.</p>
    </div>
    <p class="normal">Let's configure glcoud so we can deploy a <code class="Code-In-Text--PACKT-">Dockerfile</code>:</p>
    <ol>
      <li class="list" value="1">Update your <code class="Code-In-Text--PACKT-">Dockerfile</code> to override the <code class="Code-In-Text--PACKT-">ENTRYPOINT</code> command:
        <pre class="programlisting"><code class="hljs dockerfile"><strong>Dockerfile</strong>
<span class="hljs-keyword">FROM</span> duluca/minimal-node-web-server:lts-alpine
<span class="hljs-keyword">WORKDIR</span><span class="bash"> /usr/src/app</span>
<span class="hljs-keyword">COPY</span><span class="bash"> dist/<span class="hljs-built_in">local</span>-weather-app public</span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [ <span class="hljs-string">"npm"</span>, <span class="hljs-string">"start"</span> ]</span>
</code></pre>
        <div class="note">
          <p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">ENTRYPOINT</code> command in <code class="Code-In-Text--PACKT-">minimal-node-web-server</code> runs a process called <code class="Code-In-Text--PACKT-">dumb-init</code> to force <a id="_idIndexMarker977"/>the process ID for your Node process to be randomized. However, gcloud fails to execute this command, which is why we're overriding it.</p>
        </div>
      </li>
      <li class="list">Create <a id="_idIndexMarker978"/>a new gcloud project:
        <pre class="programlisting"><code class="hljs elixir"><span class="hljs-variable">$ </span>gcloud projects create localcast-weather
</code></pre>
        <div class="packt_tip">
          <p>Remember to use your own project name!</p>
        </div>
      </li>
      <li class="list">Navigate to <a href="https://console.cloud.google.com/ "><span class="url">https://console.cloud.google.com/</span></a></li>
      <li class="list">Locate your new project and select the <strong class="screen-text">Billing</strong> option from the sidebar, as shown in the following screenshot:<figure class="mediaobject"><img alt="" src="../Images/B14094_09_10.png"/></figure>
        <p class="packt_figref">Figure 9.10: Billing options</p>
      </li>
      <li class="list">Follow the <a id="_idIndexMarker979"/>instructions to set up a billing account.<div class="packt_tip">
          <p>If you see it, the Freemium account option will also work. Otherwise, you may choose to take advantage of free trial offers. However, it is a good idea to set a budget alert <a id="_idIndexMarker980"/>to be notified if you get charged over a certain amount per month. Find more info at <a href="https://cloud.google.com/billing/docs/how-to/modify-project"><span class="url">https://cloud.google.com/billing/docs/how-to/modify-project</span></a>.</p>
        </div>
      </li>
      <li class="list">Create a <code class="Code-In-Text--PACKT-">.gcloudignore</code> file and ignore everything but your <code class="Code-In-Text--PACKT-">Dockerfile</code> and <code class="Code-In-Text--PACKT-">dist</code> folder:
        <pre class="programlisting"><code class="hljs diff"><strong>.gcloudignore</strong>
/*
<span class="hljs-addition">!Dockerfile</span>
<span class="hljs-addition">!dist/</span>
</code></pre>
      </li>
      <li class="list">Add a new npm script to build your <code class="Code-In-Text--PACKT-">Dockerfile</code> in the cloud:
        <pre class="programlisting"><code class="hljs actionscript"><strong><span class="hljs-class"><span class="hljs-keyword">package</span>.<span class="hljs-title">json</span></span></strong><span class="hljs-class">
  <span class="hljs-title">scripts</span>: {</span>
    <span class="hljs-string">"gcloud:build"</span>: <span class="hljs-string">"gcloud builds submit --tag gcr.io/localcast-weather/localcast-weather --project localcast-weather"</span>,
  }
</code></pre>
        <div class="packt_tip">
          <p>Remember to use your own project name!</p>
        </div>
      </li>
      <li class="list">Add another npm script to deploy your published container:
        <pre class="programlisting"><code class="hljs actionscript"><strong><span class="hljs-class"><span class="hljs-keyword">package</span>.<span class="hljs-title">json</span></span></strong><span class="hljs-class">
  <span class="hljs-title">scripts</span>: {</span>
    <span class="hljs-string">"gcloud:deploy"</span>: <span class="hljs-string">"gcloud run deploy --image gcr.io/localcast-weather/localcast-weather --platform managed --project localcast-weather --region us-east1"</span>
  }
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note that you should provide the region closest to your geographical location for the best possible experience.</p>
      </li>
      <li class="list">Build your <code class="Code-In-Text--PACKT-">Dockerfile</code> as follows:
        <pre class="programlisting"><code class="hljs dockerfile">$ npm <span class="hljs-keyword">run</span><span class="bash"> gcloud:build</span>
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Before running this command, remember to build your application for <code class="Code-In-Text--PACKT-">prod</code>. Whatever you have in your <code class="Code-In-Text--PACKT-">dist</code> folder will get deployed.</p>
        <div class="packt_tip">
          <p>Note that on the initial run, you will be prompted to answer questions to configure your account for initial use. Select your account and project name correctly, otherwise, take the default options. The <code class="Code-In-Text--PACKT-">build</code> command may fail during the first run. Sometimes it takes multiple runs for gcloud to warm up and successfully build your container.</p>
        </div>
      </li>
      <li class="list" value="10">Once your <a id="_idIndexMarker981"/>container is published, deploy it using the following command:
        <pre class="programlisting"><code class="hljs dockerfile">$ npm <span class="hljs-keyword">run</span><span class="bash"> gcloud:deploy</span>
</code></pre>
      </li>
    </ol>
    <p class="normal">A successful deployment will look like the following: </p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_11.png"/></figure>
    <p class="packt_figref">Figure 9.11: A successful deployment</p>
    <p class="normal">Congrats, you've just deployed your container on Google Cloud. You should be able to access your <a id="_idIndexMarker982"/>app using the URL in the Terminal output.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">As always, consider adding CLI commands as npm scripts to your project so that you can maintain a living documentation of your scripts. These scripts will also allow you to leverage pre and post scripts in npm, allowing you to automate the building of your application, your container, and the tagging process. So, the next time you need to deploy, you only need to run one command. I encourage the reader to seek inspiration from the npm scripts for Docker utility we set up earlier to create your own set of scripts for gcloud.</p>
    </div>
    <p class="normal">For <a id="_idIndexMarker983"/>more information and some <a id="_idIndexMarker984"/>sample projects, refer to <a href="https://cloud.google.com/run/docs/quickstarts/prebuilt-deploy"><span class="url">https://cloud.google.com/run/docs/quickstarts/prebuilt-deploy</span></a> and <a href="https://cloud.google.com/run/docs/quickstarts/build-and-deploy"><span class="url">https://cloud.google.com/run/docs/quickstarts/build-and-deploy</span></a>.</p>
    <h2 class="title" id="_idParaDest-325">Configuring Docker with Cloud Run</h2>
    <p class="normal">In the previous section, we submitted our <code class="Code-In-Text--PACKT-">Dockerfile</code> and <code class="Code-In-Text--PACKT-">dist</code> folder to gcloud so that it can build <a id="_idIndexMarker985"/>our container for us. This is a convenient option that avoids some of the additional configuration steps. However, you can still <a id="_idIndexMarker986"/>leverage your Docker-based workflow to build and publish your container.</p>
    <p class="normal">Let's configure Docker with gcloud:</p>
    <ol>
      <li class="list" value="1">Set your default region:
        <pre class="programlisting"><code class="hljs routeros">$ gcloud<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> run/region us-east1
</code></pre>
      </li>
      <li class="list">Configure Docker with the gcloud container registry:
        <pre class="programlisting"><code class="hljs elixir"><span class="hljs-variable">$ </span>gcloud auth configure-docker
</code></pre>
      </li>
      <li class="list">Tag your already built container with a gcloud hostname:
        <pre class="programlisting"><code class="hljs crmsh">$ docker <span class="hljs-keyword">tag</span> <span class="hljs-title">duluca</span>/localcast-weather:latest gcr.io/localcast-weather/localcast-weather:latest
</code></pre>
        <div class="packt_tip">
          <p>For detailed <a id="_idIndexMarker987"/>instructions on how to tag your image, refer to <a href="https://cloud.google.com/container-registry/docs/pushing-and-pulling"><span class="url">https://cloud.google.com/container-registry/docs/pushing-and-pulling</span></a>.</p>
        </div>
      </li>
      <li class="list">Publish your container to gcloud using Docker:
        <pre class="programlisting"><code class="hljs gradle">$ docker <span class="hljs-keyword">push</span> gcr.io<span class="hljs-regexp">/localcast-weather/</span>localcast-weather:latest
</code></pre>
      </li>
      <li class="list">Execute the <code class="Code-In-Text--PACKT-">deploy</code> command:
        <pre class="programlisting"><code class="hljs jboss-cli">$ gcloud run <span class="hljs-keyword">deploy</span> <span class="hljs-params">--image</span> gcr.io/localcast-weather/localcast-weather <span class="hljs-params">--platform</span> managed <span class="hljs-params">--project</span> localcast-weather
</code></pre>
        <div class="packt_tip">
          <p>During initial deployment, this command may appear to be stuck. Try again in 15 minutes or so.</p>
        </div>
      </li>
      <li class="list">Follow the <a id="_idIndexMarker988"/>onscreen instructions to complete your deployment.</li>
      <li class="list" value="7">Follow the URL displayed on screen to check that your app has been successfully deployed.</li>
    </ol>
    <p class="normal">The preceding <a id="_idIndexMarker989"/>steps demonstrate a deployment technique that is similar to the one we leveraged when deploying to AWS ECS in <em class="italics">Chapter 13</em>, <em class="italics">Highly Available Cloud Infrastructure on AWS</em>.</p>
    <p class="normal">For more <a id="_idIndexMarker990"/>information, refer to <a href="https://cloud.google.com/sdk/gcloud/reference/run/deploy"><span class="url">https://cloud.google.com/sdk/gcloud/reference/run/deploy</span></a>. For the following few sections, we will be switching back to LemonMart.</p>
    <h2 class="title" id="_idParaDest-326">Troubleshooting Cloud Run</h2>
    <p class="normal">In order to <a id="_idIndexMarker991"/>troubleshoot your glcoud commands, you <a id="_idIndexMarker992"/>may utilize the Google Cloud Platform Console at <a href="https://console.cloud.google.com/"><span class="url">https://console.cloud.google.com/</span></a>.</p>
    <p class="normal">Under the Cloud Run menu, you can keep track of the containers you are running. If errors occur during your deployment, you may want to check the logs to see the messages created by your container. Refer to the following screenshot, which shows the logs from my <code class="Code-In-Text--PACKT-">localcast-weather</code> deployment:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_12.png"/></figure>
    <p class="packt_figref">Figure 9.12: Cloud Run logs</p>
    <p class="normal">To learn <a id="_idIndexMarker993"/>more about troubleshooting Cloud Run, refer to <a href="https://cloud.google.com/run/docs/troubleshooting"><span class="url">https://cloud.google.com/run/docs/troubleshooting</span></a>.</p>
    <p class="normal">Congratulations! You have <a id="_idIndexMarker994"/>mastered the fundamentals of working with Docker containers in your local development environment and pushing them to multiple registries and runtime environments in the cloud.</p>
    <h1 class="title" id="_idParaDest-327">Continuous deployment</h1>
    <p class="normal">CD is the idea <a id="_idIndexMarker995"/>that code changes that successfully pass through your pipeline can be automatically deployed to a target environment. Although there are examples of continuously deploying to production, most enterprises prefer to target a dev environment. A gated approach is adopted to move the changes through the various stages of dev, test, staging, and finally production. CircleCI can facilitate gated deployment with approval workflows, which is covered later in this section.</p>
    <p class="normal">In CircleCI, to deploy your image, we need to implement a <code class="Code-In-Text--PACKT-">deploy</code> job. In this job, you can deploy to a multitude of targets such as Google Cloud Run, Docker Hub, Heroku, Azure, or AWS ECS. Integration <a id="_idIndexMarker996"/>with these targets will involve multiple steps. At a high level, these steps are as follows:</p>
    <ol>
      <li class="list" value="1">Configure an orb for your target environment, which provides the CLI tools required to deploy your software.</li>
      <li class="list">Store login credentials or access keys specific to the target environment as CircleCI environment variables.</li>
      <li class="list">Build a container in the CI pipeline, if not using a platform-specific <code class="Code-In-Text--PACKT-">build</code> command. Then use <code class="Code-In-Text--PACKT-">docker push</code> to submit the resulting Docker image to the target platform's Docker registry.</li>
      <li class="list" value="4">Execute a platform-specific <code class="Code-In-Text--PACKT-">deploy</code> command to instruct the target to run the Docker image that was just pushed.</li>
    </ol>
    <p class="normal">By using a Docker-based workflow, we achieve great amounts of flexibility in terms of systems and target environments we can use. The following diagram illustrates this point by highlighting the possible permutation of choices that are available to us:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_13.png"/></figure>
    <p class="packt_figref">Figure 9.13: n-to-n deployment</p>
    <p class="normal">As you can see, in a containerized world, the possibilities are limitless. I will demonstrate how you can <a id="_idIndexMarker997"/>deploy to Google Cloud Run using containers and CI later in this chapter. Outside of Docker-based workflows, you can use purpose-built CLI tools to quickly deploy your app. Next, let's see how you can deploy your app to Vercel Now using CircleCI.</p>
    <h2 class="title" id="_idParaDest-328">Deploying to Vercel Now using CircleCI</h2>
    <p class="normal">In <em class="italics">Chapter 4</em>, <em class="italics">Automated Testing, CI, and Release to Production</em>, we configured the LocalCast <a id="_idIndexMarker998"/>Weather app to build using CircleCI. We can enhance our CI pipeline to take the build output <a id="_idIndexMarker999"/>and optionally deploy it to Vercel Now.</p>
    <div class="packt_tip">
      <p>Note that ZEIT Now has rebranded to Vercel Now in 2020.</p>
    </div>
    <div class="note">
      <p class="Information-Box--PACKT-">This section uses the <strong class="bold">local-weather-app</strong> repo. The <code class="Code-In-Text--PACKT-">config.yml</code> file for this section is named <code class="Code-In-Text--PACKT-">.circleci/config.ch9.yml</code>. You can also find a pull request <a id="_idIndexMarker1000"/>that executes the <code class="Code-In-Text--PACKT-">.yml</code> file from this chapter on CircleCI at <a href="https://github.com/duluca/local-weather-app/pull/50"><span class="url">https://github.com/duluca/local-weather-app/pull/50</span></a> using the <code class="Code-In-Text--PACKT-">branch deploy_Vercelnow</code>.</p>
      <p class="Information-Box--PACKT-">Note that this branch has a modified configuration in <code class="Code-In-Text--PACKT-">config.yml</code> and <code class="Code-In-Text--PACKT-">Dockerfile</code> to use the <code class="Code-In-Text--PACKT-">projects/ch6</code> code from <strong class="bold">local-weather-app</strong>.</p>
    </div>
    <p class="normal">Let's update the <code class="Code-In-Text--PACKT-">config.yml</code> file to add a new job named <code class="Code-In-Text--PACKT-">deploy</code>. In the upcoming Workflows section, we will use this job to deploy a pipeline when approved:</p>
    <ol>
      <li class="list" value="1">Create a token from your Vercel Now account.</li>
      <li class="list">Add an environment variable to your CircleCI project named <code class="Code-In-Text--PACKT-">NOW_TOKEN</code> and store your Vercel Now token as the value.</li>
      <li class="list">In <code class="Code-In-Text--PACKT-">config.yml</code>, update the <code class="Code-In-Text--PACKT-">build</code> job with the new steps and add a new job named <code class="Code-In-Text--PACKT-">deploy</code>:
        <pre class="programlisting"><code class="hljs dts"><strong>.circleci/config.yml</strong>
...
<span class="hljs-symbol">jobs:</span>
<span class="hljs-symbol">  build:</span>
    ...       
    - run:
<span class="hljs-symbol">        name:</span> Move compiled app to workspace
<span class="hljs-symbol">        command:</span> |
          set -exu
          mkdir -p <span class="hljs-meta-keyword">/tmp/</span>workspace/dist
          mv dist/local-weather-app <span class="hljs-meta-keyword">/tmp/</span>workspace<span class="hljs-meta-keyword">/dist/</span>
    - persist_to_workspace:
<span class="hljs-symbol">        root:</span> <span class="hljs-meta-keyword">/tmp/</span>workspace
<span class="hljs-symbol">        paths:</span>
          - dist/local-weather-app
<span class="hljs-symbol">  deploy:</span>
<span class="hljs-symbol">    docker:</span>
      - image: circleci/node:lts
<span class="hljs-symbol">    working_directory:</span> ~/repo
<span class="hljs-symbol">    steps:</span>
      - attach_workspace:
<span class="hljs-symbol">          at:</span> <span class="hljs-meta-keyword">/tmp/</span>workspace
      - run: npx now --token $NOW_TOKEN --platform-version <span class="hljs-number">2</span> --prod <span class="hljs-meta-keyword">/tmp/</span>workspace<span class="hljs-meta-keyword">/dist/</span>local-weather-app --confirm
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">In the <code class="Code-In-Text--PACKT-">build</code> job, after the build is complete, we add two new steps. First, we move the compiled app that's in the <code class="Code-In-Text--PACKT-">dist</code> folder to a workspace <a id="_idIndexMarker1001"/>and persist that workspace so we can use it later in another job. In a new job, named <code class="Code-In-Text--PACKT-">deploy</code>, we attach the workspace and use npx to run the <code class="Code-In-Text--PACKT-">now</code> command to deploy the <code class="Code-In-Text--PACKT-">dist</code> folder. This is a straightforward process.</p>
        <div class="packt_tip">
          <p>Note that <code class="Code-In-Text--PACKT-">$NOW_TOKEN</code> is the environment variable we stored on the CircleCI project.</p>
        </div>
      </li>
      <li class="list">Implement <a id="_idIndexMarker1002"/>a simple CircleCI workflow to continuously deploy the outcome of your <code class="Code-In-Text--PACKT-">build</code> job:
        <pre class="programlisting"><code class="hljs yaml"><strong><span class="hljs-string">.circleci/config.yml</span></strong>
<span class="hljs-string">...</span>
<span class="hljs-attr">workflows:</span>
  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">build-test-and-deploy:</span>
    <span class="hljs-attr">jobs:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">build</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">deploy:</span>
         <span class="hljs-attr">requires:</span>
           <span class="hljs-bullet">-</span> <span class="hljs-string">build</span>
</code></pre>
        <div class="packt_tip">
          <p>Note that the <code class="Code-In-Text--PACKT-">deploy</code> job waits for the <code class="Code-In-Text--PACKT-">build</code> job to complete before it can execute.</p>
        </div>
      </li>
      <li class="list" value="5">Ensure <a id="_idIndexMarker1003"/>that your CI pipeline executed successfully by inspecting the test results:</li>
    </ol>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_14.png"/></figure>
    <p class="packt_figref">Figure 9.14: Successful Vercel Now deployment of local-weather-app on the deploy_Vercelnow branch</p>
    <p class="normal">Most CLI commands <a id="_idIndexMarker1004"/>for cloud providers need to be installed in your pipeline to function. Since Vercel Now has an npm package, this is easy to do. CLI tools for AWS, Google Cloud, or Microsoft Azure need to be installed using tools such as <code class="Code-In-Text--PACKT-">brew</code> or <code class="Code-In-Text--PACKT-">choco</code>. Doing this manually in a CI environment is tedious. Next, we will cover orbs, which helps to solve the problem.</p>
    <h2 class="title" id="_idParaDest-329">Deploying to GCloud using orbs</h2>
    <p class="normal">Orbs <a id="_idIndexMarker1005"/>contain a set of <a id="_idIndexMarker1006"/>configuration elements to encapsulate shareable behavior between CircleCI projects. CircleCI provides orbs that are developed by the maintainers of CLI tools. These orbs make it easy for you to add a CLI tool to your pipeline <a id="_idIndexMarker1007"/>without having <a id="_idIndexMarker1008"/>to set it up manually, with minimal configuration. </p>
    <div class="packt_tip">
      <p>To work with orbs, your <code class="Code-In-Text--PACKT-">config.yml</code> version number must be set to <code class="Code-In-Text--PACKT-">2.1</code> and, in your CircleCI security settings, you must select the option to allow uncertified orbs.</p>
    </div>
    <p class="normal">The following are some orbs that you can use in your projects:</p>
    <ul>
      <li class="list"><code class="Code-In-Text--PACKT-">circleci/aws-cli</code> and <code class="Code-In-Text--PACKT-">circleci/aws-ecr</code> provide you with the AWS CLI tool <a id="_idIndexMarker1009"/>and help <a id="_idIndexMarker1010"/>you to interact with <strong class="bold">AWS Elastic Container Service</strong> (<strong class="bold">AWS ECS</strong>), performing tasks such as <a id="_idIndexMarker1011"/>deploying your containers to AWS ECR.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">circleci/aws-ecs</code> streamlines <a id="_idIndexMarker1012"/>your CircleCI config to deploy your containers to AWS ECS.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">circleci/gcp-cli</code> and <code class="Code-In-Text--PACKT-">circleci/gcp-gcr</code> provide <a id="_idIndexMarker1013"/>you with the GCloud CLI tool <a id="_idIndexMarker1014"/>and access <a id="_idIndexMarker1015"/>to <strong class="bold">Google Container Registry</strong> (<strong class="bold">GCR</strong>).</li>
      <li class="list"><code class="Code-In-Text--PACKT-">circleci/gcp-cloud-run</code> streamlines your CircleCI config to deploy your containers <a id="_idIndexMarker1016"/>to Cloud Run.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">circleci/azure-cli</code> and <code class="Code-In-Text--PACKT-">circleci/azure-acr</code> provide you with the Azure CLI <a id="_idIndexMarker1017"/>tools and <a id="_idIndexMarker1018"/>access <a id="_idIndexMarker1019"/>to <strong class="bold">Azure Container Registry</strong> (<strong class="bold">ACR</strong>).</li>
    </ul>
    <div class="packt_tip">
      <p>Check out <a id="_idIndexMarker1020"/>the Orb registry for more information on how to use these orbs at <a href="https://circleci.com/orbs/registry"><span class="url">https://circleci.com/orbs/registry</span></a>.</p>
    </div>
    <p class="normal">Now, let's configure the <code class="Code-In-Text--PACKT-">circleci/gcp-cloud-run</code> orb with the Local Weather app so we can continuously deploy our app to GCloud, without having to manually install and configure the gcloud CLI tool on our CI server.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">On the <strong class="bold">local-weather-app</strong> repo, you can find a pull request that executes the Cloud Run configuration from this step on CircleCI, at <a href="https://github.com/duluca/local-weather-app/pull/51"><span class="url">https://github.com/duluca/local-weather-app/pull/51</span></a>, using the <code class="Code-In-Text--PACKT-">deploy_cloudrun </code>branch.</p>
      <p class="Information-Box--PACKT-">Note that this branch has a modified configuration in <code class="Code-In-Text--PACKT-">config.yml</code> and <code class="Code-In-Text--PACKT-">Dockerfile</code> to use the <code class="Code-In-Text--PACKT-">projects/ch6</code> code from <strong class="bold">local-weather-app</strong>.</p>
    </div>
    <p class="normal">First, configure your CircleCI and GCloud accounts so you can deploy from a CI server. This is <a id="_idIndexMarker1021"/>markedly different from <a id="_idIndexMarker1022"/>deploying from your development machine, because the gcloud CLI tools automatically set up the necessary authentication configuration for you. Here, you will have to do this manually:</p>
    <ol>
      <li class="list" value="1">In your CircleCI account settings, under the security section, ensure you allow execution of uncertified/unsigned orbs.</li>
      <li class="list">In the CircleCI project settings, add an environment variable named <code class="Code-In-Text--PACKT-">GOOGLE_PROJECT_ID</code>.<div class="packt_tip">
          <p>If you used the same project ID as I did, this should be <code class="Code-In-Text--PACKT-">localcast-weather</code>.</p>
        </div>
      </li>
      <li class="list">Create a GCloud service account key for your project's existing service account.<div class="packt_tip">
          <p>Creating a service account key will result in a JSON file. Do not check this file into your code repository. Do not share the contents of it over insecure communication channels such as email or SMS. Exposing the contents of this file means that any third party can access your GCloud resources permitted by the key permissions.</p>
        </div>
      </li>
      <li class="list">Copy the contents of the JSON file to a CircleCI environment variable named <code class="Code-In-Text--PACKT-">GCLOUD_SERVICE_KEY</code>.</li>
      <li class="list">Add another environment variable named <code class="Code-In-Text--PACKT-">GOOGLE_COMPUTE_ZONE</code> and set it to your preferred zone.<div class="packt_tip">
          <p>I used <code class="Code-In-Text--PACKT-">us-east1</code>.</p>
        </div>
      </li>
      <li class="list">Update your <code class="Code-In-Text--PACKT-">config.yml</code> file to add an orb named <code class="Code-In-Text--PACKT-">circleci/gcp-cloud-run</code>:
        <pre class="programlisting"><code class="hljs angelscript"><strong>.circleci/config.yml</strong>
<strong>version: <span class="hljs-number">2.1</span></strong>
orbs:
  cloudrun: circleci/gcp-cloud-<span class="hljs-symbol">run@</span><span class="hljs-number">1.0</span><span class="hljs-number">.2</span>
  ...
</code></pre>
      </li>
      <li class="list">Next, implement <a id="_idIndexMarker1023"/>a new job named <code class="Code-In-Text--PACKT-">deploy_cloudrun</code>, leveraging orb features to initialize, build, deploy, and <a id="_idIndexMarker1024"/>test our deployment:
        <pre class="programlisting"><code class="hljs yaml"><strong><span class="hljs-string">.circleci/config.yml</span></strong>
<span class="hljs-string">...</span>
<span class="hljs-attr">deploy_cloudrun:</span>
  <span class="hljs-attr">docker:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">'cimg/base:stable'</span>
  <span class="hljs-attr">working_directory:</span> <span class="hljs-string">~/repo</span>
  <span class="hljs-attr">steps:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">attach_workspace:</span>
        <span class="hljs-attr">at:</span> <span class="hljs-string">/tmp/workspace</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">checkout</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span>
        <span class="hljs-attr">name:</span> <span class="hljs-string">Copy</span> <span class="hljs-string">built</span> <span class="hljs-string">app</span> <span class="hljs-string">to</span> <span class="hljs-string">dist</span> <span class="hljs-string">folder</span>
        <span class="hljs-attr">command:</span> <span class="hljs-string">cp</span> <span class="hljs-string">-avR</span> <span class="hljs-string">/tmp/workspace/dist/</span> <span class="hljs-string">.</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">cloudrun/init</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">cloudrun/build:</span>
       <span class="hljs-attr">tag:</span> <span class="hljs-string">'gcr.io/${GOOGLE_PROJECT_ID}/test-${CIRCLE_SHA1}'</span>
       <span class="hljs-attr">source:</span> <span class="hljs-string">~/repo</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">cloudrun/deploy:</span>
        <span class="hljs-attr">image:</span> <span class="hljs-string">'gcr.io/${GOOGLE_PROJECT_ID}/test-${CIRCLE_SHA1}'</span>
        <span class="hljs-attr">platform:</span> <span class="hljs-string">managed</span>
        <span class="hljs-attr">region:</span> <span class="hljs-string">us-east1</span>
        <span class="hljs-attr">service-name:</span> <span class="hljs-string">localcast-weather</span>
        <span class="hljs-attr">unauthenticated:</span> <span class="hljs-literal">true</span>
    <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span>
        <span class="hljs-attr">command:</span> <span class="hljs-string">&gt;
          GCP_API_RESULTS=$(curl -s "$GCP_DEPLOY_ENDPOINT")
          if ! echo "$GCP_API_RESULTS" | grep -nwo "LocalCast Weather"; then
            echo "Result is unexpected"
            echo 'Result: '
            curl -s "$GCP_DEPLOY_ENDPOINT"
            exit 1;
          fi
</span>        <span class="hljs-attr">name:</span> <span class="hljs-string">Test</span> <span class="hljs-string">managed</span> <span class="hljs-string">deployed</span> <span class="hljs-string">service.</span>
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">We first load the <code class="Code-In-Text--PACKT-">dist</code> folder from the <code class="Code-In-Text--PACKT-">build</code> job. We then run <code class="Code-In-Text--PACKT-">cloudrun/init</code>, so that the CLI tool can be initialized. With <code class="Code-In-Text--PACKT-">cloudrun/build</code>, we build the <code class="Code-In-Text--PACKT-">Dockerfile</code> at the root of our project, which automatically stores the result of our build in GCR. Then, <code class="Code-In-Text--PACKT-">cloudrun/deploy</code> deploys the image we just built, taking our code live. In the last command, using the <code class="Code-In-Text--PACKT-">curl</code> tool, we retrieve the <code class="Code-In-Text--PACKT-">index.html</code> file of our website and check to see that it's properly deployed by searching for the LocalCast Weather string.</p>
      </li>
      <li class="list">Update <a id="_idIndexMarker1025"/>your workflow to continuously <a id="_idIndexMarker1026"/>deploy to gcloud:
        <pre class="programlisting"><code class="hljs yaml"><strong><span class="hljs-string">.circleci/config.yml</span></strong>
<span class="hljs-string">...</span>
<span class="hljs-attr">workflows:</span>
 <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">build-test-and-deploy:</span>
    <span class="hljs-attr">jobs:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">build</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">deploy_cloudrun:</span>
          <span class="hljs-attr">requires:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">build</span>
</code></pre>
        <div class="packt_tip">
          <p>Note that you can have multiple <code class="Code-In-Text--PACKT-">deploy</code> jobs that simultaneously deploy to multiple targets.</p>
        </div>
      </li>
      <li class="list" value="9">Ensure that your CI pipeline executed successfully by inspecting the test results:</li>
    </ol>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_15.png"/></figure>
    <p class="packt_figref">Figure 9.15: Successful gcloud deployment of local-weather-app on the deploy_cloudrun branch</p>
    <p class="normal">CD works <a id="_idIndexMarker1027"/>great for development and testing environments. However, it is usually desirable to have gated deployments, where <a id="_idIndexMarker1028"/>a person must approve a deployment before it reaches a production environment. Next, let's see how you can implement this with CircleCI.</p>
    <h2 class="title" id="_idParaDest-330">Gated CI workflows</h2>
    <p class="normal">In CircleCI, you <a id="_idIndexMarker1029"/>can define a <a id="_idIndexMarker1030"/>workflow to control how and when your jobs are executed. Consider the following configuration, given the jobs <code class="Code-In-Text--PACKT-">build</code> and <code class="Code-In-Text--PACKT-">deploy</code>:</p>
    <pre class="programlisting"><code class="hljs yaml"><strong><span class="hljs-string">.circleci/config.yml</span></strong>
<span class="hljs-attr">workflows:</span>
  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">build-and-deploy:</span>
    <span class="hljs-attr">jobs:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">build</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">hold:</span>
          <span class="hljs-attr">type:</span> <span class="hljs-string">approval</span>
          <span class="hljs-attr">requires:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">build</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">deploy:</span>
          <span class="hljs-attr">requires:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">hold</span>
</code></pre>
    <p class="normal">First, the <code class="Code-In-Text--PACKT-">build</code> job gets executed. Then, we introduce a special job named <code class="Code-In-Text--PACKT-">hold</code> with type <code class="Code-In-Text--PACKT-">approval</code>, which requires the <code class="Code-In-Text--PACKT-">build</code> job to be successfully completed. Once this happens, the <a id="_idIndexMarker1031"/>pipeline is put <a id="_idIndexMarker1032"/>on hold. If or when a decision-maker approves the <code class="Code-In-Text--PACKT-">hold</code>, then the <code class="Code-In-Text--PACKT-">deploy</code> step can execute. Refer to the following screenshot to see what a <code class="Code-In-Text--PACKT-">hold</code> looks like:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_16.png"/></figure>
    <p class="packt_figref">Figure 9.16: A hold in the pipeline</p>
    <p class="normal">Consider a more sophisticated workflow, shown in the following code snippet, where the <code class="Code-In-Text--PACKT-">build</code> and <code class="Code-In-Text--PACKT-">test</code> steps are broken out into two separate jobs:</p>
    <pre class="programlisting"><code class="hljs yaml"><span class="hljs-attr">workflows:</span>
  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
    <span class="hljs-attr">build-test-and-approval-deploy:</span>
      <span class="hljs-attr">jobs:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">build</span> 
      <span class="hljs-bullet">-</span> <span class="hljs-string">test</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">hold:</span>
         <span class="hljs-attr">type:</span> <span class="hljs-string">approval</span>
         <span class="hljs-attr">requires:</span>
           <span class="hljs-bullet">-</span> <span class="hljs-string">build</span>
           <span class="hljs-bullet">-</span> <span class="hljs-string">test</span>
         <span class="hljs-attr">filters:</span>
           <span class="hljs-attr">branches:</span>
             <span class="hljs-attr">only:</span> <span class="hljs-string">master</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">deploy:</span>
        <span class="hljs-attr">requires:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">hold</span>
</code></pre>
    <p class="normal">In this case, the <code class="Code-In-Text--PACKT-">build</code> and <code class="Code-In-Text--PACKT-">test</code> jobs are executed in parallel. If we're on a branch, this is where <a id="_idIndexMarker1033"/>the pipeline stops. Once the branch is merged with <code class="Code-In-Text--PACKT-">master</code>, then the pipeline is put on hold and a decision-maker has the option to deploy a particular build or not. This type of branch filtering <a id="_idIndexMarker1034"/>ensures that only code that's been merged to <code class="Code-In-Text--PACKT-">master</code> can be deployed, which is in line with GitHub flow.</p>
    <p class="normal">Next, we dive deeper into how you can customize Docker to fit your workflow and environments.</p>
    <h1 class="title" id="_idParaDest-331">Advanced continuous integration</h1>
    <p class="normal">In <em class="italics">Chapter 4</em>, <em class="italics">Automated Testing, CI, and Release to Production</em>, we covered a basic CircleCI pipeline leveraging default features. Beyond the basic automation of unit test execution, one of <a id="_idIndexMarker1035"/>the other goals of CI is to enable a consistent and repeatable environment to build, test, and generate deployable artifacts of your application with every code push. Before pushing some code, a developer should have a reasonable expectation that their build will pass; therefore, creating a reliable CI environment that automates commands that developers can also run in their local machines is paramount. To achieve this goal, we will build a custom build pipeline that can run on any OS without configuration or any variation in behavior.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">This section uses the <strong class="bold">lemon-mart</strong> repo. Ensure that your project has been properly configured by executing <code class="Code-In-Text--PACKT-">npm run docker:debug</code> as described earlier in the chapter.</p>
    </div>
    <h2 class="title" id="_idParaDest-332">Containerizing build environments</h2>
    <p class="normal">In order to <a id="_idIndexMarker1036"/>ensure a consistent build environment across various OS platforms, developer machines, and CI environments, you <a id="_idIndexMarker1037"/>may containerize your build environment. Note that there are at least half a dozen common CI tools currently in use. Learning the ins and outs of every tool is an almost impossible task to achieve.</p>
    <p class="normal">Containerization of your build environment is an advanced concept that goes above and beyond what is currently expected of CI tools. However, containerization is a great way to standardize over 90% of your build infrastructure and can be executed in almost any CI environment. With this approach, the skills you learn and the build configuration you create become far more valuable, because both your knowledge and the tools you create become transferable and reusable.</p>
    <p class="normal">There are <a id="_idIndexMarker1038"/>many strategies to containerize your build environment with different levels of granularity and performance expectations. For <a id="_idIndexMarker1039"/>the purpose of this book, we will focus on reusability and ease of use. Instead of creating a complicated, interdependent set of Docker images that may allow for more efficient fail-first and recovery paths, we will focus on a single and straightforward workflow. Newer versions of Docker have a great feature called multi-stage builds, which allow you to define a multi-image process in an easy-to-read manner and maintain a singular <code class="Code-In-Text--PACKT-">Dockerfile</code>.</p>
    <p class="normal">At the end of the process, you can extract an optimized container image as our deliverable artifact, shedding the complexity of the images used previously in the process.</p>
    <p class="normal">As a reminder, your single <code class="Code-In-Text--PACKT-">Dockerfile</code> would look like the following sample:</p>
    <pre class="programlisting"><code class="hljs dockerfile"><strong>Dockerfile</strong>
<span class="hljs-keyword">FROM</span> duluca/minimal-node-web-server:lts-alpine 
<span class="hljs-keyword">WORKDIR</span><span class="bash"> /usr/src/app</span>
<span class="hljs-keyword">COPY</span><span class="bash"> dist/lemon-mart public</span>
</code></pre>
    <h2 class="title" id="_idParaDest-333">Multi-stage Dockerfiles</h2>
    <p class="normal">Multi-stage builds work by using multiple <code class="Code-In-Text--PACKT-">FROM</code> statements in a single <code class="Code-In-Text--PACKT-">Dockerfile</code>, where <a id="_idIndexMarker1040"/>each stage can perform a task <a id="_idIndexMarker1041"/>and make any resources within its instance available to other stages. In a build environment, we can implement various build-related tasks as their own stages, and then copy the end result, such as the <code class="Code-In-Text--PACKT-">dist</code> folder of an Angular build, to the final image, which contains a web server. In this case, we will implement three stages of images:</p>
    <ul>
      <li class="list"><strong class="bold">Builder</strong>: Used to <a id="_idIndexMarker1042"/>build a production version of your Angular app</li>
      <li class="list"><strong class="bold">Tester</strong>: Used to <a id="_idIndexMarker1043"/>run unit and e2e tests against headless Chrome instances</li>
      <li class="list"><strong class="bold">Web server</strong>: The final <a id="_idIndexMarker1044"/>result containing only the optimized production bits</li>
    </ul>
    <div class="note">
      <p class="Information-Box--PACKT-">Multi-stage <a id="_idIndexMarker1045"/>builds require Docker version 17.05 or higher. To read more about multi-stage builds, read the documentation at <a href="https://docs.docker.com/develop/develop-images/multistage-build"><span class="url">https://docs.docker.com/develop/develop-images/multistage-build</span></a>.</p>
    </div>
    <p class="normal">As the <a id="_idIndexMarker1046"/>following diagram shows, the builder <a id="_idIndexMarker1047"/>will build the application and the tester will execute the tests:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_17.png"/></figure>
    <p class="packt_figref">Figure 9.17: Multi-stage Dockerfile</p>
    <p class="normal">The final image will be built using the outcome of the builder step.</p>
    <p class="normal">Start by creating a new file to implement the multi-stage configuration, named <code class="Code-In-Text--PACKT-">integration.Dockerfile</code>, at the root of your project.</p>
    <h3 class="title" id="_idParaDest-334">Builder</h3>
    <p class="normal">The first stage is <code class="Code-In-Text--PACKT-">builder</code>. We need a lightweight build environment that can ensure consistent <a id="_idIndexMarker1048"/>builds across the board. For this purpose, I've created a sample Alpine-based Node build environment complete with the npm, bash, and Git tools. This <a id="_idIndexMarker1049"/>minimal container is called <code class="Code-In-Text--PACKT-">duluca/minimal-node-build-env</code>, which is based on node-alpine and can be found on <a id="_idIndexMarker1050"/>Docker Hub at <a href="https://hub.docker.com/r/duluca/minimal-node-build-env"><span class="url">https://hub.docker.com/r/duluca/minimal-node-build-env</span></a>. This image is about 10 times smaller than node.</p>
    <p class="normal">The size of Docker images has a real impact on build times, since the CI server or your team members will spend extra time pulling a larger image. Choose the environment that best fits your needs.</p>
    <p class="normal">Let's create a builder using a suitable base image:</p>
    <ol>
      <li class="list" value="1">Ensure that you have the <code class="Code-In-Text--PACKT-">build:prod</code> command in place in <code class="Code-In-Text--PACKT-">package.json</code>:
        <pre class="programlisting"><code class="hljs actionscript"><strong><span class="hljs-class"><span class="hljs-keyword">package</span>.<span class="hljs-title">json</span></span></strong><span class="hljs-class">
"<span class="hljs-title">scripts</span>": {</span>
  <span class="hljs-string">"build:prod"</span>: <span class="hljs-string">"ng build --prod"</span>,
}
</code></pre>
      </li>
      <li class="list">Inherit from a Node.js-based build environment, such as <code class="Code-In-Text--PACKT-">node:lts-alpine</code> or <code class="Code-In-Text--PACKT-">duluca/minimal-node-build-env:lts-alpine</code>.</li>
      <li class="list" value="3">Implement your environment-specific build script in a new <code class="Code-In-Text--PACKT-">Dockerfile</code>, named <code class="Code-In-Text--PACKT-">integration.Dockerfile</code>, as shown:
        <pre class="programlisting"><code class="hljs routeros"><strong>integration.Dockerfile</strong>
<span class="hljs-keyword">FROM</span> duluca/minimal-node-build-env:lts-alpine as builder
ENV <span class="hljs-attribute">BUILDER_SRC_DIR</span>=/usr/src
<span class="hljs-comment"># setup source code directory and copy source code</span>
WORKDIR <span class="hljs-variable">$BUILDER_SRC_DIR</span>
COPY . .
<span class="hljs-comment"># install dependencies and build</span>
<span class="hljs-builtin-name">RUN</span> npm ci
<span class="hljs-builtin-name">RUN</span> npm <span class="hljs-builtin-name">run</span> style
<span class="hljs-builtin-name">RUN</span> npm <span class="hljs-builtin-name">run</span> lint
<span class="hljs-builtin-name">RUN</span> npm <span class="hljs-builtin-name">run</span> build:prod
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p>CI environments will check out your source code from GitHub and place it in the current directory. So, copying the source code from the <strong class="bold">current working directory</strong> (<strong class="bold">CWD</strong>) using <a id="_idIndexMarker1051"/>the dot notation should work, as it does in your local development environment. If you run into issues, refer to your CI provider's documentation.</p>
    </div>
    <p class="normal">Next, let's see <a id="_idIndexMarker1052"/>how you can debug your Docker build.</p>
    <h4 class="title">Debugging build environments</h4>
    <p class="normal">Depending on <a id="_idIndexMarker1053"/>your particular needs, your initial setup of the builder portion of the Dockerfile may be frustrating. To test out new commands or debug errors, you may need to directly interact with the build environment.</p>
    <p class="normal">To interactively experiment and/or debug within the build environment, execute the following command:</p>
    <pre class="programlisting"><code class="hljs crmsh">$ docker run -it duluca/minimal-<span class="hljs-keyword">node</span>-build-env:<span class="hljs-title">lts-alpine</span> /bin/bash
</code></pre>
    <p class="normal">You can test or debug commands within this temporary environment before baking them into your <code class="Code-In-Text--PACKT-">Dockerfile</code>.</p>
    <h3 class="title" id="_idParaDest-335">Tester</h3>
    <p class="normal">The second stage is <code class="Code-In-Text--PACKT-">tester</code>. By default, the Angular CLI generates a testing requirement that is geared <a id="_idIndexMarker1054"/>toward a development environment. This will not work in a CI environment; we must configure Angular to work against a headless browser that can execute without the assistance of a GPU and, furthermore, a containerized environment to execute the tests against.</p>
    <p class="normal">Angular testing tools are covered in <em class="italics">Chapter 4</em>, <em class="italics">Automated Testing, CI, and Release to Production</em>.</p>
    <h4 class="title">Conﬁguring a headless browser for Angular</h4>
    <p class="normal">The protractor <a id="_idIndexMarker1055"/>testing tool officially supports <a id="_idIndexMarker1056"/>running against Chrome in headless mode. In order to execute Angular tests in a CI environment, you will need to configure your test runner, Karma, to run with a headless Chrome instance:</p>
    <ol>
      <li class="list" value="1">Update <code class="Code-In-Text--PACKT-">karma.conf.js</code> to include a new headless browser option:
        <pre class="programlisting"><code class="hljs css"><strong><span class="hljs-selector-tag">Karma</span><span class="hljs-selector-class">.conf</span><span class="hljs-selector-class">.js</span></strong>
...
    <span class="hljs-selector-tag">browsers</span>: <span class="hljs-selector-attr">[<span class="hljs-string">'Chrome'</span>, <span class="hljs-string">'ChromiumHeadless'</span>, <span class="hljs-string">'ChromiumNoSandbox'</span>]</span>,
    <span class="hljs-selector-tag">customLaunchers</span>: {
      <span class="hljs-attribute">ChromiumHeadless</span>: {
        base: <span class="hljs-string">'Chrome'</span>,
        flags: [
          <span class="hljs-string">'--headless'</span>,
          <span class="hljs-string">'--disable-gpu'</span>,
          // Without a remote debugging port, Google Chrome exits immediately.
          <span class="hljs-string">'--remote-debugging-port=9222'</span>,
          ],
        debug: true,
      },
      <span class="hljs-selector-tag">ChromiumNoSandbox</span>: {
        <span class="hljs-attribute">base</span>: <span class="hljs-string">'ChromiumHeadless'</span>,
        flags: [<span class="hljs-string">'--no-sandbox'</span>, <span class="hljs-string">'--disable-translate'</span>, <span class="hljs-string">'--disable- extensions'</span>]
      },
    },
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">The <code class="Code-In-Text--PACKT-">ChromiumNoSandbox</code> custom launcher encapsulates all the configuration elements needed for a good default setup.</p>
      </li>
      <li class="list">Update <a id="_idIndexMarker1057"/>the <code class="Code-In-Text--PACKT-">protractor</code> configuration <a id="_idIndexMarker1058"/>to run in headless mode:
        <pre class="programlisting"><code class="hljs vim"><strong>e2e/protractor.<span class="hljs-keyword">conf</span>.js</strong>
...
  capabilitie<span class="hljs-variable">s:</span> { 
    browserName: <span class="hljs-string">'chrome'</span>,
    chromeOption<span class="hljs-variable">s:</span> {
      arg<span class="hljs-variable">s:</span> [
        <span class="hljs-string">'--headless'</span>,
        <span class="hljs-string">'--disable-gpu'</span>,
        <span class="hljs-string">'--no-sandbox'</span>,
        <span class="hljs-string">'--disable-translate'</span>,
        <span class="hljs-string">'--disable-extensions'</span>,
        <span class="hljs-string">'--window-size=800,600'</span>,
      ],
    },
  },
...
</code></pre>
        <div class="note">
          <p class="Information-Box--PACKT-">In order to test your application for responsive scenarios, you can use the <code class="Code-In-Text--PACKT-">--window-size</code> option, as shown earlier, to change the browser settings.</p>
        </div>
      </li>
      <li class="list">Update the <code class="Code-In-Text--PACKT-">package.json</code> scripts to select the new browser option in the production build scenarios:
        <pre class="programlisting"><code class="hljs jboss-cli"><strong>package.json</strong>
<span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">...</span>
  <span class="hljs-string">"test"</span>: <span class="hljs-string">"ng test lemon-mart --browsers Chrome"</span>,
  <span class="hljs-string">"test:prod"</span>: <span class="hljs-string">"npm test -- --browsers ChromiumNoSandbox   --  watch=false"</span>
<span class="hljs-string">...</span>
}
</code></pre>
        <div class="packt_tip">
          <p>Note that <code class="Code-In-Text--PACKT-">test:prod</code> doesn't include <code class="Code-In-Text--PACKT-">npm run e2e</code>. e2e tests are integration tests that take longer to execute, so think twice about including them as <a id="_idIndexMarker1059"/>part of your critical build pipeline. e2e tests will not run on the lightweight testing environment mentioned in the next section, as they require more resources and time to execute.</p>
        </div>
      </li>
    </ol>
    <p class="normal">Now, let's define <a id="_idIndexMarker1060"/>the containerized testing environment.</p>
    <h4 class="title">Conﬁguring our testing environment</h4>
    <p class="normal">For a lightweight <a id="_idIndexMarker1061"/>testing environment, we will be leveraging an Alpine-based installation of the Chromium browser:</p>
    <ol>
      <li class="list" value="1">Inherit from <code class="Code-In-Text--PACKT-">duluca/minimal-node-chromium:lts-alpine</code>.</li>
      <li class="list" value="2">Append the following configuration to <code class="Code-In-Text--PACKT-">integration.Dockerfile</code>:
        <pre class="programlisting"><code class="hljs dockerfile"><strong>integration.Dockerfile</strong>
...
<span class="hljs-keyword">FROM</span> duluca/minimal-node-chromium:lts-alpine as tester
<span class="hljs-keyword">ENV</span> BUILDER_SRC_DIR=/usr/src
<span class="hljs-keyword">ENV</span> TESTER_SRC_DIR=/usr/src
<span class="hljs-keyword">WORKDIR</span><span class="bash"> <span class="hljs-variable">$TESTER_SRC_DIR</span></span>
<span class="hljs-keyword">COPY</span><span class="bash"> --from=builder <span class="hljs-variable">$BUILDER_SRC_DIR</span> .</span>
<span class="hljs-comment"># force update the webdriver, so it runs with latest version of Chrome</span>
<span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">cd</span> ./node_modules/protractor &amp;&amp; npm i webdriver-manager@latest</span>
<span class="hljs-keyword">WORKDIR</span><span class="bash"> <span class="hljs-variable">$TESTER_SRC_DIR</span></span>
<span class="hljs-keyword">RUN</span><span class="bash"> npm run <span class="hljs-built_in">test</span>:prod</span>
</code></pre>
      </li>
    </ol>
    <p class="normal">The preceding <a id="_idIndexMarker1062"/>script will copy the production build from the <code class="Code-In-Text--PACKT-">builder</code> stage and execute your test scripts in a predictable manner.</p>
    <h3 class="title" id="_idParaDest-336">Web server</h3>
    <p class="normal">The third <a id="_idIndexMarker1063"/>and final stage generates the container that will be your web server. Once this stage is complete, the prior stages will be discarded, and the end result will be an optimized sub-10 MB container:</p>
    <ol>
      <li class="list" value="1">Append the following <code class="Code-In-Text--PACKT-">FROM</code> statement at the end of the file to build the web server, but this time, <code class="Code-In-Text--PACKT-">COPY</code> the production-ready code from <code class="Code-In-Text--PACKT-">builder</code>, as shown in the following code snippet:
        <pre class="programlisting"><code class="hljs dockerfile"><strong>integration.Dockerfile</strong>
...
<span class="hljs-keyword">FROM</span> duluca/minimal-nginx-web-server:<span class="hljs-number">1</span>-alpine as webserver
<span class="hljs-keyword">ENV</span> BUILDER_SRC_DIR=/usr/src
<span class="hljs-keyword">COPY</span><span class="bash"> --from=builder <span class="hljs-variable">$BUILDER_SRC_DIR</span>/dist/lemon-mart /var/www</span>
<span class="hljs-keyword">CMD</span><span class="bash"> <span class="hljs-string">'nginx'</span></span>
</code></pre>
      </li>
      <li class="list">Build and test your multi-stage <code class="Code-In-Text--PACKT-">Dockerfile</code>:
        <pre class="programlisting"><code class="hljs powershell"><span class="hljs-variable">$</span> docker build <span class="hljs-operator">-f</span> integration.Dockerfile .
</code></pre>
        <div class="note">
          <p class="Information-Box--PACKT-">Depending on your operating system, you may see Terminal errors. So long as the Docker image successfully builds in the end, then you can safely ignore these errors. For reference purposes, when we later build this image on CircleCI, no errors are logged on the CI server.</p>
        </div>
      </li>
      <li class="list" value="3">Save your script as a new npm script named <code class="Code-In-Text--PACKT-">build:integration</code>, as shown:
        <pre class="programlisting"><code class="hljs routeros"><strong>package.json</strong>
<span class="hljs-string">"scripts"</span>: {
<span class="hljs-built_in">..</span>.
  <span class="hljs-string">"build:integration"</span>: <span class="hljs-string">"cross-conf-env docker image build -f integration.Dockerfile . -t <span class="hljs-variable">$npm_package_config_imageRepo</span>:latest"</span>,
<span class="hljs-built_in">..</span>.
}
</code></pre>
      </li>
    </ol>
    <p class="normal">Great work! You've defined a custom build and test environment. Let's visualize the end result of our efforts as follows:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_18.png"/></figure>
    <p class="packt_figref">Figure 9.18: Multi-stage build environment results</p>
    <p class="normal">By leveraging a multi-stage <code class="Code-In-Text--PACKT-">Dockerfile</code>, we can define a customized build environment, and only ship the necessary bytes at the end of the process. In the preceding <a id="_idIndexMarker1064"/>example, we are avoiding shipping 250+ MB of development dependencies to our production server and only delivering a 7 MB container that has a minimal memory footprint.</p>
    <p class="normal">Now, let's execute this containerized pipeline on CircleCI.</p>
    <h2 class="title" id="_idParaDest-337">CircleCI container-in-container</h2>
    <p class="normal">In <em class="italics">Chapter 4</em>, <em class="italics">Automated Testing, CI, and Release to Production</em>, we created a relatively simple <a id="_idIndexMarker1065"/>CircleCI file. Later on, we will repeat the same configuration for this project as well, but for now, we will be using a container-within-a-container setup leveraging the multi-stage <code class="Code-In-Text--PACKT-">Dockerfile</code> we just created.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">On the <strong class="bold">lemon-mart</strong> repo, the <code class="Code-In-Text--PACKT-">config.yml</code> file for this section is named <code class="Code-In-Text--PACKT-">.circleci/config.docker-integration.yml</code>. You can also find a pull request that executes the <code class="Code-In-Text--PACKT-">.yml</code> file from this chapter on CircleCI at <a href="https://github.com/duluca/lemon-mart/pull/25"><span class="url">https://github.com/duluca/lemon-mart/pull/25</span></a> using the <code class="Code-In-Text--PACKT-">docker-integration </code>branch.</p>
      <p class="Information-Box--PACKT-">Note that this build uses a modified <code class="Code-In-Text--PACKT-">integration.Dockerfile</code> to use the <code class="Code-In-Text--PACKT-">projects/ch8</code> code from <strong class="bold">lemon-mart</strong>.</p>
    </div>
    <p class="normal">In your <a id="_idIndexMarker1066"/>source code, create a folder named <code class="Code-In-Text--PACKT-">.circleci</code> and add a file named <code class="Code-In-Text--PACKT-">config.yml</code>:</p>
    <pre class="programlisting"><code class="hljs yaml"><strong><span class="hljs-string">.circleci/config.yml</span></strong>
<span class="hljs-attr">version:</span> <span class="hljs-number">2.1</span>
<span class="hljs-attr">jobs:</span>
  <span class="hljs-attr">build:</span>
    <span class="hljs-attr">docker:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">circleci/node:lts</span>
    <span class="hljs-attr">working_directory:</span> <span class="hljs-string">~/repo</span>
    <span class="hljs-attr">steps:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">checkout</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">setup_remote_docker</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">Execute</span> <span class="hljs-string">Pipeline</span> <span class="hljs-string">(Build</span> <span class="hljs-string">Source</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">Test</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">Build</span> <span class="hljs-string">Web</span> <span class="hljs-string">Server)</span>
          <span class="hljs-attr">command:</span> <span class="hljs-string">|
            docker build -f integration.Dockerfile . -t lemon-mart:$CIRCLE_BRANCH
            mkdir -p docker-cache
            docker save lemon-mart:$CIRCLE_BRANCH | gzip &gt; docker-cache/built-image.tar.gz
</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">save_cache:</span>
          <span class="hljs-attr">key:</span> <span class="hljs-string">built-image-{{</span> <span class="hljs-string">.BuildNum</span> <span class="hljs-string">}}</span>
          <span class="hljs-attr">paths:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">docker-cache</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">store_artifacts:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">docker-cache/built-image.tar.gz</span>
          <span class="hljs-attr">destination:</span> <span class="hljs-string">built-image.tar.gz</span>
<span class="hljs-attr">workflows:</span>
  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">build-and-deploy:</span>
    <span class="hljs-attr">jobs:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">build</span>
</code></pre>
    <p class="normal">In the preceding <code class="Code-In-Text--PACKT-">config.yml</code> file, a workflow named <code class="Code-In-Text--PACKT-">build-and-deploy</code> is defined, which contains a job named <code class="Code-In-Text--PACKT-">build</code>. The job uses CircleCI's pre-built <code class="Code-In-Text--PACKT-">circleci/node:lts image</code>.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">build</code> job has five steps: </p>
    <ol>
      <li class="list" value="1"><code class="Code-In-Text--PACKT-">checkout</code> checks out the source code from GitHub.</li>
      <li class="list"><code class="Code-In-Text--PACKT-">setup_remote_docker</code> informs CircleCI to set up a Docker-within-Docker environment, so we can run containers within our pipeline. </li>
      <li class="list"><code class="Code-In-Text--PACKT-">run</code> executes the <code class="Code-In-Text--PACKT-">docker build -f integration.Dockerfile .</code> command to initiate our custom build process, caches the resulting Alpine-based image, and tags it with <code class="Code-In-Text--PACKT-">$CIRCLE_BRANCH.</code></li>
      <li class="list"><code class="Code-In-Text--PACKT-">save_cache</code> saves the image we created in the cache, so it can be consumed by the next step.</li>
      <li class="list" value="5"><code class="Code-In-Text--PACKT-">store_artifacts</code> reads the created image from the cache and publishes the image as a build artifact, which can be downloaded from the web interface or used by another job to deploy it to a cloud environment.</li>
    </ol>
    <p class="normal">After you <a id="_idIndexMarker1067"/>sync your changes to GitHub, if everything goes well, you will have a passing <em class="italics">green</em> build. As shown in the following screenshot, this build was successful:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_19.png"/></figure>
    <p class="packt_figref">Figure 9.19: Green build on CircleCI using the lemon-mart docker-integration branch</p>
    <div class="packt_tip">
      <p>Note that the tarred and gzipped image file size is 9.2 MB, which includes our web applications on top of the roughly 7 MB base image size.</p>
    </div>
    <p class="normal">At the moment, the CI server is running and executing our three-step pipeline. As you can see in <a id="_idIndexMarker1068"/>the preceding screenshot, the build is producing a tarred and gzipped file of the web server image, named <code class="Code-In-Text--PACKT-">built-image.tar.gz</code>. You can download <a id="_idIndexMarker1069"/>this file from the <strong class="bold">Artifacts</strong> tab. However, we're not deploying the resulting image to a server.</p>
    <p class="normal">You have now adequately mastered working with CircleCI. We will revisit this multi-stage <code class="Code-In-Text--PACKT-">Dockerfile</code> to perform a deployment on AWS in <em class="italics">Chapter 13</em>, <em class="italics">Highly Available Cloud Infrastructure on AWS</em>.</p>
    <p class="normal">Next, let's see how you can get a code coverage report from your Angular app and record the result in CircleCI.</p>
    <h1 class="title" id="_idParaDest-338">Code coverage reports</h1>
    <p class="normal">A good way to understand the amount and the trends of unit test coverage for your Angular <a id="_idIndexMarker1070"/>project is through a code coverage report.</p>
    <p class="normal">In order to generate the report for your app, execute the following command from your <code class="Code-In-Text--PACKT-">project</code> folder:</p>
    <pre class="programlisting"><code class="hljs brainfuck"><span class="hljs-comment">$</span> <span class="hljs-comment">npx</span> <span class="hljs-comment">ng</span> <span class="hljs-comment">test</span> --<span class="hljs-comment">browsers</span> <span class="hljs-comment">ChromiumNoSandbox</span> --<span class="hljs-comment">watch=false</span> --<span class="hljs-comment">code</span><span class="hljs-literal">-</span><span class="hljs-comment">coverage</span>
</code></pre>
    <p class="normal">The resulting report will be created as an HTML file under a folder named <code class="Code-In-Text--PACKT-">coverage</code>; execute the following command to view it in your browser:</p>
    <pre class="programlisting"><code class="hljs angelscript">$ npx http-server -c<span class="hljs-number">-1</span> -o -p <span class="hljs-number">9875</span> ./coverage
</code></pre>
    <div class="packt_tip">
      <p>Install <code class="Code-In-Text--PACKT-">http-server</code> as a development dependency in your project.</p>
    </div>
    <p class="normal">Here's the folder-level sample coverage report generated by <code class="Code-In-Text--PACKT-">istanbul/nyc</code> for LemonMart:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_20.png"/></figure>
    <p class="packt_figref">Figure 9.20: Istanbul code coverage report for LemonMart</p>
    <p class="normal">You can drill <a id="_idIndexMarker1071"/>down on a particular folder, such as <code class="Code-In-Text--PACKT-">src/app/auth</code>, and get a file-level report, as shown here:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_21.png"/></figure>
    <p class="packt_figref">Figure 9.21: Istanbul code coverage report for src/app/auth</p>
    <p class="normal">You can <a id="_idIndexMarker1072"/>drill down further to get line-level coverage for a given file, such as <code class="Code-In-Text--PACKT-">cache.service.ts</code>, as shown here:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14094_09_22.png"/></figure>
    <p class="packt_figref">Figure 9.22: Istanbul code coverage report for cache.service.ts</p>
    <p class="normal">In the preceding screenshot, you can see that lines <strong class="bold">5</strong>, <strong class="bold">12</strong>, <strong class="bold">17-18</strong>, and <strong class="bold">21-22</strong> are not covered by any test. The <strong class="screen-text">I</strong> icon denotes that the <code class="Code-In-Text--PACKT-">if</code> path was not taken. We can increase our code coverage by implementing unit tests that exercise the functions that are contained within <code class="Code-In-Text--PACKT-">CacheService</code>. As an exercise, the reader should attempt to at least cover one of these functions with a new unit test and observe the code coverage report change.</p>
    <h2 class="title" id="_idParaDest-339">Code coverage in CI</h2>
    <p class="normal">Ideally, your CI server <a id="_idIndexMarker1073"/>configuration should generate and host <a id="_idIndexMarker1074"/>the code coverage report with every test run. You can then use code coverage as another code quality gate to prevent pull requests being merged if the new code is bringing down the overall code coverage <a id="_idIndexMarker1075"/>percentage. This is a great way to reinforce the <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>) mindset.</p>
    <p class="normal">You can use <a id="_idIndexMarker1076"/>a service such as Coveralls, found at <a href="https://coveralls.io/"><span class="url">https://coveralls.io/</span></a>, to implement <a id="_idIndexMarker1077"/>your code coverage <a id="_idIndexMarker1078"/>checks, which can embed your code coverage levels directly on a GitHub pull request.</p>
    <p class="normal">Let's configure Coveralls for LemonMart:</p>
    <div class="note">
      <p class="Information-Box--PACKT-">On the <strong class="bold">lemon-mart</strong> repo, the <code class="Code-In-Text--PACKT-">config.yml</code> file for this section is named <code class="Code-In-Text--PACKT-">.circleci/config.ch9.yml</code>.</p>
    </div>
    <ol>
      <li class="list" value="1">In your CircleCI account settings, under the security section, ensure that you allow execution of uncertified/unsigned orbs.</li>
      <li class="list">Register your GitHub project at <a href="https://coveralls.io/"><span class="url">https://coveralls.io/</span></a>.</li>
      <li class="list">Copy the repo token and store it as an environment variable in CircleCI named <code class="Code-In-Text--PACKT-">COVERALLS_REPO_TOKEN</code>.</li>
      <li class="list">Create a new branch before you make any code changes.</li>
      <li class="list">Update <code class="Code-In-Text--PACKT-">karma.conf.js</code> so it stores code coverage results under the <code class="Code-In-Text--PACKT-">coverage</code> folder:
        <pre class="programlisting"><code class="hljs css"><strong><span class="hljs-selector-tag">karma</span><span class="hljs-selector-class">.conf</span><span class="hljs-selector-class">.js</span></strong>
...
    <span class="hljs-selector-tag">coverageIstanbulReporter</span>: {
      <span class="hljs-attribute">dir</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>).<span class="hljs-built_in">join</span>(__dirname, <strong><span class="hljs-string">'coverage'</span></strong>),
      reports: [<span class="hljs-string">'html'</span>, <span class="hljs-string">'lcovonly'</span>],
      fixWebpackSourcePaths: true,
    },
...
</code></pre>
      </li>
      <li class="list">Update the <code class="Code-In-Text--PACKT-">.circleci/config.yml</code> file with the Coveralls orb as shown:
        <pre class="programlisting"><code class="hljs angelscript"><strong>.circleci/config.yml</strong>
version: <span class="hljs-number">2.1</span>
orbs:
  <strong>coveralls: coveralls/<span class="hljs-symbol">coveralls@</span><span class="hljs-number">1.0</span><span class="hljs-number">.4</span></strong>
</code></pre>
      </li>
      <li class="list">Update the <code class="Code-In-Text--PACKT-">build</code> job to store code coverage results and upload them to Coveralls:
        <pre class="programlisting"><code class="hljs yaml"><strong><span class="hljs-string">.circleci/config.yml</span></strong>
<span class="hljs-attr">jobs:</span>
  <span class="hljs-attr">build:</span>
    <span class="hljs-string">...</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">test</span> <span class="hljs-string">--</span> <span class="hljs-string">--watch=false</span> <span class="hljs-string">--code-coverage</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">e2e</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">store_test_results:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">./test_results</span>
      <strong><span class="hljs-bullet">-</span> <span class="hljs-attr">store_artifacts:</span></strong>
<strong>          <span class="hljs-attr">path:</span> <span class="hljs-string">./coverage</span></strong>
<strong>      <span class="hljs-bullet">-</span> <span class="hljs-string">coveralls/upload</span></strong>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span>
          <span class="hljs-attr">name:</span> <span class="hljs-string">Tar</span> <span class="hljs-string">&amp;</span> <span class="hljs-string">Gzip</span> <span class="hljs-string">compiled</span> <span class="hljs-string">app</span>
          <span class="hljs-attr">command:</span> <span class="hljs-string">tar</span> <span class="hljs-string">zcf</span> <span class="hljs-string">dist.tar.gz</span> <span class="hljs-string">dist/lemon-mart</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">store_artifacts:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">dist.tar.gz</span>
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note that the orb automatically configures Coveralls for your account, so the <code class="Code-In-Text--PACKT-">coveralls</code>/<code class="Code-In-Text--PACKT-">upload</code> command can upload your code coverage results. </p>
      </li>
      <li class="list">Commit <a id="_idIndexMarker1079"/>your changes to the branch and publish it.</li>
      <li class="list">Create <a id="_idIndexMarker1080"/>a pull request on GitHub using the branch.</li>
      <li class="list">On the pull request, verify that you can see that Coveralls is reporting your project's code coverage, as shown:<figure class="mediaobject"><img alt="" src="../Images/B14094_09_23.png"/></figure>
        <p class="packt_figref">Figure 9.23: Coveralls reporting code coverage</p>
      </li>
      <li class="list" value="11">Merge the pull request to your master branch.</li>
    </ol>
    <p class="normal">Congratulations! Now, you can modify your branch protection rules to require that code coverage <a id="_idIndexMarker1081"/>levels must be above <a id="_idIndexMarker1082"/>a certain percentage before a pull request can be merged to master.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The LemonMart <a id="_idIndexMarker1083"/>project at <a href="https://github.com/duluca/lemon-mart"><span class="url">https://github.com/duluca/lemon-mart</span></a> implements a full-featured <code class="Code-In-Text--PACKT-">config.yml</code> file. This <a id="_idIndexMarker1084"/>file also implements <a href="http://Cypress.io"><span class="url">Cypress.io</span></a>, a far more robust solution compared to Angular's e2e tool, in CircleCI as well. The Cypress orb can record test results and allow you to view them from your CircleCI pipeline.</p>
    </div>
    <p class="normal">Leveraging what you have learned in this chapter, you can incorporate the <code class="Code-In-Text--PACKT-">deploy</code> scripts from LocalCast Weather for LemonMart and implement a gated deployment workflow.</p>
    <h1 class="title" id="_idParaDest-340">Summary</h1>
    <p class="normal">In this chapter, you learned about DevOps and Docker. You containerized your web app, deployed a container to Google Cloud Run using CLI tools, and learned how to implement gated CI workflows. You leveraged advanced CI techniques to build a container-based CI environment leveraging a multi-stage <code class="Code-In-Text--PACKT-">Dockerfile</code>. Also, you became familiar with orbs, workflows, and code coverage tools.</p>
    <p class="normal">We leveraged CircleCI as a cloud-based CI service and highlighted the fact that you can deploy the outcome of your builds to all major cloud hosting providers. You have seen how you can achieve CD. We covered example deployments to Vercel Now and Google Cloud Run via CircleCI, allowing you to implement automated deployments.</p>
    <p class="normal">With a robust CI/CD pipeline, you can share every iteration of your app with clients and team members and quickly deliver bug fixes or new features to your end users.</p>
    <h1 class="title" id="_idParaDest-341">Exercise</h1>
    <ol>
      <li class="list" value="1"> Add CircleCI and Coveralls badges to the <code class="Code-In-Text--PACKT-">README.md</code> file on your code repository.</li>
      <li>Implement Cypress for e2e testing and run it in your CircleCI pipeline using the Cypress orb.</li>
      <li>Implement a Vercel Now deployment and a conditional workflow for the Lemon Mart app. You can find the resulting <code class="Code-In-Text--PACKT-">config.yml</code> file on the lemon-mart repo, named <code class="Code-In-Text--PACKT-">.circleci/config.ch9.yml</code>.</li>
    </ol>
    <h1 class="title" id="_idParaDest-342">Further reading</h1>
    <ul>
      <li class="list"><em class="italics">Dockerfile reference</em>, 2020, <a href="https://docs.docker.com/engine/reference/builder/"><span class="url">https://docs.docker.com/engine/reference/builder/</span></a></li>
      <li class="list"><em class="italics">CircleCI orbs</em>, 2020, <a href="https://circleci.com/orbs/"><span class="url">https://circleci.com/orbs/</span></a></li>
      <li class="list"><em class="italics">Deploying container images</em>, 2020, <a href="https://cloud.google.com/run/docs/depl"><span class="url">https://cloud.google.com/run/docs/depl</span></a>oying</li>
      <li class="list"><em class="italics">Creating and managing service account keys</em>, 2020, <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#iam-service-account-keys-cr"><span class="url">https://cloud.google.com/iam/docs/creating-managing-service-account-keys#iam-service-account-keys-create-console</span></a></li>
    </ul>
    <h1 class="title" id="_idParaDest-343">Questions</h1>
    <p class="normal">Answer the following questions as best as you can to ensure that you've understood the key concepts from this chapter without Googling. Do you need help answering the questions? See <em class="italics">Appendix D</em>, <em class="italics">Self-Assessment Answers</em> online at <a href="https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf"><span class="url">https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf</span></a> or visit <a href="https://expertlysimple.io/angular-self-assessment"><span class="url">https://expertlysimple.io/angular-self-assessment</span></a>.</p>
    <ol>
      <li class="list" value="1">Explain the difference between a Docker image and a Docker container.</li>
      <li>What is the purpose of a CD pipeline?</li>
      <li>What is the benefit of CD?</li>
      <li>How do we cover the configuration gap?</li>
      <li>What does a CircleCI orb do?</li>
      <li>What are the benefits of using a multi-stage <code class="Code-In-Text--PACKT-">Dockerfile</code>?</li>
      <li>How does a code coverage report help maintain the quality of your app?</li>
    </ol>
  </div>
</body></html>