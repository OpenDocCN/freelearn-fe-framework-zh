- en: Create React App and Babel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you come from a background where maybe you haven't worked with JavaScript
    for a long time, or maybe you're new to JavaScript and Create React App is your
    conduit for using it, you may see a lot of syntax throughout this book and while
    exploring other people's projects and find that the code is hard to read without
    a thorough understanding of what's going on. This chapter aims to bridge that
    gap for people who are new to Babel and describe what it brings to the table with
    our Create React App project.
  prefs: []
  type: TYPE_NORMAL
- en: The other goal of this chapter is for people who are already comfortable with
    JavaScript, but are curious about what features Babel introduces and has turned
    on by default in a Create React App project, so that you can take advantage of
    all of the quality-of-life improvements and cleaner syntax rules in your project
    and really put that finishing touch on your project. The goal is to teach you
    production-ready code so that you're able to contribute at the highest level on
    your React projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we work through this chapter, you can expect to get caught up on the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Const variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New arrow function syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array and object destructuring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array and object spread operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Fragments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Babel and the latest JavaScript syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve been building up this application to act as our base and in the process
    we''ve introduced a lot of syntax that may not be the same JavaScript that you''re
    used to writing! For example, we''ve written a few functions with this sort of
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax here is not particularly tricky and you can probably figure out
    what''s going on, but maybe you don''t fully understand how all of that ends up
    as a function when all is said and done. You may be more used to writing functions
    in a similar pattern to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or maybe something more like a function declaration without the variable, such
    as the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The reality is that as JavaScript progresses, there are new and more efficient
    methods of writing a large variety of different language constructs. Some offer
    helpful shortcuts, or maybe they provide a nice quality-of-life improvement for
    developers. Since Create React App runs on Node.js, we get some syntax improvements
    here and there, but generally speaking, Node integrates those new features and
    syntax into its standard library at a much slower pace.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of this chapter, we'll dive deeper into how to write, incorporate,
    and, most importantly, *understand* modern JavaScript code in our Create React
    App projects. We'll take a look at what features are currently supported in Create
    React App and learn how to take full advantage of each and every one of them!
  prefs: []
  type: TYPE_NORMAL
- en: What is Babel?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Babel is designed to bridge the gap between *the features JavaScript will have*
    and *the features Node.js supports right now*, and turn that resulting code into
    something that Node.js can understand. That means that even if Node chooses not
    to support something (or maybe can't support due to incompatibilities with an
    existing system) you're still covered!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand why Babel is incorporated by default into Create React App projects,
    you need to understand a little bit of its history (similar to why it's helpful
    to understand the history of why Create React App was turned into a tool). Back
    before this handy little CLI tool, a lot of the configuration was manual, and,
    typically, these projects would be either built against vanilla Node.js or on
    browsers directly. Whatever JavaScript you wanted to do was limited to the minimum
    number of features that would be supported against either every version of Node
    that could run your code or every browser you chose to support with your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, you ended up with basically no support for anything fun or quality
    of life either. Think of it like the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Browser** | **Feature A** | **Feature B** | **Feature C** | **Feature D**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Internet Explorer | No | Yes | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| Firefox | Yes | Yes | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Chrome | Yes | Yes | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Safari | No | Yes | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| What my code can support | No | Yes | No | No |'
  prefs: []
  type: TYPE_TB
- en: Using the previous table as an example, we get to support *Feature B* in our
    project and absolutely nothing else! There's nothing more demoralizing than knowing
    you could potentially support some insanely great feature in your programming
    language but not being able to use it because some users would have negative or
    completely broken experiences.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe you and your company decide that you want to pare down the number of browsers
    you officially support so that you can get some of these new features. Now you
    need to make a decision about sacrificing your user base and alienating old and
    new users so that you can use newer language features. Maybe it makes for a better
    experience for your other users and that ends up being worth the cost, but then
    those decisions need to be made carefully and against what percentage of your
    users is using what. For example, if you decided you'd only support Safari, you'd
    alienate every single Windows user, not just every single Internet Explorer user.
  prefs: []
  type: TYPE_NORMAL
- en: These decisions are heavy and have longstanding impacts to the health of your
    application. Alienating a user base at the start of your project's life could
    mean that it never recovers from that in the first place!
  prefs: []
  type: TYPE_NORMAL
- en: Where does Babel fit into the puzzle?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Babel comes to the rescue here by saying, *Hey, we'll give you those language
    f**eatures you want to use, but that not enough browsers support*. This becomes
    a massive relief as you start to use a larger and larger code base and run around
    some of the worst ways you used to have to architect larger JavaScript applications!
    Now if you want to use imports and new syntax and anything else, you can just
    do so!
  prefs: []
  type: TYPE_NORMAL
- en: Babel acts as a **transpiler**, which is a very fancy way of saying that it
    takes your JavaScript code that everything may not be able to be understood and
    turns it into JavaScript code that will be able to be understood! Babel will,
    based on different configurations, settings, and something called **stages**,
    allow you to opt in to all kinds of new syntax and language features and ensure
    that your code will run on most modern browsers! Granted, nothing is ever bulletproof
    and you will, of course, find different scenarios that aren't supported by some
    particular browser. You can't win them all, unfortunately!
  prefs: []
  type: TYPE_NORMAL
- en: Exploring modern JavaScript with Babel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this section, we're going to explore the different modern
    JavaScript tricks and techniques that Babel allows us to use as a major part of
    our code. We'll take a look at the different ways that we can implement all kinds
    of different code and patterns, exploring the differences between the JavaScript
    standard ways to do certain tricks and the shorthand syntax that Babel will allow
    us to use. The first, especially if you haven't written any modern JavaScript
    in a long time, is the addition of different variable declarations, such as `const`
    and `let`.
  prefs: []
  type: TYPE_NORMAL
- en: The `let` variable allows us to declare a variable with very specific scoping
    rules. While `var` is scoped to the nearest function block and gets used as a
    result of that, `let` is instead scoped to the nearest block in general, and can't
    be used before it's declared. You also can't redeclare variables with the same
    name with `let`.
  prefs: []
  type: TYPE_NORMAL
- en: The `const` variable allows us to declare a constant with the same scoping rules
    as `let`, overall. The best practice is to use both of these far more than using
    `var`. In fact, I personally never use `var` if I'm working with code that I know
    supports const and let instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move on to the first more complex thing we''ve run into as part
    of our application code: JSX!'
  prefs: []
  type: TYPE_NORMAL
- en: JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at a very simple example of JSX code; something very similar to the
    code we've already written. It's easier for us to start off simple and build it
    up a little bit so you can see how JSX actually helps us write our code a little
    faster and smarter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, this is just a simple `HelloWorld div` in React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Like I said, nothing particularly fancy or difficult yet. Let''s take a look
    at the plain JavaScript version of this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It does the same thing at the end of the day: it creates an `HelloWorld` React
    component, and then that component itself contains a single `div` with an `HelloWorld`
    body as the text. Where this starts to get more complicated is when you have to
    start including child components as well. Using our previous an `HelloWorld` component,
    let''s expand it and make the person we''re greeting configurable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The analog in regular JavaScript would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open up our project and experiment with changing some of the syntax
    in our existing project to use the non-JSX method of creating React components
    and elements. Our goal is that we should get to a point where we''ve added a little
    divider in between each of the `Todo` items in our `TodoList` component. We shouldn''t
    have to modify too much to make this work, but we''re going to use the non-JSX
    method to build out the `Divider` component. We''ll start off by creating `src/Divider.js`
    and `src/Divider.css`, and then we''ll start off by writing `src/Divider.js` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s not a whole lot extra that we''re doing here; we''re creating a `div` container
    with a class of `Divider` (you can see here why `class` isn''t available for you
    to use in React JSX; it would not make sense, since `class` is what we use to
    declare classes, such as for our class-based stateful components). In our function,
    which doesn''t take in any additional properties, we return the results of the
    `React.createElement()` function. `React.createElement()` takes three arguments
    to its call: the main element we''re creating (either an HTML tag, such as `div`
    or `hr`, or the fully-qualified name of the function or variable, such as `Todo`),
    followed by an object with the properties that you''re passing on to this element,
    and finally the array of children that should live inside that component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll populate our `src/Divider.css` with some fancy CSS to make our
    `hr` into nice gradient-based dividing lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, go into `src/TodoList.js`, where we''ll `import` our new `Divider` and
    modify a little bit of code to include the new divider. First, we''ll start off
    with `import` at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we''ll actually place the `Divider` inside of the code. We''ll need to
    go down to the `renderItems()` function and change the body to wrap `Todo` inside
    of a `div` container (we can get around this by using React Fragments, but we''ll
    talk about this more a little bit later), and then include the `Divider` component
    at the bottom of that. Also, note that for each of the key properties in the following
    JSX code, we''re prefixing the "description" with a little description of the
    component we''re building to avoid collisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Save and reload, and we should have some new dividers breaking up our `Todo`
    items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55cd75f0-c009-40d2-b326-cabdd15d0f89.png)'
  prefs: []
  type: TYPE_IMG
- en: And there we are, a new `Divider` written entirely in vanilla JavaScript!
  prefs: []
  type: TYPE_NORMAL
- en: The next code snippet is just provided as an example of what a full, more complicated
    function would look like written without any JSX. You don't actually need to do
    any of this work!
  prefs: []
  type: TYPE_NORMAL
- en: 'Just for fun, let''s take a look at what our two `render()` function calls
    in `TodoList` would look like without JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Everything will still function exactly the same, so if this was something you
    wanted to pursue and you preferred this syntax to JSX, that remains an option
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Function syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's also spend a little bit of time talking about the different ways to write
    functions that we can take advantage of when using Babel paired with Create React
    App. In the code we wrote previously, we already talked a bit about this and showed
    a few examples of alternate function syntax, but we're going to dive more deeply
    into everything now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately, there are a few standard ways in JavaScript, without any frills,
    to declare a function. We can either choose the method of declaring a function
    with the `function` keyword, or we could declare it as a variable. Let''s look
    at a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also write this, without using any frills from Babel, via the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And the way that we''d invoke that function after having built it is just simply
    via the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'So now, think back to some of the other functions that we''ve written over
    the previous two chapters. We''ve frequently defined functions using a `const`
    statement, which would turn the `function` we''ve written previously into the
    following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: While this is practically identical to the variable method of declaring functions
    in old JavaScript, there's a minor difference in terms of the syntax that's worth
    pointing out, and that's in the way that the function signature is declared in
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, after our variable declaration, we'd write the function and then
    parentheses with the arguments in it. In modern JavaScript, we can use something
    called **arrow functions**. Arrow functions are a shorthand syntax shortcut with
    an extra benefit in terms of how `this` gets bound. Specifically, the context
    of `this` when the function is declared is the context of `this` when the function
    is declared. Instead of the function taking and defining its own context for `this`,
    it instead uses `this` in the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules for declaring arrow functions are pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have no arguments, you must declare the function with parentheses and
    then the fat arrow (`=>`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have one argument, you can optionally include the parentheses:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have two or more arguments, you must include the parentheses:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re returning something as a single-line function, you don''t need to
    use curly brackets or a `return` statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re returning something as a multi-line function, you must use curly
    brackets and a `return` statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Destructuring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modern JavaScript also gives us better access to destructuring. Destructuring
    is a way of matching the patterns in data structures (for example, in arrays or
    objects) and being able to turn those into individual variables in function arguments
    or in variable declarations. Let''s mess around with a few different examples
    to get a good feel for how destructuring works and how we can better take advantage
    of it. Open up `src/App.js`, where we''ll use destructuring a few times. Before
    we make our change, the `App` function should look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing exciting yet, so let''s make this code exciting! We''ll start off by
    allowing you to rename your app, since maybe you don''t feel that `Todoifier`
    is a great name for an app! We''ll start off by adding a simple data structure
    above our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll destructure this data structure into a single variable name. We''ll
    add the following line right after we declare our `details` data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'What we''re doing here is rewriting the structure of the data structure we
    created in the `details` variable and then saying that we want it to take the
    value in the `header` key of the `details` variable and ignore everything else,
    and then throw it into the `header` variable. The end result is that we should
    expect to see `Todoifier` in the `header` variable. Just to make sure, let''s
    throw a `console.log` statement and verify the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see it show up in our JavaScript console in the browser if all went
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2c19437-7a71-4369-983e-8c41f5fd9ba7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There we are! Now that we know this works, let''s hop back over to the `App`
    component and add in a reference to the `header` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When our page refreshes, we should see whatever value you threw in the `header`
    value in the `details` variable! Let''s make it a little cleaner and a little
    bit closer to what you''d normally expect to see in production code, because right
    now the code we''ve written is a bit redundant. Delete the reference to `appName`
    and the `console.log` statement and we''ll write a new function to use in our
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We're actually using a few separate tricks here! We're using the new function
    declaration syntax and simple function `return` syntax, and we're using destructuring
    to make our code super simple and clean! We destructure a passed-in argument to
    pull the `title` and `headerColor` out and store those in the title and `color`
    variables, respectively!
  prefs: []
  type: TYPE_NORMAL
- en: 'We then pass those into the `h2` tag to set the CSS `color` style and the displayed
    `title` of the application! The final step is that we need to hook up this component
    to use the new `header` function we just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And there we are! With this code in place, we should see a red header with
    the name Todoifier! Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d9b2a48-88cd-4dc7-8500-82dcaef778fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can actually destructure arrays as well! For example, let''s say we have
    a few unique options we want to start off our list with. We can capture those
    as named variables through array-destructuring, and we can also take advantage
    of some other syntax tricks we''ll learn later, such as array spreads! Let''s
    take a look at `src/TodoList.js` and change our constructor to use array-destructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Array-destructuring is just based on position; the only new trick here is that
    after matching `item1` and `item2`, we''re just going to throw the remainder of
    the array onto a variable called `rest`, which we''ll join with some spaces and
    the word `"and"`. Let''s see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/995f2163-34f3-4bbf-959f-5577a3b0cbeb.png)'
  prefs: []
  type: TYPE_IMG
- en: Optional arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting optional arguments for functions is thankfully a pretty simple endeavor!
    If you want to make a `function` argument optional, all you need to do is add
    an equals sign after the name of the parameter and give it a default value. For
    example, let''s revisit the `sayHello` function we wrote a little bit earlier
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s modify that so that if someone doesn''t specify a `name`, the function
    call will not just fail out or throw an error for the developer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that since we''re using an optional variable for the argument list, we
    need to enclose it in parentheses again! Now, if someone were to call that function
    without specifying any parameters, we''d expect to see in our console Hello Unknown!,
    something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, let''s write this into our previous `headerDisplay` function. It
    will be a little messy, sure, but it''s great to know how to use this effectively,
    since it''s a great way to implement defensive programming in your projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we were to go back and change our App component''s call to the `header()`
    function to just pass in a blank object, we would expect the header to instead
    say `TodoList` with a blue header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the results before we revert the change to our `header` function
    and change it back into passing in the `details` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e050b12-bb6d-4ef8-bc80-7edeb79ac47d.png)'
  prefs: []
  type: TYPE_IMG
- en: The spread operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember a little bit earlier in the chapter, when we wrote an ellipse and
    then a variable name? Any time you do that, you''re telling JavaScript to stuff
    the rest of the unmatched stuff into here and join it to the current data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code tells JavaScript that the item in the first spot goes into
    the `item1` variable, the item in the second spot goes into the `item2` variable,
    and then everything else after that goes into the `rest` variable. We can take
    advantage of this as well when we want to add items onto an array in a non-destructive
    way. Remember the `addTodo()` function that lives in `src/TodoList.js`? Let''s
    take a look at that in greater detail to see how we can use array spreads elsewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code is telling JavaScript to set the `items` key in the component''s
    `state` to be equal to the current value of `this.state.items`, and then concatenate
    `item` onto the end of that list. The code is identical to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also do this with objects in JavaScript code with Babel''s most recent
    update in Create React App, which is great for `state` modification, since `state`
    modification is just changing objects around! Let''s head back to `src/App.js`
    and write a sample bit of code that also sets a background color for our `header`.
    We''ll start off with our object spread and set a new variable called `moreDetails`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re just taking the `details` data structure, and then on top of that, we''re
    either adding new keys or replacing values for existing keys. Next, we''ll need
    to modify the `headerDisplay` function to be able to work with a background color
    being passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step of this is to change the call in the `App` component to pass
    in `moreDetails` to the `header` instead of `details` or a blank object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After you save and reload, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb93503b-6a75-414b-8867-e91cb332aab0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The line of code for the `Object` spread is the equivalent of us writing the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It's just a little more concise and easier to read, so it's great that the Create
    React App team and the Babel team made this supported in the most recent version!
  prefs: []
  type: TYPE_NORMAL
- en: React Fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final thing we're going to talk about in this chapter is the new support
    for React Fragments! React Fragments are a brand-new, but important, feature.
    Previously, if you wanted to include multiple components at the same level, you
    *always* had to have a root component, even for things such as multiple table
    rows, which never really made sense; you'd have to nest `<td>` tags inside of
    `<div>`, which is just weird.
  prefs: []
  type: TYPE_NORMAL
- en: 'It ends up with you having to choose between writing what''s technically invalid
    HTML or writing compliant React code, which tends to just end up as awkward or
    bad code to get around the limitation. Now, instead, we can write code encased
    in special Fragment tags (`<Fragment>` and `</Fragment>`) to denote the start
    and end of a fragment, respectively. We can reference these as `<React.Fragment>`,
    `<Fragment>` (if we choose to `import Fragment` where we `import Component`, such
    as in the following line of code), or as `<>` for a shortcut:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick warning about using the shortcut syntax of `<>` and `</>`: if you''re
    using Fragments inside of code that''s building a list of Fragments, you can''t
    use the shortcut syntax and still specify a `key` property; you will have to use
    either `React.Fragment` or `Fragment`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we go back to `src/TodoList.js`, in our `renderItems()` function, we can
    see the perfect place to replace an extraneous `<div>` with a `Fragment` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: At the top of the function, where we `import Component` as a named `import`
    from `React`, we'll also need to include `Fragment`, similar to the line of code
    a little bit higher up in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The end result is otherwise identical; the major difference is that instead
    of placing each of the Todos and Dividers inside of extra `div` for no reason,
    they can all sit next to each other in the DOM tree and keep your code significantly
    cleaner, especially in the case of working with HTML tables, where introducing
    an extra `div` will actually just break your code!
  prefs: []
  type: TYPE_NORMAL
- en: A quick recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we end this chapter, let''s look at the final state of all of the code
    that we''ve written. Our `src/TodoList.js` has expanded and includes a lot of
    new tricks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `src/App.js` component has expanded significantly as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot, but were pretty productive! We talked a lot about how to take
    full advantage of the better and cleaner syntax that Babel offers us in a Create
    React App 2 project!
  prefs: []
  type: TYPE_NORMAL
- en: Even this is really just scratching the surface of what you can do in modern
    JavaScript, but it covers a lot of the common patterns and tricks that you'll
    see throughout this book. We hope this guide will give you everything you need
    to be able to execute projects and to understand and contribute at the highest
    levels!
  prefs: []
  type: TYPE_NORMAL
- en: We'll be exploring a lot of these code techniques in future chapters, so make
    sure you have a firm grasp of everything we discussed in this chapter before you
    forge ahead!
  prefs: []
  type: TYPE_NORMAL
