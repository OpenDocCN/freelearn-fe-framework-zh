- en: ECMAScript and TypeScript Crash Course
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECMAScript和TypeScript速成课程
- en: '[Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml), *Quick Start,* was
    a heterogeneous mix of topics that may have seemed a little loosey-goosey, but
    it was presented that way to lay down a swath of material and topics related to
    frontend web application development—with an obvious inroad to Angular, for starting
    your adventure in becoming an Angular guru. From this point onward, each chapter
    will remain as focused as possible and thus is dedicated to a specific area of
    coverage. As you progress through the chapters, you will generally find them to
    become more and more technical. This is a natural progression and not to be feared,
    because, as you may recall, one of my promises made to you in [Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml), *Quick
    Start,* was to not get so deeply entwined in the technical details as to reach
    a point of diminishing returns. In other words, no deep technical babble that
    won''t add any value to our purpose. Instead, we''ll get as technical as we need
    to get—no more, and no less. Additionally, the material will be presented in an
    engaging way, where you have the greatest chance for retention with the least
    amount of effort.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第一章](f1243d74-a120-408f-8181-cb379b457dd1.xhtml)，*快速入门*，是一个杂乱的主题混合，可能看起来有点松散，但是以这种方式呈现是为了铺设与前端Web应用程序开发相关的一大片材料和主题，显然是为了开始你成为Angular大师的冒险。从这一点开始，每一章都将尽可能保持专注，并且专门致力于特定的覆盖领域。随着你逐渐深入各章，你会发现它们变得越来越技术化。这是一个自然的进步，不必害怕，因为你可能还记得，我在[第一章](f1243d74-a120-408f-8181-cb379b457dd1.xhtml)，*快速入门*中对你做出的承诺之一是不要陷入技术细节以至于达到收益递减的地步。换句话说，不会有任何对我们目的没有任何价值的深奥技术的废话。相反，我们会变得尽可能技术化——不多，也不少。此外，材料将以一种引人入胜的方式呈现，你将以最小的努力获得最大的保留可能性。'
- en: Regardless, please do not take this comment to mean that you don't have to work
    at it. As with anything else in life, the better you want to become at something,
    the more work it will take on your part. We all reap what we sow. That being said,
    this chapter and the next one will be a gradual ramp up to the technical deep
    dives that follow—kind of like the warm-up before we start working our Angular
    technical muscles throughout the rest of the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，请不要认为这意味着你不必努力。和生活中的任何其他事情一样，你想要变得更优秀，就需要付出更多的努力。种瓜得瓜，种豆得豆。话虽如此，本章和下一章将是逐渐升级到接下来的技术深入探讨的过渡阶段——有点像在我们开始在整本书中运用Angular技术之前的热身。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The relationship between JavaScript and TypeScript.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript和TypeScript之间的关系。
- en: A crash course on TypeScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript的速成课程
- en: The (quick) roadmap
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: （快速）路线图
- en: This chapter is a crash course on TypeScript and is meant to serve as a way
    to fast-track the transition from JavaScript to TypeScript for developers who are
    already comfortable with JavaScript.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于TypeScript的速成课程，旨在为已经熟悉JavaScript的开发人员快速过渡到TypeScript提供帮助。
- en: As was mentioned in [Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml),
    Q*uick Start,* TypeScript is the language we'll be using throughout this book
    when working on Angular-specific things and so this chapter serves as your preparation
    for the programmatic part of getting up to speed for web development with Angular.
    You can think of [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml), *Bootstrap
    – Grid Layout and Components*, as being this chapter's cousin, in that its goal
    is similar but for the presentation side (that is, the layout of the web pages)
    as opposed to the programmatic side. Together, [Chapter 2](82376b53-6401-4844-9440-7ba76a2fb6a2.xhtml), *ECMAScript
    and TypeScript Crash Course*, and [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml),
    *Bootstrap – Grid Layout and Components**,* will round out the prerequisites for
    building client-side web applications in general—regardless of the client-side
    web application framework, but also specifically for Angular-based ones. From
    [Chapter 5](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml), *Flex-layout – Angular's
    Powerful Responsive Layout Engine*, onward, it's going to all pretty much be Angular-centric.
    In a nutshell, that's our roadmap for this chapter and the next. Let's start warming
    up our technical muscles!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第1章](f1243d74-a120-408f-8181-cb379b457dd1.xhtml)中提到的，TypeScript是我们在本书中处理Angular特定事务时将使用的语言，因此本章将作为您准备好使用Angular进行Web开发的程序化部分。您可以将[第3章](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml)《Bootstrap-网格布局和组件》视为本章的表兄弟，因为它的目标类似，但是针对的是呈现方面（即网页布局），而不是程序化方面。[第2章](82376b53-6401-4844-9440-7ba76a2fb6a2.xhtml)《ECMAScript和TypeScript速成课程》和[第3章](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml)《Bootstrap-网格布局和组件》将一起完成构建客户端Web应用程序的先决条件-无论客户端Web应用程序框架如何，但也特别适用于基于Angular的应用程序。从[第5章](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml)《Flex-layout-Angular的强大响应式布局引擎》开始，几乎都将是以Angular为中心。简而言之，这是本章和下一章的路线图。让我们开始热身我们的技术肌肉！
- en: The relationship between JavaScript and TypeScript
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript和TypeScript之间的关系
- en: 'JavaScript and TypeScript are inextricably tied together. Thus, while this
    chapter covers two technologies, ECMAScript and TypeScript, they are similar enough
    for this chapter to cover both simultaneously. How similar are they to each other?
    Well, for the most part, you can consider TypeScript to be a superset of JavaScript.
    The most useful description of their relationship is the following: TypeScript
    is a strictly typed language with lot of powerful features with optional typing,
    and with its transpiler, it becomes plain JavaScript. This is important and brings
    several advantages for developers; it''s compelling enough for Google''s Angular
    team to switch from JavaScript to TypeScript for developing Angular itself. We''ll
    cover what a transpiler is, as well as what the advantages of using TypeScript
    are, very shortly.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript和TypeScript是密不可分的。因此，虽然本章涵盖了ECMAScript和TypeScript两种技术，但它们足够相似，以至于本章可以同时涵盖两者。它们彼此有多相似？嗯，大部分时间，您可以将TypeScript视为JavaScript的超集。它们之间关系最有用的描述是：TypeScript是一种带有许多强大功能和可选类型的严格类型语言，通过其转译器，它变成了普通的JavaScript。这对开发人员来说非常重要，并带来了几个优势；这足够引人注目，以至于谷歌的Angular团队决定从JavaScript转换到TypeScript来开发Angular本身。我们将很快介绍转译器是什么，以及使用TypeScript的优势是什么。
- en: A series of fortunate events for JavaScript
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript的一系列幸运事件
- en: Before we jump into the technical parts and the code, it would be worthwhile
    to take a quick look at the evolution of JavaScript, and some of the drivers that
    led to the need for a language such as a TypeScript. Also, just as Angular's naming
    jungle caused some confusion in the development community, JavaScript has had
    an even more confusing versioning past since its inception over two decades ago,
    and so I'd like to try and clear up some of the confusion around JavaScript's version
    naming. More importantly, I'd like to cover what I like to refer to as the series
    of fortunate events for JavaScript. This will help set the pace for much of the
    material we'll be covering together in the rest of the book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入技术部分和代码之前，值得快速看一下JavaScript的演变以及导致需要像TypeScript这样的语言的一些驱动因素。此外，就像Angular的命名混乱在开发社区中引起了一些困惑，自从20多年前诞生以来，JavaScript的版本过去更加混乱，因此我想尝试澄清一些关于JavaScript版本命名的混乱。更重要的是，我想讨论一下我所说的JavaScript的一系列幸运事件。这将有助于为我们在本书的其余部分一起涵盖的大部分内容设定节奏。
- en: I must confess, I love working with JavaScript. I have always enjoyed the language—not
    for the language itself, but because it allowed us to make the web come alive
    without the need for other plugins, such as Flash or Shockwave. However, in recent
    years, there are a few additional reasons for why I love working with the language,
    and the exact reasons I love JavaScript are precisely the series of fortunate events
    that I will cover shortly. Having said that, I have friends in the industry that
    are on the other end of the spectrum, who view JavaScript as a *toy language,* and
    prefer to remain shackled to languages such as Java and C#, avoiding JavaScript
    at all costs until they have to grudgingly write some code for the client side.
    These old-timers' usage of JavaScript typically extends no further than binding
    a click event to a function call (using the jQuery library) to submit form data to
    their Java or C# APIs. Sure, about a decade ago, JavaScript wasn't as powerful as
    Java or C# for a few reasons, such as it was a language that only ran on the client
    side (that is, on browsers), there were not as many libraries for it, and highly
    performant runtimes for it did not really exist. All this was about to change
    due the series of fortunate events—specifically, three of them. Let's review them
    quickly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，我喜欢使用JavaScript。我一直喜欢这种语言，不是因为语言本身，而是因为它让我们能够使网络生动起来，而无需其他插件，如Flash或Shockwave。然而，近年来，我喜欢使用这种语言的原因还有一些额外的原因，而我喜欢JavaScript的确切原因正是我即将介绍的一系列幸运事件。话虽如此，我在行业中有一些朋友持相反的观点，他们认为JavaScript是一种“玩具语言”，并且更倾向于使用Java和C#等语言，尽量避免使用JavaScript，直到他们不得不勉强为客户端编写一些代码。这些老手对JavaScript的使用通常不会超出使用jQuery库将点击事件绑定到函数调用（以提交表单数据到他们的Java或C#
    API）。当然，大约十年前，由于JavaScript只能在客户端（即浏览器）上运行，没有那么多的库，也没有真正高性能的运行时，因此JavaScript并不像Java或C#那样强大。所有这些都将因为一系列幸运事件而发生改变，具体来说，有三个。让我们快速回顾一下。
- en: Chromium project
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chromium项目
- en: The first one was Google's Chromium Project. In September of 2008, Google released Chrome
    V8, which was a high-performant JavaScript engine. Google's Chrome V8 supercharged
    the way in which JavaScript code was able to be executed. It was such a successful
    project that it enabled other technologies to materialize, including the one that
    truly changed JavaScript's future immediately and forever: Node.js (referred to
    simply as Node).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是谷歌的Chromium项目。2008年9月，谷歌发布了Chrome V8，这是一个高性能的JavaScript引擎。谷歌的Chrome V8极大地提高了JavaScript代码的执行方式。这是一个非常成功的项目，它使其他技术得以实现，包括真正立即和永远改变了JavaScript未来的技术：Node.js（简称Node）。
- en: Javascript frameworks
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript框架
- en: The second event in the series of fortunate events that have cemented JavaScript's
    reign as the most important programming language for web applications, and possibly for mobile
    and even desktop applications as well, has been the explosion of JavaScript frameworks.
    Ever since about 2010, the development world has gone absolutely ballistic in
    its insatiable urge to create JavaScript-based frameworks, not only for client-side web
    application development (such as Ember, Knockout, and React), but for server-side libraries
    (thanks again to Node), frameworks for creating native mobile applications (such
    as Ionic, React Native, and Native Script), and frameworks for developing desktop
    applications as well (such as Meteor and Electron). I haven't mentioned Angular
    in this paragraph, because we've already learned that Angular can be used for
    building cross-platform applications for all three domains—browser, desktop, and
    native mobile.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的统治地位作为最重要的Web应用程序编程语言，甚至可能是移动应用程序和甚至桌面应用程序的事件系列中的第二个事件，是JavaScript框架的爆炸式增长。自2010年以来，开发世界对创建基于JavaScript的框架的渴望已经变得非常疯狂，不仅用于客户端Web应用程序开发（如Ember，Knockout和React），还用于服务器端库（再次感谢Node），用于创建原生移动应用程序的框架（如Ionic，React
    Native和Native Script），以及用于开发桌面应用程序的框架（如Meteor和Electron）。我在这段话中没有提到Angular，因为我们已经知道Angular可以用于构建跨平台应用程序，涵盖了浏览器、桌面和原生移动应用程序的所有三个领域。
- en: ECMAScript 2015
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECMAScript 2015
- en: The third event in this series of fortunate events was the release of ECMAScript
    2015. ECMAScript is the official name for JavaScript when discussing its standard. Despite the
    increase in major version releases, the JavaScript language had largely gone on unchanged
    for many years. This was due to differences between influencing players (who are
    best left), causing splintered development and stalled progress in evolving the
    language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运事件系列中的第三个事件是ECMAScript 2015的发布。ECMAScript是JavaScript标准的官方名称。尽管主要版本发布数量增加，但JavaScript语言多年来基本上没有发生变化。这是由于影响力玩家之间的分歧（最好不要提），导致语言的发展分裂和停滞不前。
- en: 'To summarize, this was a whirlwind tour of the current state of JavaScript
    and some of its ecosystem. JavaScript''s ecosystem is so vast that several books
    would need to be written to cover it. For instance, we''ve not even made mention
    of visualization JavaScript libraries. There are hundreds, if not thousands, of
    libraries available for JavaScript that you can use for your projects that we
    can''t even hope to begin to cover. However, there is a part of the JavaScript
    ecosystem that we will absolutely cover: unit testing. You probably know about
    the importance of unit testing, and have likely written unit tests for server-side
    code using frameworks such as JUnit, NUnit, RSpec, and others, depending on the
    programming language you used. However, unit testing is just as important on the
    client side, and most developers don''t do it, even though they may write unit
    test script for the server side. Well, in [Chapter 13](0e54e15a-bc1a-402b-adaa-28f877c68323.xhtml), *Unit
    Testing*, you will learn how to write unit tests for the client side and, specifically,
    how to write them to test your Angular application. The two frameworks we''ll
    cover together are Jasmine (a popular unit testing framework) and Karma (a test
    runner that has plugins for testing frameworks, such as Jasmine).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这是对JavaScript当前状态及其生态系统的一个快速概述。JavaScript的生态系统非常庞大，需要写好几本书来覆盖它。例如，我们甚至没有提到可视化JavaScript库。JavaScript有数百甚至数千个可用于项目的库，我们甚至无法开始覆盖。但是，JavaScript生态系统中有一部分我们一定会涵盖：单元测试。您可能知道单元测试的重要性，并且可能已经使用诸如JUnit、NUnit、RSpec等框架为服务器端代码编写了单元测试，具体取决于您使用的编程语言。但是，客户端上的单元测试同样重要，大多数开发人员并没有进行单元测试，即使他们可能已经为服务器端编写了单元测试脚本。在[第13章](0e54e15a-bc1a-402b-adaa-28f877c68323.xhtml)中，*单元测试*，您将学习如何为客户端编写单元测试，特别是如何编写它们来测试您的Angular应用程序。我们将一起介绍的两个框架是Jasmine（一种流行的单元测试框架）和Karma（一个具有用于测试框架的插件的测试运行器，如Jasmine）。
- en: With this chapter's technical preamble out of the way, let's strap on our scuba
    gear and dive into TypeScript's ocean!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有了本章的技术前言，让我们戴上潜水装备，潜入TypeScript的海洋吧！
- en: TypeScript crash course
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript速成课程
- en: 'TypeScript has a number of advantages over JavaScript for developers, including
    the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript对开发人员比JavaScript具有许多优势，包括以下内容：
- en: Purely object-oriented
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯粹的面向对象
- en: Optional static typing
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的静态类型
- en: Type inference
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型推断
- en: Access to ECMAScript features
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问ECMAScript功能
- en: Transpilation
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转译
- en: Great tooling support with IntelliSense
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliSense的强大工具支持
- en: You can build Angular applications!
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以构建Angular应用程序！
- en: Transpilation versus compilation
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转译与编译
- en: 'Developers can usually define what compilation is, within the context of programming.
    The definition would be something like this: compilation is the process of transforming
    source code, by putting it through another program known as a compiler, into machine-readable
    code. This resultant code is typically referred to as assembly code, which is
    a set of machine instructions native to the machine''s CPU, which the code is
    meant to be run on.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员通常可以在编程的上下文中定义编译是什么。定义可能是这样的：编译是将源代码通过另一个称为编译器的程序转换为机器可读代码的过程。这个结果代码通常被称为汇编代码，它是一组本机于机器CPU的机器指令，代码是要在其上运行的机器。
- en: Transpilation, on the other hand, is the process of transforming source code
    written in one language into equivalent code in another (or target) language.
    While this definition is good enough for discussion, for it to be fully accurate
    we have to also note that the source and target languages may, in fact, be different
    versions (or releases) of the same language. For our transpilation needs, we'll
    be using TypeScript's transpiler, tsc, which comes packaged with TypeScript. The
    reason we care about transpilation when building Angular applications is because
    we will be writing our code in TypeScript. However, web browsers only have JavaScript
    engines/interpreters, and so we need a way to transpile it into JavaScript.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，转译是将用一种语言编写的源代码转换为另一种（或目标）语言的等效代码的过程。虽然这个定义对于讨论来说已经足够好了，但为了完全准确，我们还必须注意到源语言和目标语言实际上可能是同一语言的不同版本（或发布）。对于我们的转译需求，我们将使用TypeScript的转译器tsc，它与TypeScript捆绑在一起。我们关心转译的原因是因为我们将在构建Angular应用时使用TypeScript编写代码。然而，Web浏览器只有JavaScript引擎/解释器，因此我们需要一种将其转译为JavaScript的方法。
- en: let
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让
- en: 'The `let` and `const` keywords were introduced in ES6\. In order to discuss
    what these are and how they work, let''s review what the `var` keyword does. Prior
    to ES6, the way in which you initialized a variable was to use the `var` keyword.
    The two things to remember about `var` are the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`和`const`关键字是在ES6中引入的。为了讨论它们是什么以及它们如何工作，让我们回顾一下`var`关键字的作用。在ES6之前，初始化变量的方式是使用`var`关键字。关于`var`需要记住的两件事是：'
- en: When you use `var` to define a variable outside of a function body, it becomes
    globally scoped. This is to say that all the other functions in your JavaScript
    file have access to it. While this may sometimes be convenient, it can also be
    dangerous because the value may inadvertently be changed by a function other than
    the one that you intended the variable to be used for. This is possible when more
    than one function refers to the same variable name.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您使用`var`在函数体外定义变量时，它将成为全局作用域。这意味着JavaScript文件中的所有其他函数都可以访问它。虽然这有时可能很方便，但也可能很危险，因为值可能会被意图之外的函数无意中更改。当多个函数引用相同的变量名时，这种情况是可能的。
- en: When you use `var` to define a variable within a function, it becomes locally
    scoped. In contrast to globally scoped variables, locally scoped variables are
    only accessible within the function in which they were created. This is true regardless
    of block scope because JavaScript variables declared with the `var` keyword are
    scoped to the nearest parent function.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您使用`var`在函数内部定义变量时，它将成为局部作用域。与全局作用域变量相反，局部作用域变量只能在创建它们的函数内部访问。这是真实的，无论块作用域如何，因为使用`var`关键字声明的JavaScript变量作用域限定在最近的父函数内。
- en: You can, of course, still use `var` to declare and define your variables, since
    the keyword has not been deprecated. It's just that you now have more explicit
    control over the behavior of your initialization code, and the readability of
    the code has improved with `let` and `const`, since the intentions are clear for
    when you're looking at JavaScript code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您仍然可以使用`var`来声明和定义变量，因为该关键字尚未被弃用。只是现在您对初始化代码的行为有了更明确的控制，并且使用`let`和`const`后代码的可读性得到了改善，因为在查看JavaScript代码时意图是清晰的。
- en: The `let` keyword creates block scope local variables and gets its name from
    other languages that have a similar construct, such as Lisp, Clojure, Scala, and
    F#. In these languages, variables declared using `let` can be assigned, but not
    changed. However, in ES6, variables assigned using `let` can be changed; even
    so, regardless of whether they are changed or not, the variable is a local block
    scoped variable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`关键字创建了块作用域的局部变量，并且其名称来源于其他具有类似构造的语言，比如Lisp、Clojure、Scala和F#。在这些语言中，使用`let`声明的变量可以被赋值，但不能被改变。然而，在ES6中，使用`let`赋值的变量可以被改变；即使如此，无论它们是否被改变，该变量都是一个本地块作用域变量。'
- en: 'If you find this is a little confusing, you''re not alone. Getting a firm understanding
    of the nuances in variable scoping is not something that you can learn by just
    reading. Programming is like learning math (or like learning most things, for
    that matter): the more you do it, the better you get. That being said, one way
    to boil it all down in your mind is to look at this one main difference between
    `var` and `let`: since you can have more than one block within a function, and
    even nested blocks (or sub-blocks), variables defined with the `let` keyword are
    accessible only within the block they are defined, as well as from that block''s
    nested blocks. In contrast, the scope of variables defined with `var` is the entire
    closing function. Remember that one main difference, and you''re golden.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这有点令人困惑，你并不孤单。要牢固理解变量作用域的微妙之处并不是仅仅通过阅读就能学会的事情。编程就像学数学（或者学大多数事情一样）：你做得越多，就会变得越好。话虽如此，将所有这些都归纳到你的脑海中的一种方法是看待`var`和`let`之间的这个主要区别：由于在一个函数内可以有多个块，甚至是嵌套块（或子块），使用`let`关键字定义的变量只能在其定义的块内访问，以及从该块的嵌套块中访问。相比之下，使用`var`定义的变量的作用域是整个封闭函数。记住这个主要区别，你就掌握了。
- en: 'Let''s look at some code to understand the impact of the `let` keyword, and
    then we can move on to discussing the `const` keyword:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些代码来理解`let`关键字的影响，然后我们可以继续讨论`const`关键字：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Const
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量
- en: The `const` keyword creates a constant. You'll be glad to know that since you've
    gone through the pain of understanding what the `let` keyword does, understanding
    what the `const` keyword does will be dead simple. Ready? Here it is … `const`
    and `let` are identical in the way in which their scoping works. The only difference
    between `let` and `const` is that you cannot redeclare a constant, and its value
    can't be changed. That's it. Let's move on to discussing some data types.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`关键字创建一个常量。你会很高兴知道，因为你已经经历了理解`let`关键字的痛苦，理解`const`关键字的作用将会非常简单。准备好了吗？在这里……`const`和`let`在它们的作用域工作方式上是相同的。`let`和`const`之间唯一的区别是你不能重新声明一个常量，它的值也不能被改变。就是这样。让我们继续讨论一些数据类型。'
- en: Data typing
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: Every programming language has data types. They only vary in the number of types
    available, and the values (and range of values, for number types) that the typed
    variable can hold. I won't wade into the philosophical debate between strongly
    typed versus statically typed versus loosely typed languages (usually referred
    to as static versus dynamic typing) in this book—but since this chapter is devoted
    to JavaScript and TypeScript, I do need to say a couple of quick things about
    their typing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都有数据类型。它们只在可用类型的数量以及类型变量可以保存的值（以及数字类型的值范围）方面有所不同。我不会在本书中探讨强类型与静态类型与弱类型语言之间的哲学辩论（通常称为静态与动态类型）—但由于本章专门讨论JavaScript和TypeScript，我需要简要谈一下它们的类型。
- en: JavaScript is a loosely typed language—which is to say it is a dynamic language
    as opposed to it being a static language. What this means is that variables in
    JavaScript are not bound to any particular type, but rather their values are associated
    with a type. Variables can be assigned, and re-assigned, to values of all available
    types. While convenient, hard-to-find bugs can occur, since there is no compiler
    that checks for adherence of value to a typed reference—and this is because when
    you declare a variable using `var`, `let`, or `const`, you do not specify an associated
    type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种弱类型语言——也就是说它是一种动态语言，而不是静态语言。这意味着JavaScript中的变量不绑定到任何特定类型，而是它们的值与类型相关联。变量可以被分配和重新分配给所有可用类型的值。虽然方便，但由于没有编译器检查值是否符合类型引用，因此很难找到错误。这是因为当你使用`var`、`let`或`const`声明变量时，你没有指定关联的类型。
- en: In contrast, TypeScript is optionally statically typed. The important word here
    is *optionally*. TypeScript is a statically typed language, yes, but it does not
    force you to explicitly annotate your variable with the intended type. This is
    because TypeScript has what is called type inference, which is to say that the
    TypeScript runtime will infer the variables data type at runtime. This is the
    default behavior of TypeScript. Now, this is where the optional part of it comes…
    if you want to strictly type the variable, thereby binding the datatype to the
    variable instead of it resting with the variable's value, you have to explicitly
    add a type annotation to the variable declaration.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，TypeScript是可选的静态类型。这里的关键词是*可选*。TypeScript是一种静态类型语言，但它不强制你明确注释你的变量所需的类型。这是因为TypeScript具有所谓的类型推断，也就是说TypeScript运行时将在运行时推断变量的数据类型。这是TypeScript的默认行为。现在，这就是可选部分的地方……如果你想严格地给变量加上类型，从而将数据类型绑定到变量而不是与变量的值相关，你必须在变量声明中明确添加类型注释。
- en: 'Here it is in code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码中的情况：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Both the preceding lines are valid TypeScript syntax, but here are their differences:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行都是有效的TypeScript语法，但它们之间有所不同：
- en: The first line, the statically typed variable, which is annotated with the `num` keyword,
    is checked by the TypeScript transpiler, and any issues will be reported by it
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行是静态类型变量，使用`num`关键字进行注释，由TypeScript转译器检查，任何问题都将由它报告
- en: The second line, where the variable declaration is made in the JavaScript fashion
    (that is, no annotations for static typing), goes unchecked, and any issues will
    only be found at runtime
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行，变量声明以JavaScript的方式进行（也就是说，没有静态类型的注释），不受检查，任何问题只能在运行时发现。
- en: 'ES6 has seven data types, six of which are known as primitive data types, and
    one of which is a reference data type (which is just called `Object`). JavaScript
    also has several built-in data types in its standard library, but since this is
    not comprehensive coverage of JavaScript, we''ll only cover a few of them here:
    the ones that you''re likely to use in your Angular development.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ES6有七种数据类型，其中六种被称为原始数据类型，一种被称为引用数据类型（只是称为`Object`）。JavaScript标准库中还有几种内置数据类型，但由于这不是JavaScript的全面覆盖，我们只会在这里涵盖其中一些：你可能会在你的Angular开发中使用的那些。
- en: 'The following is the list of the primitive data types provided:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是提供的原始数据类型列表：
- en: 'Null'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空
- en: Undefined
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义
- en: Boolean
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: Number
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: String
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Symbol
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号
- en: 'The following are the built-in data types provided:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是提供的内置数据类型：
- en: Dates
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期
- en: Arrays
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Maps
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图
- en: Sets
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Objects
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象
- en: 'Only having primitive data types and built-in complex data types is not enough
    when writing expressive software that attempts to model the real world or fictitious
    worlds (in gaming). The solution is to have programming languages with a construct
    for creating custom objects. Fortunately, JavaScript, and thus TypeScript, is
    a programming language that allows for the creation of custom objects. An object
    in JavaScript is a collection of mapped keys and values, where a key can be either
    a string or a symbol. This is similar to the case for many other programming languages,
    such as for Python''s dictionary, and Ruby''s hash. Not to get too technical just
    for the sake of being technical (which is a pet peeve of mine, and maybe is one
    for you as well), but JavaScript is not a *classical* object-oriented language.
    Rather, JavaScript uses prototypal inheritance to create other objects instead
    of creating an instance of an object from a class definition. In other words,
    JavaScript doesn''t have the notion of classes. JavaScript has prototypes. Objects
    in JavaScript inherit directly from other objects. In fact, when you create an
    empty object in JavaScript using curly braces, it''s really syntactic sugar for
    using the `create` method of the built-in object. There are several ways available
    to you for creating an empty object in JavaScript. We won''t cover them all here,
    but we''ll cover two of the ways that have been available in JavaScript for many
    years, and are made available to us in ES6:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 仅具有原始数据类型和内置复杂数据类型并不足以编写表达性软件，试图模拟现实世界或虚构世界（在游戏中）。解决方案是拥有具有创建自定义对象构造的编程语言。幸运的是，JavaScript，因此TypeScript，是一种允许创建自定义对象的编程语言。JavaScript中的对象是一组映射键和值的集合，其中键可以是字符串或符号。这类似于许多其他编程语言的情况，例如Python的字典和Ruby的哈希。不要仅仅为了技术而变得太技术化（这是我讨厌的事情，也可能是你讨厌的事情），但JavaScript不是*经典*面向对象的语言。相反，JavaScript使用原型继承来创建其他对象，而不是从类定义创建对象的实例。换句话说，JavaScript没有类的概念。JavaScript有原型。JavaScript中的对象直接从其他对象继承。实际上，当您在JavaScript中使用大括号创建一个空对象时，这实际上是使用内置对象的`create`方法的语法糖。在JavaScript中有几种可用的方法可以创建一个空对象。我们不会在这里涵盖它们所有，但我们将涵盖两种多年来在JavaScript中可用的方法，并在ES6中提供给我们的方法：
- en: Using the `Object` constructor: `var myObject = new Object();`
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Object`构造函数：`var myObject = new Object();`
- en: Using the curly brace syntax: `var myObject = {};`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用大括号语法：`var myObject = {};`
- en: Using ES6 class syntax (we'll get to the syntax in the following *Classes* section)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ES6类语法（我们将在接下来的*类*部分介绍语法）
- en: The first two methods create an empty object. If you want to create an empty
    object in JavaScript with minimal fuss, the second approach is obviously the easiest.
    However, the third approach, ES6 class syntax, is what we'll be using in this
    book.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方法创建一个空对象。如果您想在JavaScript中轻松创建一个空对象，第二种方法显然是最简单的。然而，第三种方法，ES6类语法，是我们将在本书中使用的方法。
- en: JSON
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: 'JSON, which is an acronym for JavaScript Object Notation, is not a data type
    per se, but rather structured data. JSON is used as a lightweight data interchange
    format and is used by many programming languages. Not only will we cover this
    more a little later, but we will make extensive use of this format to pass data
    back and forth between our Angular application and the backend web services that
    we''ll also be building for it. Just as programming languages have data types, data
    interchange formats often do as well. Here are the data types allowed to be represented
    in JSON:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是JavaScript对象表示法的缩写，不是一种数据类型，而是结构化数据。JSON被用作轻量级数据交换格式，并被许多编程语言使用。我们不仅将在稍后更详细地介绍这一点，而且我们将广泛使用这种格式在我们的Angular应用程序和我们为其构建的后端Web服务之间传递数据。就像编程语言有数据类型一样，数据交换格式通常也有。以下是JSON允许表示的数据类型：
- en: String
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Number
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: Object
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Array
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Boolean
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔
- en: 'Null'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空
- en: 'You may have noticed that there is a large overlap between JavaScript and JSON
    data types. This is not by accident because JSON is JavaScript Object Notation,
    and thus was modeled after JavaScript''s data types. Here''s an example of JSON
    data that contains the names and ages of three people (each of which is a JavaScript
    object):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到JavaScript和JSON数据类型之间有很大的重叠。这并非偶然，因为JSON是JavaScript对象表示法，因此是模仿JavaScript的数据类型而建模的。以下是一个包含三个人的姓名和年龄的JSON数据的示例（每个都是JavaScript对象）：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the previous JSON example, I have `people` as the key, and its value is
    an array of three `people` objects. There''s no hard and fast rule that says you
    have to name structures nested structures, but it does become more legible. In
    this simple example, you could have instead omitted the key with no loss of data,
    as this next JSON sample shows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的JSON示例中，我有`people`作为键，其值是一个包含三个`people`对象的数组。并没有硬性规定说你必须给嵌套结构命名，但这样做会更易读。在这个简单的例子中，你可以省略键而不会丢失数据，就像下一个JSON示例所示的那样：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, the first example, where we have the `people` key, is not only easier
    to read but is also easier to work with in the code. When we write our RESTful
    web service APIs for our application in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating
    Backend Data Services,* we will take the first approach, providing keys for our
    collections of data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在第一个例子中，我们有`people`键，不仅更容易阅读，而且在代码中更容易处理。当我们在[第12章](9610f27b-03db-4258-8a68-24eb3901117b.xhtml)中为我们的应用编写RESTful
    web服务API时，我们将采取第一种方法，为我们的数据集提供键。
- en: Here's an interesting note for you about data interchange formats. While there
    are a few formats to choose from, such as XML and SOAP (Simple Object Access Protocol),
    when developing web services, JSON is the most popular one of all, and it was
    inspired by JavaScript.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据交换格式，这里有一个有趣的注释。虽然有一些可供选择的格式，比如XML和SOAP（简单对象访问协议），但在开发Web服务时，JSON是最受欢迎的格式，它受到JavaScript的启发。
- en: Where would we be without JavaScript? I shudder to think about it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有JavaScript，我们会在哪里呢？我不敢想象。
- en: JavaScript runtime environment
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript运行环境
- en: 'The rest of this chapter has many code snippets, so if you''d like to experiment
    with the material as you work your way through the chapter, it''s a good idea
    to fire up your JavaScript runtime environment. Unless you''re using a JavaScript
    IDE, such as WebStorm by JetBrains, you have a few options available to you for
    testing out JavaScript code. Here are three of the many choices:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分有许多代码片段，所以如果您想在阅读本章的过程中尝试材料，最好启动JavaScript运行环境。除非您使用JavaScript IDE，比如JetBrains的WebStorm，否则您有几种选择可以用来测试JavaScript代码。以下是其中的三种选择：
- en: You can use an online a JavaScript console, such as [https://es6console.com/](https://es6console.com/).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用在线的JavaScript控制台，比如[https://es6console.com/](https://es6console.com/)。
- en: You can use Node right in your Terminal (Appendix A shows you how to install
    Node).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在终端中使用Node（附录A向你展示了如何安装Node）。
- en: You can use the console within your developer tools in your browser. For instance,
    I primarily develop using Chrome, and Google has excellent tools for developers.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在浏览器的开发者工具中使用控制台。例如，我主要使用Chrome进行开发，而Google有出色的开发者工具。
- en: Any of these choices will work just fine. I prefer using the Node Terminal for
    quick little things and it's what I used to test the code I wrote for this chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 任何这些选择都可以很好地工作。我更喜欢在Node终端中快速地做一些小事情，这也是我用来测试我为本章编写的代码的工具。
- en: Arrays
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Arrays are part of a collection of objects, and are referred to as indexed
    collections. If you''ve written any amount of JavaScript, you have used arrays.
    Array objects can hold any valid JavaScript data types and can grow and shrink
    by calling their built-in methods, such as `push` and `splice`. You can search
    for the existence of a value in the array with the `indexOf` method, get an array''s
    length by using its `length` property, and so on. The JavaScript syntax for creating
    an empty array is the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是对象集合的一部分，被称为索引集合。如果你写过一定量的JavaScript，你一定使用过数组。数组对象可以保存任何有效的JavaScript数据类型，并且可以通过调用它们的内置方法（如`push`和`splice`）来增长和缩小。你可以使用`indexOf`方法来搜索数组中值的存在，使用`length`属性来获取数组的长度，等等。创建一个空数组的JavaScript语法如下：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can then use the array''s built-in `push` method to add an item to the
    array, like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以使用数组的内置`push`方法来向数组中添加一个项，就像这样：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Alternatively, you can create the array in place in one fell swoop, like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以一次性地创建数组，就像这样：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `indexOf` method is quite handy, and we''re sure to make use of it later.
    Let''s quickly cover this one before moving on to `TypedArrays`. When you need
    to find where in the array a specific item is, or whether it exists in an array
    at all, you can use the `indexOf` method. Let''s assume we''d like to see where
    in array the Mercedes is. We can search for it like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexOf`方法非常方便，我们肯定会在后面用到它。在继续讲解`TypedArrays`之前，让我们快速介绍一下这个方法。当你需要找到数组中特定项的位置，或者判断它是否存在于数组中时，你可以使用`indexOf`方法。假设我们想要查找Mercedes在数组中的位置。我们可以这样搜索：'
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Given our `myDreamCars` array, the `indexOf` function would return 1\. This
    is because arrays in JavaScript start their index at 0, and the Mercedes was in
    the second slot of our array. What if what we''re looking for is not in the array?
    Let''s see what happens when we look for a Corvette:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 给定我们的`myDreamCars`数组，`indexOf`函数会返回1。这是因为JavaScript中的数组从0开始索引，而Mercedes在我们的数组中是第二个位置。如果我们要查找的东西不在数组中会怎样呢？让我们看看当我们查找Corvette时会发生什么：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the preceding line is executed, the `indexOf` function returns a -1, which
    indicates that the item we were searching for was not found.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行上述行时，`indexOf`函数会返回-1，这表示我们搜索的项没有找到。
- en: TypedArray
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypedArray
- en: '`TypedArray` is used in ES6 and even though it has a few of the same methods
    as normal JavaScript array objects, it is quite different from what you''d probably
    expect. In fact, `TypedArray` is not an array at all. If you try passing in `TypedArray`
    to `Array.isArray()`, you will see that the value returned is `false`. OK, so
    what are they then?`TypedArray` gives us a view of an underlying binary data buffer
    and enables us to access and manipulate data. We won''t be covering `TypedArray` in
    this book because we won''t be using them, and it is an advanced data type and
    mechanism, but the reason I mentioned it is so that you are aware that it exists.
    Before we move on, let me at least cover the motivation for its creation and a
    use case for when you may wish to look into possibly using it. `TypedArray` came
    into being with ES6 because web applications are getting more advanced all the
    time, and the client machine now has so much power available to it that writing
    a client application that processes and manipulates audio and video is a good
    idea. In order to do this, you need a mechanism to enable your JavaScript code
    to be able to read and write data to these raw binary streams.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypedArray`在ES6中使用，尽管它具有与普通JavaScript数组对象相同的一些方法，但它与您可能期望的有很大不同。事实上，`TypedArray`根本不是数组。如果您尝试将`TypedArray`传递给`Array.isArray()`，您会发现返回的值是`false`。那么它们是什么呢？`TypedArray`为我们提供了对底层二进制数据缓冲区的视图，并使我们能够访问和操作数据。我们不会在本书中涵盖`TypedArray`，因为我们不会使用它们，它是一种高级数据类型和机制，但我提到它的原因是让您知道它的存在。在我们继续之前，让我至少解释一下它的创建动机和您可能希望考虑可能使用它的用例。`TypedArray`随着ES6的出现而出现，因为Web应用程序变得越来越先进，客户端机器现在有如此多的可用性能，编写一个处理和操作音频和视频的客户端应用程序是一个好主意。为了做到这一点，您需要一种机制来使您的JavaScript代码能够读取和写入这些原始二进制流的数据。'
- en: 'Two examples of something that you may want to build where `TypedArray` would
    be put to immediate good use are the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望构建的两个立即可以使用`TypedArray`的示例是：
- en: Video editing (where you wish to remove segments of unwanted footage)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频编辑（您希望删除不需要的镜头段）
- en: Sampling audio (where you change the frequency of a sound byte, maybe creating
    11 versions of the original sample to create a chromatic scale, so as to be able
    to play melodies from the original single sample)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对音频进行采样（更改声音字节的频率，也许创建原始样本的11个版本以创建一个音阶，以便能够从原始单个样本中演奏旋律）
- en: Once again, this is an example of how far JavaScript has come.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这是JavaScript发展的一个例子。
- en: Maps
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地图
- en: 'Maps is a data structure that came to JavaScript in ES6\. Maps are used for
    mapping values to values. Moreover, they allow the use of arbitrary values as
    keys, meaning that you can use integers as keys, or strings, or even objects;
    however, the use of symbols as keys is not allowed. There are also a few handy
    methods for performing operations on maps, and you can also iterate over a map.
    Let''s take a look at some code for creating a map and explore some of its common
    built-in functions. Let''s first create our map. We''ll create one for mapping
    learning curves to programming languages, using the `new` keyword:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 地图是一种数据结构，它在ES6中引入了JavaScript。地图用于将值映射到值。此外，它们允许使用任意值作为键，这意味着您可以使用整数作为键，或字符串，甚至对象；但是，不允许使用符号作为键。还有一些方便的方法可以在地图上执行操作，并且您还可以对地图进行迭代。让我们来看一些创建地图的代码，并探索一些常见的内置函数。首先让我们创建我们的地图。我们将创建一个用于将学习曲线映射到编程语言的地图，使用`new`关键字：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And now let''s add a few entries to it using the Map''s set function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用地图的设置功能向其添加一些条目：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'While you can add key-value pairs in `Map` one line at a time, as we just did,
    the `set` method is chainable and so we can use this syntax to accomplish the
    exact same thing, which saves some typing:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以一次在`Map`中添加键值对，就像我们刚刚做的那样，但`set`方法是可链接的，所以我们可以使用这种语法来完成完全相同的事情，这样可以节省一些输入：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Alternatively, as a third way to declare and initialize our language learning
    curve `Map`, we can pass an array of two element arrays to the Map''s constructor.
    Let''s assume we had our array of two-element arrays set up like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，作为声明和初始化我们的语言学习曲线`Map`的第三种方法，我们可以将一个包含两个元素数组的数组传递给Map的构造函数。假设我们的两个元素数组设置如下：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can then pass that into the constructor like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以像这样将其传递给构造函数：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These three methods of creating our `Map` all produce the exact same results.
    Cool, let''s move on and quickly look at some of the common operations that can
    be done on `Map`. We can get the Map''s size using its `size` property:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种创建`Map`的方法都会产生完全相同的结果。好了，让我们继续快速看一下可以在`Map`上执行的一些常见操作。我们可以使用`size`属性获取Map的大小：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can retrieve a key''s value using the `get` function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`get`函数检索键的值：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can check for the existence of a key in `Map` using its `has` function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`has`函数检查`Map`中键的存在：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can delete a key and its value using the `delete` function:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`delete`函数删除一个键及其值：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can clear out a set, removing all its items in one fell swoop, with the `clear`
    function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`clear`函数一次性清除一个集合中的所有项。
- en: 'If you''re following along in your JavaScript environment, don''t try this
    just yet because we need some data to iterate through it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在JavaScript环境中跟着做，现在不要尝试这样做，因为我们需要一些数据来迭代：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can iterate over `Map` very easily in JavaScript using the `for` construct,
    but we need to know what we would like to iterate over. Do we want to get our
    map''s keys? or its values? Or maybe we''d like to get both. Here is how we iterate
    over our map''s keys:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，你可以很容易地使用`for`构造迭代`Map`，但我们需要知道我们想要迭代什么。我们想要获取我们地图的键吗？还是它的值？或者我们想要获取两者。这是如何迭代我们地图的键：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is how we iterate over our map''s values:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何迭代我们地图的值：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is how we iterate over both our Map''s keys and its values:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何迭代我们地图的键和值：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Most of the time, you'll probably want to have access to your map's keys and
    values and so you should use the map's `entries` function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你可能希望访问你的地图的键和值，所以你应该使用地图的`entries`函数。
- en: A bit later in this chapter, we'll take a look at a construct that ES6 gave
    us, called destructuring, which gives us the ability to access keys and values
    directly.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的稍后部分，我们将看一下ES6给我们的一个构造，叫做解构，它使我们能够直接访问键和值。
- en: WeakMap
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WeakMap
- en: '`WeakMap` is a funny creature and is not inherited from `Map`, although they
    both are collections of key-value pairs and share some of the same functionality.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakMap`是一个有趣的生物，它不是从`Map`继承而来，尽管它们都是键值对的集合，并且共享一些相同的功能。'
- en: The most important difference between `Map` and `WeakMap` is the datatypes that
    can be used as their keys. With a, we've seen that you can use a variety of data
    types as its keys, including objects. However, `WeakMap` can only have objects
    as its keys. This is by design and makes `WeakMap` particularly useful if you
    only care to have access to the value of the key if the key has not yet been garbage
    collected. Let that sink in for a moment. I know it sounds like a strange use
    case, but if you consider that `WeakMap` can help mitigate memory leaks in your
    JavaScript programs, it may be enough for thinking of how you may be able to make
    use of `WeakMap` in your code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`和`WeakMap`之间最重要的区别是可以用作它们的键的数据类型。通过`Map`，我们已经看到可以使用各种数据类型作为其键，包括对象。但是，`WeakMap`只能将对象作为其键。这是有意设计的，并且使`WeakMap`特别有用，如果只关心在键尚未被垃圾回收时访问键的值。让这一点沉淀片刻。我知道这听起来像一个奇怪的用例，但是如果考虑到`WeakMap`可以帮助减轻JavaScript程序中的内存泄漏，可能足够考虑如何在代码中使用`WeakMap`。'
- en: The *Weak* part of the data structure's name comes from the fact that `WeakMap`
    holds the references to its key objects weakly. This is to say that they are candidates
    for being garbage collected. This fact leads us to this next point. Since our
    keys may be garbage collected at any point without our involvement, it would not
    make sense to make them enumerable, and so they are not, and this means that we
    cannot iterate over the collection.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构名称中的*Weak*部分来自于`WeakMap`弱引用其键对象。这意味着它们有可能被垃圾回收。这一事实导致了我们的下一个观点。由于我们的键可能在任何时候被垃圾回收而无需我们的参与，因此将它们列举出来是没有意义的，因此它们不是，这意味着我们无法遍历集合。
- en: If you need to iterate over the list of keys or values in your collection, you
    should use the `Map`. Conversely, if you don't need to iterate over `Map` and
    just intend to use it as a lookup table, you may want to consider using `WeakMap`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要遍历集合中键或值的列表，则应使用`Map`。相反，如果不需要遍历`Map`，只打算将其用作查找表，则可以考虑使用`WeakMap`。
- en: We will learn about `Set` in the next section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节学习`Set`。
- en: Set
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Set
- en: '`Set` is a collection of unique values and can be iterated over in the order
    in which its elements were added to it. `Set` can contain homogeneous data but
    each piece of data (that is, element) needs to be unique. If you try to add an
    existing element to a set, there will be no effect on the set.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`是一个唯一值的集合，并且可以按照其元素添加到其中的顺序进行迭代。`Set`可以包含同类数据，但是每个数据（即元素）都需要是唯一的。如果尝试将现有元素添加到集合中，对集合不会产生影响。'
- en: Sets have many of the same functionality that maps have. Let's create a `Set`
    object and zip through a few of its commonly used functions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 集合具有许多与映射相同的功能。让我们创建一个`Set`对象，并快速浏览一些常用的函数。
- en: 'To create a set, we call its constructor using the `new` keyword:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个集合，我们使用`new`关键字调用它的构造函数：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s add a few elements (that is, celestial objects) to our `Set`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的`Set`添加一些元素（即天体）：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'OK, the number `7` isn''t exactly a celestial object, but I wanted to show
    you that you can add different types of elements to the same `Set`. The same thing
    with our array of constellations: we can add arrays, and any type of object, to
    our `Set`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，数字`7`并不完全是天体，但我想向您展示您可以将不同类型的元素添加到同一个`Set`中。与我们的星座数组一样：我们可以向我们的`Set`添加数组和任何类型的对象。
- en: 'We can get the size of our `Set` using the `size` property:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`size`属性获取我们的`Set`的大小：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Don''t do this now, but you can clear out `Set` using its `clear` function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不要这样做，但是您可以使用其`clear`函数清除`Set`：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can delete an element from our `Set` by passing its value into set''s `delete`
    function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将其值传递到集合的`delete`函数中来从我们的`Set`中删除一个元素：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can iterate over `Set` using the `for` construct, as we used for our `Map`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`for`循环来迭代`Set`，就像我们用于`Map`一样：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you''d like to perform an operation on every element in your `Set`, you
    can use set''s `forEach` function, which takes a callback as its parameter. For
    instance, if you had a set of integers in your `Set` and wanted to square all
    of them, this is how you can accomplish that:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想对`Set`中的每个元素执行操作，可以使用set的`forEach`函数，该函数以回调作为其参数。例如，如果您的`Set`中有一组整数，并且想要对它们进行平方运算，可以这样实现：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code does not change the elements within our `Set` while it prints
    the squared values to our console. We can''t easily change our elements in place,
    but we can create a new `Set` and store our squared elements in there, like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码不会更改我们`Set`中的元素，而是将平方值打印到控制台。我们无法轻松地就地更改我们的元素，但是我们可以创建一个新的`Set`并将我们的平方元素存储在其中，就像这样：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can check for the existence of an element in our `Set` using the `has` function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`has`函数来检查我们的`Set`中是否存在元素：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you recall from when we covered maps, the `Map` object had the following
    three functions: keys, values, and entries. Sets have these same three functions
    as well, but their resulting value is quite different. When you call these built-in
    functions on your `Set`, you will get a `SetIterator` object back.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得我们讨论过的`Map`，`Map`对象有以下三个函数：keys，values和entries。`Set`也有这三个函数，但它们的返回值是非常不同的。当您在`Set`上调用这些内置函数时，将会得到一个`SetIterator`对象。
- en: We won't be using `SetIterator` in this book, but as with when I gave you a
    use case for `TypedArray`, I'd like to give you a use case for `SetIterator`.
    A `Map` object and a `Set` object are different data structures, and you iterate
    through each of these structures in different ways. If you use iterators, you
    can build a function that can iterate through these two types of data structures
    in the same way. In other words, you can pass the objects into your function that
    iterates over the collections without worrying about their type.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们不会使用`SetIterator`，但是就像我给您介绍`TypedArray`的用例一样，我想给您介绍`SetIterator`的用例。`Map`对象和`Set`对象是不同的数据结构，您可以以不同的方式迭代这些结构。如果使用迭代器，可以构建一个可以以相同方式迭代这两种类型数据结构的函数。换句话说，您可以将对象传递到迭代集合的函数中，而不必担心它们的类型。
- en: WeakSet
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WeakSet
- en: '`WeakSet` is a collect of weakly held objects, where each one must be unique;
    duplicate objects are not allowed to be added. Recall from our discussion on `WeakMap`
    that its keys may be garbage collected from under our feet since their keys can
    only be objects. Thus, as it was with `WeakMap`, so it is with `WeakSet` with
    respect to iteration: we can''t iterate over the collection.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakSet`是一组弱引用对象，每个对象必须是唯一的；不允许添加重复的对象。回想一下我们在`WeakMap`上的讨论，由于它们的键只能是对象，因此它们的键可能会在我们脚下被垃圾回收。因此，就像`WeakMap`一样，对于迭代，`WeakSet`也是如此：我们无法对集合进行迭代。'
- en: '`WeakSet` has a very small amount of built-in functions, namely add, delete,
    and has. `WeakSet` also has a `length` property, similar to arrays, as opposed
    to the `size` property for `Map`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakSet`有非常少量的内置函数，即add，delete和has。`WeakSet`还有一个`length`属性，类似于数组，而不是`Map`的`size`属性。'
- en: Let's take a quick look at the syntax for creating a `WeakSet` object, and its
    property and functions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下创建`WeakSet`对象的语法，以及它的属性和函数。
- en: 'We can create an empty `WeakSet` object using its constructor:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用其构造函数创建一个空的`WeakSet`对象：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s create three empty objects to add to our `WeakSet`, and then add them
    to it using the `WeakSet` object''s `add` function, and then get the number of
    objects it contains using its `length` property:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建三个空对象添加到我们的`WeakSet`中，然后使用`WeakSet`对象的`add`函数将它们添加到其中，然后使用其`length`属性获取它包含的对象数量：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You may be asking, *Wait a minute. You said that the objects must all be unique,
    and any duplicates will not be inserted into the WeakSet* object. *All the objects
    are empty; are they not the same?* True, duplicate objects will be rejected when
    the insertion operation is tried. However, while our three objects all have the
    same value (that is, they are all empty), they are in fact three separate and
    distinct objects.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问，*等一下。您说对象必须都是唯一的，任何重复的对象都不会被插入到WeakSet*对象中。*所有对象都是空的；它们不是相同的吗？*是的，当尝试插入操作时，重复的对象将被拒绝。然而，虽然我们的三个对象都具有相同的值（即它们都是空的），但它们实际上是三个独立且不同的对象。
- en: In JavaScript, as with most other object-oriented languages, it is the object
    reference (that is, the underlying memory address) and not its contents that determine
    whether the object is the same as another object or not.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，与大多数其他面向对象的语言一样，决定对象是否与另一个对象相同的是对象引用（即底层内存地址），而不是其内容。
- en: 'Here is how you can compare two object variables referencing the same object:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以比较两个引用同一对象的对象变量的方法：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`objA` and `objB` each reference empty objects, but these are two different
    objects; thus, `blnSameObject` will be set to `false`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`objA`和`objB`各自引用空对象，但这是两个不同的对象；因此，`blnSameObject`将被设置为`false`。'
- en: 'If we did the following since the `objB` and `objC` variables point to the
    same object in memory, the line that tries to add `objC` to `myWeakSet` will have
    no effect on `myWeakSet` because the underlying object was already contained in
    the `WeakSet` object:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们做了以下操作，由于`objB`和`objC`变量指向内存中的同一个对象，试图将`objC`添加到`myWeakSet`的行将不会对`myWeakSet`产生影响，因为底层对象已经包含在`WeakSet`对象中：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Classes
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: Several pages ago, we covered three different ways to create an object in JavaScript.
    I had also mentioned that we were going to cover how to create an object using
    the ES6 class syntax later on. Additionally, I had mentioned that JavaScript doesn't
    have the notion of classes, yet we're covering classes in this section. Let's
    clear all this up and take a look at how to create classes in JavaScript, and
    how to create objects from these classes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 几页前，我们介绍了在JavaScript中创建对象的三种不同方法。我还提到我们将在后面介绍如何使用ES6类语法创建对象。此外，我还提到JavaScript没有类的概念，但我们在本节中涵盖了类。让我们澄清这一切，看看如何在JavaScript中创建类，以及如何从这些类创建对象。
- en: For JavaScript releases prior to ES6, the notion of classes did not exist. Rather,
    whenever you created an object, under the hood the JavaScript runtime would inherit
    directly from other objects, and not from classes (remember that JavaScript is
    not a classical object-oriented language; it uses prototypal inheritance). This
    doesn't make JavaScript *bad*, but it does make it different. In order to bring
    the same style and semantics from classical object orientation, ES6 brought us
    the notion of classes. A class is a blueprint for objects, and when we create
    an object from this blueprint, or template, it is referred to as instantiation.
    We use a class to instantiate (to bring into existence) one or more objects from
    it. Let's get into the syntax.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6之前的JavaScript版本中，不存在类的概念。相反，每当创建对象时，JavaScript运行时会直接从其他对象继承，而不是从类继承（请记住，JavaScript不是经典的面向对象语言；它使用原型继承）。这并不是说JavaScript*不好*，但它确实与众不同。为了将经典面向对象的风格和语义带入，ES6给我们带来了类的概念。类是对象的蓝图，当我们从这个蓝图或模板创建一个对象时，它被称为实例化。我们使用类来实例化（使之存在）一个或多个对象。让我们来看一下语法。
- en: 'Let''s create a `Car` class and give it a constructor, three properties, and
    three methods:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`Car`类，并为其提供一个构造函数、三个属性和三个方法：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: I've purposely used the term *methods* here, whereas previously I had always
    referred to them as *functions*. Since we're now discussing classes and objects,
    in the classical object-orientation parlance, *method *is of better choice a word
    than *function*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意在这里使用了术语*方法*，而以前我总是把它们称为*函数*。因为我们现在讨论的是类和对象，在经典的面向对象术语中，*方法*比*函数*更好。
- en: 'The two relationships that you need to remember for any object-oriented language,
    are the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要记住任何面向对象语言的两种关系，如下：
- en: Objects are instances of their classes
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象是它们类的实例
- en: Objects encapsulate data and methods that manipulate that data
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象封装了操作数据的数据和方法
- en: The data represents the state of the object at any moment in time, and the methods
    represent the behaviors the object has. That's pretty much it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 数据代表对象在任何时刻的状态，方法代表对象具有的行为。就是这样。
- en: 'OK, back to our class example. Our `Car` class has a constructor that takes
    two parameters: the car''s make and model. It also has three instance variables:
    `make`, `model`, and `speed`. Additionally, it has two methods, `speedUp` and
    `slowDown`. Lastly, the `speed` instance variable is actually a property; this
    is because it has an associated getter and setter.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，回到我们的类示例。我们的`Car`类有一个构造函数，它接受两个参数：汽车的制造商和型号。它还有三个实例变量：`make`，`model`和`speed`。此外，它有两个方法，`speedUp`和`slowDown`。最后，`speed`实例变量实际上是一个属性；这是因为它有一个关联的getter和setter。
- en: Something to pay attention to is that the setter and getter in our class have
    an underscore in front of the property name, while the associated instance variable
    does not. This is important because, without the underscores, the JavaScript runtime
    would throw an exception (that is, `RangeError: Maximum call stack size exceeded`) when
    instantiating your `Car` object.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '需要注意的是，我们类中的setter和getter在属性名称前面有一个下划线，而关联的实例变量没有。这很重要，因为如果没有下划线，JavaScript运行时在实例化您的`Car`对象时会抛出异常（即`RangeError:
    Maximum call stack size exceeded`）。'
- en: Great! So, how do we create our instance of it (that is, a `Car` object), and
    how can we call its methods and read its property?Here's the code to help answer
    these questions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！那么，我们如何创建它的实例（即`Car`对象），以及如何调用它的方法和读取它的属性？以下是代码来帮助回答这些问题。
- en: 'We create our `Car` object just like any other object, by calling its constructor:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建我们的`Car`对象就像创建任何其他对象一样，通过调用它的构造函数：
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s read our car''s current speed:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们读一下我们车的当前速度：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Oh, man! `Zero` miles per hour? That''s unacceptable. Let''s step on the gas
    pedal! See this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，天啊！零英里每小时？这是不可接受的。让我们踩油门！看这个：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'How fast are we going? We''d better check:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的速度有多快？我们最好检查一下：
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Crap! We just entered a school zone and have to drop down to a maximum speed
    of 20 mph:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 该死！我们刚刚进入了一个学校区，必须将最高速度降到20英里/小时：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s check our speed again:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次检查我们的速度：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Whew! OK, we're good at this speed, for now.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！好了，目前我们的速度还可以。
- en: 'To wrap up this section, here are a couple of things to keep in mind about
    classes in JavaScript:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下这一部分，在JavaScript中有几件事情要记住：
- en: Unlike Java or Python, for instance, classes in JavaScript can only have one
    constructor. Overloading constructors is not supported.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Java或Python不同，JavaScript中的类只能有一个构造函数。不支持构造函数重载。
- en: You can have a super call in your class (used in calling the constructor of
    a class higher up in the hierarchy), but it must be called prior to using the
    `this` reference, as in when we assign the `make` and `model` parameters to their
    respective instance variables.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在你的类中使用super调用（用于调用层次结构中更高级别的类的构造函数），但必须在使用`this`引用之前调用它，就像我们将`make`和`model`参数分配给它们各自的实例变量时一样。
- en: Interfaces
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: So far, we have been looking at several new additions to JavaScript that have
    been made available to us. This section on interfaces, for our purposes, is a
    TypeScript-specific thing, since JavaScript does not have the notion of interfaces.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在看一些JavaScript的新添加，这些对我们来说是可用的。对于我们来说，接口部分是TypeScript特有的东西，因为JavaScript没有接口的概念。
- en: 'Interfaces are like a contract for a class and provide a set of rules that
    the class must follow. Let''s switch gears from building a `Car` class to building
    an `Animal` class, and, while we''re at it, let''s have our class implement an
    interface we''ll call `Species`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接口就像是类的合同，并提供了类必须遵循的一组规则。让我们从构建`Car`类转换到构建`Animal`类，并且在此过程中，让我们的类实现一个我们称之为`Species`的接口：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Our `Animal` class is empty. It doesn't even have a constructor or any instance
    variables, and that is not a problem for us, since it still serves our purposes
    to demonstrate how to use interfaces.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Animal`类是空的。它甚至没有构造函数或任何实例变量，但对我们来说这并不是问题，因为它仍然可以满足我们演示如何使用接口的目的。
- en: 'Take a look at the `Species` interface for a moment. You''ll notice a couple
    of things:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微看一下`Species`接口。你会注意到一些事情：
- en: It has two public properties. TypeScript has access modifiers, just like Java
    and C# have, and we'll get to those when we make use of them in later chapters.
    For now, all you need to know is that the lack of an access modifier on the properties
    makes the properties public. This is important because since an interface describes
    the public interface of the class that implements it, its properties must be public.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有两个公共属性。TypeScript有访问修饰符，就像Java和C#一样，我们将在后面的章节中使用它们时介绍。现在，你只需要知道属性上缺少访问修饰符意味着属性是公共的。这很重要，因为由于接口描述了实现它的类的公共接口，其属性必须是公共的。
- en: The second thing that you'll notice is that we're typing the properties. We're
    declaring the `name` property as being of type string, and the `isExtinct` property
    as being of type boolean. This is one major advantage of TypeScript, as we've
    previously learned, and is where TypeScript got its name (that is, a typed JavaScript).
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二件你会注意到的事情是我们在输入属性。我们声明`name`属性的类型为字符串，`isExtinct`属性的类型为布尔值。这是TypeScript的一个主要优势，正如我们之前学到的那样，也是TypeScript得名的原因（即，一个有类型的JavaScript）。
- en: 'We''ll see access modifiers in action later in the book. There are three of
    them:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面看到访问修饰符的作用。有三种：
- en: '**Public:** This is the default modifier and it means that the property or
    function is visible to all other code'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共的：** 这是默认的修饰符，意味着属性或函数对所有其他代码可见'
- en: '**Private:** The visibility to a class''s properties and functions marked as
    private are only available to member functions of the class that they''re declared
    in'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有：** 类的属性和函数标记为私有的可供其声明的类的成员函数使用'
- en: '**Protected**: This is the same as private, but the class members are also
    visible to any classes that are inherited from the class that they''re declared
    in'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护的：** 这与私有相同，但类成员也对从其声明的类继承的任何类可见'
- en: The way in which we marry the class to the interface is by using the `implements`
    keyword in the class definition, as we have done so in this example. Once we do
    that, the class must adhere to the interface contract.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将类与接口结合的方式是在类定义中使用`implements`关键字，就像我们在这个例子中所做的那样。一旦我们这样做，类必须遵守接口的合同。
- en: So now what? Well, if the `Animal` class doesn't implement the two properties
    that the `Species` interface says it must, then TypeScript will throw an error
    during transpilation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 那么现在呢？如果`Animal`类没有实现`Species`接口规定的两个属性，那么TypeScript在转译过程中会抛出错误。
- en: We can also have an interface describe an optional contract, and we can do this
    by appending a question mark to the end of the property or function. We don't
    have a function listed in our interface, but we can absolutely have functions
    as well.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在属性或函数的末尾添加问号来描述一个可选的接口。我们的接口中没有列出函数，但我们也绝对可以有函数。
- en: 'If our interface was an optional contract, it would look like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的接口是一个可选的合同，它会是这样的：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Inheritance
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: We mentioned that class members marked with the protected access modifier are
    also visible to any classes that are inherited from the class that they're declared
    in, and so we'd better discuss inheritance real quick.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，标有受保护访问修饰符的类成员也对任何从它们声明的类继承的类可见，因此我们最好快速讨论一下继承。
- en: Inheritance does not mean that the classes that we create will become independently
    wealthy; that's a whole different kind of inheritance. The kind of inheritance
    that we're talking about is a little less exciting, but far more useful for our
    JavaScript code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 继承并不意味着我们创建的类会变得独立富裕；那是一种完全不同的继承。我们谈论的继承类型可能不那么令人兴奋，但对于我们的JavaScript代码来说，它更有用。
- en: 'A class can inherit from another class. In order for a class to do that, we
    use the `extends` keyword in the class definition. Let''s switch gears once more,
    this time going from `Animal` to `Employee` (though I''ve seen some bathrooms
    and kitchens at a couple of my client locations, and I can tell you that some
    employees can also be animals). Let''s get to the code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以从另一个类继承。为了做到这一点，我们在类定义中使用`extends`关键字。让我们再次转换一下，这次是从`Animal`到`Employee`（尽管我在一些客户地点的一些浴室和厨房看到过一些动物，我可以告诉你一些员工也可以是动物）。让我们来看代码：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s create an `Employee` object, and have the employee announce himself:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`Employee`对象，并让员工宣布自己：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s create a `Manager` object and have the manager announce himself:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`Manager`对象，并让经理宣布自己：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here''s what''s going on:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么：
- en: We created an `Employee` class.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`Employee`类。
- en: We created a `Manager` class that inherits from `Employee`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个从`Employee`继承的`Manager`类。
- en: The `Manager` class does not have any properties or functions, other than it's
    constructor. However, it inherits the properties (`name` and `title`), and the
    method (`annouceThyself`), from the `Employee` class.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Manager`类除了构造函数之外，没有任何属性或函数。但是，它从`Employee`类继承了属性（`name`和`title`）和方法（`annouceThyself`）。'
- en: The constructor in the `Manager` class calls the constructor in the `Employee`
    class, passing in the manager's name.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Manager`类中的构造函数调用`Employee`类中的构造函数，传递经理的名字。'
- en: The manager's constructor reassigns the value for the `title` property.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经理的构造函数重新分配了`title`属性的值。
- en: 'This was fairly straightforward but there are two takeaways here for you to
    remember:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当简单的，但这里有两个要点要记住：
- en: The inheriting class gets all the class members from the class that it inherits
    from
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承类从它继承的类中获取所有类成员。
- en: One constructor can call it's parent's constructor, and this can continue up
    the chain, if the parent had a parent, and so on
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数可以调用它的父类的构造函数，并且如果父类有父类，等等，这种情况可以一直延续下去。
- en: Destructuring
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构
- en: Destructuring is a super cool and super useful construct that we will use many
    times throughout this book, and it'll be something that you won't be able to live
    without in your Angular projects well after you finish this book. In short, destructuring
    is a JavaScript expression that enables us to easily extract data from objects
    and collections.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 解构是一个非常酷和非常有用的构造，我们将在本书中多次使用它，而且在你完成本书后，你在你的Angular项目中也无法离开它。简而言之，解构是一个JavaScript表达式，它使我们能够轻松地从对象和集合中提取数据。
- en: Back when we were looking at `Map` objects, I had mentioned that we would look
    at an example of destructuring. Here it is.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看`Map`对象时，我提到我们会看一个解构的例子。在这里。
- en: 'Assume we have the following object:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下对象：
- en: '[PRE47]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we wanted to extract `firstName`, `lastName`, and `publisher`, we know exactly
    how to do that the old-fashioned way (that is, before ES6):'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想提取`firstName`，`lastName`和`publisher`，我们知道如何以传统的方式做到这一点（即在ES6之前）：
- en: '[PRE48]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Well, destructuring (despite it''s odd-looking syntax) saves us a lot of keystrokes
    by giving us the exact same result (new variables with the extracted data) with
    the following syntax:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，解构（尽管它的语法看起来有点奇怪）通过以下语法节省了我们大量的按键次数，给我们提供了相同的结果（提取数据的新变量）：
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can easily see that it did its job by writing a variable out to the console:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地看到，它通过将一个变量写入控制台来完成了它的工作：
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It's pretty handy, and we're going to make good use of it when we write our
    application together.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便，当我们一起编写应用程序时，我们将充分利用它。
- en: Template strings
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板字符串
- en: Template strings are strings that are enclosed within backticks (that is, `
    ).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串是用反引号括起来的字符串（即`）。
- en: 'Note: the backtick character is typically found on the same key on your keyboard
    as the tilde (that is ~), and is immediately to the left of the number 1 key.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：反引号字符通常与波浪号（即~）在键盘上的同一个键上，并且紧挨着数字1键的左边。
- en: 'JavaScript always gave us the ability to create strings using double quotes
    as well as by using single quotes, so what was the motivation for the third type
    of string creation character? Well, as it turns out, given the proliferation of
    frontend frameworks, there was a common need to do three things:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript总是允许我们使用双引号和单引号来创建字符串，那么为什么要使用第三种类型的字符串创建字符呢？嗯，事实证明，鉴于前端框架的大量使用，有一个共同的需求需要做三件事：
- en: String interpolation
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串插值
- en: Multiline strings
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多行字符串
- en: Tagged templates
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记模板
- en: for-of loop
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for-of循环
- en: JavaScript brought us the `forEach` construct for looping through collections.
    It is a great built-in method to use, but you can't break out of this loop. We
    also have the `for-in` loop, which is great for objects with keys that are strings,
    but it has some drawbacks when iterating through arrays.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript为我们带来了`forEach`构造，用于循环遍历集合。这是一个很好的内置方法，但你无法跳出这个循环。我们还有`for-in`循环，对于具有字符串键的对象来说非常好，但在迭代数组时有一些缺点。
- en: 'Enter the new `for-of` loop. It works well for objects, arrays, and maps, and
    you can break out of it. Here is the syntax, which is identical to that for the
    `for-in` loop, other than changing `in` to `of`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 进入新的`for-of`循环。它适用于对象、数组和映射，并且你可以跳出它。以下是语法，与`for-in`循环的语法相同，只是将`in`更改为`of`：
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Decorators
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: Decorators are also a TypeScript thing. Decorators in TypeScript decorate functions
    and classes, just as they do in some other languages, such as Python and Java.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器也是TypeScript的一部分。TypeScript中的装饰器装饰函数和类，就像它们在其他一些语言中一样，比如Python和Java。
- en: We won't spend too much time here because we won't be writing our own decorators
    for the application we're going to build together, but since Angular makes use
    of decorators quite a bit, I wanted to at least give you an idea of what they
    are used for. We'll also look at a quick example of how to create one and how
    to use it, but we'll fly through it quickly.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会花太多时间在这里，因为我们不会为我们要一起构建的应用程序编写自己的装饰器，但由于Angular大量使用装饰器，我想至少让你了解它们的用途。我们还将看一个快速的例子，如何创建一个装饰器以及如何使用它，但我们会快速地飞过它。
- en: 'Decorators are a way to add functionality to a function or a class (typically
    a class), by annotating the class with the decorator. The decorator is just a
    function, although it has some strange looking syntax at first glance. Let''s
    look at some code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是一种通过用装饰器注释类来为函数或类（通常是类）添加功能的方法。装饰器只是一个函数，尽管乍一看它的语法看起来有些奇怪。让我们看一些代码：
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is intermediate to advanced level TypeScript, and an entire chapter can
    be written on decorators. We don't have the luxury to cover them in detail here,
    but the takeaway is that they are simply functions that add functionality to functions
    or classes, and to do that you only need to annotate the function or class with
    the name of the decorator (that is, `@NameOfDecorator`).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是中级到高级水平的TypeScript，整个章节都可以写关于装饰器的内容。我们没有时间在这里详细介绍它们，但要记住的是，它们只是简单地为函数或类添加功能的函数，你只需要用装饰器的名称来注释函数或类（即`@NameOfDecorator`）。
- en: Promises
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promises
- en: We will cover promises in greater detail when we make use of them in [Chapter
    12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating Backend Data Services*,
    and so I'll defer the code until that time. The reason is thatshowing a really
    good real-world example of a promise, so that it's not contrived, takes quite
    a bit of code, since there needs to be asynchronous code that is called. So, I
    promise to have real-world promises later on in the book. However, we can at least
    look at a definition so that you know what they are.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第12章](9610f27b-03db-4258-8a68-24eb3901117b.xhtml) *集成后端数据服务*中使用它们时，我们将更详细地介绍promises，所以我会推迟代码。原因是展示一个真正好的实际例子需要相当多的代码，因为需要调用异步代码。所以，我承诺在书中稍后会有真实世界的promises。但是，我们至少可以看一下定义，这样你就知道它们是什么。
- en: When you call a function that may take a long time to return a result or to
    complete its task, and you don't want to delay the execution of your program,
    you can call that function asynchronously. This means that your code will continue
    on to the next line after it calls the function on the previous line asynchronously.
    If you don't call it asynchronously, your program's execution will stop and wait
    for the function you last called to return from what it was doing, such as reading
    a bunch of records from a database.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个可能需要很长时间才能返回结果或完成任务的函数时，而且你不想延迟程序的执行，你可以异步调用该函数。这意味着你的代码在异步调用前一行后会继续执行到下一行。如果你不异步调用它，你的程序的执行将停止并等待你最后调用的函数从它正在做的事情中返回，比如从数据库中读取一堆记录。
- en: There are a few different ways to call a function asynchronously. The most common
    way to call a function asynchronously is to use callbacks. A callback is a function
    that you pass to the function that you call asynchronously so it can then call
    that function when it has completed its work. That's how callbacks got their name;
    the function you called calls you back when it's done.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的方法可以异步调用函数。异步调用函数最常见的方式是使用回调函数。回调函数是你传递给异步调用的函数的函数，这样它就可以在完成工作后调用该函数。这就是回调函数得名的原因；你调用的函数在完成时会回调你。
- en: Promises are another mechanism we can use to program asynchronously. Although
    Promises made things a little more manageable, writing good asynchronous code
    in JavaScript is often still notoriously difficult. Because of this fact, people
    started writing JavaScript libraries to try and make asynchronous code easier
    to write. There are several out there. One library that saved my sanity is called
    Async.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Promises是我们可以用来异步编程的另一种机制。虽然Promises使事情变得更加可控，但在JavaScript中编写良好的异步代码通常仍然非常困难。因为这个事实，人们开始编写JavaScript库来尝试使异步代码更容易编写。有几种库可供选择。一个拯救了我的理智的库叫做Async。
- en: 'All this being said, I still have not given you a definition of Promises, so
    here it is: a Promise is a proxy for a value that is not yet known; it''s like
    a placeholder for the value that will eventually come back from a function that
    was called asynchronously. This construct allows asynchronous functions to immediately
    return a value as if it was a synchronous method. The initial value that is returned
    is a Promise, and the Promise will eventually be replaced by the value that comes
    back from the called function once it has completed its work.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我仍然没有给你一个Promise的定义，所以在这里：Promise是一个代理尚未知的值；它就像一个值的占位符，最终将从异步调用的函数中返回。这种构造允许异步函数立即返回一个值，就像它是一个同步方法一样。返回的初始值是一个Promise，一旦调用的函数完成了它的工作，Promise最终将被返回的值替换。
- en: I know this may be a lot to get your head around, but when we write our code
    in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating Backend
    Data Services*, you will understand Promises. That's a promise, pun intended.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这可能需要花费一些时间来理解，但当我们在[第12章](9610f27b-03db-4258-8a68-24eb3901117b.xhtml)中编写我们的代码，*集成后端数据服务*，你将理解Promise。这是一个承诺，双关语。
- en: Modules
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: Prior to ES6, JavaScript did not have the notion of modules. Modules are simple
    code files that can be loaded into the other code so that the functions within
    the module that is being loaded are made available to the code that is importing
    the module. Modules can load modules. Modules lead to modular code, and that is
    a good thing. Rather than write a monolithic bunch of code in one file, you can
    split it up into logical units and have that code live in more than one file.
    This leads to code reuse, namespacing, and maintainability.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6之前，JavaScript没有模块的概念。模块是简单的代码文件，可以加载到其他代码中，以便加载的模块中的函数对导入模块的代码可用。模块可以加载模块。模块导致模块化的代码，这是一件好事。与其在一个文件中编写庞大的代码块，不如将其分割成逻辑单元，并使该代码存在于多个文件中。这导致了代码重用，命名空间和可维护性。
- en: While JavaScript didn't have modules, we were still able to accomplish the same
    thing, to a degree. We can load script files with script tags before calling their
    functions in our web pages. However, what about JavaScript running on the server
    side, or another environment outside of web pages? Without modules, writing non-monolithic
    applications becomes difficult.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JavaScript没有模块，但我们仍然能够在一定程度上实现相同的功能。我们可以在网页中调用函数之前使用脚本标签加载脚本文件。但是，对于在服务器端或网页之外的其他环境中运行的JavaScript，没有模块，编写非单片应用程序变得困难。
- en: let's move on to the code.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行代码。
- en: 'Assume we have a file named `alphafunctions.js` that has the following code
    in it:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`alphafunctions.js`的文件，其中包含以下代码：
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `export` keyword is used to mark which functions can be exported and thus
    imported into other modules.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`export`关键字用于标记哪些函数可以被导出，因此可以被其他模块导入。'
- en: 'Let''s now assume we have this file, `main.js`, with the following code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们有这个文件`main.js`，其中包含以下代码：
- en: '[PRE54]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Default exports
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认导出
- en: Let's assume that we always want to import our `alpha1` function into other
    modules, or at least more often than not. We can add the keyword's export default
    before the `keyword` function. So, when we import it, we no longer need the curly
    braces around the function name. Let's see this in the code.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们总是希望将我们的`alpha1`函数导入到其他模块中，或者至少更频繁地这样做。我们可以在`keyword`函数之前添加关键字`export default`。因此，当我们导入它时，我们不再需要在函数名称周围使用大括号。让我们在代码中看到这一点。
- en: 'See `alphafunctions.js`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`alphafunctions.js`：
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'See `main.js`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`main.js`：
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: While this isn't an earth-shattering difference, the terms default exports do
    come up in conversation and in code snippets on blog posts, and so on, so I wanted
    to make sure we at least took a quick look so that you understood why the curly
    braces were sometimes there, and other times not. When you use JavaScript libraries,
    you'll see this in the documentation and code examples as well. So, now you know.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不是一个惊人的差异，但“默认导出”这个术语在对话和博客文章的代码片段中经常出现，因此我想确保我们至少快速看一下，这样你就明白为什么有时会有大括号，而有时没有。当你使用JavaScript库时，你也会在文档和代码示例中看到这一点。所以，现在你知道了。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have covered some of the history around JavaScript, and
    specifically the series of fortunate events around JavaScript's ecosystem that
    have cemented the language as the most important programming language in recent
    history. We can now not only write client-side code for execution in the browser,
    but we can write JavaScript code that runs on the server. As if this wasn't a
    compelling enough reason to use more JavaScript than what you may have used in
    the past, you can also use JavaScript for native mobile development, and for creating
    desktop applications as well. It's quite an exciting story!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了JavaScript的一些历史，特别是围绕JavaScript生态系统的一系列幸运事件，这些事件巩固了该语言作为近代最重要的编程语言。现在我们不仅可以编写在浏览器中执行的客户端代码，还可以编写在服务器上运行的JavaScript代码。如果这还不足以成为使用更多JavaScript的有力理由，你还可以将JavaScript用于原生移动开发，以及创建桌面应用程序。这真是一个令人兴奋的故事！
- en: We then took a low fly-by look at the additions to JavaScript that were added
    with the release of ES6\. These additions were quite substantial, especially since
    JavaScript had remained largely unchanged for over a decade, and have really strengthened
    the language as a result. We also enumerated some of the benefits that TypeScript
    brings to the table. Remember that you can view TypeScript as being a superset
    of JavaScript, and you can define it as ES6 plus optional typing.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们简要地查看了ES6发布时添加到JavaScript中的一些内容。这些新增内容相当重要，特别是因为JavaScript在十多年来基本保持不变，因此这些新增内容真正加强了语言。我们还列举了TypeScript带来的一些好处。请记住，你可以将TypeScript视为JavaScript的超集，并且可以将其定义为ES6加上可选类型。
- en: Microsoft's contribution of TypeScript to JavaScript developers was one of the
    most important things the company has contributed to the open source world in
    a long time. Angular itself was written in TypeScript, due to the advantages TypeScript
    has over pure JavaScript, and so when building Angular applications, it's best
    to use TypeScript to write them. We've remembered that JavaScript is the only
    language that can be executed in the browser, but fortunately, TypeScript ships
    with a transpiler to turn our TypeScript code into pure JavaScript code.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 微软将TypeScript贡献给JavaScript开发人员是该公司长期以来对开源世界做出的最重要的贡献之一。Angular本身就是用TypeScript编写的，因为TypeScript相对于纯JavaScript具有优势，所以在构建Angular应用程序时，最好使用TypeScript进行编写。我们记得JavaScript是唯一可以在浏览器中执行的语言，但幸运的是，TypeScript附带了一个转译器，可以将我们的TypeScript代码转换为纯JavaScript代码。
- en: As mentioned in the roadmap, chapter 3 *Bootstrap – Responsive Grid Layout and
    Components*,  we have a similar goal. In this chapter we will do a crash course
    on SASS, which is what we'll be using to style our Angular components instead
    of using CSS. We'll also cover enough of Bootstrap to get you comfortable with
    using the venerable CSS framework to lay out our web pages for ListingCarousel,
    the web application we'll be building together. You'll gain enough knowledge to
    immediately apply these skills to virtually any web application project you may
    currently have or soon be starting on in the future.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如路线图中所述，第3章《Bootstrap - 响应式网格布局和组件》，我们有一个类似的目标。在本章中，我们将对SASS进行快速介绍，这是我们将用来为我们的Angular组件设计样式的工具，而不是使用CSS。我们还将涵盖足够的Bootstrap知识，让您能够舒适地使用这个古老的CSS框架来布局我们将一起构建的网络应用程序ListingCarousel的网页。您将获得足够的知识，立即将这些技能应用于您目前可能拥有或将来可能开始的几乎任何网络应用项目中。
