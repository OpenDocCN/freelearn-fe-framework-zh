- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Using Libraries for Large-Scale Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用库构建大型应用程序
- en: Before you start learning how to use different libraries to develop large-scale
    and enterprise-ready applications with Vue.js 3, you need to understand these
    individual libraries and the various features they are bundled with to help you
    navigate through building scalable and enterprise-ready applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始学习如何使用不同的库使用 Vue.js 3 开发大型和面向企业的应用程序之前，你需要了解这些单个库以及它们捆绑的各种功能，以帮助你导航构建可扩展和面向企业的应用程序。
- en: In this chapter, we will cover the essential aspects of Vuex, Axios, and Vue
    Router and how to integrate them with Vue 3 to develop an enterprise application.
    This background information will put you in a better position to grasp the terms
    and concepts of these libraries and help you understand how to build and scale
    an enterprise-ready application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖 Vuex、Axios 和 Vue Router 的基本方面，以及如何将它们与 Vue 3 集成以开发企业级应用程序。这些背景信息将使你更好地理解这些库的术语和概念，并帮助你了解如何构建和扩展企业级应用程序。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将涵盖以下关键主题：
- en: Exploring large-scale Vuex
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索大型 Vuex
- en: Structuring with the repository pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存储模式进行结构化
- en: Creating a repository folder
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建存储文件夹
- en: Structuring Vue navigation with Vue Router
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Vue Router 结构化 Vue 导航
- en: Once you’ve mastered each of these topics, you will be ready to get started
    with building your first enterprise-ready application with Vue 3.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了这些主题中的每一个，你将准备好开始使用 Vue 3 构建你的第一个企业级应用程序。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To get started with this chapter, we recommend reading through [*Chapter 1*](B17237_01.xhtml#_idTextAnchor015),
    *Getting Started with Vue.js 3*, and its overview of Vue 3 and the Composition
    API, which will be intensively used in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始本章的学习，我们建议阅读 [*第 1 章*](B17237_01.xhtml#_idTextAnchor015)，“Vue.js 3 入门”，以及其中对
    Vue 3 和组合 API 的概述，这些将在本章中广泛使用。
- en: Exploring large-scale Vuex
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索大型 Vuex
- en: '**Vuex** is the state management library for Vue applications. It serves as
    a central store for all the components in a Vue application. It is also a library
    implementation tailored specifically to Vue.js to take advantage of its granular
    reactivity system for efficient updates.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vuex** 是 Vue 应用程序的状态管理库。它作为 Vue 应用程序中所有组件的中心存储。它也是一个专门针对 Vue.js 定制的库实现，以利用其细粒度响应性系统进行高效更新。'
- en: Significant benefits can be derived when using Vuex for the state management
    of a Vue application. Still, it can easily be misused and overwhelmed if not adequately
    structured—especially when building a large-scale enterprise application—due to
    the size of the project and the number of components and features that will be
    introduced in the project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vuex 对 Vue 应用程序进行状态管理可以带来显著的好处。然而，如果不进行适当的结构化，它很容易被误用和压倒，尤其是在构建大型企业级应用程序时——由于项目的规模以及将在项目中引入的组件和功能数量。
- en: To tackle this structure problem, we will introduce you to different structures
    to arrange your Vuex store and the law of predictability discussed in [*Chapter
    4*](B17237_04.xhtml#_idTextAnchor112), *Architecture for Large-Scale Web Applications*,
    to accommodate large-scale Vue applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个结构问题，我们将向您介绍不同的结构来安排您的 Vuex 存储，以及在第 [*第 4 章*](B17237_04.xhtml#_idTextAnchor112)
    中讨论的可预测性法则，“大型 Web 应用程序的架构”，以适应大型 Vue 应用程序。
- en: In this section, we will discuss Vuex states, getters, mutations, and actions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论 Vuex 的状态、获取器、突变和动作。
- en: Practically, the usual way to structure your Vuex store is to have every piece
    of code inside a single `index.js` file called a **single state tree**. This method
    works perfectly for a small project and helps to avoid navigating through different
    files to find a single method.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，结构化 Vuex 存储的常用方法是让所有代码都位于一个名为 **单状态树** 的单个 `index.js` 文件中。这种方法对于小型项目来说非常完美，有助于避免在不同文件中导航以找到单个方法。
- en: However, when developing an enterprise project using Vuex, using single state
    trees becomes very bloated and difficult to maintain.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当使用 Vuex 开发企业项目时，使用单状态树会变得非常臃肿且难以维护。
- en: To reduce this large file and split the file into different features, Vuex allows
    us to divide our store into **Vuex modules**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少这个大文件并将其拆分为不同的功能，Vuex 允许我们将我们的存储拆分为 **Vuex 模块**。
- en: 'Before we dive in, the Vue community has introduced a new state management
    system called Pinia that fixes the problems of Vuex and is directly compatible
    with Vue 3\. As of the time of writing, Pinia was still in the development and
    beta phase. You can learn more about Pinia and how to integrate it into your Vue
    3 application here: [https://pinia.vuejs.org/](https://pinia.vuejs.org/).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入之前，Vue 社区引入了一个新的状态管理系统，称为 Pinia，它解决了 Vuex 的问题，并且与 Vue 3 直接兼容。截至写作时，Pinia
    仍处于开发和测试阶段。你可以在[https://pinia.vuejs.org/](https://pinia.vuejs.org/)了解更多关于 Pinia
    以及如何将其集成到你的 Vue 3 应用程序中的信息。
- en: Vuex modules
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vuex 模块
- en: A Vuex module is a way to split our store based on features, where each module
    can contain its states, getters, actions, mutations, and even nested modules.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 模块是根据功能拆分我们的存储的一种方式，其中每个模块可以包含其状态、获取器、动作、突变，甚至嵌套模块。
- en: This method allows us to split our store into features and create different
    files and folders to arrange the store correctly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许我们将存储拆分为功能，创建不同的文件和文件夹来正确地安排存储。
- en: We’ll learn how we can split our store into features in the next subsection.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中学习如何将我们的存储拆分为功能。
- en: Assuming our *Pinterest* application will have different states such as photos,
    users, comments, and so on, we can split the store into separate modules as opposed
    to having it in a single file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的 *Pinterest* 应用程序将具有不同的状态，如照片、用户、评论等，我们可以将存储拆分为单独的模块，而不是将其放在一个文件中。
- en: Using Vuex modules
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Vuex 模块
- en: 'As stated in the previous section, using Vuex modules comes with great benefits,
    and we will stick to it throughout this book. Firstly, let’s look at the folder
    structure of our Vuex module store:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用 Vuex 模块带来了巨大的好处，我们将在这本书中坚持使用它。首先，让我们看看我们的 Vuex 模块存储的文件夹结构：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in the preceding code block, we have created different modules
    to wrap our Vuex state, actions, and mutations respectively. It can be useful
    to structure our project into different features.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前代码块所示，我们创建了不同的模块来分别包装我们的 Vuex 状态、动作和突变。这有助于将我们的项目结构化为不同的功能。
- en: Now that we understand how to structure our Vuex store for enterprise projects,
    let’s discuss how to access and manage the store from a component in Vue in the
    next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何为企业项目构建 Vuex 存储，让我们在下一节中讨论如何在 Vue 组件中访问和管理存储。
- en: The Vuex state
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vuex 状态
- en: First and most importantly, let’s discuss states and how we can manage the state
    of a module Vuex store.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，也是最重要的，让我们讨论状态以及我们如何管理模块 Vuex 存储的状态。
- en: '**The Vuex state** is the data you stored inside your Vuex store and can be
    accessed anywhere in your Vue application.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vuex 状态**是你在 Vuex 存储内部存储的数据，可以在你的 Vue 应用程序的任何地方访问。'
- en: The Vuex state follows the single-state-tree pattern. This single object contains
    all your application-level states. It serves as the “single source of truth”.
    But, since we’re adopting modularity to manage our enterprise-ready application,
    we are going only to learn how to access and manage our module states.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 状态遵循单状态树模式。这个单一的对象包含所有应用程序级别的状态。它作为“单一事实来源”。但是，由于我们正在采用模块化来管理我们的企业级应用程序，我们只将学习如何访问和管理我们的模块状态。
- en: 'The following code snippet shows how to create a simple Vuex state:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何创建一个简单的 Vuex 状态：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In addition, you can access a Vuex store outside of components. For example,
    you access Vuex inside of Vue services, helper files, and so on. However, in the
    next section, we will explore different ways to access our state in the components.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以在组件外部访问 Vuex 存储。例如，你可以在 Vue 服务、辅助文件中等地方访问 Vuex。然而，在下一节中，我们将探讨在组件中访问状态的不同方法。
- en: Accessing state without mapping
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不映射访问状态
- en: Assuming this is our store for all photos in our *Pinterest* application and
    we have that `photos` state, how do we access it in our components?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这是我们 *Pinterest* 应用程序中所有照片的存储，并且我们有那个 `photos` 状态，我们如何在组件中访问它？
- en: 'To access the `Photos` array, we will use our module name with the store name,
    as shown in the following code snippet:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 `Photos` 数组，我们将使用模块名称与存储名称，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The previous code snippet shows how to access a moduled store by creating a
    new `Photos` component and displaying all the photos in the photo’s state.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何通过创建一个新的 `Photos` 组件来访问模块存储，并显示照片状态中的所有照片。
- en: To access the `Photos` state array, we used the name of the module it belongs
    to and accessed the state property *before* the `photos` array.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 `Photos` 状态数组，我们使用了它所属的模块名称，并在 `photos` 数组之前访问了状态属性。
- en: Next, we’re going to explore how to access the Vuex state using the mapping
    approach.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何使用映射方法访问 Vuex 状态。
- en: Accessing the state with mapping
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用映射访问状态
- en: The best way to access the store is to use **Vuex state maps**, ([https://vuex.vuejs.org/guide/state.html#the-mapstate-helper](https://vuex.vuejs.org/guide/state.html#the-mapstate-helper)),
    which we will use throughout this book. You c[an go to the official Vuex](https://vuex.vuejs.org/)
    documentation ([https://vuex.vuejs.org/](https://vuex.vuejs.org/)) to learn more.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 访问存储的最佳方式是使用 **Vuex 状态映射**（[https://vuex.vuejs.org/guide/state.html#the-mapstate-helper](https://vuex.vuejs.org/guide/state.html#the-mapstate-helper)），我们将在这本书的整个过程中使用它。你可以访问官方
    Vuex（[https://vuex.vuejs.org/](https://vuex.vuejs.org/)）文档了解更多信息。
- en: Using Vuex mappers is great when your components need to make use of multiple
    store-state properties or getters. Declaring all these states and getters can
    get repetitive and verbose, and that’s exactly what a Vuex mapper tends to solve.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的组件需要使用多个存储状态属性或获取器时，使用 Vuex 映射器是非常好的。声明所有这些状态和获取器可能会变得重复和冗长，这正是 Vuex 映射器试图解决的问题。
- en: 'Let’s take an example of creating a simple `Photos` component and using the
    Vuex state to display different images:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以创建一个简单的 `Photos` 组件并使用 Vuex 状态来显示不同图像为例：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding snippet creates a `Photos` component, loops through the data from
    our Vuex state, and displays the images in the store.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段创建了一个 `Photos` 组件，遍历 Vuex 状态中的数据，并在存储中显示图像。
- en: There you have it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。
- en: We will use this method in further discussion with actions, mutations, and getters.
    You should *never* forget the names of your modules.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在与动作、突变和获取器的进一步讨论中使用此方法。你绝对不应该忘记你模块的名称。
- en: We now have a fair understanding of the Vuex state and modules and how we will
    structure our enterprise and large-scale Vuex application for easy maintainability
    and accessibility.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对 Vuex 状态和模块有了相当的了解，以及我们将如何构建我们的企业级和大规模 Vuex 应用程序，以便易于维护和访问。
- en: Let’s discuss getters and how we can manipulate our Vuex state using **Vuex
    getters** and map getters in the next section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论获取器，以及我们如何在下一节中使用 **Vuex 获取器**和映射获取器来操作我们的 Vuex 状态。
- en: Vuex getters
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vuex 获取器
- en: Vuex getters are very useful for manipulating the Vuex state. Sometimes, you
    might want to filter or sort the Vuex state before returning the data to the components.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 获取器（getters）在操作 Vuex 状态方面非常有用。有时，你可能想在将数据返回给组件之前过滤或排序 Vuex 状态。
- en: Vuex allows us to create getters that manipulate the state just as computed
    properties in Vue will do. It also caches the result and updates the cache when
    data changes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 允许我们创建获取器（getters），就像 Vue 中的计算属性一样操作状态。它还会缓存结果，并在数据更改时更新缓存。
- en: 'In each module, we will define its specific getters to manipulate the state
    in that module. For example, we will create a getter to filter photos based on
    user ID in our `Photos` module, like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个模块中，我们将定义其特定的获取器来操作该模块的状态。例如，我们将在 `Photos` 模块中创建一个获取器，根据用户 ID 过滤照片，如下所示：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code snippet shows how to create a getter that filters all the
    photos added by a particular user whose ID is passed to the `getters` method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何创建一个获取器，该获取器可以过滤出通过 `getters` 方法传递的特定用户 ID 添加的所有照片。
- en: 'Next, let’s access the getter in our component using the `map` helper. See
    the following code snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 `map` 辅助函数在我们的组件中访问获取器。请看以下代码片段：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Vuex getters are a great way to manipulate and manage Vuex states before they
    go out to our components and can come in handy for filtering, sorting, updating,
    and deleting records from our Vuex state.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 获取器是操作和管理 Vuex 状态的绝佳方式，在它们发送到我们的组件之前非常有用，并且对于过滤、排序、更新和从 Vuex 状态中删除记录都很有帮助。
- en: Next, we will discuss **Vuex mutations** and how we can use them in an enterprise-ready
    application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 **Vuex 突变**以及如何在企业级应用程序中使用它们。
- en: Vuex mutations
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vuex 突变（mutations）
- en: The only way to change the state of a Vuex state is by committing a mutation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 更改 Vuex 状态的唯一方法是提交一个突变（mutation）。
- en: A Vuex mutation is similar to an event. It takes a string called `type` and
    a function called `handler`. The `handler` function is where you perform the mutation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 突变类似于事件。它包含一个名为 `type` 的字符串和一个名为 `handler` 的函数。`handler` 函数是执行突变的地方。
- en: 'Assuming we’re still working with our *Pinterest* photo store, we can add a
    new `Photo` object to our state with the following code snippet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们仍在使用我们的 *Pinterest* 照片存储，我们可以使用以下代码片段向我们的状态中添加一个新的 `Photo` 对象：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we will look at accessing the Vuex mutation module. We can access it
    using Vuex map helpers, which is the recommended way for enterprise projects:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看访问 Vuex 突变模块。我们可以使用 Vuex 映射辅助工具来访问它，这是企业项目的推荐方式：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Lastly, we can call the `addPhoto()` method anywhere in our component, pass
    the `Photo` object as the only argument, and let Vuex do its thing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在组件的任何地方调用 `addPhoto()` 方法，将 `Photo` 对象作为唯一参数传递，让 Vuex 做它的事情。
- en: In addition, the most comprehensive place to use Vuex mutations is in **Vuex
    actions**. In the next section, we will discuss Vuex actions in detail and demonstrate
    how they can be used in enterprise applications.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用 Vuex 突变的最佳位置是在 **Vuex 动作** 中。在下一节中，我们将详细讨论 Vuex 动作并展示它们如何在企业应用程序中使用。
- en: Vuex actions
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vuex 动作
- en: Vuex actions are similar to Vuex mutations, but instead, they are asynchronous
    and are primarily used to commit Vuex mutations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 动作类似于 Vuex 突变，但它们是异步的，主要用于提交 Vuex 突变。
- en: Vuex actions can make API calls to our backend server and commit the response
    to our Vuex state using Vuex mutations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex 动作可以向我们的后端服务器发出 API 调用，并使用 Vuex 突变将响应提交到 Vuex 状态。
- en: Traditionally, to make an API call with Vuex actions, we will do it directly
    inside the store, as the following code snippet shows.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，要使用 Vuex 动作进行 API 调用，我们将在存储中直接进行，如下代码片段所示。
- en: 'Using our *Pinterest* photo example, we will have a store similar to this one:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的 *Pinterest* 照片示例，我们将有一个类似这样的存储：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, to dispatch the action in our component, we will stick with using Vuex
    maps to dispatch the action and retrieve a new photo corresponding to the ID passed
    into the `getPhoto()` method:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了在我们的组件中分发动作，我们将继续使用 Vuex 映射来分发动作并检索与传递到 `getPhoto()` 方法的 ID 对应的新照片：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So far, we have covered a lot on building large-scale applications with Vuex,
    and we have elucidated Vuex modules, states, getters, mutations, and actions and
    how to apply them in building enterprise-ready applications.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经详细介绍了使用 Vuex 构建大规模应用程序的内容，并阐明了 Vuex 模块、状态、获取器、突变和动作以及如何在构建企业级应用程序中应用它们。
- en: To further solve the problem of structure, we will introduce you to the use
    of the **repository pattern** in arranging your Vuex store, structuring all your
    API calls into a repository, and accessing them in your Vuex actions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步解决结构问题，我们将向您介绍在安排 Vuex 存储时使用 **仓库模式** 的方法，将所有 API 调用结构化到一个仓库中，并在 Vuex 动作中访问它们。
- en: Structuring with the repository pattern
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用仓库模式进行结构化
- en: When building a large-scale, enterprise-ready Vue application, you must get
    the project’s structure right from the ground up.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个大规模、企业级 Vue 应用程序时，你必须从项目结构开始就做对。
- en: Separating your Vuex store into individual modules based on an application’s
    features is excellent and provides direct access to files, making debugging and
    maintenance a breeze.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序的功能将 Vuex 存储分离成单独的模块是很好的，它提供了直接访问文件，使得调试和维护变得容易。
- en: Using this method alone poses a problem. Your Vuex actions become extremely
    large with many API calls, extracting API data, and handling errors all happening
    in the Vuex actions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用这种方法会带来问题。您的 Vuex 动作会变得非常大，包含许多 API 调用，提取 API 数据和处理错误都在 Vuex 动作中发生。
- en: Introducing the repository pattern helps eliminate this bloated code base and
    separates the API calls and management from Vuex.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍仓库模式有助于消除庞大的代码库，并将 API 调用和管理从 Vuex 中分离出来。
- en: In this section, we will first get an overview of the repository pattern. Then,
    we will create a repository folder for our Vue application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先概述仓库模式。然后，我们将为我们的 Vue 应用程序创建一个仓库文件夹。
- en: Firstly, before we explore how to use the repository pattern in Vuex, let’s
    get a clear overview of the repository pattern and what can be achieved with it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们探讨如何在 Vuex 中使用仓库模式之前，让我们先对仓库模式有一个清晰的概述以及它能实现什么。
- en: Overview of the repository pattern
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仓库模式概述
- en: The repository pattern is a significant pattern used in creating an enterprise-level
    application, either the frontend or the backend of any enterprise application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库模式是在创建企业级应用程序时使用的一个重要模式，无论是任何企业应用程序的前端还是后端。
- en: It restricts us from working directly with data in the application and creating
    a new layer for database operations, business logic, and the application UI.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 它限制了我们直接在应用程序中处理数据，并为数据库操作、业务逻辑和应用程序UI创建了一个新的层级。
- en: 'The following is a list of a few reasons you should use the repository pattern
    in your frontend development, especially when building enterprise applications:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你应该在你的前端开发中使用仓库模式的原因列表，尤其是在构建企业应用程序时：
- en: The data access code is reusable everywhere across the entire project
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据访问代码在整个项目中任何地方都是可重用的
- en: It is effortless to implement the domain logic
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现领域逻辑非常容易
- en: You can unit-test your business logic quickly without any form of tight coupling
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以快速对业务逻辑进行单元测试，而无需任何形式的紧密耦合。
- en: It aids in the decoupling of business logic and the application UI
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于解耦业务逻辑和应用程序UI
- en: '**Dependency injection** (**DI**) is good when writing testable enterprise
    code, and repository patterns help you achieve DI even in your frontend projects.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**（**DI**）在编写可测试的企业代码时很好，而仓库模式可以帮助你在前端项目中实现DI。'
- en: DI
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: DI
- en: DI is a programming technique that makes a class independent of its dependencies.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: DI是一种编程技术，它使一个类与其依赖项独立。
- en: In the repository pattern, you write an encapsulated code base by hiding the
    details of how your data is retrieved and processed in your Vuex store.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库模式中，你通过隐藏如何在Vuex存储中检索和处理数据来编写封装的代码库。
- en: To implement the repository pattern, we will follow the *Consuming APIs Using
    the Repository Pattern in Vue.js* article I wrote ([https://medium.com/backenders-club/consuming-apis-using-the-repository-pattern-in-vue-js-e64671b27b09](https://medium.com/backenders-club/consuming-apis-using-the-repository-pattern-in-vue-js-e64671b27b09)).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现仓库模式，我们将遵循我写的关于“在Vue.js中使用仓库模式消费API”的文章（[https://medium.com/backenders-club/consuming-apis-using-the-repository-pattern-in-vue-js-e64671b27b09](https://medium.com/backenders-club/consuming-apis-using-the-repository-pattern-in-vue-js-e64671b27b09)）。
- en: 'To consume our backend APIs in Vue.js using the repository pattern, let’s demonstrate
    doing so with an example. Let’s assume we have a Vuex store action making different
    API calls, such as the one in the following code snippet, and we want to implement
    the repository pattern on it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用仓库模式在Vue.js中消费后端API，让我们通过一个示例来展示如何做到这一点。假设我们有一个Vuex存储操作执行不同的API调用，如下面的代码片段所示，我们想在它上面实现仓库模式：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we can follow the upcoming steps to improve the Vuex store by implementing
    the repository pattern.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以按照接下来的步骤通过实现仓库模式来改进Vuex存储。
- en: Creating a repository folder
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建仓库文件夹
- en: 'First, create a folder in the root directory or `src` folder by running the
    following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过运行以下命令在根目录或`src`文件夹中创建一个文件夹：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will call ours `repositories`. This folder will contain all your repositories
    and the HTTP client configurations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称之为`repositories`。这个文件夹将包含所有你的仓库和HTTP客户端配置。
- en: Creating a clients folder
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建客户文件夹
- en: We will create a `Clients` folder inside the newly created `repositories` folder.
    What will be inside this folder are the different HTTP clients used.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在新创建的`repositories`文件夹内创建一个`Clients`文件夹。这个文件夹里将包含所有使用的HTTP客户端。
- en: Sometimes, due to the nature of the project, some projects might require several
    HTTP clients to make API calls due to different reasons. One can be a fallback
    if the default refuses to connect.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，由于项目的性质，一些项目可能需要多个HTTP客户端来执行API调用，原因各不相同。其中一个可以作为默认连接失败时的后备。
- en: 'Hence, creating a `Clients` folder is crucial to configure all the HTTP clients
    at once. Run the following command to create one:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建一个`Clients`文件夹对于一次性配置所有HTTP客户端至关重要。运行以下命令来创建一个：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating an xxxClient.js class
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建xxxClient.js类
- en: You can create a class file corresponding to the HTTP client you are using.
    The naming is subjective, and for `AxiosClient.js` file and put it in all default
    configurations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个与所使用的HTTP客户端对应的类文件。命名是主观的，对于`AxiosClient.js`文件，将其放入所有默认配置中。
- en: Axios
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Axios
- en: Axios is a promise-based HTTP client for Node.js and the browser. It can run
    in the browser and Node.js with the same code base.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Axios是一个基于Promise的HTTP客户端，适用于Node.js和浏览器。它可以在浏览器和Node.js上使用相同的代码库运行。
- en: 'Run the following command to create the folder:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来创建文件夹：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In summary, you might want to use many HTTP clients, so you create different
    `xxxClient.js` files for each with their specific configuration.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你可能需要使用许多HTTP客户端，因此为每个客户端创建不同的`xxxClient.js`文件，并为其指定特定的配置。
- en: 'For Axios, these are my default configurations just for this test:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Axios，以下是我为这次测试设置的默认配置：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can add more default configurations for Axios in the preceding file and
    export the Axios instance.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的文件中为Axios添加更多默认配置，并导出Axios实例。
- en: Creating an individual repository class
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个单独的仓库类
- en: Next, we will create an individual repository based on the number of features
    we have in our enterprise application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将根据我们在企业应用程序中的功能数量创建一个单独的仓库。
- en: 'For instance, we are building a *Pinterest* clone application, and we are sure
    the application will have the **Photos** and **Users** features. So, we can start
    by creating a repository for the mentioned features by running the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们正在构建一个*Pinterest*克隆应用程序，我们确信该应用程序将具有**照片**和**用户**功能。因此，我们可以通过运行以下命令开始为提到的功能创建仓库：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These repositories will contain all API calls for the individual features. We
    will start by creating a **Create, Read, Update,** and **Delete** (**CRUD**) operation
    for the respective repositories to give us an overview. In contrast, we will update
    the repositories as we progress along in the book.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些仓库将包含所有针对单个功能的API调用。我们将首先为相应的仓库创建一个**创建、读取、更新**和**删除**（**CRUD**）操作，以获得概述。相比之下，我们将随着本书的进展更新仓库。
- en: 'Open the `PhotoRepository.js` file and add the following scripts:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`PhotoRepository.js`文件并添加以下脚本：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we are going to open the `UserRespository.js` file and add the following
    scripts:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将打开`UserRespository.js`文件并添加以下脚本：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have created two repositories for our *Pinterest* clone application, and
    any API-related code will go into the individual repository.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的*Pinterest*克隆应用程序创建了两个仓库，任何与API相关的代码都将放入单独的仓库中。
- en: Creating a RepositoryFactory.js class
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个`RepositoryFactory.js`类
- en: 'Create a `RepositoryFactory` factory class inside the `repositories` folder
    by running the following command to export all the different individual repositories
    you may have created so that they’re easy to use anywhere across your application:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`repositories`文件夹内通过运行以下命令创建一个`RepositoryFactory`工厂类，以导出您可能创建的所有不同单独的仓库，以便在应用程序的任何地方轻松使用：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once done, paste in the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，粘贴以下代码：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we have improved our Vuex store by creating repositories, let’s see
    how to use these in the next section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过创建仓库改进了我们的Vuex存储，让我们看看如何在下一节中使用这些仓库。
- en: Using the repository pattern
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用仓库模式
- en: 'Let’s see how to utilize the repositories we have created in our Vuex store.
    Open your Vuex store `photos` file created earlier and replace the `getPhoto`
    action method with the following code to utilize the repository pattern:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在我们的Vuex存储中利用我们创建的仓库。打开您之前创建的Vuex存储`photos`文件，并将`getPhoto`动作方法替换为以下代码以利用仓库模式：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using the repository pattern eliminates the need to handle errors, manipulate
    the data retrieved from the API in the Vuex store, and only return the actual
    data needed in Vuex. This approach also utilizes the **Don’t Repeat Yourself**
    (**DRY**) principle of software engineering as the repositories can be used across
    the project by creating a new one.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仓库模式消除了处理错误、在Vuex存储中操作从API检索的数据以及只返回Vuex中实际需要的数据的需求。这种方法还利用了软件工程中的**不要重复自己**（**DRY**）原则，因为可以通过创建一个新的来在整个项目中使用仓库。
- en: Structuring doesn’t end when you have your HTTP API calls sorted out with repository
    patterns. It extends to the way you arrange your navigation. The navigation file
    should not be bloated with a large code base that’s difficult to understand.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化并不随着您使用仓库模式整理好HTTP API调用而结束。它还扩展到您安排导航的方式。导航文件不应该包含大量难以理解的代码库。
- en: In the next section, we will arrange and structure our navigation using Vue
    Router to ensure maintainability and scalability in our enterprise project.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用Vue Router来安排和结构化我们的导航，以确保在我们面向企业的项目中保持可维护性和可扩展性。
- en: Structuring Vue navigation with Vue Router
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vue Router构建Vue导航
- en: When building an enterprise-ready application, it’s evident that the navigation
    system will be massive since there will be many navigations, routes, and pages.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个面向企业的应用程序时，很明显导航系统将会很大，因为会有很多导航、路由和页面。
- en: This section will show you how to structure Vue Router in your enterprise project
    properly. To achieve this, we will use the *split-by-feature* approach to organizing
    Vue Router so that it’s easy to navigate, as we achieved with Vuex earlier in
    the chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示如何在企业项目中正确地构建Vue Router。为了实现这一点，我们将使用*按功能分割*的方法来组织Vue Router，使其易于导航，就像我们在本章早期使用Vuex时所做的那样。
- en: This approach will create a structure where public and private routes will be
    separated, and more routes can also be separated individually.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将创建一个结构，其中公共和私有路由将被分离，并且还可以单独分离更多路由。
- en: The folder structure
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件夹结构
- en: The folder will comprise an index file, a public file, and a private file containing
    all the routes belonging to each category.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件夹将包含一个 index 文件、一个公共文件和一个私有文件，其中包含每个类别的所有路由。
- en: 'In the root of your `src` folder, create a `router` folder and create the following
    files inside the folder by typing in the following commands one after the other
    in your terminal:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 `src` 文件夹根目录下创建一个 `router` 文件夹，并在文件夹内通过在终端中依次输入以下命令创建以下文件：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The current folder structure is pretty straightforward, and we will customize
    it more as we progress with the book. Here’s what each file will contain:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当前文件夹结构相当简单，随着本书的进展，我们将对其进行更多定制。以下是每个文件将包含的内容：
- en: '`index.js`: This file will contain the `beforeEach` logic and assembling of
    all the other routes'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.js`：此文件将包含 `beforeEach` 逻辑和所有其他路由的组装'
- en: '`public.js`: This file will contain all the public-facing routes that do not
    need restrictions, such as the login page, registration page, and so on'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public.js`：此文件将包含所有不需要限制的面向公共的路由，例如登录页面、注册页面等'
- en: '`private.js`: This file will contain all the private routes used for authenticated
    users and many restrictions and metadata'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private.js`：此文件将包含所有用于认证用户和许多限制以及元数据的私有路由'
- en: '`combine.js`: This file will combine private and public files and make it easy
    to concatenate it with the main router file'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combine.js`：此文件将合并私有和公共文件，并使其易于与主路由文件连接'
- en: Next, let’s create an index file to contain the setup of our newly created project.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个 index 文件来包含我们新创建项目的设置。
- en: The index.js file
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: index.js 文件
- en: 'The index file is the powerhouse. Open the `index.js` file and add the following
    code to export all the routes created in the public and private files:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: index 文件是核心。打开 `index.js` 文件，添加以下代码以导出在公共和私有文件中创建的所有路由：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In Vue Router, there are two different history modes mostly in use when developing
    Vue applications with Vue Router:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue Router 中，当使用 Vue Router 开发 Vue 应用时，主要使用两种不同的历史模式：
- en: Hash mode
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hash 模式
- en: HTML5 mode
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML5 模式
- en: Hash mode
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hash 模式
- en: This uses a `#` (hash) symbol before the actual URL to simulate a full URL so
    that the page won’t be reloaded when the URL changes. This is possible because
    the pages or sections after the hash never get sent to the server. The implication
    is that it does not impact the SEO of the page but is the default setup for Vue
    Router.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在 URL 前使用 `#`（哈希）符号来模拟完整 URL，这样当 URL 发生变化时页面不会重新加载。这是因为哈希符号后的页面或部分永远不会发送到服务器。这意味着它不会影响页面的
    SEO，但这是 Vue Router 的默认设置。
- en: HTML5 mode
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML5 模式
- en: As seen in the preceding example, this is created using the `createWebHistory()`
    function, and it is the recommended method for enterprise and production-ready
    applications. It requires a bit of tedious configuration on the server for it
    to work properly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，这是使用 `createWebHistory()` 函数创建的，并且是适用于企业和生产级应用的推荐方法。它需要在服务器上进行一些繁琐的配置才能正常工作。
- en: The combine.js file
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: combine.js 文件
- en: 'This is a single utility file that combines all the routes in a single file
    to be exported to the main router file. Open the file and add the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个单一的实用文件，将所有路由合并到一个文件中，以便导出到主路由文件。打开文件并添加以下代码：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After adding the routes to the utility file, we will import them into the `main.js`
    file, as shown in the next section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在将路由添加到工具文件后，我们将如下一节所示将它们导入到 `main.js` 文件中。
- en: Adding the router to Vue
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将路由添加到 Vue
- en: 'Lastly, we will add our router to the Vue instance, as shown in the next snippet.
    Open the `main.js` file and add the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将把我们的路由添加到 Vue 实例中，如下一节所示。打开 `main.js` 文件，添加以下代码：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we progress in this book, we will revisit the `public.js` and `private.js`
    files to add more routes based on the *Pinterest* clone application we develop.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本书中的进展，我们将重新访问 `public.js` 和 `private.js` 文件，根据我们开发的 *Pinterest* 克隆应用程序添加更多路由。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter started by exploring the different libraries to develop large-scale
    and enterprise-ready applications with Vue.js 3\. We discussed the individual
    libraries and their different features in detail to foster our understanding of
    building scalable and enterprise-ready applications. We also covered the essentials
    of Vuex, discussing how to structure our large-scale Vuex store by splitting Vuex
    actions, modules, getters, and states using the split-by-feature approach.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先探讨了开发具有 Vue.js 3 的可扩展性和企业级应用程序的不同库。我们详细讨论了各个库及其不同的功能，以加深我们对构建可扩展和企业级应用程序的理解。我们还讨论了
    Vuex 的基本要素，讨论了如何通过按功能拆分 Vuex 动作、模块、获取器和状态来构建我们的大规模 Vuex 存储库。
- en: Next, we discussed the essentials of **separation of concerns** (**SoC**) by
    using the repository pattern to split large Vuex actions into individual repositories
    and make our enterprise application maintainable. The repository pattern is essential
    in creating an enterprise application, and we demonstrated how to implement it
    in Vue 3.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用仓库模式将大型 Vuex 动作拆分为单独的仓库，并使我们的企业应用程序易于维护，讨论了**关注点分离**（**SoC**）的基本要素。仓库模式在创建企业应用程序中至关重要，我们展示了如何在
    Vue 3 中实现它。
- en: Lastly, we discussed how to structure Vue Router to avoid bloated and large
    router files as it will be difficult to maintain when the project becomes larger.
    We discussed strategic patterns to split the Vue Router files into different files
    to enable maintainability and ease of debugging.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了如何构建 Vue Router，以避免在项目变得更大时出现臃肿和庞大的路由文件，因为那时将难以维护。我们讨论了将 Vue Router
    文件拆分为不同文件的战略模式，以实现可维护性和易于调试。
- en: In the next chapter, we will dive deeper into scaling the performance of enterprise
    Vue 3 applications. We will explore different performance and scalability hacks
    to build an enterprise-ready Vue 3 application, such as asynchronous components’
    loading/lazy loading, tree shaking, image compression, and so on. You will learn
    how to properly increase the performance of your Vue 3 application by applying
    the tricks in the next chapter to develop large-scale applications with maintainability
    and scalability.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨企业 Vue 3 应用程序的性能扩展。我们将探索不同的性能和可扩展性技巧，以构建一个企业级 Vue 3 应用程序，例如异步组件的加载/懒加载、摇树优化、图像压缩等。你将学习如何通过在下一章中应用技巧来适当提高你的
    Vue 3 应用程序的性能，以开发具有可维护性和可扩展性的大规模应用程序。
- en: 'Part 2: Large-Scale Apps and Scaling Performance in Vue.js 3'
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 部分：大规模应用程序和 Vue.js 3 中的性能扩展
- en: In this part, you will learn best practices in building large-scale applications,
    with scalability and performance as first-class citizens. In addition, you will
    learn and explore different techniques in scaling large application performance.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，你将学习构建大规模应用程序的最佳实践，其中可扩展性和性能是首要考虑的因素。此外，你还将学习和探索不同的技术，以扩展大型应用程序的性能。
- en: 'This part comprises the following chapters:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 3*](B17237_03.xhtml#_idTextAnchor087), [*Scaling Performance in Vue.js
    3*](https://epic.packtpub.services/index.php?module=oss_Chapters&action=DetailView&record=e17b2903-7123-3af0-d559-61d6c930c89c)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 3 章*](B17237_03.xhtml#_idTextAnchor087)，[*Vue.js 3 中的性能扩展*](https://epic.packtpub.services/index.php?module=oss_Chapters&action=DetailView&record=e17b2903-7123-3af0-d559-61d6c930c89c)'
- en: '[*Chapter 4*](B17237_04.xhtml#_idTextAnchor112), [*Architecture for Large-Scale
    Web*](https://epic.packtpub.services/index.php?module=oss_Chapters&action=DetailView&record=2a7a717b-e1bb-58f4-e12f-61d6c9e83477)
    *Applications*'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 4 章*](B17237_04.xhtml#_idTextAnchor112)，[*大规模 Web 应用程序的架构*](https://epic.packtpub.services/index.php?module=oss_Chapters&action=DetailView&record=2a7a717b-e1bb-58f4-e12f-61d6c9e83477)
    应用程序'
