["```js\n---\ntype: Blog\ntitle: My First Hackathon Experience\ndesc: This post is all about my learnings from my first\n  hackathon experience in London.\ndate: 2020-06-20\ntags: [hackathon, webdev, ux]\n---\n# Body Content\n```", "```js\n    const { createFilePath } = require('gatsby-source-\n     filesystem');\n    exports.onCreateNode = ({ node, getNode, actions }) => {\n      const { createNodeField } = actions;\n      if (node.internal.type === 'MarkdownRemark') {\n        const slug = createFilePath({ node, getNode,\n        basePath: 'pages' });\n        createNodeField({\n          node,\n          name: 'slug',\n          value: slug,\n        });\n      }\n    };\n    ```", "```js\n    import React from \"react\";\n    import Layout from \"../components/layout/Layout\";\n    import TagList from \"../components/blog-posts/TagList\"\n    export default function BlogPage() {\n      return (\n        <Layout>\n          <div className=\"max-w-5xl space-y-4 mx-auto \n           py-6 md:py-12 overflow-x-hidden lg:overflow-x-\n           visible\">\n            <h1 className=\"text-4xl font-bold\">Blog\n              Title</h1>\n            <div className=\"flex items-center space-x-2\">\n              <p className=\"text-lg opacity-50\">Date</p>\n              <TagList tags={[\"ux\"]} />\n            </div>\n            <div>\n               Article Body\n            </div>\n          </div>\n        </Layout>\n      );\n    }\n    ```", "```js\n    import React, { Fragment } from \"react\";\n    const TagList = ({ tags }) => {\n      return (\n        <Fragment>\n          {tags.map((tag) => (\n            <div\n              key={tag}\n              className=\"rounded-full px-2 py-1 uppercase\n                text-xs bg-blue-600 text-white\"\n            >\n              <p>{tag}</p>\n            </div>\n          ))}\n        </Fragment>\n      );\n    };\n    export default TagList\n    ```", "```js\n    const path = require('path');\n    const { createFilePath } = require('gatsby-source-\n      filesystem');\n    exports.createPages = async ({ actions, graphql,\n     reporter }) => {\n     const { createPage } = actions;\n     const BlogPostTemplate =\n     path.resolve('./src/templates/blog-page.js');\n     const BlogPostQuery = await graphql('\n     {\n     allMarkdownRemark(filter: { frontmatter: { type:\n     { eq: \"Blog\" } } }) {\n     nodes {\n     fields {\n     slug\n     }\n     }\n     }\n     }\n     ');\n     if (BlogPostQuery.errors) {\n     reporter.panicOnBuild('Error while running GraphQL\n     query.');\n     return;\n     }\n     BlogPostQuery.data.allMarkdownRemark.nodes.forEach(({ \n     fields: { slug } }) => {\n     createPage({\n     path: 'blog${slug}',\n     component: BlogPostTemplate,\n     context: {\n     slug: slug,\n     },\n     });\n     });\n    };\n    ```", "```js\n    import React from \"react\";\n    slug property we defined in the gatsby-node.js file comes in handy. We can use that slug to find the blog post where slug matches in the node's fields. We query for all the data that we need to populate this page with and retrieve date, title, tags, and the Markdown HTML. This is then passed into the template via the data prop, exactly like in our single instance pages. We can then use this content to swap out the static placeholder content we had previously.\n    ```", "```js\n      createPage({\n          path: 'blog${slug}',\n          component: BlogPostTemplate,\n          defer: true,\n          context: {\n            slug: slug,\n          },\n        });\n    ```", "```js\n    import React from \"react\";\n    import { Link } from \"gatsby\";\n    const Pagination = ({ numPages, currentPage }) => {\n     var pageArray = [];\n     for (var i = 1; i <= numPages; i++) pageArray[i] = i;\n      return (\n        <div>\n          <ul>\n            {currentPage !== 1 && (\n              <li>\n                <Link to={currentPage === 2 ? '/blog' :\n                  '/blog/${currentPage - 1}'}>\n                  Previous\n                </Link>\n              </li>\n            )}\n            {pageArray.map((pageNum) => (\n              <li key={'pageNum_${pageNum}'} >\n                <Link to={pageNum === 1 ? '/blog' :\n                  '/blog/${pageNum}'}>\n                  {pageNum}\n                </Link>\n              </li>\n            ))}\n            {currentPage !== numPages && (\n              <li>\n                <Link to={'/blog/${currentPage +\n                  1}'}>Next</Link>\n              </li>\n            )}\n          </ul>\n        </div>\n      );\n    };\n    export default Pagination;\n    ```", "```js\n    /*\n         Space for page component\n    */\n    export const pageQuery = graphql'\n      query($skip: Int!, $limit: Int!) {\n        blogposts: allMarkdownRemark(\n          limit: $limit\n          skip: $skip\n          filter: { frontmatter: { type: { eq: \"Blog\" } } }\n          sort: { fields: frontmatter___date, order: DESC }\n        ) {\n          nodes {\n            frontmatter {\n              date\n              title\n              tags\n              desc\n            }\n            fields {\n              slug\n            }\n          }\n        }\n      }\n    ';\n    ```", "```js\n    import React from \"react\";\n    import { graphql, Link } from \"gatsby\";\n    import Layout from \"../components/layout/Layout\";\n    import Pagination from \"../components/blog-\n      posts/Pagination\";\n    import TagList from \"../components/blog-posts/TagList\"\n    export default function BlogPreview({ pageContext,\n      data }) {\n      const {\n        numPages,\n        currentPage\n      } = pageContext\n      const {\n        blogposts: { nodes },\n      } = data;\n      // return statement\n    }\n    ```", "```js\n      return (\n        <Layout>\n          <div className=\"max-w-5xl mx-auto space-y-8 py-6\n            md:py-12\">\n            {nodes.map(\n              ({ frontmatter: { date, tags, title, desc },\n                 fields: { slug } }) => (\n                <div>\n                  <Link to={'/blog${slug}'}>\n                    <h2 className=\"text-2xl font-\n                      medium\">{title}</h2>\n                    <div className=\"flex items-center\n                      space-x-2\">\n                      <p className=\"text-lg opacity-\n                        50\">{date.split(\"T\")[0]}</p>\n                      <TagList tags={tags}/>\n                    </div>\n                    <p>{desc}</p>\n                  </Link>\n                </div>\n              )\n            )}\n            <Pagination numPages={numPages}\n             currentPage={currentPage} />\n          </div>\n        </Layout>\n      );\n    ```", "```js\n    exports.createPages = async ({ actions, graphql,\n      reporter }) => {\n      const { createPage } = actions;\n      const BlogPostTemplate =\n       path.resolve('./src/templates/blog-page.js');\n      BlogPreviewTemplate, then we run our Markdown query as normal. As we will be now using BlogPostQuery.data.allMarkdownRemark.nodes in two places (blog previews and blog post page creation), we can assign it to a constant. We will also assign two more constants â€“ the number of posts per page (postsPerPage) and the number of pages (numPages) that we will need for pagination. postsPerPage specifies how many posts we want on each of our paginated blog post previews. numPages calculates how many preview pages are needed by dividing the total number of posts by postsPerPage and then rounding up to the nearest whole integer using the Math.ceil function. We then create an Array with a length equal to the number of pages and loop through it using the forEach function. For each index (i), we use the createPage action. We provide this action with the path to where the page should be located, which is /blog if i is 0 and /blog/i+1 for anything higher. We also provide BlogPreviewTemplate and context, which contain limit and skip, which we utilize on the page.\n    ```", "```js\n    npm i lodash\n    ```", "```js\n    import React, { Fragment } from \"react\";\n    import { Link } from \"gatsby\";\n    import { kebabCase } from \"lodash\"\n    const TagList = ({ tags }) => {\n      return (\n        <Fragment>\n          {tags.map((tag) => (\n            <Link key={tag}\n               to={'/tags/${kebabCase(tag)}'}>\n            <div\n              key={tag}\n              className=\"rounded-full px-2 py-1 uppercase\n                text-xs bg-blue-600 text-white\"\n            >\n              <p>{tag}</p>\n            </div>\n            </Link>\n          ))}\n        </Fragment>\n      );\n    };\n    export default TagList\n    ```", "```js\n    /*\n         Space for page component\n    */\n    export const pageQuery = graphql'\n      query($tag: String) {\n        blogposts: allMarkdownRemark(\n          sort: { fields: [frontmatter___date], order:\n            DESC }\n          filter: { frontmatter: { tags: { in: [$tag] },\n            type: { eq: \"Blog\" } } }\n        ) {\n          totalCount\n          nodes {\n            frontmatter {\n              date\n              title\n              tags\n              desc\n            }\n            fields {\n              slug\n            }\n          }\n        }\n      }\n    ';\n    ```", "```js\n    import React from \"react\";\n    import { graphql, Link } from \"gatsby\";\n    import Layout from \"../components/layout/Layout\";\n    import TagList from \"../components/blog-\n      posts/TagList\";\n    export default function Tags({ pageContext, data }) {\n      const { tag } = pageContext;\n      const {\n        blogposts: { nodes },\n      } = data;\n      return (\n        <Layout>\n          <div>\n            <p>Posts tagged with \"{tag}\"</p>\n            {nodes.map(\n              ({ frontmatter: { date, tags, title, desc },\n                 fields: { slug } }) => (\n                <div>\n                  <Link to={'/blog${slug}'}>\n                    <h2>{title}</h2>\n                    <div>\n                      <p>{date.split(\"T\")[0]}</p>\n                      <TagList tags={tags} />\n                    </div>\n                    <p>{desc}</p>\n                  </Link>\n                </div>\n              )\n            )}\n          </div>\n        </Layout>\n      );\n    }\n    ```", "```js\n    const _ = require(\"lodash\");\n    ```", "```js\n    exports.createPages = async ({ actions, graphql,\n       reporter }) => {\n    // actions destructure & other templates\n    TagsTemplate. Then, we append our query with a new query to our Markdown source. This group (which we've named tagsGroup) retrieves an array containing every unique tag that is within frontmatter of our posts. We can then use this new data to loop through every `tag` and create a `tag` page for each one. We pass a `path` to each `createPages` function, pointing to `tags/`, followed by the `tag` name that's parsed through the `kebabCase` function. We pass the `component` property we want it to build the page with, which in our case is `TagsTemplate`, at the beginning of this file. You will also notice that we are also passing `tag` to the page's `context` so that the page knows which `tag` it relates to.\n    ```", "```js\n    npm install @gatsby-contrib/gatsby-plugin-elasticlunr-\n    search\n    ```", "```js\n    {\n          resolve: '@gatsby-contrib/gatsby-plugin-\n            elasticlunr-search',\n          options: {\n            fields: ['title', 'tags', 'desc'],\n            resolvers: {\n              MarkdownRemark: {\n                title: node => node.frontmatter.title,\n                tags: node => node.frontmatter.tags,\n                desc: node => node.frontmatter.desc,\n                path: node => '/blog'+node.fields.slug,\n              },\n            },\n            filter: (node, getNode) =>\n            node.frontmatter.type === \"Blog\",\n          },\n        },\n    ```", "```js\n    import React, { useState, useEffect } from \"react\";\n    import { Link } from \"gatsby\";\n    import { Index } from \"elasticlunr\";\n    const Search = ({ searchIndex }) => {\n      const [query, setQuery] = useState(\"\");\n      let [index, setIndex] = useState();\n      let [results, setResults] = useState([]);\n      useEffect(() => {\n        setIndex(Index.load(searchIndex));\n      }, [searchIndex]);\n    };\n    export default Search\n    ```", "```js\n    const search = (evt) => {\n        const query = evt.target.value;\n        setQuery(query);\n        setResults(\n          index\n            .search(query, { expand: query.length > 2 })\n            .map(({ ref }) =>\n         index.documentStore.getDoc(ref))\n        );\n      };  \n    ```", "```js\n    const searchResultSize = 3;\n    return (\n        <div className=\"relative w-64 text-gray-600\">\n          <input\n            type=\"search\"\n            name=\"search\"\n            placeholder=\"Search\"\n            autoComplete=\"off\"\n            aria-label=\"Search\"\n            onChange={search}\n            value={query}\n          />\n          {results.length > 0 && (\n            <div>\n              {results\n                .slice(0, searchResultSize)\n                .map(({ title, description, path }) => (\n                  <Link key={path} to={path}>\n                    <p>{title}</p>\n                    <p className=\"text-\n                     xs\">{description}</p>\n                  </Link>\n                ))}\n              {results.length > searchResultSize && (\n                <Link to={'/search?q=${query}'}>\n                  <p>+ {results.length - searchResultSize}\n                    more</p>\n                </Link>\n              )}\n            </div>\n          )}\n        </div>\n      );\n    ```", "```js\n    import React from \"react\";\n    import { Link, Header.js is not a page component, we cannot append the graphql query to the end of the page as Gatsby is not looking for it. However, we can still locate data with the component by using StaticQuery. Static queries differ from page queries as they cannot accept variables like our pages can via page context. In this scenario, that's not a constraint as the search index is always static.`StaticQuery` has two important props â€“ `query` and `render`. `query` accepts a `graphql` query, while `render` tells the component what to render with the data from that query. In this particular instance, we are querying for the elasticlunr `index`, and then rendering our `Search` component using that `data`, passing `index` as a prop.\n    ```"]