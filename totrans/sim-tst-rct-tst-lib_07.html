<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer137">
			<h1 id="_idParaDest-108"><em class="italic"><a id="_idTextAnchor109"/>Chapter 7</em>: End-to-End UI Testing with Cypress</h1>
			<p>In previous chapters, we learned how to test applications at the component level using React Testing Library. In this chapter, we will learn how to test applications at the system level by executing end-to-end testing using Cypress. End-to-end tests play an essential role in helping teams gain the confidence their applications will work as expected for end users in production. By including end-to-end tests in test strategies, teams can gain a lot of knowledge about how applications behave when all dependencies work together. Cypress is a modern, JavaScript end-to-end testing framework that can handle anything that runs in the browser, including applications built with popular frameworks such as React, Angular, and Vue. Cypress features allow teams to install, write, run, and debug tests within minutes.</p>
			<p>In addition to system-level testing, it provides the ability to write unit and integration tests, making the framework great for developers and quality engineers. Also, Cypress differs from tools such as Selenium by running tests directly in the browser versus requiring browser drivers, automatically waiting for commands and assertions before proceeding, providing visual feedback for each test command when run, and access to recorded test runs via the Cypress Dashboard.</p>
			<p>In this chapter, we're going to cover the following main topics: </p>
			<ul>
				<li>Installing Cypress in an existing project</li>
				<li>Enhancing Cypress DOM queries with <strong class="source-inline">cypress-testing-library</strong></li>
				<li>Using Cypress to implement test-driven development</li>
				<li>Reviewing Cypress design patterns</li>
				<li>Executing API testing with Cypress</li>
				<li>Implementing Gherkin-style tests with Cucumber</li>
			</ul>
			<p>The knowledge gained in this chapter will add additional test strategies to complement skills learned with React Testing Library.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor110"/>Technical requirements</h1>
			<p>For the examples in this chapter, you will need to have Node.js installed on your machine. We will be using the <strong class="source-inline">create-react-app</strong> CLI tool and the Next.js React framework (<a href="https://nextjs.org/">https://nextjs.org/</a>) for all code examples. Please familiarize yourself with Next.js before starting the chapter if needed. Code snippets will be provided throughout the chapter to help you understand the code under test, but the objective is understanding how to test the code.</p>
			<p>You can find code examples for this chapter here: <a href="https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter07">https://github.com/PacktPublishing/Simplify-Testing-with-React-Testing-Library/tree/master/Chapter07</a>.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor111"/>Getting started with Cypress</h1>
			<p>In this section, you will learn how to install and set up <strong class="bold">Cypress</strong> in an existing project. We will <a id="_idIndexMarker350"/>also write a test for a user flow. Use the following command at the command line to install Cypress:</p>
			<p class="source-code">npm install cypress --save-dev</p>
			<p>The preceding command will install Cypress as a development dependency in your project. Once Cypress is installed, run the following command:</p>
			<p class="source-code">npx cypress open</p>
			<p>The preceding command runs the Cypress interactive Test Runner. The Test Runner allows us to manually do things such as select specific tests to run, pick a browser to use for test execution, and see the browser output alongside each associated Cypress command. When we run Cypress in interactive mode for the first time, it creates a suggested folder structure for Cypress projects:</p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="Images/Figure_7.1_B16887.jpg" alt="Figure 7.1 – First Cypress open run&#13;&#10;" width="937" height="619"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – First Cypress open run</p>
			<p>In the preceding screenshot, Cypress informs us that it automatically created a <strong class="source-inline">cypress</strong> folder structure <a id="_idIndexMarker351"/>on our behalf in the root of the project that includes the following sub-folders – <strong class="source-inline">fixtures</strong>, <strong class="source-inline">integration</strong>, <strong class="source-inline">plugins</strong>, and <strong class="source-inline">support</strong>. The sub-folders allow us to quickly get up and running without needing to do any manual configuration. The <strong class="source-inline">fixtures</strong> folder is used to create static data typically used for stubbing network data in tests. The <strong class="source-inline">integration</strong> folder is used to create test files. Inside the <strong class="source-inline">integration</strong> folder, Cypress provides an <strong class="source-inline">examples</strong> folder with numerous examples of using Cypress to test applications.</p>
			<p>The <strong class="source-inline">plugins</strong> folder is used to extend the behavior of Cypress in many ways, such as programmatically changing the config file, generating reports in HTML format after test runs, or adding <a id="_idIndexMarker352"/>support for automated visual testing, just to name a few. Cypress <a id="_idIndexMarker353"/>provides many <em class="italic">out-of-the-box</em> commands such as <strong class="source-inline">click</strong>, <strong class="source-inline">type</strong>, and assertions <a id="_idIndexMarker354"/>from third-party tools such as <strong class="bold">Mocha</strong> (<a href="https://mochajs.org/">https://mochajs.org/</a>), <strong class="bold">Chai</strong> (<a href="https://www.chaijs.com/">https://www.chaijs.com/</a>), and <strong class="bold">jQuery</strong> (<a href="https://jquery.com/">https://jquery.com/</a>).</p>
			<p>The <strong class="source-inline">support</strong> folder is used to create custom commands or add third-party commands with tools <a id="_idIndexMarker355"/>such as <strong class="bold">Cypress Testing Library</strong>, which we will learn about in the next section, <em class="italic">Enhancing query selectors with Cypress Testing Library</em>. Cypress also creates a <strong class="source-inline">cypress.json</strong> file at the root of the project folder. The <strong class="source-inline">cypress.json</strong> file is used to set global settings such as the global base URL Cypress will use in tests, set custom timeouts for elements to appear in the DOM, or even change the folder location of our test files from <strong class="source-inline">integration</strong> to <strong class="source-inline">e2e</strong>, for example. There are numerous settings we can configure in the <strong class="source-inline">cypress.json</strong> file.</p>
			<p>In the top-right <a id="_idIndexMarker356"/>corner of the Cypress Test Runner is a drop-down list allowing you to select the browser to use for test runs:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="Images/Figure_7.2_B16887.jpg" alt="Figure 7.2 – Cypress browser dropdown&#13;&#10;" width="293" height="264"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Cypress browser dropdown</p>
			<p>In the preceding screenshot, the <strong class="bold">Chrome 88</strong>, <strong class="bold">Firefox 80</strong>, <strong class="bold">Edge 88</strong>, and <strong class="bold">Electron 87</strong> version browsers are available to use for test runs. Available browsers are based on Cypress-compatible browsers installed on the user's machine. The Cypress-supported browsers are Firefox and Chrome-family browsers such as Edge and Electron. The Electron browser is available by default in Cypress and is also used for running tests in headless mode, meaning without the browser UI.</p>
			<p>To execute a test, simply click the test name from the list of available tests:</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="Images/Figure_7.3_B16887.jpg" alt="Figure 7.3 – Example test run&#13;&#10;" width="1104" height="619"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Example test run</p>
			<p>In the preceding screenshot, the <strong class="source-inline">actions.spec.js</strong> test file located in the <strong class="source-inline">examples</strong> folder was run. The screen's right side displays the state of the application in the browser <a id="_idIndexMarker357"/>throughout each step of the test. The left side of the screen shows the result of each test within the test file. If we wanted to, we could click into each test, hover over each Cypress command, and see the resulting DOM state before and after the command was executed. Being able to hover over each command to view the resulting DOM output is a great feature. </p>
			<p>Cypress makes debugging easier as compared to other end-to-end testing frameworks. For example, if Cypress cannot find an element in the browser specified in our test, it provides helpful error messages:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="Images/Figure_7.4_B16887.jpg" alt="Figure 7.4 – Cypress error output" width="797" height="425"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – Cypress error output </p>
			<p>In the preceding <a id="_idIndexMarker358"/>screenshot, Cypress provides feedback by informing us that an input element named <strong class="source-inline">firSDFstName</strong> was never found after 4 seconds inside the Test Runner. Cypress also allows us to click a link to open our code editor at the line where the error occurred.</p>
			<p>Now that we understand the basics of installing, running, and executing tests with the Cypress Test Runner, we will write a checkout flow test next. When a user checks out, the application progresses through four screens. The first screen is for the shipping address:</p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="Images/Figure_7.5_B16887.jpg" alt="Figure 7.5 – Shipping address Checkout screen&#13;&#10;" width="726" height="490"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Shipping address Checkout screen</p>
			<p>In the <a id="_idIndexMarker359"/>preceding screenshot, a form is shown where a user can enter their shipping address information. The second screen is for the payment details:</p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="Images/Figure_7.6_B16887.jpg" alt="Figure 7.6 – Payment details Checkout screen " width="749" height="393"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6 – Payment details Checkout screen </p>
			<p>In the <a id="_idIndexMarker360"/>preceding screenshot, a form is shown where a user can enter their payment information. The third screen is for reviewing the order:</p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="Images/Figure_7.7_B16887.jpg" alt="Figure 7.7 – Review your order Checkout screen " width="567" height="673"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – Review your order Checkout screen </p>
			<p>In the <a id="_idIndexMarker361"/>preceding screenshot, a summary displaying all form values entered on previous screens is shown. Note, for the purposes of this demonstration, the purchased items <strong class="bold">T-shirt</strong>, <strong class="bold">Denim Jeans</strong>, and <strong class="bold">Nike Free Runner</strong> are hardcoded in the application and will not be a focus in the test we will write. The last screen is the order submitted screen:</p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="Images/Figure_7.8_B16887.jpg" alt="Figure 7.8 – Order submitted Checkout screen&#13;&#10;" width="1000" height="346"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8 – Order submitted Checkout screen</p>
			<p>In the preceding screenshot, a confirmation is shown, displaying a <strong class="bold">Thank you</strong> message, an order number, and information informing the customer about email communication for order updates.</p>
			<p>For the purposes of this demonstration, the order number is hardcoded and will not be a focus of our test. Now that we understand the user flow, we can write the test code:</p>
			<p class="source-code"><strong class="bold">import user from '../support/user'</strong></p>
			<p class="source-code">describe('Checkout Flow', () =&gt; {</p>
			<p class="source-code">  it('allows a user to enter address and payment info and place         an order', () =&gt; {</p>
			<p class="source-code">    <strong class="bold">cy.visit('/')</strong></p>
			<p>In the preceding code, we first import a <strong class="source-inline">user</strong> object to use in the test. The <strong class="source-inline">user</strong> object simply provides <a id="_idIndexMarker362"/>fake values to enter into each <strong class="source-inline">form</strong> input, so we don't have to hardcode each value. Next, we use the <strong class="source-inline">visit</strong> command via the global <strong class="source-inline">cy</strong> variable to visit the application.</p>
			<p>All available Cypress methods are chained off the <strong class="source-inline">cy</strong> variable. Note that the <strong class="source-inline">'/'</strong> used in the <strong class="source-inline">visit</strong> method represents the URL relative to our tests' base URL. By using a relative URL, we don't have to enter the full URL in our tests. We can set the <strong class="source-inline">baseURL</strong> property via the <strong class="source-inline">cypress.json</strong> file:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "baseUrl": "http://localhost:3000"</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we set <strong class="source-inline">baseUrl</strong> to <strong class="source-inline">http://localhost:3000</strong>, allowing us to use <strong class="source-inline">'/'</strong> when we want to visit the index page or other pages relative to the index page. </p>
			<p>Next, we will write the code to complete the <strong class="bold">Shipping address</strong> screen:</p>
			<p class="source-code">    cy.get('input[name="firstName"]').type(user.firstName)</p>
			<p class="source-code">    cy.get('input[name="lastName"]').type(user.lastName)</p>
			<p class="source-code">    cy.get('input[name="address1"]').type(user.address1)</p>
			<p class="source-code">    cy.get('input[name="city"]').type(user.city)</p>
			<p class="source-code">    cy.get('input[name="state"]').type(user.state)</p>
			<p class="source-code">    cy.get('input[name="zipCode"]').type(user.zipCode)</p>
			<p class="source-code">    cy.get('input[name="country"]').type(user.country)</p>
			<p class="source-code">    cy.contains(/next/i).click()</p>
			<p>In the preceding code, we use the <strong class="source-inline">get</strong> command to select each input element via its <strong class="source-inline">name</strong> attribute. We also <a id="_idIndexMarker363"/>use the <strong class="source-inline">type</strong> command to enter a value for each input. Next. We use the <strong class="source-inline">contains</strong> command to select the button element with the text <strong class="source-inline">next</strong> and click it using the <strong class="source-inline">click</strong> command.</p>
			<p>Next, we will enter values for the <strong class="bold">Payment details</strong> screen:</p>
			<p class="source-code">    cy.get('input[name="cardType"]').type(user.cardType)</p>
			<p class="source-code">    cy.get('input[name="cardHolder"]').type(user.cardHolder)</p>
			<p class="source-code">    cy.get('input[name="cardNumber"]').type(user.cardNumber)</p>
			<p class="source-code">    cy.get('input[name="expiryDate"]').type(user.expiryDate)</p>
			<p class="source-code">    cy.get('input[name="cardCvv"]').type(user.cardCvv)</p>
			<p class="source-code">    cy.contains(/next/i).click()</p>
			<p>In the preceding code, we use the <strong class="source-inline">get</strong> and <strong class="source-inline">type</strong> commands to select and enter values in each input. Then, we use the <strong class="source-inline">contains</strong> command to click the <strong class="bold">next</strong> button.</p>
			<p>Next, we will verify entered values for shipping and payment details on the <strong class="bold">Review your order</strong> screen:</p>
			<p class="source-code">    cy.contains(`${user.firstName} </p>
			<p class="source-code">      ${user.lastName}`).should('be.visible')</p>
			<p class="source-code">    cy.contains(user.address1).should('be.visible')</p>
			<p class="source-code">    cy.contains(`${user.city}, ${user.state} </p>
			<p class="source-code">     ${user.zipCode}`).should(</p>
			<p class="source-code">      'be.visible'</p>
			<p class="source-code">    )</p>
			<p class="source-code">    cy.contains(user.country).should('be.visible')</p>
			<p class="source-code">    cy.contains(user.cardType).should('be.visible')</p>
			<p class="source-code">    cy.contains(user.cardHolder).should('be.visible')</p>
			<p class="source-code">    cy.contains(user.cardNumber).should('be.visible')</p>
			<p class="source-code">    cy.contains(user.expiryDate).should('be.visible')</p>
			<p class="source-code">    cy.contains(/place order/i).click()</p>
			<p>We use the <strong class="source-inline">contains</strong> command to select each element via form values entered on previous screens in the preceding code. We also use the <strong class="source-inline">should</strong> command to assert that each element is visible on the screen. Then, we use the <strong class="source-inline">contains</strong> command to select the button with the text <strong class="source-inline">place order</strong> and click it using the <strong class="source-inline">click</strong> command.</p>
			<p>Finally, we verify <a id="_idIndexMarker364"/>the application lands on the order submitted screen:</p>
			<p class="source-code">     cy.contains(/thank you for your </p>
			<p class="source-code">       order/i).should('be.visible')</p>
			<p>In the preceding code, we use the <strong class="source-inline">contains</strong> and <strong class="source-inline">should</strong> commands to verify an element with the text <strong class="bold">Thank you for your order.</strong> visible on the screen. To run the test, we can use the <strong class="source-inline">npx cypress open command</strong> directly at the command line as previously learned at the beginning of this section, but we can also create an <strong class="source-inline">npm</strong> script:</p>
			<p class="source-code">    "cy:open": "cypress open",</p>
			<p>In the preceding code, we create a <strong class="source-inline">cy:open</strong> script to run the Cypress Test Runner. We can also create another script to run tests in headless mode:</p>
			<p class="source-code">    "cy:run": "cypress run",</p>
			<p>We create a <strong class="source-inline">cy:run</strong> script to run Cypress in headless mode via the <strong class="source-inline">cypress run</strong> command in the preceding code. We can use the <strong class="source-inline">cy:run</strong> script in situations where we don't <a id="_idIndexMarker365"/>want to use the interactive mode, such as running via a <strong class="bold">Continuous Integration and Continuous Delivery</strong> (<strong class="bold">CI/CD</strong>) server. Before <a id="_idIndexMarker366"/>running Cypress, be sure that your development server is already up and running because Cypress does not start the development server for you. When we execute the test via the <strong class="source-inline">cy:open</strong> interactive mode, we get the following output:</p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="Images/Figure_7.9_B16887.jpg" alt="Figure 7.9 – Checkout flow test results&#13;&#10;" width="1205" height="781"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9 – Checkout flow test results</p>
			<p>In the <a id="_idIndexMarker367"/>previous screenshot, the test run indicates the <strong class="source-inline">checkOutFlow</strong> test passed as expected. Now you know how to install and use Cypress to test a user flow. In the next section, we will install a plugin to enhance our element selector commands.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor112"/>Enhancing Cypress commands with the Cypress Testing Library</h1>
			<p>In the <a id="_idIndexMarker368"/>previous section, we learned how to install and write a user flow test using Cypress. In this section, we <a id="_idIndexMarker369"/>will learn <a id="_idIndexMarker370"/>how to install and configure the <strong class="bold">Cypress Testing Library</strong> to add enhanced query selectors. The Cypress Testing Library will allow us to use DOM Testing Library query methods in Cypress. Install the library using the following command:</p>
			<p class="source-code">npm install --save-dev @testing-library/cypress</p>
			<p>The preceding code installs <strong class="source-inline">@testing-library/cypress</strong> as a development dependency in your project. After the library is installed, we can add it to the Cypress <strong class="source-inline">commands</strong> file:</p>
			<p class="source-code">import '@testing-library/cypress/add-commands'</p>
			<p>In the preceding code, we extended the Cypress commands with those from the Cypress Testing Library. Now that we have the Cypress Testing Library installed, we can use it in our tests. It should be noted that only <strong class="source-inline">findBy*</strong> methods from the DOM Testing Library are included <a id="_idIndexMarker371"/>to support <a id="_idIndexMarker372"/>the Cypress retry-ability feature that retries commands a number of times before timing out.</p>
			<p>In the <em class="italic">Getting started with Cypress</em> section of this chapter, we wrote a test for a checkout flow. We can refactor element queries in that test with those from the Cypress Testing Library. For example, we can refactor the code for the <strong class="bold">Shipping address</strong> screen like so:</p>
			<p class="source-code">    cy.findByRole('textbox', { name: /first name/i </p>
			<p class="source-code">      }).type(user.firstName)</p>
			<p class="source-code">    cy.findByRole('textbox', { name: /last name/i </p>
			<p class="source-code">      }).type(user.lastName)</p>
			<p class="source-code">    cy.findByRole('textbox', { name: /address line 1/i </p>
			<p class="source-code">      }).type(user.address1)</p>
			<p class="source-code">    cy.findByRole('textbox', { name: /city/i </p>
			<p class="source-code">      }).type(user.city)</p>
			<p class="source-code">    cy.findByRole('textbox', { name: /state/i </p>
			<p class="source-code">      }).type(user.state)</p>
			<p class="source-code">    cy.findByRole('textbox', { name: /postal code/i </p>
			<p class="source-code">      }).type(user.zipCode)</p>
			<p class="source-code">    cy.findByRole('textbox', { name: /country/i </p>
			<p class="source-code">      }).type(user.country)</p>
			<p class="source-code">    cy.findByText(/next/i).click()</p>
			<p>In the <a id="_idIndexMarker373"/>previous code, we updated all selectors to find <strong class="source-inline">input</strong> elements by their <strong class="bold">Accessible Rich Internet Application</strong> (<strong class="bold">ARIA</strong>) textbox role using <strong class="source-inline">findByRole</strong> queries. ARIA attributes are used by individuals using assistive technology to locate elements. We also updated the selector for the <strong class="bold">next</strong> button by using the <strong class="source-inline">findByText</strong> query. The same refactoring pattern is used for the <strong class="bold">Payment details</strong> and <strong class="bold">Review your order</strong> screens. Finally, we can refactor the code for the order submitted screen like so:</p>
			<p class="source-code">        cy.findByRole('heading', { name: /thank you for </p>
			<p class="source-code">          your order/i }).should(</p>
			<p class="source-code">      'be.visible'</p>
			<p class="source-code">    )</p>
			<p class="source-code">    cy.findByRole('heading', { name: /your order number is </p>
			<p class="source-code">      #2001539/i }).should(</p>
			<p class="source-code">      'be.visible'</p>
			<p class="source-code">    )</p>
			<p>In the previous code, we updated the two selectors to find elements by their heading role using the <strong class="source-inline">findByRole</strong> query. Our test code now queries elements in ways that are more <a id="_idIndexMarker374"/>accessible, providing <a id="_idIndexMarker375"/>more confidence that the application will work for all users, including those using assistive technology such as screen readers. Also, the test code reads better when viewing each line in the Test Runner screen.</p>
			<p>Now you know how to install the Cypress Testing Library and refactor existing tests using queries that avoid using implementation details. In the next section, we will learn how to use test-driven development with Cypress to add features to a blog application.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor113"/>Cypress-driven development</h1>
			<p>In the previous section, we installed the Cypress Testing Library and refactored an existing <a id="_idIndexMarker376"/>test for a checkout flow. In this section, we will use Cypress to drive the development of new features for an existing blog application <a id="_idIndexMarker377"/>created with <strong class="bold">Next.js</strong>. Next.js is a popular framework that provides a pleasant experience for teams to build static or server-rendered React applications.</p>
			<p>Example <a id="_idIndexMarker378"/>features that Next.js provides are <em class="italic">out-of-the-box</em> routing, built-in CSS support, and API routes. Please see the Next.js documentation (<a href="https://nextjs.org/">https://nextjs.org/</a>) for more details. The <strong class="bold">MY BLOG</strong> application currently has two pages, a <strong class="bold">Home</strong> page displaying all blog posts and a page to display blog details. The page that displays a list of posts looks as follows:</p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="Images/Figure_7.10_B16887.jpg" alt="Figure 7.10 – Blog home page&#13;&#10;" width="942" height="599"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.10 – Blog home page</p>
			<p>In the <a id="_idIndexMarker379"/>previous screenshot, the <strong class="bold">Home</strong> page displays two blog posts, <strong class="bold">I love React</strong> and <strong class="bold">I love Angular</strong>. Blog data is stored in a MongoDB database and sent to the frontend via the API once the application loads. Each blog post displays a category, title, published date, an excerpt, and a <strong class="bold">Continue Reading</strong> link from top to bottom.</p>
			<p>To view a blog's details, a user can click either the blog title or the <strong class="bold">Continue Reading</strong> link. For example, we see the following after clicking the <strong class="bold">I love React</strong> title:</p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="Images/Figure_7.11_B16887.jpg" alt="Figure 7.11 – Blog detail page&#13;&#10;" width="745" height="761"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.11 – Blog detail page</p>
			<p>We see <a id="_idIndexMarker380"/>the full content of the <strong class="bold">I love React</strong> blog post in the preceding screenshot. We also see the published date and a <strong class="bold">BACK TO BLOG</strong> link to navigate back to the <strong class="bold">Home</strong> page. The application's current state only allows new blog posts to be created via a <strong class="source-inline">POST</strong> request to the API or directly adding new posts to the database.</p>
			<p>We need to add a feature that allows users to add new posts via the UI. We can use Cypress to write a test for the expected behavior and build out the UI little by little until the feature is complete and the test passes. The following test shows the final expected behavior:</p>
			<p class="source-code">import fakePost from '../support/generateBlogPost'</p>
			<p class="source-code"> </p>
			<p class="source-code">describe('Blog Flow', () =&gt; {</p>
			<p class="source-code">    let post = {}</p>
			<p class="source-code">  beforeEach(()=&gt; (post = fakePost()))</p>
			<p class="source-code">  it('allows a user to create a new blog post', () =&gt; {</p>
			<p class="source-code">    cy.visit('/')</p>
			<p class="source-code">    cy.findByRole('link', { name: /new post/i }).click()</p>
			<p>In the previous code, first, we import <strong class="source-inline">fakePost</strong>, a custom method that will generate unique test data for each test run and set it as the value for the variable post. We don't want to create identical blog posts, so the custom <a id="_idIndexMarker381"/>method helps by always creating unique data. Next, we visit the <strong class="bold">Home</strong> page and click a link with the name <strong class="bold">New Post</strong>. The <strong class="bold">New Post</strong> link should navigate us to a page where we can enter values for a new post.</p>
			<p>Next, we test the code for entering values for the new post:</p>
			<p class="source-code">    cy.findByRole('textbox', { name: /title/i </p>
			<p class="source-code">      }).type(post.title)</p>
			<p class="source-code">    cy.findByRole('textbox', { name: /category/i </p>
			<p class="source-code">      }).type(post.category)</p>
			<p class="source-code">    cy.findByRole('textbox', { name: /image link/i </p>
			<p class="source-code">      }).type(post.image_url)</p>
			<p class="source-code">    cy.findByRole('textbox', { name: /content/i </p>
			<p class="source-code">      }).type(post.content)</p>
			<p>In the preceding code, we find each <strong class="source-inline">textbox</strong> element by its unique name and enter associated values via the custom <strong class="source-inline">post</strong> method. Finally, we create the last pieces of the test:</p>
			<p class="source-code">    cy.findByRole('button', { name: /submit/i }).click()</p>
			<p class="source-code">    cy.findByRole('link', { name: post.title </p>
			<p class="source-code">     }).should('be.visible')</p>
			<p class="source-code">  })</p>
			<p class="source-code">})</p>
			<p>In the preceding code, we click the <strong class="bold">submit</strong> button. Once we click the <strong class="bold">submit</strong> button, the data should be sent to the API, saved to the database, and then the application should navigate us back to the <strong class="bold">Home</strong> page. Finally, once on the <strong class="bold">Home</strong> page, we verify the title for the post we created is visible on the screen.</p>
			<p>We will run the test using the Cypress Test Runner to utilize its interactive features and keep it open throughout building the feature. Our test will fail as expected when run:</p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="Images/Figure_7.12_B16887.jpg" alt="Figure 7.12 – Blog Flow test failure" width="1043" height="429"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.12 – Blog Flow test failure </p>
			<p>In the previous screenshot, the first step succeeded in navigating to the <strong class="bold">Home</strong> page, but the <a id="_idIndexMarker382"/>output informs us that the test failed because a <strong class="source-inline">link</strong> element with the name <strong class="bold">New Post</strong> was not found after 4 seconds in the second test step. Four seconds is the default time that Cypress will continue to query for the element before timing out.</p>
			<p>We also see a helpful message from the DOM Testing Library informing us which accessible elements are visible in the DOM. Further, we can look at the browser at the point of test failure and see that the <strong class="bold">New Post</strong> link is not visible. Now we can update the UI to make the second test step pass:</p>
			<p class="source-code">&lt;Link href="/add"&gt;</p>
			<p class="source-code"><strong class="bold">&lt;a className="font-bold inline-block px-4 py-2 text-3xl"&gt;</strong></p>
			<p class="source-code"><strong class="bold">  New Post</strong></p>
			<p class="source-code"><strong class="bold">&lt;/a&gt;</strong></p>
			<p class="source-code">&lt;/Link&gt;</p>
			<p>In the previous code, we added a link that will navigate the user to an <strong class="bold">Add a new blog</strong> page when clicked. Notice the <strong class="source-inline">hyperlink</strong> element is wrapped in a <strong class="source-inline">Link</strong> component. The <strong class="source-inline">Link</strong> component allows for client-side route navigation. The Test Runner automatically reruns when we save the test file. Since we already wrote all the necessary test code, we can trigger a test run by saving the file.</p>
			<p>We will need to perform this action after each UI change. Now we get the following output when the test runs:</p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="Images/Figure_7.13_B16887.jpg" alt="Figure 7.13 – Blog Flow add page failure&#13;&#10;" width="1002" height="638"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.13 – Blog Flow add page failure</p>
			<p>In the <a id="_idIndexMarker383"/>previous screenshot, our test code can now successfully open the <strong class="bold">Home</strong> page, click the <strong class="bold">New Post</strong> link and land on the <strong class="bold">Add</strong> page. However, now the output indicates our test failed because an element with the name <strong class="source-inline">title</strong> and role <strong class="source-inline">textbox</strong> was not found at step <strong class="bold">4</strong>. We can update the UI by creating an <strong class="source-inline">input</strong> element with the name <strong class="source-inline">title</strong> and the <strong class="source-inline">textbox</strong> role:</p>
			<p class="source-code">&lt;label htmlFor="title"&gt;Title&lt;/label&gt;</p>
			<p class="source-code"> &lt;input</p>
			<p class="source-code">   type="text"</p>
			<p class="source-code">   autoFocus</p>
			<p class="source-code">   id="title"</p>
			<p class="source-code">   name="title"</p>
			<p class="source-code">   placeholder="Blog Title"</p>
			<p class="source-code">   value={newBlog.title}</p>
			<p class="source-code">   onChange={handleChange}</p>
			<p class="source-code"> /&gt;</p>
			<p>In the previous code, we add a <strong class="source-inline">Title label</strong> element and an associated <strong class="source-inline">input</strong> element of type <strong class="source-inline">text</strong>. Although not demonstrated in the last code, we also went ahead and added the <strong class="source-inline">Category</strong>, <strong class="source-inline">Image link</strong>, and <strong class="source-inline">Content</strong> input elements similar in structure to the <strong class="source-inline">Title input</strong> element. Now we get the following output when we trigger a test run:</p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="Images/Figure_7.14_B16887.jpg" alt="Figure 7.14 – Blog Flow add page input element refactor " width="1201" height="643"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.14 – Blog Flow add page input element refactor </p>
			<p>In the <a id="_idIndexMarker384"/>previous screenshot, our test code can now successfully open the <strong class="bold">Home</strong> page. Click the <strong class="bold">New Post</strong> link, and add values in the <strong class="source-inline">Title</strong>, <strong class="source-inline">Category</strong>, <strong class="source-inline">Image link</strong>, and <strong class="source-inline">Content</strong> <strong class="source-inline">input</strong> elements on the <strong class="bold">Add</strong> page. However, now the output indicates our test failed because a <strong class="source-inline">Submit</strong> button was not found at step <strong class="bold">12</strong>. We can update the UI by creating the <strong class="source-inline">Submit</strong> button:</p>
			<p class="source-code">&lt;button&gt;Submit&lt;/button&gt;</p>
			<p>We created and added a <strong class="source-inline">Submit</strong> button to the <strong class="bold">Add</strong> page in the previous code. The <strong class="source-inline">Submit</strong> button is part of the <strong class="source-inline">form</strong> element and, when clicked, calls a method that sends the form data to the API and, ultimately, the database. Although not a focus for our test, we also added a <strong class="source-inline">cancel</strong> <strong class="source-inline">button</strong> element in the UI. Now we get the following output when we trigger a test run:</p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="Images/Figure_7.15_B16887.jpg" alt="Figure 7.15 – Blog Flow add page completed refactor &#13;&#10;" width="1009" height="589"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.15 – Blog Flow add page completed refactor </p>
			<p>In the previous screenshot, the output indicates the test finally passes. We can see the new blog post in the browser created by our test on the screen's right side. With the last refactor, we have completed all the feature steps that allow users to add new posts via the UI.</p>
			<p>For our <a id="_idIndexMarker385"/>next feature, we want users to have the ability to delete blog posts via the UI. We will add a <strong class="source-inline">delete</strong> link to the blog detail page that makes a <strong class="source-inline">DELETE</strong> request to the API when clicked. The application's current state only allows blog posts to be deleted via a <strong class="source-inline">DELETE</strong> request to the API or directly in the database. Our previous test can be updated to perform actions to delete the new blog post after creation like so:</p>
			<p class="source-code">    cy.findByRole('link', { name: post.title }).click()</p>
			<p class="source-code">    cy.findByText(/delete post&gt;/i).click()</p>
			<p class="source-code">    cy.findByRole('link', { name: post.title </p>
			<p class="source-code">     }).should('not.exist')</p>
			<p>In the preceding code, first, we click the title of the blog post to delete to navigate to its detail page. Next, we find and click the link with the text <strong class="source-inline">delete post</strong>. Finally, we verify the post is no longer in the list of blog posts on the <strong class="bold">Home</strong> page. We get the following output when we trigger a test run by saving the file:</p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="Images/Figure_7.16_B16887.jpg" alt="Figure 7.16 – Blog Flow delete post test failure" width="1207" height="517"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.16 – Blog Flow delete post test failure</p>
			<p>In the <a id="_idIndexMarker386"/>previous screenshot, the output indicates the test failed at step <strong class="bold">18</strong> when an element with the text <strong class="source-inline">delete post</strong> could not be found. We can update the UI by creating the missing element:</p>
			<p class="source-code">&lt;a onClick={handleDelete}&gt;Delete post&amp;#62;&lt;/a&gt;;</p>
			<p>In the preceding code, we add a <strong class="source-inline">hyperlink</strong> element with the text <strong class="source-inline">Delete post</strong>. When the hyperlink is clicked, it calls a <strong class="source-inline">handleDelete</strong> method to send a <strong class="source-inline">DELETE</strong> request to the API and ultimately remove the blog post from the database. We get the following output when we save the test file to trigger a test run:</p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="Images/Figure_7.17_B16887.jpg" alt="Figure 7.17 – Blog Flow delete post completed refactor &#13;&#10;" width="901" height="698"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.17 – Blog Flow delete post completed refactor </p>
			<p>In the <a id="_idIndexMarker387"/>previous screenshot, the output indicates the test finally passes with the blog post deleted. With the addition of the <strong class="source-inline">delete</strong> link, we have completed all the feature steps that allow users to delete blog posts via the UI. Now you know how to develop features using Cypress-driven development.</p>
			<p>The approach can be beneficial when you want to see the application in a specific state as you build out a feature. In the next section, we will cover Cypress design patterns.</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor114"/>Writing Tests using Cypress design patterns </h1>
			<p>In the previous section, we learned how to use Cypress to drive the development of new features <a id="_idIndexMarker388"/>to a blog application. In this section, we will look at two design patterns to structure our Cypress code. Design patterns help teams by providing solutions to problems such as writing maintainable code or designing responsive websites. First, we will look at the Page Object Model, followed by custom commands.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor115"/>Creating page objects in Cypress</h2>
			<p>The <strong class="bold">Page Object Model</strong> (<strong class="bold">POM</strong>) is a popular design pattern commonly used in Selenium <a id="_idIndexMarker389"/>test frameworks to increase readability and maintainability <a id="_idIndexMarker390"/>for end-to-end tests. The POM model consists of creating an object-oriented <strong class="source-inline">class</strong> representation for each page in an application, including custom methods to select and interact with various page elements. An advantage of using the POM model is abstracting away multiple lines of test code inside a single method.</p>
			<p>Also, page objects serve as a single source of truth for actions performed on specific pages. In the <em class="italic">Cypress-driven development</em> section, we added a feature to allow users to create a new blog post through the UI. We can refactor the test code using the POM pattern. First, we will create a page object for the <strong class="bold">Home</strong> page:</p>
			<p class="source-code">class HomePage {</p>
			<p class="source-code">  navigateToHomePage() {</p>
			<p class="source-code">    cy.visit('/')</p>
			<p class="source-code">  }</p>
			<p class="source-code">  navigateToAddPage() {</p>
			<p class="source-code">    cy.findByRole('link', { name: /new post/i }).click()</p>
			<p class="source-code">  }</p>
			<p class="source-code">  getBlogPost(post) {</p>
			<p class="source-code">    return cy.findByRole('link', { name: post.title })</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">export const homePage = new HomePage()</p>
			<p>In the preceding code, first, we create a page object for the <strong class="bold">Home</strong> page with <strong class="source-inline">navigateToHomePage</strong>, <strong class="source-inline">navigateToAddPage</strong>, and <strong class="source-inline">getBlogPost</strong> methods. Then, we export a new instance of the object to use in test files. Next, we will create a page object for the <strong class="bold">Add</strong> page:</p>
			<p class="source-code">class AddPage {</p>
			<p class="source-code">  createNewPost(newPost) {</p>
			<p class="source-code">    cy.findByRole('textbox', { name: /title/i </p>
			<p class="source-code">     }).type(newPost.title)</p>
			<p class="source-code">    cy.findByRole('textbox', { name: /category/i </p>
			<p class="source-code">     }).type(newPost.category)</p>
			<p class="source-code">    cy.findByRole('textbox', { name: /image link/i </p>
			<p class="source-code">     }).type(newPost.image_url)</p>
			<p class="source-code">    cy.findByRole('textbox', { name: /content/i </p>
			<p class="source-code">     }).type(newPost.content)</p>
			<p class="source-code">    cy.findByRole('button', { name: /submit/i }).click()</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">export const addPage = new AddPage()</p>
			<p>In the preceding code, we create a page object for the <strong class="bold">Add</strong> page with a <strong class="source-inline">createNewPost</strong> method that accepts a <strong class="source-inline">newPost</strong> object with data to enter for the new post. The page <a id="_idIndexMarker391"/>object is exported for use in test files. Now that we have page objects representing the <strong class="bold">Home</strong> and <strong class="bold">Add</strong> pages, we can use them in a test:</p>
			<p class="source-code">import post from '../support/generateBlogPost'</p>
			<p class="source-code">import { addPage } from './pages/AddPage'</p>
			<p class="source-code">import { homePage } from './pages/HomePage'</p>
			<p>In the preceding code, first, we import the fake <strong class="source-inline">post</strong> method to generate unique post data in the test. Next, we import the <strong class="source-inline">addPage</strong> and <strong class="source-inline">homePage</strong> page objects. Next, we will write the main test code:</p>
			<p class="source-code">      it('POM: allows a user to create a new blog post', ()</p>
			<p class="source-code">       =&gt; {</p>
			<p class="source-code">    homePage.navigateToHomePage()</p>
			<p class="source-code">    homePage.navigateToAddPage()</p>
			<p class="source-code">    addPage.createNewPost(post)</p>
			<p class="source-code">    homePage.getBlogPost(post).should('be.visible')</p>
			<p class="source-code">  })</p>
			<p>In the preceding code, first, we navigate to the <strong class="bold">Home</strong> page. Next, we navigate to the <strong class="bold">Add</strong> page. Then, we create a new post with values from the fake <strong class="source-inline">post</strong> method. Finally, we get the new post on the <strong class="bold">Home</strong> page and verify that it is visible on the screen.</p>
			<p>In the <em class="italic">Cypress-driven development</em> section, we added another feature to delete blog posts through the UI. We can add a method for this feature in our page objects and verify our test's behavior. First, we will add a new method to the <strong class="source-inline">homePage</strong> page object:</p>
			<p class="source-code">navigateToPostDetail(post) {</p>
			<p class="source-code"> cy.findByRole('link', { name: post.title }).click()</p>
			<p class="source-code">}</p>
			<p>In the <a id="_idIndexMarker392"/>previous code, we added a <strong class="source-inline">navigateToPostDetail</strong> method that accepts a <strong class="source-inline">post</strong> argument when called. Next, we will create a page object for the <strong class="bold">Post Detail</strong> page:</p>
			<p class="source-code">class PostDetailPage {</p>
			<p class="source-code">  deletePost() {</p>
			<p class="source-code">    cy.findByText(/delete post&gt;/i).click()</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">export const postDetailPage = new PostDetailPage()</p>
			<p>In the preceding code, we created a page object for the <strong class="bold">Post Detail</strong> page and added a <strong class="source-inline">deletePost</strong> method. We also exported an instance of the page object to use in tests. Now we can use the new page object methods in our existing test:</p>
			<p class="source-code">import { postDetailPage } from './pages/PostDetailPage'</p>
			<p>In the previous code, first, we import the <strong class="source-inline">postDetailPage</strong> page object similar to how we did with other page objects. Next, we will add the associated methods to delete the post:</p>
			<p class="source-code">    homePage.navigateToPostDetail(post)</p>
			<p class="source-code">    postDetailPage.deletePost()</p>
			<p class="source-code">    homePage.getBlogPost(post).should('not.exist')</p>
			<p>In the preceding code, we invoked the <strong class="source-inline">navigateToPostDetail</strong> and <strong class="source-inline">deletePost</strong> methods and verified the post no longer exists on the <strong class="bold">Home</strong> page. Now our task of refactoring the test code to page objects is completed. Our test code is shorter and abstracts away many test step details.</p>
			<p>However, our page object design does present an issue if we split the <em class="italic">add blog post</em> and <em class="italic">delete blog post</em> features into two different tests. The first test will create a blog post:</p>
			<p class="source-code">  it('POM: allows a user to create a new blog post', () =&gt; {</p>
			<p class="source-code">    homePage.navigateToHomePage()</p>
			<p class="source-code">    homePage.navigateToAddPage()</p>
			<p class="source-code">    addPage.createNewPost(post)</p>
			<p class="source-code">    homePage.getBlogPost(post).should('be.visible')</p>
			<p class="source-code">  })</p>
			<p>In the <a id="_idIndexMarker393"/>preceding code, the test <strong class="source-inline">'POM: allows a user to create a new blog post'</strong> creates a blog post. Next, we will create the test to delete the blog post:</p>
			<p class="source-code">  it('POM: allows a user to delete a new blog post', () =&gt; {</p>
			<p class="source-code">    homePage.navigateToHomePage()</p>
			<p class="source-code">    homePage.navigateToAddPage()</p>
			<p class="source-code">    addPage.createNewPost(post)</p>
			<p class="source-code">    homePage.navigateToPostDetail(post)</p>
			<p class="source-code">    postDetailPage.deletePost()</p>
			<p class="source-code">    homePage.getBlogPost(post).should('not.exist')</p>
			<p class="source-code">  })</p>
			<p>In the preceding code, the test <strong class="source-inline">'POM: allows a user to delete a new blog post'</strong> deletes a blog post. The <strong class="bold">Delete</strong> test's problem is that we have to write many of the same test steps from the previous test and the actions most important to the test to delete the post. As a testing best practice, we want to avoid writing the same test steps in multiple tests.</p>
			<p>In the next section, we will learn how to resolve this problem with custom Cypress commands.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor116"/>Creating custom Commands in Cypress</h2>
			<p>In the previous section, we learned how to write tests using the POM pattern. However, we came <a id="_idIndexMarker394"/>across an issue where we had to write the same test steps in a different test. Cypress provides a custom command feature to resolve the issue. Custom commands allow us to add additional commands to Cypress. In the <em class="italic">Enhancing Cypress commands with the Cypress Testing Library</em> section, we added third-party custom commands. Now we will learn how to write our own custom commands. First, we will create a custom method to create a new blog post:</p>
			<p class="source-code">Cypress.Commands.add('createBlogPost', post =&gt; {</p>
			<p class="source-code">  cy.visit('/')</p>
			<p class="source-code">  cy.findByRole('link', { name: /new post/i }).click()</p>
			<p class="source-code">  cy.findByRole('textbox', { name: /title/i </p>
			<p class="source-code">   }).type(post.title)</p>
			<p class="source-code">  cy.findByRole('textbox', { name: /category/i </p>
			<p class="source-code">   }).type(post.category)</p>
			<p class="source-code">  cy.findByRole('textbox', { name: /image link/i </p>
			<p class="source-code">   }).type(post.image_url)</p>
			<p class="source-code">  cy.findByRole('textbox', { name: /content/i </p>
			<p class="source-code">   }).type(post.content)</p>
			<p class="source-code">  cy.findByRole('button', { name: /submit/i }).click()</p>
			<p class="source-code">   })</p>
			<p>In the preceding code, we add a custom <strong class="source-inline">createBlogPost</strong> command to Cypress via the <strong class="source-inline">Commands.add</strong> method inside the <strong class="source-inline">commands.js</strong> file. Next, we will use the custom method in our test:</p>
			<p class="source-code">  it('Custom Command: allows a user to delete a new blog </p>
			<p class="source-code">    post', () =&gt; {</p>
			<p class="source-code">    <strong class="bold">cy.createBlogPost(post)</strong></p>
			<p class="source-code">    homePage.navigateToPostDetail(post)</p>
			<p class="source-code">    postDetailPage.deletePost()</p>
			<p class="source-code">    homePage.getBlogPost(post).should('not.exist')</p>
			<p class="source-code">  })</p>
			<p>In the preceding code, we replace the previous code that creates a new blog post with the custom <strong class="source-inline">createBlogPost</strong> method we created. The custom method eliminates the need to explicitly write the same code lines to create a blog post. We can use the custom method in any future test when needed. However, for our specific test to delete a blog post, we can go a step further.</p>
			<p>Although our custom <strong class="source-inline">createBlogPost</strong> method eliminates the need to write duplicate lines of code, we are still performing the same steps to create a new blog post via the UI. Executing the same steps in multiple tests is a bad testing practice as we are repeating steps we've already tested. If we have controllable access to our application's API, we can reduce repeated steps through the UI.</p>
			<p>Cypress <a id="_idIndexMarker395"/>provides an HTTP <strong class="source-inline">request client</strong> that we can use to communicate with the API directly. Using the <strong class="source-inline">request client</strong>, we can bypass the UI to avoid repeating steps already tested and speed up our test. We can refactor our custom <strong class="source-inline">createBlogPost</strong> method like so:</p>
			<p class="source-code">  cy.request('POST', '/api/add', post).then(response =&gt; {</p>
			<p class="source-code">    expect(response.body.message).to.equal(</p>
			<p class="source-code">      `The blog "${post.title}" was successfully added`</p>
			<p class="source-code">    )</p>
			<p class="source-code">  })</p>
			<p>In the previous code, we use the <strong class="source-inline">request</strong> method to make a <strong class="source-inline">POST</strong> request to the API at <strong class="source-inline">/api/add</strong> and send a <strong class="source-inline">post</strong> object containing values for the new post. Then we assert the server sends back the message <strong class="source-inline">The blog "blog title here" was successfully added</strong>, indicating the new post was added to the database. Note that <strong class="source-inline">"blog title here"</strong> in the message would be replaced with the blog post's real title when the request is made. Now we can update our test code:</p>
			<p class="source-code">    <strong class="bold">cy.createBlogPost(post)</strong></p>
			<p class="source-code"><strong class="bold">    homePage.navigateToHomePage()</strong></p>
			<p class="source-code">    homePage.navigateToPostDetail(post)</p>
			<p class="source-code">    postDetailPage.deletePost()</p>
			<p class="source-code">    homePage.getBlogPost(post).should('not.exist')</p>
			<p>In the previous code, our test looks almost identical to the previous version. The only change is the implementation of the <strong class="source-inline">createBlogPost</strong> method and adding the <strong class="source-inline">navigateToHomePage</strong> method. However, now the test will run faster because we skip creating a new blog post through the UI. Although we used the POM pattern along with custom commands in this section, it should be noted that we could have solely used custom commands.</p>
			<p>We only need to test the <em class="italic">add blog post</em> and <em class="italic">delete blog post</em> features in one unique test to add the confidence they will work as expected for users. If tagged as critical user flows, the tests could run again in regression test suites to ensure the features continue to work <a id="_idIndexMarker396"/>as new features are added. We could write the Cypress commands to interact with the application directly without using the POM pattern and use custom commands in situations where we have to rerun the same steps.</p>
			<p>Now you know how to structure maintainable test code and reduce duplicate steps by implementing the POM pattern and custom Cypress commands.</p>
			<p>In the next section, we will build our knowledge of the Cypress <strong class="source-inline">request client</strong> by testing our application's API routes.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor117"/>Testing APIs with Cypress</h1>
			<p>In the previous section, we learned how to structure test code using the POM and custom <a id="_idIndexMarker397"/>commands design patterns. We also learned that we <a id="_idIndexMarker398"/>could use Cypress to interact with our application's API directly. In this section, we will build on the previous section's learnings by testing the API of the blog application previously introduced in the <em class="italic">Cypress-driven development</em> section.</p>
			<p>The blog application accepts four API requests: a <strong class="source-inline">GET</strong> request to get all posts, a <strong class="source-inline">POST</strong> request to add a post, a <strong class="source-inline">POST</strong> request to get a single post, and a <strong class="source-inline">DELETE</strong> request to delete a post. First, we will test the <strong class="source-inline">GET</strong> request for all posts:</p>
			<p class="source-code">import fakePost from '../support/generateBlogPost';</p>
			<p class="source-code">  const post = fakePost()</p>
			<p class="source-code"> </p>
			<p class="source-code">const getAllPosts = () =&gt; cy.request('/api/posts').its('body.</p>
			<p class="source-code">posts');</p>
			<p class="source-code">const deletePost = (post) =&gt;</p>
			<p class="source-code">  cy.request('DELETE', `/api/delete/${post.id}`, {</p>
			<p class="source-code">    id: post.id,</p>
			<p class="source-code">    name: post.title,</p>
			<p class="source-code">  });</p>
			<p class="source-code"> </p>
			<p class="source-code">const deleteAllPosts = () =&gt; getAllPosts().each(deletePost);</p>
			<p class="source-code">beforeEach(deleteAllPosts);</p>
			<p>In the <a id="_idIndexMarker399"/>preceding code, first, we import the <strong class="source-inline">fakePost</strong> method <a id="_idIndexMarker400"/>used to generate dynamic post data for each test run and assign it to the variable post. Next, we create three test setup methods: <strong class="source-inline">getAllPosts</strong>, <strong class="source-inline">deletePost</strong>, and <strong class="source-inline">deleteAllPosts</strong>. Before each test run, we want to start with an empty database.</p>
			<p>The <strong class="source-inline">deleteAllPosts</strong> method will get all current posts from the database via <strong class="source-inline">getAllPosts</strong>, which calls <strong class="source-inline">deletePost</strong> to delete each post. Finally, we pass <strong class="source-inline">deleteAllPosts</strong> to <strong class="source-inline">beforeEach</strong>, which will call <strong class="source-inline">deleteAllPosts</strong> before each test run. Next, we will write the main code for the <em class="italic">get all posts</em> request:</p>
			<p class="source-code">    cy.request('POST', '/api/add', {</p>
			<p class="source-code">      title: post.title,</p>
			<p class="source-code">      category: post.category,</p>
			<p class="source-code">      image_url: post.image_url,</p>
			<p class="source-code">      content: post.content</p>
			<p class="source-code">    })</p>
			<p class="source-code">    cy.request('/api/posts').as('posts')</p>
			<p class="source-code">    cy.get('@posts').its('status').should('equal', 200)</p>
			<p class="source-code">    cy.get('@posts').its('body.posts.length').should('equal', </p>
			<p class="source-code">  1)</p>
			<p>In the preceding code, we first use the <strong class="source-inline">request</strong> method to add a new blog post to the API to save in the database. Next, we use <strong class="source-inline">request</strong> to get all posts from the database. Since we wiped the database before the test, we should receive the one blog post we just created from the database.</p>
			<p>We use the <strong class="source-inline">as</strong> method, a Cypress feature that allows us to save a code line as an alias. Then, we use the <strong class="source-inline">get</strong> method to access the alias using the required <strong class="source-inline">@</strong> symbol before the alias <a id="_idIndexMarker401"/>name to verify the API server's response status <a id="_idIndexMarker402"/>code is <strong class="source-inline">200</strong>. Finally, we assert that the length of the <strong class="source-inline">posts</strong> body is <strong class="source-inline">1</strong>. Next, we will test the <em class="italic">create new blog post</em> request:</p>
			<p class="source-code">    cy.request('POST', '/api/add', post).as('newPost')</p>
			<p class="source-code">    cy.get('@newPost').its('status').should('equal', 200)</p>
			<p class="source-code">    cy.get('@newPost')</p>
			<p class="source-code">      .its('body.message')</p>
			<p class="source-code">      .should('be.equal', `The blog "${post.title}" was </p>
			<p class="source-code">        successfully added`)</p>
			<p>In the preceding code, first, we created a new blog post and saved the result as an alias labeled <strong class="source-inline">newPost</strong>. Then, we verify the API response status is <strong class="source-inline">200</strong> and that the response message is <strong class="source-inline">The blog "title here" was successfully added</strong>, where <strong class="source-inline">"title here"</strong> would be equal to the actual title in the test. Next, we will test the <em class="italic">delete a post</em> request:</p>
			<p class="source-code">    cy.request('POST', '/api/add', post)</p>
			<p class="source-code">getAllPosts().each(post =&gt;</p>
			<p class="source-code">  cy</p>
			<p class="source-code">    .request('DELETE', `/api/delete/${post.id}`, {</p>
			<p class="source-code">      id: post.id,</p>
			<p class="source-code">      title: post.title</p>
			<p class="source-code">    })</p>
			<p class="source-code">    .then(response =&gt; {</p>
			<p class="source-code">      expect(response.status).equal(200)</p>
			<p class="source-code">      expect(response.body.message).equal(</p>
			<p class="source-code">        `post "${post.title}" successfully deleted`</p>
			<p class="source-code">      )</p>
			<p class="source-code">    })</p>
			<p class="source-code">)</p>
			<p>In the preceding code, we add a new post similar to what we did in previous tests. Then, we use <strong class="source-inline">getAllPosts</strong> to requests all current posts, which is only one, and make a <strong class="source-inline">DELETE</strong> request to remove each one from the application. Then, we verify the API sends a status of 200 indicating successful deletion.</p>
			<p>Finally, we verify <a id="_idIndexMarker403"/>the API sends a response message that provides <a id="_idIndexMarker404"/>textual confirmation that the post has been deleted. For the final test, we will verify the <em class="italic">get a single post </em>request:</p>
			<p class="source-code">    cy.request('POST', '/api/add', post)</p>
			<p class="source-code">    getAllPosts().each(post =&gt;</p>
			<p class="source-code">      cy</p>
			<p class="source-code">        .request(`/api/post/${post.id}`)</p>
			<p class="source-code">        .its('body.post.title')</p>
			<p class="source-code">        .should('equal', post.title)</p>
			<p class="source-code">    )</p>
			<p class="source-code">  })</p>
			<p>In the preceding code, first, we create a new post similar to previous tests. Then, we get all posts and verify the post <strong class="source-inline">title</strong> sent back from the API matches the <strong class="source-inline">title</strong> of the created post. Now you know how to test APIs using Cypress. It is great knowing that Cypress provides features to perform end-to-end testing for the API and UI, all in the same framework.</p>
			<p>In the next section, we will learn how to create Gherkin-style test scenarios using Cucumber.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor118"/>Writing Gherkin-style tests with Cucumber</h1>
			<p>In the previous section, we learned how to use Cypress to test API responses. In this section, we <a id="_idIndexMarker405"/>will learn how to create Gherkin-style <a id="_idIndexMarker406"/>tests with <strong class="bold">Cucumber</strong>. <strong class="bold">Gherkin</strong> is a behavior-driven <a id="_idIndexMarker407"/>development language used by <a id="_idIndexMarker408"/>Cucumber to describe test scenarios' behavior in a <em class="italic">plain-English</em> format. Tests written in Gherkin also make it easier for software teams to communicate and provide context for test cases with business leaders.</p>
			<p>Gherkin uses the following keywords: <strong class="source-inline">Feature</strong>, <strong class="source-inline">Scenario</strong>, <strong class="source-inline">Given</strong>, <strong class="source-inline">When</strong>, and <strong class="source-inline">Then</strong>. <strong class="source-inline">Feature</strong> is used to describe the thing to build, such as a login page, for example. <strong class="source-inline">Scenario</strong> describes the user flow for the feature. For example, a user can enter a username, password, and click <strong class="bold">Login</strong> to navigate to their profile page.</p>
			<p>The <strong class="source-inline">Given</strong>, <strong class="source-inline">When</strong>, and <strong class="source-inline">Then</strong> keywords describe the scenario at different stages. We could write a complete Gherkin test for a login feature like so:</p>
			<p class="source-code">Feature: Login</p>
			<p class="source-code">  Scenario: A user can enter a username, password, and </p>
			<p class="source-code">    click login to navigate to their profile page.</p>
			<p class="source-code">    Given I am on the login page</p>
			<p class="source-code">    When I enter a username</p>
			<p class="source-code">    When I enter a password</p>
			<p class="source-code">    When I click "login"</p>
			<p class="source-code">    Then I am navigated to my profile page</p>
			<p>In the previous code, we created a Gherkin test for a login feature. We can use the <strong class="source-inline">cypress-cucumber-preprocessor</strong> plugin to write Gherkin-style tests using Cypress. Install the plugin using the following command:</p>
			<p class="source-code">npm install --save-dev cypress-cucumber-preprocessor</p>
			<p>The previous command installs the <strong class="source-inline">cucumber</strong> plugin as a development dependency in your project. Once the plugin is installed, we can configure it for use in our Cypress project:</p>
			<p class="source-code">const cucumber = require('cypress-cucumber-</p>
			<p class="source-code">  preprocessor').default</p>
			<p class="source-code">module.exports = (on, config) =&gt; {</p>
			<p class="source-code">  on('file:preprocessor', cucumber())</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we add the <strong class="source-inline">cucumber</strong> plugin to the Cypress plugins file. Now the <strong class="source-inline">cucumber</strong> plugin features can be used in our tests. Next, we will add the plugin's <strong class="source-inline">feature</strong> file type to our global configuration file:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "testFiles": "**/*.feature"</p>
			<p class="source-code">}</p>
			<p>In the <a id="_idIndexMarker409"/>preceding code, we configure Cypress <a id="_idIndexMarker410"/>to use files with the <strong class="source-inline">feature</strong> extension as the test files. Next, we will add a section to our <strong class="source-inline">package.json</strong> file specifically to load the configuration for the <strong class="source-inline">cucumber</strong> plugin in our project and tell the plugin where to find our feature files:</p>
			<p class="source-code">  "cypress-cucumber-preprocessor": {</p>
			<p class="source-code">    "nonGlobalStepDefinitions": true,</p>
			<p class="source-code">    "stepDefinitions": "./cypress/e2e"</p>
			<p class="source-code">  }</p>
			<p>In the preceding code, we added the necessary configuration code to our <strong class="source-inline">package.json</strong> file. Now that Cucumber is configured in our project, we will use it to write a test for the user flow of creating and deleting a blog post for the blog application previously introduced in the <em class="italic">Cypress-driven development</em> section. First, we will create a feature file:</p>
			<p class="source-code">Feature: Blog Application</p>
			<p class="source-code">  Scenario: A user can create a blog post. </p>
			<p class="source-code">    Given I am on the home page</p>
			<p class="source-code">    When I click the "New Post" link</p>
			<p class="source-code">    When I fill out the new blog form</p>
			<p class="source-code">    When I click "Submit"</p>
			<p class="source-code">    Then I see the new post on the home page</p>
			<p>In the <a id="_idIndexMarker411"/>preceding code, we create a feature <a id="_idIndexMarker412"/>file for the scenario where a user creates a blog post. Next, we will write the associated code for the Gherkin steps:</p>
			<p class="source-code">import { Given, Then, When } from 'cypress-cucumber-</p>
			<p class="source-code">  preprocessor/steps'</p>
			<p class="source-code">import post from '../../support/generateBlogPost'</p>
			<p class="source-code">const currentPost = post</p>
			<p class="source-code">Given('I am on the home page', () =&gt; {</p>
			<p class="source-code">  cy.visit('/')</p>
			<p class="source-code">})</p>
			<p class="source-code">When('I click the "New Post" link', () =&gt; {</p>
			<p class="source-code">  cy.findByRole('link', { name: /new post/i }).click()</p>
			<p class="source-code">})</p>
			<p>In the preceding code, first, we import the <strong class="source-inline">Given</strong>, <strong class="source-inline">Then</strong>, and <strong class="source-inline">When</strong> methods from the Cypress Cucumber library. Next, we import the fake <strong class="source-inline">post</strong> method to generate test data. Since each test step will live in its own method, we store the <strong class="source-inline">fake post</strong> data to maintain the same post throughout the test. Then, we use the <strong class="source-inline">Given</strong> method to create the first test step. The step name: <strong class="source-inline">I am on the home page</strong> must match the feature file's same words. Inside the <strong class="source-inline">Given</strong> method, we write the Cypress code associated with the step. Next, use the <strong class="source-inline">When</strong> method to create the next step. Next, we will add the following step definitions:</p>
			<p class="source-code">When('I fill out the new blog form', () =&gt; {</p>
			<p class="source-code">  cy.findByRole('textbox', { name: /title/i </p>
			<p class="source-code">   }).type(currentPost.title)</p>
			<p class="source-code">  cy.findByRole('textbox', { name: /category/i </p>
			<p class="source-code">   }).type(currentPost.category)</p>
			<p class="source-code">  cy.findByRole('textbox', { name: /image link/i </p>
			<p class="source-code">   }).type(currentPost.image_url)</p>
			<p class="source-code">  cy.findByRole('textbox', { name: /content/i </p>
			<p class="source-code">   }).type(currentPost.content)</p>
			<p class="source-code">})</p>
			<p class="source-code">When('I click "Submit"', () =&gt; {</p>
			<p class="source-code">  cy.findByRole('button', { name: /submit/i }).click()</p>
			<p class="source-code">})</p>
			<p>In the <a id="_idIndexMarker413"/>preceding code, we used the <strong class="source-inline">When</strong> method <a id="_idIndexMarker414"/>to write the associated code for the <strong class="source-inline">I fill out the new blog form</strong> and <strong class="source-inline">I click "Submit"</strong> steps. Finally, we use the <strong class="source-inline">Then</strong> method to create the final step definition:</p>
			<p class="source-code">Then('I see the new post on the home page', () =&gt; {</p>
			<p class="source-code">  cy.findByRole('link', { name: currentPost.title </p>
			<p class="source-code">   }).should('be.visible')</p>
			<p class="source-code">})</p>
			<p>In the preceding code, we use the <strong class="source-inline">Then</strong> method to create the associated code for the <strong class="source-inline">I see the new post on the home page</strong> step. We will create a Cucumber test for the <em class="italic">delete a blog post</em> user flow for the next test.</p>
			<p>First, we make the Gherkin feature scenario:</p>
			<p class="source-code">  Scenario: A user can delete a blog post. </p>
			<p class="source-code">    Given I am on the home page</p>
			<p class="source-code">    When I click the blog post name link</p>
			<p class="source-code">    When I click the delete link</p>
			<p class="source-code">    Then the post is removed from the home page</p>
			<p>In the preceding code, we create a scenario for deleting a blog post. Next, we will write the associated step definitions:</p>
			<p class="source-code">When('I click the blog post name link', () =&gt; {</p>
			<p class="source-code">  cy.findByRole('link', { name: currentPost.title </p>
			<p class="source-code">   }).click()</p>
			<p class="source-code">})</p>
			<p class="source-code">When('I click the delete link', () =&gt; {</p>
			<p class="source-code">  cy.findByText(/delete post&gt;/i).click()</p>
			<p class="source-code">})</p>
			<p>In the preceding code, we use the <strong class="source-inline">When</strong> method to add the associated test code for the <strong class="source-inline">I click the blog post name link</strong> and <strong class="source-inline">I click the delete link</strong> steps. Finally, we use the <strong class="source-inline">Then</strong> method to create the <strong class="source-inline">the post is removed from the home page</strong> step:</p>
			<p class="source-code">Then('the post is removed from the home page', () =&gt; {</p>
			<p class="source-code">  cy.findByRole('link', { name: currentPost.title </p>
			<p class="source-code">   }).should('not.exist')</p>
			<p class="source-code">})</p>
			<p>In the <a id="_idIndexMarker415"/>preceding code, we add the test code <a id="_idIndexMarker416"/>associated with the last step to verify the deleted post is removed from the <strong class="bold">Home</strong> page. Notice that we didn't need to create another method for the <strong class="source-inline">I am on the home page</strong> step. Cucumber is smart enough to use any step definition that matches the string of text in the feature file.</p>
			<p>Now you know how to write Gherkin-style tests in Cypress using Cucumber. You can do other things with Cucumber, such as adding tags to run specific tests and creating data tables that allow you to test multiple arguments for similar Gherkin steps.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor119"/>Using React Developer Tools with Cypress</h1>
			<p>In the previous section, we learned how to write tests using Cucumber. In this section, we will <a id="_idIndexMarker417"/>learn how to install <strong class="bold">React Developer Tools</strong> for <a id="_idIndexMarker418"/>development. React Developer Tools is a great tool to have while developing React applications. It enables you to <a id="_idIndexMarker419"/>inspect the hierarchy of components rendered in the DOM and do things such as viewing and editing component props and state. There are Chrome and Firefox extensions available to install React Developer Tools. There is also a standalone Electron app version, which is useful, such as when you want to debug React applications in Safari or mobile browsers. We will also learn how to use the standalone version with Cypress.</p>
			<p>Use the following command to install via the command line:</p>
			<p class="source-code">npm install --save-dev react-devtools</p>
			<p>The preceding command will install <strong class="source-inline">react-devtools</strong> as a development dependency in your project. Next, we need to add a script that will connect <strong class="source-inline">react-devtools</strong> to your application. If you are building a Next.js application, install the special <strong class="source-inline">&lt;script src="http://localhost:8097"&gt;</strong> script in the <strong class="source-inline">Head</strong> component in the <strong class="source-inline">_document.js</strong> file:</p>
			<p class="source-code">&lt;Head&gt;</p>
			<p class="source-code">  <strong class="bold">&lt;script src="http://localhost:8097"&gt;&lt;/script&gt;</strong></p>
			<p class="source-code">&lt;/Head&gt;</p>
			<p>In the <a id="_idIndexMarker420"/>preceding code, we added the script <a id="_idIndexMarker421"/>inside the <strong class="source-inline">Head</strong> component. The script ensures React Developer Tools connects to your Next.js application. If you are building an application using <strong class="source-inline">create-react-app</strong>, install the special script in the <strong class="source-inline">head</strong> element of the <strong class="source-inline">index.html</strong> file located in the <strong class="source-inline">public</strong> folder:</p>
			<p class="source-code">&lt;!DOCTYPE html&gt;</p>
			<p class="source-code">&lt;html lang="en"&gt;</p>
			<p class="source-code">  &lt;head&gt;</p>
			<p class="source-code">    <strong class="bold">&lt;script src="http://localhost:8097"&gt;&lt;/script&gt;</strong></p>
			<p>In the preceding code, we add the script as the first thing inside the <strong class="source-inline">head</strong> element. We need to remember to remove the special <strong class="source-inline">react-devtools</strong> script before deploying the application to production because it is a development tool that would add unnecessary code to our production-versioned application.</p>
			<p>After the script has been added, next we will create an <strong class="source-inline">npm</strong> script in the <strong class="source-inline">package.json</strong> file to start the tool:</p>
			<p class="source-code">"scripts": {</p>
			<p class="source-code">  <strong class="bold">"devtools": "react-devtools"</strong></p>
			<p>In the preceding code, we added a <strong class="source-inline">devtools</strong> script to run <strong class="source-inline">react-devtools</strong>. Now that we have a script to run the tool, the last thing we need to do is start our application, the Cypress interactive tool, and <strong class="source-inline">react-devtools</strong>: each in a separate tab at the command line.</p>
			<p>For Next.js applications, use the following command:</p>
			<p class="source-code">npm run dev</p>
			<p>We ran the preceding command to start the Next.js application in development. For <strong class="source-inline">create-react-app</strong> applications, use the following command:</p>
			<p class="source-code">npm start</p>
			<p>We ran <a id="_idIndexMarker422"/>the preceding command to start <a id="_idIndexMarker423"/>the <strong class="source-inline">create-react-app</strong> application in development. In the <em class="italic">Getting started with Cypress</em> section, we created a <strong class="source-inline">"cy:open"</strong> script to start Cypress in interactive mode. We can run the script like so:</p>
			<p class="source-code">npm run cy:open</p>
			<p>In the preceding command, we ran the script to start Cypress. The next thing we need to do is run the <strong class="source-inline">react-devtools</strong> script:</p>
			<p class="source-code">npm run devtools</p>
			<p>In the preceding command, we ran the script to start <strong class="source-inline">react-devtools</strong>. When run, <strong class="source-inline">react-devtools</strong> opens its application on our computer:</p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="Images/Figure_7.18_B16887.jpg" alt="Figure 7.18 – React Developer Tools application" width="459" height="435"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.18 – React Developer Tools application</p>
			<p>In the <a id="_idIndexMarker424"/>preceding screenshot, <strong class="source-inline">react-devtools</strong> opens <a id="_idIndexMarker425"/>and listens for our application to run to connect to it. Once we run any of our Cypress tests via the interactive mode, the applications component tree will populate inside of the <strong class="source-inline">react-devtools</strong> application:</p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="Images/Figure_7.19_B16887.jpg" alt="Figure 7.19 – React Developer Tools component tree view" width="769" height="683"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.19 – React Developer Tools component tree view</p>
			<p>In the preceding screenshot, the <strong class="source-inline">react-devtools</strong> application displays the resulting component tree of the running test. With the application running, we have many tools available, such as clicking on component names to view related information:</p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="Images/Figure_7.20_B16887.jpg" alt="Figure 7.20 – React Developer Tools component details&#13;&#10;" width="1252" height="584"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.20 – React Developer Tools component details</p>
			<p>In the <a id="_idIndexMarker426"/>preceding screenshot, we select one of <a id="_idIndexMarker427"/>the <strong class="source-inline">Link</strong> components on the left side of the <strong class="source-inline">react-devtools</strong> screen. When we click the component, it displays associated information on the <strong class="source-inline">react-devtools</strong> screen's right side, such as <strong class="source-inline">props</strong> and <strong class="source-inline">hooks</strong>. We also see the Cypress interactive mode screen on the right side of the screenshot.</p>
			<p>Now you know how to use React Developer Tools with Cypress. In addition to the debugging tools provided by Cypress, you now have an extra tool to debug React applications while running Cypress.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor120"/>Summary</h1>
			<p>In this chapter, you have learned new strategies to test applications using Cypress. You can write end-to-end tests to verify critical user flows for applications. You learned how to implement API testing. You now know the benefits of using Cypress-driven development to create new features. You understand the POM and custom command design patterns to structure and organize test code.</p>
			<p>Finally, you learned how to use Cucumber to write Gherkin-style tests that enhance communication with non-technical team members.</p>
			<p>Congratulations, you have reached the end of our journey and now know about numerous strategies and tools to simplify testing React applications! The concepts and skills gained in this book will help you write quality code no matter what JavaScript project you tackle in the future.</p>
			<p>Good luck, and always remember, no great software is built without a foundation of great tests.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor121"/>Questions</h1>
			<ol>
				<li>Find a previous project and install and write a suite of end-to-end tests with Cypress.</li>
				<li>Create a CRUD API and test it using Cypress.</li>
				<li>Build a full-stack React application and write as many tests as you can think of using as many different strategies gained from this book as possible.</li>
			</ol>
		</div>
	</div></body></html>