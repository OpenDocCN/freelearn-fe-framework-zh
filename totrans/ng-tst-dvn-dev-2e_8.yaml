- en: Chapter 8. Telling the World
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。告诉世界
- en: The build up of TDD focused on fundamental components, namely the life cycle
    and process, using step-by-step walk-throughs. We have studied several applications
    from the ground up, understanding how to build Angular applications and use tools
    to test them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的构建主要关注基本组件，即生命周期和过程，使用逐步讲解。我们从底层研究了几个应用程序，理解了如何构建Angular应用程序并使用工具来测试它们。
- en: It's time to expand further into the depths of Angular and integrate services,
    EventEmitters, and routes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进一步深入Angular的深处并集成服务、EventEmitters和路由了。
- en: 'This chapter will be slightly different from the others in a few ways:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在几个方面将与其他章节略有不同：
- en: Instead of building a brand new application, we will use the search application
    from [Chapter 7](ch07.html "Chapter 7. Flip Flop"), *Flip Flop*
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用[第7章](ch07.html "第7章。翻转")中的搜索应用程序，而不是构建全新的应用程序，*翻转*
- en: We will add the unit tests for Angular routes and navigation that were skipped
    in previous chapters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将为Angular路由和导航添加上一章中跳过的单元测试
- en: We will make the existing search application more modern by separating the commonly
    used actions into services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将通过将常用操作分离到服务中来使现有的搜索应用程序更加现代化
- en: We will take advantage of the Angular `EventEmitter` class to communicate between
    the different components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将利用Angular的`EventEmitter`类在不同的组件之间进行通信
- en: Getting ready to communicate
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备进行通信
- en: We will follow a different approach in this chapter, as we've already learned the
    TDD approach. We developed a small project in the previous chapter, and our plan
    is to work with that project and make it better in order to present it to the
    world.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将采取不同的方法，因为我们已经学习了TDD方法。我们在上一章开发了一个小型项目，我们的计划是使用这个项目并使其变得更好，以便向世界展示。
- en: So, before the walk-through, we will have to review and identify any problems
    and the scope for improvement of the project. To do so, we have to be confident
    of the code base of the search application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在开始讲解之前，我们必须回顾并识别项目中存在的问题以及改进的范围。为此，我们必须对搜索应用程序的代码库有信心。
- en: Loading the existing project
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载现有项目
- en: To start with, we will copy the project from [Chapter 7](ch07.html "Chapter 7. Flip
    Flop"), *Flip Flop*, which was originally from [https://github.com/angular/quickstart](https://github.com/angular/quickstart), and
    rename it `angular-member-search`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从[第7章](ch07.html "第7章。翻转")，*翻转*复制项目，该项目最初来自[https://github.com/angular/quickstart](https://github.com/angular/quickstart)，并将其重命名为`angular-member-search`。
- en: 'Let''s proceed and get ready to run it:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，准备运行它：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To confirm the installation and run the project, the application will automatically
    run it in a web browser.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认安装并运行项目，应用程序将自动在网页浏览器中运行它。
- en: 'Here is the output we should get when we will run the project:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行项目时，我们应该得到以下输出：
- en: '![Loading the existing project](img/image_08_001.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![加载现有项目](img/image_08_001.jpg)'
- en: Oh! We have our end-to-end test ready in the project. Before we go for an update,
    we have to be sure that the existing e2e tests are successful.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 哦！我们在项目中已经有了端到端测试。在我们进行更新之前，我们必须确保现有的e2e测试是成功的。
- en: 'Let''s run the `e2e` test in a separate console:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在单独的控制台中运行`e2e`测试：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Yes, everything passes successfully:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，一切测试都成功通过：
- en: '![Loading the existing project](img/image_08_002.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![加载现有项目](img/image_08_002.jpg)'
- en: Unit testing
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: In the previous chapter, we started with the top-down approach. The goal was
    to elaborate on end-to-end testing based on what we had learned. We had the user
    scenario clear, we went through the tests, and our scenario passed our implementation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始使用自顶向下的方法。目标是基于我们所学的内容详细阐述端到端测试。我们有明确用户场景，我们通过了测试，并且我们的场景通过了我们的实现。
- en: In the previous chapter, we only covered end-to-end testing. So, in this chapter,
    we'll cover unit tests as much as we can.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们只涵盖了端到端测试。因此，在本章中，我们将尽可能多地涵盖单元测试。
- en: Also, in the previous chapter, we mostly looked at Angular routes and navigation.
    So now, as a logical extension, we will look at how to test Angular routes and
    navigation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在上一章中，我们主要关注Angular路由和导航。因此，现在作为一个逻辑上的扩展，我们将探讨如何测试Angular路由和导航。
- en: Testing a component
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试组件
- en: 'Before we go ahead with the component test, we should discuss some points about testing
    Angular components. We already have a basic idea: in Angular, everything is a
    combination of some components. So it would be great for us to learn in more detail
    about Angular component testing.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行组件测试之前，我们应该讨论一些关于测试Angular组件的观点。我们已经有了一个基本的概念：在Angular中，一切都是一些组件的组合。因此，深入了解Angular组件测试对我们来说将是非常有益的。
- en: We can test a component in various ways, based on its behavior and use case.
    We could even have test specs for multiple components when they work together
    as an application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据组件的行为和用例以各种方式测试组件。我们甚至可以为多个组件编写测试规范，当它们作为一个应用程序一起工作时。
- en: Let's have a look at some of the ways of testing components.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看测试组件的一些方法。
- en: Isolated testing
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隔离测试
- en: Isolated testing, also known as solo testing, is named so because this type
    of test can run without the need to compile components according to test specs.
    If it doesn't compile, it will not have the compiled template in the test spec;
    only the component class and its methods. This means that if a component's features
    are not very DOM dependent, it can be tested in an isolated manner.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离测试，也称为单独测试，之所以这样命名，是因为这种测试可以在不需要根据测试规范编译组件的情况下运行。如果它没有编译，它将不会在测试规范中有编译后的模板；只有组件类及其方法。这意味着如果组件的功能不太依赖于DOM，它可以通过隔离的方式进行测试。
- en: Isolated testing is mostly used for complex feature or calculation testing,
    where it just initiates the component class and calls all the methods.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离测试主要用于复杂功能或计算测试，其中它只需初始化组件类并调用所有方法。
- en: 'For example, take a look at the unit tests of [Chapter 6](ch06.html "Chapter 6. The
    First Step"), *The First Step*, where `AppComponent` was responsible for adding
    comments and increasing their likes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看[第6章](ch06.html "第6章。第一步")的单元测试，*第一步*，其中`AppComponent`负责添加评论和增加它们的点赞数：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Shallow testing
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浅层测试
- en: Isolated testing sometimes fulfills the requirements of the test spec, but not
    always. Most of the time, components have DOM dependent features. In such cases,
    it is important to render the component's template in the test specs so that we
    have the compiled template in the scope and test specs are able to interact with
    DOM.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离测试有时可以满足测试规范的要求，但并不总是如此。大多数时候，组件都有依赖于DOM的功能。在这种情况下，在测试规范中渲染组件的模板非常重要，这样我们就有编译后的模板在作用域内，并且测试规范能够与DOM交互。
- en: For example, if we want to write a basic unit test for our `AppComponent`, which
    is mostly DOM dependent as there is no method in the component class, then we
    just need to compile the component and check that it is defined. In addition,
    we can have a test spec if the component's template has the correct text inside
    the `<h1>` element.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想为我们的`AppComponent`编写一个基本的单元测试，该组件主要依赖于DOM，因为组件类中没有方法，那么我们只需要编译组件并检查它是否已定义。此外，如果组件的模板在`<h1>`元素内具有正确的文本，我们还可以有一个测试规范。
- en: 'The code will look as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将如下所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Integration testing
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'The following are some key points on integration testing:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些关于集成测试的关键点：
- en: The name *integration testing* should give us some idea of what kind of test
    it is. It is similar to shallow testing as it also needs to compile the component
    with the template and interact with the DOM.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “集成测试”这个名字应该给我们一些关于它是哪种测试的线索。它与浅层测试类似，因为它也需要编译带有模板的组件并与DOM交互。
- en: We will next look at our route and navigation test suite, where we will integrate
    the `AppComponent`, router, and navigation test suites.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将查看我们的路由和导航测试套件，其中我们将集成`AppComponent`、路由器和导航测试套件。
- en: We have a test suite ready for `AppComponent`, as it includes the `navbar` component
    and `router-outlet` component. All of these together work to fulfill the routing
    specs.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经为`AppComponent`准备好了测试套件，因为它包括`navbar`组件和`router-outlet`组件。所有这些一起工作以满足路由规范。
- en: So, to get a confident test spec for a router, we should go with integration
    testing.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，为了获得对路由器的自信测试规范，我们应该选择集成测试。
- en: We will look at an example of router testing with a detailed explanation in
    the following sections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将通过一个详细的示例来查看路由器测试。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The main difference between integration testing and shallow testing is that
    integration testing works for the test suite of the complete application, or a
    small portion of the application, where multiple components work together to solve
    some purpose. It shares some similarities with end-to-end testing, but with a different
    approach.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试和浅层测试之间的主要区别在于，集成测试适用于完整应用程序的测试套件或应用程序的小部分，其中多个组件协同工作以解决某些目的。它与端到端测试有一些相似之处，但采用不同的方法。
- en: Karma configuration
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Karma 配置
- en: In previous chapters, the default Karma configuration was used, but no explanation
    about this default configuration has been given yet. **File watching** is a useful
    default behavior that will now be reviewed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，使用了默认的 Karma 配置，但尚未对此默认配置进行解释。**文件监视** 是一个有用的默认行为，现在将对其进行审查。
- en: File watching
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件监视
- en: "File watching is enabled by default when the Karma `init` command is used.\
    \ \LFile watching in Karma is configured with the following definition in the\
    \ \L`karma.conf.js` file:"
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Karma `init` 命令时，默认启用文件监视。Karma 中的文件监视通过在 `karma.conf.js` 文件中的以下定义进行配置：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The file watching feature works as expected and watches the files defined in
    the configuration's `files` array. When a file is updated, changed, or deleted,
    Karma responds by rerunning the tests. From a TDD perspective, this is a great
    feature, as tests will continue to run without any manual intervention.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 文件监视功能按预期工作，监视配置中定义的 `files` 数组中的文件。当文件更新、更改或删除时，Karma 会通过重新运行测试来响应。从 TDD 的角度来看，这是一个很棒的功能，因为测试将在没有任何手动干预的情况下继续运行。
- en: 'The main point to watch out for is the addition of files. If the file being
    added doesn''t match the criteria in the `files` array, the `autoWatch` parameter
    won''t respond to the change. As an example, let''s consider that the files are
    defined as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的主要点是文件的添加。如果被添加的文件不匹配 `files` 数组中的标准，`autoWatch` 参数不会对更改做出响应。例如，让我们考虑以下文件定义：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If this is the case, the watcher will find all the files and subdirectory files
    ending in `.js`. If a new file is in a different directory, not in `dir1`, then
    the watcher will not be able to respond to the new file because it is in a different
    directory from what it was configured in.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，监视器将找到所有以 `.js` 结尾的文件和子目录文件。如果新文件位于不同的目录中，而不是 `dir1` 目录中，那么监视器将无法响应新文件，因为它不在配置的目录中。
- en: Testing routers and navigation
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试路由器和导航
- en: We were introduced to Angular routers and navigation alongside the general components
    in [Chapter 7](ch07.html "Chapter 7. Flip Flop"), *Flip Flop*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 7 章](ch07.html "第 7 章。翻转") *翻转* 中介绍了 Angular 路由器和导航，与一般组件一起。
- en: As we have discussed the different types of tests for Angular components, routers
    and navigation, we will look at integration testing. For that, we will use our
    application component test, that is, our base component, and we will then integrate
    navigation and `router-outlet` component tests with the application component
    to test the router.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了 Angular 组件、路由器和导航的不同类型的测试，我们将查看集成测试。为此，我们将使用我们的应用程序组件测试，即我们的基础组件，然后我们将集成导航和
    `router-outlet` 组件测试与应用程序组件一起测试路由器。
- en: Testing the app component
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试应用程序组件
- en: Before we go ahead with router testing, we will get ready with our application
    component tests. In the app component test, we will test whether the component
    is defined and initiated correctly, and then we will test the page title by selecting
    the DOM element.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行路由器测试之前，我们将为我们的应用程序组件测试做好准备。在应用程序组件测试中，我们将测试组件是否被正确定义和初始化，然后我们将通过选择 DOM
    元素来测试页面标题。
- en: 'We learned about shallow testing in previous sections; when we interact with
    DOM elements, we need shallow testing. The same goes here: as we will have to
    deal with DOM elements, we will use shallow testing as our application component
    test.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中学习了浅层测试；当我们与 DOM 元素交互时，我们需要浅层测试。这里也是一样：由于我们将不得不处理 DOM 元素，我们将使用浅层测试作为我们的应用程序组件测试。
- en: For shallow testing, we will need to depend on the `TestBed` Angular test API
    from Angular core testing, which will be used to compile and initiate the components
    in the test suite. Besides that, we will have to depend on the `ComponentFixture`
    module from core testing. We will need two more modules, named `By` and `DebugElement`,
    from the Angular core and platform APIs to interact with DOM elements.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于浅层测试，我们需要依赖于 Angular 核心测试中的 `TestBed` Angular 测试 API，它将用于编译和初始化测试套件中的组件。除此之外，我们还需要依赖于核心测试中的
    `ComponentFixture` 模块。我们还需要从 Angular 核心和平台 API 中获取两个额外的模块，名为 `By` 和 `DebugElement`，以与
    DOM 元素交互。
- en: 'Our app component test will be located at `spec/unit/app.component.ts` and
    will look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件测试将位于 `spec/unit/app.component.ts`，其结构如下：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we run this test, we will see the following result:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个测试，我们将看到以下结果：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our application component test is ready now; next, we will perform a router
    test, including `router-outlet` and navigation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序组件测试现在已经准备好了；接下来，我们将执行一个路由测试，包括 `router-outlet` 和导航。
- en: Testing router
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试路由
- en: The Angular router is not part of Angular core; it's a separate module that
    has to be imported before being used. It has some directives, such as `RouterOutlet`
    and `RouterLink`, which play an active role in fulfilling router activities. To
    test the router, first we will test these directives, in order to prepare the
    platform for testing the complete router.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 路由不是 Angular 核心的一部分；它是一个单独的模块，在使用之前必须导入。它有一些指令，如 `RouterOutlet` 和 `RouterLink`，在执行路由活动时发挥着积极作用。为了测试路由，我们首先将测试这些指令，以便为测试完整路由准备平台。
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We can test the router using the actual router module, but sometimes it creates
    some complexity for the entire routing system. Due to this, test specs may fail
    without providing an accurate error. To avoid this, it's recommended to create
    router stubs and use those for router testing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用实际的路由模块来测试路由，但有时它会给整个路由系统带来一些复杂性。因此，测试规范可能会在没有提供准确错误的情况下失败。为了避免这种情况，建议创建路由占位符并使用这些占位符进行路由测试。
- en: Router stubs
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由占位符
- en: I had the router stubs idea from Angular's official testing docs. I liked the
    idea about the routing stubs and copied the `router-stubs` file from `angular.io/public/docs/_examples/testing/ts/testing/router-stubs.ts`
    in Angular's GitHub repository. The first router stubs directive is `RouterStubLinksDirective`,
    which is responsible for hosting the element or anchor link (`<a>`) to perform
    the `click` event for the directive's `onClick()` method. The URL bound to the
    `[routerLink]` attribute flows to the directive's `linkParams` property. When
    the anchor link (`<a>`) is clicked on, it should trigger the `onClick()` method,
    and it will set to the tentative `navigateTo` property.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我从 Angular 的官方测试文档中得到了路由占位符的想法。我喜欢路由占位符的想法，并从 Angular 的 GitHub 仓库中的 `angular.io/public/docs/_examples/testing/ts/testing/router-stubs.ts`
    复制了 `router-stubs` 文件。第一个路由占位符指令是 `RouterStubLinksDirective`，它负责托管元素或锚点链接 (`<a>`)
    以执行指令的 `onClick()` 方法。绑定到 `[routerLink]` 属性的 URL 流向指令的 `linkParams` 属性。当锚点链接 (`<a>`)
    被点击时，应该触发 `onClick()` 方法，并将其设置为暂定的 `navigateTo` 属性。
- en: This `router-stubs` file has a dependency on the Angular router and relevant
    directives, including `RouterLink` and `RouterOutlet`, so we will need to import
    those.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `router-stubs` 文件依赖于 Angular 路由和相关指令，包括 `RouterLink` 和 `RouterOutlet`，因此我们需要导入这些。
- en: 'So, the router stubs will be located at `spec/unit/stub/router-stub.ts`, and
    the code will be as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，路由占位符将位于 `spec/unit/stub/router-stub.ts`，代码如下：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Beside the `RouterLinkStubDirective`, this stub should contain the `RouterOutletStubComponent`
    to support the `router-outlet` directive, and `RouterStub` to support the main
    router module:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `RouterLinkStubDirective`，这个占位符还应包含 `RouterOutletStubComponent` 以支持 `router-outlet`
    指令，以及 `RouterStub` 以支持主路由模块：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The router-outlet and navigation test
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由出口和导航测试
- en: As we know, the `router-outlet` and navigation (`RouterLink`) menus work together
    with the application landing page, that is, our application component. The testing
    mechanism will be of the same form. This means that we will test both of these
    modules with the application component.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，`router-outlet` 和导航 (`RouterLink`) 菜单与应用程序的着陆页（即我们的应用程序组件）协同工作。测试机制将具有相同的形式。这意味着我们将使用应用程序组件测试这两个模块。
- en: As mentioned a bit earlier, we will use an integration test here for `router-outlet`
    testing. We have our application component test suite ready; now it's time to
    integrate `router-outlet` and navigation (`RouterLink`), and we will have our
    integration test suite for the application component along with `router-outlet`
    and `RouterLink`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将在这里使用集成测试进行`router-outlet`测试。我们已经有了应用程序组件测试套件；现在是时候集成`router-outlet`和导航（`RouterLink`），我们将拥有包含`router-outlet`和`RouterLink`的应用程序组件的集成测试套件。
- en: We have the `navbar` component, which is basically a navigation component that contains
    the `RouterLink` to navigate through the router. We will have to import that component
    to our test suite for it to perform correctly. Besides the actual router module,
    we will have to import the `RouterStub` that we have created. To reiterate, `router-stubs`
    contains the `RouterOutletStubComponent` and `RouterLinkStubDirective` components.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`navbar`组件，它基本上是一个包含导航`RouterLink`以通过路由进行导航的导航组件。我们必须将该组件导入到我们的测试套件中，以便它能够正确执行。除了实际的路由模块之外，我们还需要导入我们创建的`RouterStub`。再次强调，`router-stubs`包含`RouterOutletStubComponent`和`RouterLinkStubDirective`组件。
- en: After importing all the required components, we will have to declare them in
    the `TestBed` configuration. And, as a part of the setup, we will get all the
    `navLinks` from the `RouterLinkStubDirective` in the test suite's scope to test
    and bind `click` events to the `linkParams`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入所有必需的组件后，我们将在`TestBed`配置中声明它们。作为设置的一部分，我们将从测试套件的范围内获取所有`navLinks`以进行测试并将`click`事件绑定到`linkParams`。
- en: 'The test suite''s setup will look like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件的设置将如下所示：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For the test specs, first we will test the link parameters in the navigation
    menu. We have the `navLinks`, and we will match them with the `linkParams` of
    the `navLinks`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试规范，首先我们将测试导航菜单中的链接参数。我们有`navLinks`，我们将它们与`navLinks`的`linkParams`进行匹配。
- en: Then, we will test the expected navigation while clicking on the navigation
    menu items. We will test that with the help of the `navigatedTo` method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将测试点击导航菜单项时的预期导航。我们将使用`navigatedTo`方法进行测试。
- en: 'Our test specs will look as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试规范将如下所示：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, we can say that this will cover the tests for `router-outlet` and routerLink,
    which will confirm that the router links are working as expected, and that we
    are able to navigate though the expected router after clicking on the navigation
    menu.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以说这将涵盖`router-outlet`和`routerLink`的测试，这将确认路由链接按预期工作，并且我们能够在点击导航菜单后通过预期的路由进行导航。
- en: Implementing an integration test
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施集成测试
- en: Our test specs are ready. We have been planning for an integrated test, and
    we can perform one now. Here, we are combining the app component and `navbar`
    component, along with `router-outlet` and `routerLink`, to test the route and
    navigation. We have to interact with DOM elements with the help of the `debugElement`
    module from the browser platform API.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试规范已准备就绪。我们一直在计划进行集成测试，现在我们可以进行一次测试。在这里，我们将应用程序组件和`navbar`组件以及`router-outlet`和`routerLink`结合起来，以测试路由和导航。我们必须借助浏览器平台API中的`debugElement`模块与DOM元素进行交互。
- en: The test suite is ready--time to run the test.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件已准备就绪--现在是时候运行测试了。
- en: 'Let''s run it with the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令运行它：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And all the test specs pass as expected. The result will be as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试规范都按预期通过。结果将如下所示：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: More tests...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多测试...
- en: We just added some tests that will cover a few of the features that we have
    developed so far, mostly focused on the router (`router-outlet` and `routerLink`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加了一些测试，这些测试将涵盖我们迄今为止开发的一些功能，主要关注路由（`router-outlet`和`routerLink`）。
- en: We will add more tests for members and the search feature, but we will update
    the behavior of the existing features of searching and member listing. Besides
    that, our current code base does not have proper decoupling between the components'
    features, which will make it complex to test features individually.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为成员和搜索功能添加更多测试，但我们将更新现有搜索和成员列表功能的操作行为。除此之外，我们的当前代码库在组件功能之间没有适当的解耦，这将使得单独测试功能变得复杂。
- en: We already have the end-to-end test, which will verify the output we expect
    from our components, but for unit testing, we will need to refactor the code and
    decouple them. We will cover the tests for the rest of the features after we update
    the behavior and refactor the correct code base.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了端到端测试，它将验证我们从组件中期望的输出，但对于单元测试，我们需要重构代码并解耦它们。在更新行为和重构正确的代码库之后，我们将涵盖其余功能的测试。
- en: Recap of the application behavior
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序行为概述
- en: 'Let''s look at a quick overview of the search application:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速概述一下搜索应用程序：
- en: 'Our search application invokes the Members component in the DOM. It contains
    two major parts: the search area and the result area.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的搜索应用程序在DOM中调用`Members`组件。它包含两个主要部分：搜索区域和结果区域。
- en: From the search area, we type a search query and submit it to get the expected
    result in the result area.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在搜索区域，我们输入搜索查询并将其提交到结果区域以获取预期的结果。
- en: The resulting area lists down the member list based on the search query. We
    may have figured out that we get all the data during the initialization of the
    `Members` component; that's because we call the Members component's `search()`
    method with `ngOnInit()`, and it returns all the data as our logic has been set
    to return all data when no search query is set.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果区域根据搜索查询列出成员列表。我们可能已经意识到，我们在`Members`组件的初始化期间获取了所有数据；这是因为我们使用`ngOnInit()`调用`Members`组件的`search()`方法，并且它返回所有数据，因为我们的逻辑已经设置为在没有设置搜索查询时返回所有数据。
- en: By clicking on a member's name, we can see the detailed information about that
    member on the details page.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过点击成员的姓名，我们可以在详情页面上看到该成员的详细信息。
- en: Updating the application behavior
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新应用程序行为
- en: According to the previous specification, it seems we have some incorrect behavior
    in the search feature. Right now, we are calling `search()` when initializing
    the members of the search component. This seems a bit wrong; we should start the
    search after entering the search query and/or clicking on the **Search** button.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前的规范，似乎我们在搜索功能中存在一些不正确的行为。目前，我们在初始化搜索组件的成员时调用`search()`。这似乎有点不对；我们应该在输入搜索查询和/或点击**搜索**按钮后开始搜索。
- en: The expected behavior is that it will first load all the member data and then,
    after starting the search, the data list will be updated based on the search query.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的行为是它将首先加载所有成员数据，然后在开始搜索后，数据列表将根据搜索查询进行更新。
- en: To do so, let's update the `ngOnInit()` method in `members.component.ts` and
    add a new method, `getMember()`, to have the entire data list during component
    initiation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们更新`members.component.ts`中的`ngOnInit()`方法，并添加一个新的方法`getMember()`，以便在组件初始化时拥有整个数据列表。
- en: 'The expected change will be as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的更改如下：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Identifying the problem
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别问题
- en: Based on the existing code, it seems we have defined the `getData()` method
    twice, in `members.component.ts` and `person.component.ts,` because in both the
    components, we had to call the JSON data source to get the member dataset.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 基于现有代码，看起来我们在`members.component.ts`和`person.component.ts`中定义了两次`getData()`方法，因为在两个组件中我们都需要调用JSON数据源来获取成员数据集。
- en: So, what's the problem with that? It's bad practice as it duplicates code, and
    duplication of code is hard to manage when the application becomes large and complex.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这有什么问题吗？这是不好的做法，因为它重复了代码，而当应用程序变得庞大和复杂时，代码重复难以管理。
- en: 'For example, now we have the following method twice:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，现在我们有两个这样的方法：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we have to to change the data source URL or API, we will have to change this
    method in two places. It's not so tough to change it twice, but what about 10-12
    times, or even more for a larger application?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须更改数据源URL或API，我们就必须在这两个地方更改这个方法。更改两次并不那么困难，但如果是10-12次，或者对于更大的应用程序来说更多呢？
- en: Yes, it's a problem, and it needs a solution.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是一个问题，需要解决方案。
- en: Finding a solution
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找解决方案
- en: 'We''ve identified the problem, which is code duplication. We know the solution:
    we have to write the method in a common place and use it in both components. In
    short, we have to make this method reusable so that every component can share
    it.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了问题，即代码重复。我们知道解决方案：我们必须在公共位置编写该方法并在两个组件中使用它。简而言之，我们必须使此方法可重用，以便每个组件都可以共享它。
- en: It seems simple, but we have to do it in the Angular way. We can't just move
    the method to a separate file and import that.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单，但我们必须以Angular的方式来做。我们不能只是将方法移动到单独的文件并导入。
- en: Angular introduced services for such situations. We'll now look at some of those
    services with examples.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Angular为这种情况引入了服务。现在我们将通过示例查看一些这些服务。
- en: Angular services
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular服务
- en: Angular services were introduced to write code shareable among components. So
    if we need a piece of code for many components, it's recommended to create a single
    reusable service, and wherever we need that piece of code, we can just inject
    that service to the component and use its methods as needed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Angular服务是为了在组件之间共享代码而引入的。所以如果我们需要许多组件的代码，建议创建一个单一的可重用服务，并且无论何时需要那段代码，我们都可以将其注入到组件中并按需使用其方法。
- en: "Services are used to abstract application logic. They are used to provide a\
    \ single responsibility for a particular action. Single responsibility allows\
    \ components to \Lbe easily tested and changed. This is because the focus is on\
    \ one component and \Lnot all the inner dependencies."
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 服务用于抽象应用程序逻辑。它们用于为特定操作提供单一责任。单一责任允许组件易于测试和更改。这是因为重点是单个组件，而不是所有内部依赖项。
- en: Mostly, a service acts as the data source of any application. Whenever we need
    a piece of code to communicate with the server to get data (mostly JSON), we use
    a service.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个服务充当任何应用程序的数据源。每当我们需要一段代码与服务器通信以获取数据（通常是JSON）时，我们就会使用一个服务。
- en: This is because most components need to access data, and everyone can inject
    the common service as required. So, we have a commonly used piece of code, which
    is actually the data layer for our application. We should move those parts to
    a service to make our application smart so that we can tell the world we are not
    duplicating code in any way.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为大多数组件都需要访问数据，每个人都可以根据需要注入通用服务。因此，我们有一个常用的代码片段，这实际上是我们的应用程序的数据层。我们应该将这些部分移动到服务中，使我们的应用程序更智能，这样我们就可以告诉全世界我们不会以任何方式重复代码。
- en: We have service now?
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们现在有服务了吗？
- en: As planned, we have moved the `getData()` method from the `members.component.ts`
    and `person.component.ts` components to a new file so that we can get rid of code
    duplication.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 按照计划，我们已经将`getData()`方法从`members.component.ts`和`person.component.ts`组件移动到了一个新的文件中，这样我们就可以消除代码重复。
- en: Let's create a new file at `app/services/members.service.ts`, make a new class
    to export, called `MembersService`, and move the `getData()` method there. Besides
    moving the method, we will have to import `{ Http, Response }` from the Angular
    HTTP module as `getData` has a dependency on HTTP.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app/services/members.service.ts`创建一个新的文件，创建一个新的类以导出，命名为`MembersService`，并将`getData()`方法移到那里。除了移动方法外，我们还需要从Angular
    HTTP模块导入`{ Http, Response }`，因为`getData`依赖于HTTP。
- en: 'Observe the following code sample:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下代码示例：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have a service now, and we can start using it. Let's import and use it in
    the Members component.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有服务了，我们可以开始使用它。让我们导入并使用它来在Members组件中。
- en: Wait; before that, we will have to import the service into the application module
    to have identification of it. As long as it's a service, we will have to identify
    it as a provider; the service will act as a service provider.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下；在那之前，我们必须将服务导入到应用程序模块中以便识别它。只要它是服务，我们就必须将其标识为提供者；服务将充当服务提供者。
- en: 'Our `app.module.ts` file will look like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`app.module.ts`文件将看起来像这样：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, to use the service in our component, we have to import and inject it into
    our MembersComponents with the service name `MembersService`. As long as we inject
    the service as the constructor of the component, we will have the service available
    to the entire component. To access the method, we need to call it `this.membersService.getData()`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了在组件中使用服务，我们必须导入并使用服务名`MembersService`将其注入到我们的MembersComponents中。只要我们将服务作为组件的构造函数注入，我们就可以在整个组件中使用该服务。要访问方法，我们需要调用它`this.membersService.getData()`。
- en: 'So, our Members component will look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的Members组件将看起来像这样：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Time to run and look at the output and see how the service works with the Members
    component.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行并查看输出来看看服务是如何与Members组件一起工作的。
- en: Lets point the browser to `http://localhost:3000/members`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让浏览器指向`http://localhost:3000/members`。
- en: 'Oops! What happened? We are getting an error in the browser console:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！发生了什么？我们在浏览器控制台中遇到了错误：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Based on the error, we have made a mistake: `SystemJS` (used as the module
    loaded) can''t inject `MembersService` as we missed adding something to the service
    to make it perfect. In Angular, we have to mention in every service whether it will
    be injectable; without doing so, we will not be able to inject that service into
    any component.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 根据错误，我们犯了一个错误：`SystemJS`（用作加载的模块）不能注入`MembersService`，因为我们没有在服务中添加某些内容来使其完美。在Angular中，我们必须在每个服务中说明它是否可注入；如果不这样做，我们就无法将此服务注入到任何组件中。
- en: And, for that, we will have to use the Angular **Injectable** decorator. We
    will take a look at it in brief.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们必须使用Angular的**Injectable**装饰器。我们将简要地了解一下它。
- en: Injectable services
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可注入服务
- en: The Injectable decorator is a part of the Angular core library, used when creating
    injectable services. Without defining it as injectable, it's not possible to identify
    the dependency of a service. To define it as injectable, we will have to use `@Injectable()`
    at the top of the class definition.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Injectable装饰器是Angular核心库的一部分，用于创建可注入服务。如果不将其定义为可注入的，就无法识别服务的依赖项。要将其定义为可注入的，我们将在类定义的顶部使用`@Injectable()`。
- en: 'The code will look like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将看起来像这样：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have made the service injectable. Now, we should be fine to inject it into
    the Members component and point our browser to `http://localhost:3000/members`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使服务可注入。现在，我们应该可以将其注入到`Members`组件中，并将浏览器指向`http://localhost:3000/members`。
- en: 'Hurray! No more errors, and we are getting the expected data list:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 哈喽！没有更多错误，我们正在获取预期的数据列表：
- en: '![Injectable services](img/image_08_003.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![可注入服务](img/image_08_003.jpg)'
- en: Seems like our service is injectable and working fine. It's time to implement
    it in the `PersonComponent`, as we need the data service on that component as
    well. The same as the Members component, let's import and inject it into the `PersonComponent`
    with the service name `membersService`. Again, we will have to access the data
    service method with `this.membersService.getData()`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的服务是可注入的并且运行良好。现在是时候将其实现到`PersonComponent`中，因为我们也需要在那个组件上使用数据服务。和`Members`组件一样，让我们使用服务名`membersService`将其导入并注入到`PersonComponent`中。再次，我们将不得不使用`this.membersService.getData()`来访问数据服务的方法。
- en: 'Our `PersonComponent` will look like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`PersonComponent`将看起来像这样：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Time to run and look at the output of how the service is working with the Members
    component.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行并查看服务与`Members`组件一起工作的输出了。
- en: 'We have our e2e test, which will confirm that everything is going well with
    the new changes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的端到端测试，它将确认新的更改是否一切顺利：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Yes, everything passes successfully:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，一切通过成功：
- en: '![Injectable services](img/chapter_08_02.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![可注入服务](img/chapter_08_02.jpg)'
- en: Yay! Our code refactoring hasn't affected our expected behavior.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 哈喽！我们的代码重构没有影响我们的预期行为。
- en: Services will serve you more
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务将为您带来更多
- en: To reap the complete benefits of services, we will move two more methods from
    the Members and Person components. Before that, those methods were component specific;
    now, by adding them to a service, those methods can be used from any component
    just by injecting the service.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得服务的全部好处，我们将从`Members`和`Person`组件中移动两个更多的方法。在此之前，这些方法是组件特定的；现在，通过将它们添加到服务中，这些方法可以通过注入服务从任何组件中使用。
- en: Perhaps we will benefit later from this change but want to keep these methods
    decoupled from the components.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们将来会从这次更改中受益，但想保持这些方法与组件解耦。
- en: 'The newly added code will look like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 新增的代码将看起来像这样：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Testing the service
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试服务
- en: The goal behind the code decoupling and separation was to make the code testable.
    We did so, and we have separated the data retrieval part from the Members component
    and made a service so that it will be easy to test. The service is injectable;
    other than that, it's similar to an angular component. So, to perform unit testing,
    we will test the methods that the service contains.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 代码解耦和分离背后的目标是使代码可测试。我们做到了，我们将数据检索部分从`Members`组件中分离出来，并创建了一个服务，这样它将很容易进行测试。服务是可注入的；除此之外，它和Angular组件类似。因此，为了执行单元测试，我们将测试服务包含的方法。
- en: Testing service injection
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试服务注入
- en: Like other Angular components, we can test whether the service is defined well.
    But the main difference is that, as long as the service is injectable, we will
    need to inject it in the test specs to get the instance to test.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他Angular组件一样，我们可以测试服务是否定义良好。但主要区别在于，只要服务是可注入的，我们就需要在测试规范中注入它以获取要测试的实例。
- en: For a sample test spec, we can set it up so that it will import the `TestBed`
    and `inject`, and then configure the `TestingModule` using MembersService as the
    provider. Then, in the test spec, we will inject the service and check whether the
    service is defined as expected.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个示例测试规范，我们可以这样设置：它会导入 `TestBed` 和 `inject`，然后使用 MembersService 作为提供者配置 `TestingModule`。然后，在测试规范中，我们将注入服务并检查服务是否按预期定义。
- en: 'Our sample test suite will look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例测试套件将如下所示：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For this test, the expected result will be true.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试，预期的结果将是 true。
- en: Testing HTTP requests
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试 HTTP 请求
- en: To have a unit test for HTTP requests, we will have to use the async technique
    to keep the HTTP call asynchronous, and in Angular testing, we will use the `fakeAsync`
    module, which is an async module to use with mock HTTP requests.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行 HTTP 请求的单元测试，我们必须使用异步技术来保持 HTTP 调用异步，在 Angular 测试中，我们将使用 `fakeAsync` 模块，这是一个用于模拟
    HTTP 请求的异步模块。
- en: Wait, "mock"?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，“模拟”？
- en: Well yes; to test HTTP requests in an Angular test suite, we don't need to make
    actual HTTP requests. To achieve the effect of an HTTP request, we can mock out
    our HTTP services; Angular has provided a mock service called **MockBackend**.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，是的；为了在 Angular 测试套件中测试 HTTP 请求，我们不需要进行实际的 HTTP 请求。为了达到 HTTP 请求的效果，我们可以模拟我们的
    HTTP 服务；Angular 已经提供了一个名为 **MockBackend** 的模拟服务。
- en: '`MockBackend` is a class that can be configured to provide mock responses for
    HTTP mock requests, and it will work exactly the same as HTTP services but without
    making the actual network requests.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`MockBackend` 是一个可以被配置为提供 HTTP 模拟请求的模拟响应的类，并且它将像 HTTP 服务一样工作，但不会进行实际的网络请求。'
- en: After we have configured the `MockBackend`, it can be injected into HTTP. So,
    from our service where we used `http.get`, we'll have the expected data returned.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们配置了 `MockBackend` 之后，它可以被注入到 HTTP 中。因此，从我们使用 `http.get` 的服务中，我们将得到预期的数据返回。
- en: 'Our test suite with the HTTP request will look like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的带有 HTTP 请求的测试套件将如下所示：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, at first, besides importing the `MockBackend`, we are importing the `MockConnection`,
    which is used to subscribe to the backend connection and provide the connected
    data to the next steps. Then, we configure the `MockBackend`, which will return
    the HTTP object.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，首先，除了导入 `MockBackend`，我们还导入了 `MockConnection`，它用于订阅后端连接并提供连接数据给下一步。然后，我们配置
    `MockBackend`，它将返回 HTTP 对象。
- en: 'Next, we will get ready with our test specs by injecting `MockBackend` and
    `MembersService`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过注入 `MockBackend` 和 `MembersService` 准备我们的测试规范：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the test spec, we have injected `MockBackend`, in addition to the MembersService.
    `MockBackend` will subscribe to the `backend` service with the MockConnection object.
    MockConnection will create a new `ResponseOptions` object, where, with a `ResponseOptions`
    object we can configure our response properties.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试规范中，我们注入了 `MockBackend`，除了 MembersService。`MockBackend` 将使用 MockConnection
    对象订阅 `backend` 服务。MockConnection 将创建一个新的 `ResponseOptions` 对象，其中，我们可以使用 `ResponseOptions`
    对象来配置我们的响应属性。
- en: Here, we just set the `body` property of the response object and set the `body`
    value to a predefined `mockData` object.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只设置了响应对象的 `body` 属性，并将 `body` 值设置为预定义的 `mockData` 对象。
- en: Service stubs
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务模拟
- en: We can test the service with stub data as well. For example, we can make a stubbed
    version of our `MembersService` called `MembersServiceSpy`, which will fake all
    the necessary features of that service.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用模拟数据测试服务。例如，我们可以创建一个名为 `MembersServiceSpy` 的模拟 `MembersService` 版本，它将模拟该服务所需的所有必要功能。
- en: This fake service will return a resolved `Promise` with mock data, so we can
    just use this stubbed method for testing. It will create a spy for all of the
    methods we have in the service and return a separate `Promise` for every single
    method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模拟服务将返回一个带有模拟数据的已解析 `Promise`，因此我们可以直接使用这个模拟方法进行测试。它将为服务中的所有方法创建一个间谍，并为每个单独的方法返回一个单独的
    `Promise`。
- en: 'The stubbed service will be located at `spec/unit/stub/members.service.stub.ts`,
    and it will be as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟服务将位于 `spec/unit/stub/members.service.stub.ts`，如下所示：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Service test with stubbed data
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模拟数据的 Service 测试
- en: Here, we will test the `MembersService` with stubbed data. To do so, we will
    need to import the stubbed service. And with the `TestBed` configuration, we will
    have to provide `MemberServiceSpy` as a service instead of an actual member service.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用模拟数据测试 `MembersService`。为此，我们需要导入模拟服务。并且使用 `TestBed` 配置，我们必须提供 `MemberServiceSpy`
    作为服务而不是实际的成员服务。
- en: 'The `MembersService` test suite''s code will look as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`MembersService` 测试套件的代码将如下所示：'
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Combining and running the service's tests
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合和运行服务的测试
- en: We have two test suites for the Members service here. We can bring both together
    and run the test.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有两个成员服务的测试套件。我们可以将它们合并在一起并运行测试。
- en: 'The full test suite''s code will look like the following code snippet:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 完整测试套件的代码将如下代码片段所示：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The test suite for the Members service is ready to run. Let''s run it with
    this command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 成员服务的测试套件已准备好运行。让我们用这个命令运行它：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'All the test specs pass as expected. The result will be as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试规范都按预期通过。结果将如下所示：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Communicating through the power of events
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过事件的力量进行通信
- en: Angular has more powerful event-handling capabilities compared to Angular 1.x.
    Angular 1.x has two-way data binding, whereas Angular doesn't recommend that.
    Angular handles the communication between data and templates through the power
    of events.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与Angular 1.x相比，Angular具有更强大的事件处理能力。Angular 1.x具有双向数据绑定，而Angular不推荐这样做。Angular通过事件的力量处理数据和模板之间的通信。
- en: Angular projects stand on the combination of some components. To function, these
    components need to communicate with each other to share data and events. Mostly,
    components need to communicate when they have a parent-child relationship. There
    are a few ways in which Angular can communicate between parent and child components.
    The best is by handling custom events. We will look at details about custom events
    and see how they work with our search application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Angular项目建立在一些组件的组合之上。为了运行，这些组件需要相互通信以共享数据和事件。通常，当组件具有父子关系时，它们需要通信。Angular在父组件和子组件之间通信的方式有几种。其中最好的方式是通过处理自定义事件。我们将查看自定义事件的详细信息，并了解它们如何与我们的搜索应用程序一起工作。
- en: Angular events
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular事件
- en: As we know, Angular recommends one-way data binding, which means only from components
    to DOM elements. This is unidirectional data flow, and it is how Angular works.
    What about when we need data flow in the other direction--from DOM elements to
    components? Doing so depends on different events, such as clicks, keystrokes,
    mouseover, and touch. These events will bind with DOM elements to listen to user
    action and pass that action to the component.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，Angular推荐单向数据绑定，这意味着只有从组件到DOM元素。这是一种单向数据流，这也是Angular的工作方式。那么当我们需要从DOM元素到组件的数据流时怎么办？这样做取决于不同的事件，如点击、按键、鼠标悬停和触摸。这些事件将与DOM元素绑定，以监听用户操作并将该操作传递给组件。
- en: 'The event binding syntax consists of the target event with parentheses to the
    left-hand side of the equals sign. The component contains the target event as
    a method, so whenever the event triggers, it will call the method from the component.
    Let''s look at the event that we have in the search form:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 事件绑定语法由目标事件组成，目标事件位于等号左侧的括号内。组件将目标事件作为方法包含，因此每当事件触发时，它将调用组件中的方法。让我们看看搜索表单中的事件：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Any element's events are the common targets, but it's a bit different with Angular,
    as Angular at first checks whether the target name matches with the event property
    of any known directives or components.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 任何元素的任何事件都是常见的目标，但在Angular中略有不同，因为Angular首先检查目标名称是否与任何已知指令或组件的事件属性匹配。
- en: Custom events in Angular
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular中的自定义事件
- en: Custom events are raised by directives or components with Angular `EventEmitter`.
    Directives create an `EventEmitter` object and expose themselves as its property
    to be passed via the `@Output` decorator. We will look at details of `@Output`
    decorator next. After exposing an `EventEmitter` object as a property, the directives
    will call `EventEmitter.emit(value)` to fire the event and pass the value to the
    parent directives.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义事件由Angular `EventEmitter`的指令或组件引发。指令创建一个`EventEmitter`对象，并通过`@Output`装饰器将其自身作为属性公开。我们将接下来查看`@Output`装饰器的详细信息。在将`EventEmitter`对象公开为属性之后，指令将调用`EventEmitter.emit(value)`来触发事件并将值传递给父级指令。
- en: 'The custom directive/component class will define the custom event as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义指令/组件类将如下定义自定义事件：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Parent directives will listen for the event by binding to this property and
    will receive the value through the `$event` object.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 父级指令将通过绑定到这个属性来监听事件，并通过`$event`对象接收值。
- en: 'The parent directive/component will contain the custom directive as follows,
    where it will contain the custom event as `someCustomEvent`, which will trigger
    the `doSomething()` method of the parent directives:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 父级指令/组件将包含自定义指令，如下所示，其中它将包含自定义事件`someCustomEvent`，这将触发父级指令的`doSomething()`方法：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The parent directive/component will contain the `doSomething()` method, as
    shown here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 父指令/组件将包含`doSomething()`方法，如下所示：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The Output and EventEmitter APIs
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出和`EventEmitter` API
- en: Output is a decorator class from the Angular core that is used to pass custom
    events from a child to a parent component. To use it, we need to import it from
    `@angular/core`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是Angular核心中的一个装饰器类，用于从子组件传递自定义事件到父组件。要使用它，我们需要从`@angular/core`导入它。
- en: 'When we set a custom event as `@Output`, that event will be available to listen
    to in the parent component. This decorator will be placed inside the class, as
    follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将自定义事件设置为`@Output`时，该事件将在父组件中可用以进行监听。此装饰器将放置在类内部，如下所示：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`EventEmitter` is also a core class of Angular. When we need to use it, we
    will have to import it from `@angular/core`. The `EventEmitter` API is used to
    notify the parent component by calling `EventEmitter.emit(value)` whenever the
    value changes in the child component. As we know, the parent component always
    listens to the custom event.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter`也是Angular的一个核心类。当我们需要使用它时，我们必须从`@angular/core`导入它。`EventEmitter`
    API用于在子组件中的值发生变化时通过调用`EventEmitter.emit(value)`来通知父组件。正如我们所知，父组件始终监听自定义事件。'
- en: Planning further improvements
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步规划改进
- en: The search application we have so far is a simple search application. But we
    can make it better by keeping it as simple as it is. What I mean is, we can do
    this in the best way, like we were trying to decouple the data logic by separating
    the reusable code in the new service.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前拥有的搜索应用程序是一个简单的搜索应用程序。但我们可以通过保持其简单性来使其变得更好。我的意思是，我们可以以最佳方式做到这一点，就像我们试图通过将可重用代码分离到新服务中来解耦数据逻辑一样。
- en: We still have a few more things to improve. It seems our application has not
    yet decoupled perfectly. Our components have not decoupled as we'd expected. We
    are talking about the `MembersComponent`, which contains the search feature and
    member listing feature.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些其他的事情要改进。看起来我们的应用程序还没有完全解耦。我们的组件没有像预期的那样解耦。我们正在谈论包含搜索功能和成员列表功能的`MembersComponent`。
- en: We will follow the single responsibility principle here, which means every component
    should have a single responsibility. Here, `MembersComponent` has two. So we should
    break down this component to two separate components.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循单一职责原则，这意味着每个组件都应该有一个单一职责。在这里，`MembersComponent`有两个。因此，我们应该将这个组件分解为两个单独的组件。
- en: Let's break it down to two separate components, called `MembersComponent` and
    `SearchComponent`. In fact, we just made a plan for a new component called `SearchComponent`
    and brought the search feature over there from the Members component.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将它分解为两个单独的组件，分别称为`MembersComponent`和`SearchComponent`。实际上，我们只是为新组件`SearchComponent`制定了一个计划，并将搜索功能从成员组件中迁移到那里。
- en: 'Now let''s make a plan for the behavior expected from both components:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为两个组件预期的行为制定一个计划：
- en: The search component will have the responsibility of taking the user input as
    a search query and getting the expected search result using the service we have
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索组件将负责接收用户输入作为搜索查询，并使用我们拥有的服务获取预期的搜索结果。
- en: We then pass the search result to the Members component
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将搜索结果传递给成员组件
- en: The Members component will get the search result from the search component and
    will bind the data list to the DOM
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员组件将从搜索组件获取搜索结果，并将数据列表绑定到DOM
- en: Both components will communicate and exchange data using events
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两个组件将通过事件进行通信和交换数据
- en: The plan is to make this simple app perfect by following best practices and
    using the built-in powers of Angular.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是通过遵循最佳实践和使用Angular的内置功能来使这个简单的应用程序完美。
- en: The search component
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索组件
- en: As planned, we will have to separate the search feature from the Members component.
    To do that, let's create a new component called `SearchComponent` at `app/search/search.component.ts`
    and create the search component's template file. The template file will simply
    contain the search form.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如计划所示，我们必须将搜索功能从成员组件中分离出来。为此，让我们在`app/search/search.component.ts`中创建一个新的组件`SearchComponent`，并创建搜索组件的模板文件。模板文件将简单地包含搜索表单。
- en: The search component file will have to import and inject the `MembersService`,
    as that will be used to perform the search based on the search query. The component
    will have the search query and will request the service for search and get the
    search result.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索组件文件将需要导入和注入`MembersService`，因为这将用于根据搜索查询执行搜索。组件将包含搜索查询，并将请求服务进行搜索并获取搜索结果。
- en: 'The search component''s code will look like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索组件的代码将看起来像这样：
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The template of the search component will look like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索组件的模板将看起来像这样：
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As long as our application output doesn't break, we will have to bind the search
    component to the members list page, as it was before. So, we will have to append
    the search component to the template of the Members component. In that case, it
    will become the child component of the Members component.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们的应用程序输出没有中断，我们就必须将搜索组件绑定到成员列表页面，就像之前一样。所以，我们必须将搜索组件添加到成员组件的模板中。在这种情况下，它将成为成员组件的子组件。
- en: 'The template of the Members component will look like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 成员组件的模板将看起来像这样：
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Enabling sharing between components
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用组件间的共享
- en: Now we have two separate components, the search and Members components. The
    search component has been appended to the Members component, but search results
    are not available in the Members component.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个独立的组件，搜索和成员组件。搜索组件已经被添加到成员组件中，但搜索结果在成员组件中不可用。
- en: Search and Members are separate components, and there is no bridge between them.
    Both have an isolated scope to contain their elements and variables.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索和成员是独立的组件，它们之间没有桥梁。两者都有一个独立的范围来包含它们的元素和变量。
- en: To share data between components, we need to enable communication between them.
    As explained before, Angular events will come to our rescue for us to enable communication
    between the search and Members component. From the search component, we will need
    to use Angular custom events to communicate with its parent component, `MembersComponent`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要在组件间共享数据，我们需要启用它们之间的通信。如前所述，Angular事件将帮助我们启用搜索和成员组件之间的通信。从搜索组件出发，我们需要使用Angular自定义事件与其父组件`MembersComponent`通信。
- en: Communicating with the parent component
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与父组件通信
- en: The search component is the child component of the Members component. They need
    to communicate with each other to share data. We will need to use custom events
    with the help of the Angular `EventEmiiter` API so that we can emit the search
    result from the search component after getting the result. And besides that, we
    will need to use the `@OutPut` decorator to set the search result as the output
    to use for the parent component.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索组件是成员组件的子组件。它们需要相互通信以共享数据。我们将需要使用Angular的`EventEmitter` API来帮助使用自定义事件，这样我们就可以在得到结果后从搜索组件中发出搜索结果。除此之外，我们还需要使用`@OutPut`装饰器将搜索结果设置为输出，以便用于父组件。
- en: To use both, we will need to import both from Angular core. Then, we will need
    to set `@Output` searchResult to a new instance of EventEmitter. This `@Output`
    decorator makes the `searchResult` property available as an event binding.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这两个组件，我们需要从Angular core中导入它们。然后，我们需要将`@Output`的`searchResult`设置为一个新的`EventEmitter`实例。这个`@Output`装饰器使得`searchResult`属性可以作为事件绑定使用。
- en: When the search component updates the search result, we would like to tell the
    parent component that the `searchResult` event has happened. To do so, we will
    need to call `emit(data)` with the `searchResult` we have declared as the Emitter
    object with the Output decorator. The `emit()` method is used to notify every
    time the result has been passed via a custom event.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当搜索组件更新搜索结果时，我们希望通知父组件`searchResult`事件已经发生。为此，我们需要调用`emit(data)`，其中`searchResult`是我们已声明的带有`@Output`装饰器的Emitter对象。`emit()`方法用于在每次通过自定义事件传递结果时通知。
- en: Now, the Members component can fetch the `$event` object, as we've passed it
    into the template using `(searchRessult)="anyMethod($event);`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，成员组件可以获取`$event`对象，因为我们已经通过`(searchRessult)="anyMethod($event);"`将其传递到模板中。
- en: 'After updating with `EventEmitter`, the search component will look like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新了`EventEmitter`之后，搜索组件将看起来像这样：
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now it's time to communicate with the `MembersComponent`. Let's declare the
    `onSearch()` method in the member component, which will accept the event as an
    argument.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候与`MembersComponent`通信了。让我们在成员组件中声明`onSearch()`方法，它将接受事件作为参数。
- en: 'The Members component will change to the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 成员组件将变为以下形式：
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As we are appending the search component from the members template, let's hook
    the `onSearch` function to the search component tag. We will call this `(searchResult)`--with
    parentheses around it--to tell Angular that this is an event binding.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是从成员模板中添加搜索组件，所以让我们将`onSearch`函数连接到搜索组件标签。我们将用括号包围它，命名为`(searchResult)`来告诉Angular这是一个事件绑定。
- en: 'The template of the search component will look like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索组件的模板将如下所示：
- en: '[PRE42]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Check output after refactoring
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查重构后的输出
- en: The search application will be rebranded into a store application instead of
    rewriting the search functionality that has already been written. In order to
    leverage the existing search project, it will be copied into a new project file.
    Then, the new project will use the tests to drive the development changes and
    refactoring. The refactoring steps have been left out, but a review of the code
    will show how the code and tests were modified to create the product application.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索应用程序将被重新命名为商店应用程序，而不是重写已经编写好的搜索功能。为了利用现有的搜索项目，它将被复制到一个新的项目文件中。然后，新项目将使用测试来驱动开发更改和重构。重构步骤已被省略，但代码审查将显示代码和测试是如何被修改以创建产品应用程序的。
- en: Time to run it and see how the service works with the Members component. Let's
    point our browser to `http://localhost:3000/members`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行它并查看服务如何与 Members 组件一起工作了。让我们将浏览器指向 `http://localhost:3000/members`。
- en: '![Check output after refactoring](img/chapter_08_03.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![重构后的输出检查](img/chapter_08_03.jpg)'
- en: 'We have the e2e test, which will confirm that everything''s going well with
    the new changes:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有端到端测试，它将确认新更改一切正常：
- en: '[PRE43]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Yes, we can see that everything passes successfully:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以看到一切都成功通过：
- en: '![Check output after refactoring](img/chapter_08_02.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![重构后的输出检查](img/chapter_08_02.jpg)'
- en: Yes! Our code refactoring hasn't affected our expected behavior.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！我们的代码重构没有影响我们预期的行为。
- en: '**Current project directory**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**当前项目目录**'
- en: We have updated and refactored the code, for which we have some new components,
    services, and so on. Now, we will have a new project structure, separating the
    logic and decoupling the components.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更新和重构了代码，为此我们有一些新的组件、服务等等。现在，我们将有一个新的项目结构，将逻辑分离并解耦组件。
- en: 'Our current directory structure looks like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的目录结构如下所示：
- en: '![Check output after refactoring](img/image_08_004.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![重构后的输出检查](img/image_08_004.jpg)'
- en: Moving ahead
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来
- en: In this book, I have tried to cover the topics to a certain level so that anyone
    can start with test-driven development based on Angular. But there are a lot of
    things we have skipped, most importantly, rxJS.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我试图将主题覆盖到一定水平，以便任何人都可以从基于 Angular 的测试驱动开发开始。但是，我们有很多东西都跳过了，最重要的是 rxJS。
- en: rxJS is a separate module based on reactive programming. So, we will need to
    be familiar with reactive programming to understand it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: rxJS 是基于响应式编程的一个独立模块。因此，我们需要熟悉响应式编程才能理解它。
- en: Observables
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察对象
- en: HTTP requests by default return observables as responses in Angular instead
    of resolved promises. Since we didn't look at rxJS here, we skipped observables
    and converted the responses to promises. But we should learn how observables work
    with Angular.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Angular 中的 HTTP 请求返回可观察对象作为响应，而不是解析的承诺。由于我们没有在这里查看 rxJS，我们跳过了可观察对象并将响应转换为承诺。但我们应该学习可观察对象如何在
    Angular 中工作。
- en: Publishing and subscribing
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布和订阅
- en: Publishing and subscribing messages is a powerful tool, but as with anything,
    when used the wrong way, it can lead to a mess.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 发布和订阅消息是一个强大的工具，但就像任何事物一样，如果使用不当，可能会导致混乱。
- en: 'There are two ways in which messages can be published: emit or broadcast. It
    is important to know the difference, as both work slightly differently and they
    may affect the performance of our application.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 消息可以通过两种方式发布：emit 或 broadcast。了解它们之间的区别很重要，因为它们的工作方式略有不同，可能会影响我们应用程序的性能。
- en: Self-test questions
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我测试问题
- en: Q1\. A callback function refers to a function that is called after an asynchronous
    function completes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 回调函数是指在异步函数完成后被调用的函数。
- en: 'True'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Q2\. Asynchronous functions always complete in the order in which they were
    called.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 异步函数总是按照它们被调用的顺序完成。
- en: 'True'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Q3\. There is a module called `MockBackend` to fake HTTP calls in Angular for unit
    testing.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 有一个名为 `MockBackend` 的模块可以在 Angular 中模拟 HTTP 调用以进行单元测试。
- en: 'True'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Q4\. In Angular, the `EventEmitter` API is used for component communication.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Q4. 在 Angular 中，`EventEmitter` API 用于组件通信。
- en: 'True'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored services in Angular and the power of events. We
    also saw some examples of the separation of code with services and events.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Angular 中的服务和事件的力量。我们还看到了一些使用服务和事件分离代码的例子。
- en: In addition, we looked at different types of testing for Angular components
    and wrote unit tests for the Angular router, and we integrated it with application
    components and navigation. We also explored further configuration of Karma in
    order to use its features.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们研究了 Angular 组件的不同测试类型，并为 Angular 路由编写了单元测试，并将其与应用程序组件和导航集成。我们还进一步探索了 Karma
    的配置，以便使用其功能。
- en: Now that we're at the end of the book, it's time to apply our knowledge in the real
    world. Before leaving, let's have a quick recap of what we have learned. We learned
    about TDD, how TDD works with JavaScript context, and the available testing tools,
    techniques, and frameworks. We learned about Karma and Protractor with real Angular
    projects. And now we know how to write unit and e2e tests for Angular projects.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到达了本书的结尾，是时候将我们在现实世界中的知识付诸实践了。在离开之前，让我们快速回顾一下我们已经学到的内容。我们学习了测试驱动开发（TDD），TDD
    如何与 JavaScript 上下文协同工作，以及可用的测试工具、技术和框架。我们还通过实际的 Angular 项目学习了 Karma 和 Protractor。现在我们知道了如何为
    Angular 项目编写单元测试和端到端测试。
- en: This book showed you the path to practicing TDD; now it's your job to keep learning,
    improve on this knowledge, and practice more with complex projects to be more
    confident with TDD.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 本书向您展示了实践 TDD 的路径；现在，你的任务是继续学习，提高这方面的知识，并通过更复杂的项目进行更多实践，以便对 TDD 更加自信。
