- en: Chapter 7. Components for User Experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User experience is a core concern for developers building today's applications.
    We are no longer living in a world where users are contented with an application
    that just works. The expectations are much higher. Now, an application needs to
    be highly usable and should provide an efficient workflow; users also expect it
    to bring them pleasure while performing tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to look at building some components that will increase
    the overall usability of our task management system. These features will enrich
    the current functionality and provide more efficient workflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will develop the following three technical features and embed them into
    our current application, wherever applicable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tag management**: We''ll enable the use of tags within generated content,
    such as comments, activities, and other areas where they can be of any use. Tags
    will help users build links between content and navigation shortcuts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drag and drop**: We''ll build generic components that will make use of drag
    and drop features a breeze. By enabling drag and drop features, we''ll allow users
    to fulfill certain tasks with much higher efficiency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infinite scrolling**: We''ll build a component that will reveal the content
    of lists while scrolling. This feature is not going to directly increase the workflow
    performance, but it will help us increase the overall application performance.
    It will also narrow down the user''s context by only showing relevant information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a tag management system to enter and display tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a stateful pipe to render tags using a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `sanitize-html` module to sanitize potentially unsafe content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a component to autocomplete tags during user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going through the basics of the HTML5 drag and drop API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating directives for draggable elements and drop targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `dataTransfer` objects and a custom attribute to enable selective drop
    targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom `ForOf` repeater using the asterisk template syntax to enable
    infinite scrolling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing custom change detection using the `DoCheck` lifecycle hook, and
    using `IterableDiffer` to apply DOM changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing dynamic view instantiation using `ViewContainer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The classical form of tagging enables you to associate a taxonomy with elements
    within a system and helps you organize your project. It allows you to have a many-to-many
    association that can be quickly managed, and you can use it later to filter relevant
    information.
  prefs: []
  type: TYPE_NORMAL
- en: In our task management system, we're going to use a slightly different version
    of tags. Our goal is to provide a way to have semantic shortcuts within the application.
    With the help of tags, a user should be able to cross-reference information between
    different parts of the data, providing a summary of the referenced entity as well
    as a navigation shortcut for the entity.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can include a `project` tag within a user comment. A user can
    enter the tag by simply typing in the project ID. When a comment is displayed,
    we see the title of the project and the number of open tasks within the project.
    But when we click on the tag, we directly reach the project detail page where
    the task is located.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll develop the required elements to provide a way to use
    `project` tags that will enable the user to cross-reference other projects within
    comments. We'll also use tag management in our activities, which we created in
    the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tag data entity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the tag entity that shows how we can represent tags within
    our system. We''ll create a new `Tag` class in a file under `tags/tag.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This class represents tags; whenever we store tag information, we''ll use this
    entity as a data vehicle. Let''s look at the individual fields and elaborate on
    their use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`textTag`: This is the text representation of a tag. All our tags need to be
    identified uniquely using this text representation. We can define the text representation
    of tags as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text tags always start with a hash symbol (`#`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Text tags only contain word characters or the minus symbol (`-`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All the innards of a tag, defined by other properties (`title`, `link`, and
    `type`), can be extrapolated from the `textTag` property. It can therefore be
    considered an ID.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: This is a comparatively longer text representation of a tag. It should
    contain as much detail about the subject as possible. In the case of project tags,
    this could mean the project title, open tags count, assignee, and other important
    information. Since this is the field that will be rendered if a tag is parsed,
    it''ll be beneficial if the content stays relatively condensed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`link`: A valid URL, which will be used when the tag is rendered. This URL
    will make links clickable and enable the shortcut navigation. In the case of the
    projects tags we''re going to create, this will be a URL fragment identifier that
    will link to the given project page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: This is used to distinguish between different tags and provide us a
    way to organize tags at a higher granularity level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, so good. We now have a data vehicle we can easily construct to transfer
    information about tags.
  prefs: []
  type: TYPE_NORMAL
- en: Generating tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our next step is to create a factory that will generate tags for us. All we''d
    like to pass to the factory is a subject, which can be basically anything. The
    factory will then determine the type of the subject and execute the necessary
    logic to generate a tag from it. This might sound a bit abstract at first, but
    let''s look at the code of the `generateTag` function we''ll create in a module
    under `tags/generate-tag.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's examine the `generateTag` function and what we're trying to achieve here.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we determined the subject type by checking the type attribute of the
    `subject` object. In the case of project data objects, we know that the type will
    be set to `"project"`. The following three points succinctly explain what we''ve
    done:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we were sure that we were dealing with a project here, we generated a
    new tag. In the future, we'll deal with other subject types as well, so this check
    will be required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We wanted to use an indicator for all the open tasks in the tag title. For this
    reason, we did a quick filtering of open tasks within the project and stored the
    length of the filtered array in the `openTaskCount` constant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can instantiate a new `Tag` object using the project ID as `textTag`.
    For the `title` field, we used a helper function, `limitWithElipsis`, which truncates
    project titles that are longer than 20 characters. We also appended the open tasks
    count to the tag title. For the `link` field of the `Tag` instance, we specify
    a URL that will navigate to the project details view. Finally, we used the `TAG_TYPE_PROJECT`
    constant to define the tag `type` field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a tags service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Okay, we''re done with setting up all the supporting structures we need; we
    can now move forward to create a tags service. A tags service will have the following
    responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generating and caching tags**: We won''t create tags in our system ad hoc
    if we only want to render them. The mechanics of a tags service is more like generated
    cache. Initially, a tags service gathers all the required information to generate
    all the possible tags within the system. It also reacts to changes and updates
    the list of tags if required. With this, we''ll not only save on some processing
    needs, but we''ll also have a readily available list to search for existing tags.
    This will be particularly useful if we like to present the available tags to the
    user so they can choose from them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rendering tags**: A tags service is also responsible for turning tags into
    HTML. It uses the `title` and `link` fields of the `Tag` instances to generate
    their HTML representation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parsing text content**: The parsing functionality of the tags service is
    responsible for finding text representations of tags within a string. It then
    uses the rendering function to render these tags into HTML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's create a module for our tags service in a new file under `tags/tags-service.js`.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create two utility functions that will help us process tags
    and strings containing the textual representations of tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `replaceAll` function is a simple substitute for a missing JavaScript function
    to replace multiple text occurrences within a string without using regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `findTags` function will extract any possible tag from a text string. It
    does this by applying a regular expression that will find matches for tags in
    the format discussed at the beginning of the topic. This format assumes that our
    tags always start with a hash symbol, followed by any word character or dash symbols.
    This function returns a list of all the possible text tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For our tags service, we will now define a new class that will be annotated
    with `@Injectable` so we can use it as a provider in our components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the constructor of our `TagsService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In order to generate and cache project tags, we obviously need `ProjectService`,
    which provides us with a list of all the projects. Instead of grabbing the list
    data from `ProjectService` once, we're observing the list for changes. This brings
    us the advantage that we'll not only get the initial list of projects, but we'll
    also be made aware of any changes made in the project list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We subscribed to `ProjectService` using the `change` field. This exposes `ReplaySubject`,
    which emits the project list. After storing the current project list as a member
    field, we need to call the `initializeTags` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we only support project tags currently, the only thing we need to consider
    while generating tags is the projects we have stored in our service. We can simply
    map the project list we have stored in the `projects` member field using our `generateTag`
    function. The `Array.prototype.map` function will return a new array that is already
    a list of generated tasks for the projects.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, we now have a service that uses a reactive approach to generate tags from
    the available projects. This is already addressing the first concern of our service.
    Let's look at its other responsibilities, which are parsing text content for tags
    and rendering HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering tags is not a big deal since we have already abstracted the data model
    of tags in a clean way. We need to write a method for rendering tags that will
    act as a pass-through function if the argument is not a valid `Tag` instance.
    This way, we can pass unrecognized text representations of tags as strings, and
    it will just return us the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since tags have URLs that point to a location, we''re going to use anchor HTML
    elements to represent our tags. These elements also have classes that will help
    us style tags differently than regular content. Let''s create another method within
    the tags service that can be used to render tag objects into HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method can be used to find a tag by its textual representation.
    This function will try to find the tag within our generated cache, and if unsuccessful,
    will return the `textTag` argument. This is also a pass-through mechanism that
    simplifies the handling when we parse a whole piece of text for tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, let''s implement the main method of the service. The parse
    function scans the whole text for tags and replaces them with their HTML representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to use the `findTags` utility function; this will return a list
    of all the text tags that it would find in the string content passed to the `parse`
    function. Using this text tag list, we can then iterate through the list and successively
    replace all the text tags in the content with the generated HTML using the `renderTag`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the task service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the concerns of our task service have now been taken care of, and it is
    already storing tags for the available projects. We can now go ahead and integrate
    our service into the application.
  prefs: []
  type: TYPE_NORMAL
- en: Since our tags service turns text with simple hash tags into HTML with links,
    a pipe would be a perfect helper to integrate the functionality within our components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `tags.js` file in our `pipes` folder and create a new pipe
    class, namely, `Tags`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have already created a few pipes so far. However, this pipe is a bit different
    in that it isn't a pure pipe. Pipes are considered pure if their transform function
    always returns the same output for a given input. This implies that the transform
    function should not be dependent on any other external source that can influence
    the outcome of the transform, and the only dependencies are the input values.
    This is not true for our `Tags` pipe though. It depends on `TagsService` to transform
    the input, and new tags can be stored in the tags service at any time. Successive
    transformations can successfully render tags that were not existent just a moment
    ago.
  prefs: []
  type: TYPE_NORMAL
- en: By telling Angular that our pipe is not pure, we can disable the optimization
    it performs on pure pipes. This also means that Angular will need to revalidate
    the output of the pipe on every change detection. This can lead to performance
    issues; therefore, the pure flag should be used with caution.
  prefs: []
  type: TYPE_NORMAL
- en: All right, as far as rendering tags is concerned, we are all set. Let's integrate
    our tags functionality into our `Editor` component so we can make use of them
    within the commenting system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by editing the `Editor` module located under `ui/editor/editor.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, we imported the `TagsPipe` class and referenced it to the `pipes` configuration
    of the `@Component` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: We've also added a new input to the `enableTags` component, which will allow
    us to control whether we should handle tags within the content of the editor or
    ignore them.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it, as far as changes to the component file is concerned. Let''s apply
    some changes to the template of the component by editing the `ui/editor/editor.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The only change we've made in the template is where we display the editor content.
    We've used two template elements by employing the `NgIf` asterisk template syntax.
    The latter one, if tags are disabled, renders the content as before. If tags are
    enabled, we'll be using a property binding to the `innerHTML` property of our
    editor's output HTML element. This allows us to render the HTML content. In the
    binding, we've used our `Tags` pipe that will parse the content for tags using
    `TagService`.
  prefs: []
  type: TYPE_NORMAL
- en: Completion of the tags service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's digress for a moment at this point. We've already created a tagging system,
    and we just integrated it into our `Editor` component by using the `Tags` pipe.
    If a user writes project tags in any comment now, they will be rendered by `TagsService`.
    This is fantastic! Users can now establish cross-links to other projects within
    comments, which will be automatically rendered as links showing the project title
    and open tasks. All a user needs to do is add the text representations of project
    tags to a comment. In the default data set of the book, this could be the `#project-1`
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two images show you an example of the commenting system. The
    first image is an example of an editor in edit mode, under the commenting system,
    where a text tag is entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Completion of the tags service](img/image00329.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An example where a text tag is entered
  prefs: []
  type: TYPE_NORMAL
- en: 'The second image is an example of a rendered tag enabled in the commenting
    system through our editor integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Completion of the tags service](img/image00330.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An example of rendered tag through editor integration
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re not done yet when it comes to entering tags. We cannot expect our users
    to know all the available tags within the system and then enter them manually
    within comments. Let''s look at how we can improve this in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we looked at the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: We built a tags service that generates, caches, and renders tags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We built a stateful pipe using the `pure` flag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used the `[innerHTML]` property binding to render HTML content into an element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Supporting tag input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we're going to build a component and its supporting structures to make
    the process of entering tags a smooth experience for our users. So far, they can
    write project tags, but it requires them to know the project IDs, which makes
    our tag management quite useless. What we'd like to do is provide the user with
    some choices when they are about to write a tag. Ideally, we show them the available
    tags, as soon as they start writing a tag by typing the hash (*#*) symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'What sounds simple in the first place is actually quite a tricky thing to implement.
    Our tag input needs to deal with the following challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling input events to monitor tag creation. Somehow, we need to know when
    a user starts writing a tag, and we need to know when the typed tag name is updated
    or canceled by using an invalid tag character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the position of the input caret of the user. Yeah, I know this sounds
    pretty simple, but it actually isn't. Calculating the viewport offset position
    of a user's input caret requires the use of the browser's Selection API, which
    is quite low-level and needs some abstraction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to tackle these challenges, we are going to introduce a utility class
    we can delegate the user input to. It will help us figure out the details we're
    interested in and deal with low-level APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a tag input manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a module in a new file under `tags/tag-input-manager.js`. The first
    bit of code is a function that will help us figure out the position of the user
    input caret when the user starts typing a tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let's not go into too much detail here. What this code basically does is that
    it tries to find the bounding box `DOMRect` object, which describes the `top`,
    `right`, `bottom`, and `left` offsets of the caret position relative to the viewport.
    The problem is that the Selection API does not allow us to get the position of
    the caret directly; it only allows us to get the position of the current selection.
    In case the caret is not placed correctly, we will need to insert a dummy element
    at the location of the caret and return the bounding box `DOMRect` object of the
    dummy element. Of course, we'd need to remove the dummy element again before we
    return the `DOMRect` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create a new class, `TagInputManager`, under `lib/tags/tag-input-manager.js`,
    which will deal with the user input handling for tag creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we need to call an internal `reset` method. This `reset`
    method will reset the two member fields that `TagInputManager` will expose. The
    `position` member will store the position of the latest caret, where the user
    had started writing a tag. The `textTag` member will store the current tag, which
    is recognized by `TagInputManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create a method to determine if a user is in the progress of entering
    a tag. If the `textTag` member contains a hash symbol at the beginning, we can
    assume that there is a tag entering in progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a method that will allow us to update both the current text tag,
    which is entered, as well as the updated caret position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Within the `onKeyDown` method, we expect to receive delegated `keydown` events.
    We are concerned about the backspace, which should also remove the last character
    of the tag that is currently entered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onKeyPress` method, we expect to receive delegated key press events.
    This is where the main logic of this supporting class lies. Here, we handle two
    different cases:'
  prefs: []
  type: TYPE_NORMAL
- en: If the pressed key is a hash symbol, we will start over with a new tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the pressed key is not a valid word character or a hash symbol, we will reset
    it to its initial state, which will cancel the tag entry. Otherwise, it'd mean
    that we are dealing with a valid tag character, and we'll add it to the current
    text tag string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so now we have all the support we need to handle tag input. However, we
    still need a way to show the available tags from `TagsService` to the user. For
    this purpose, we'll create a new `TagsSelect` component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a tags select component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To support the user in finding the right tag, we''ll provide them with a dropdown
    with the available tags. To do this, we need to use our `TagInputManager` class
    to recognize tags within user input as well as filter the available tags with
    user input. Let''s briefly look at the requirements of this component:'
  prefs: []
  type: TYPE_NORMAL
- en: Display the available tags gathered from `TagsService` in a tooltip/callout
    box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should support a limitation of displayed tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should support an input to filter the available tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component should accept an input parameter to position the callout box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should emit an event once the user clicks on a tag in the listed tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component should hide itself if the filter is invalid or if there are no
    elements matching the filter:![Creating a tags select component](img/image00331.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finished tags select component filtered with user input
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s start with the component class and see how we fulfill these requirements.
    First, create a new file called `tags-select.js` under `tags/tags-select`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We have no specialties to deal with in our `@Component` annotation. Let''s
    start with implementing the innards of our component. First, we''ll define the
    following input in the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using the `filter` input, we can pass a filter tag to the `TagsSelect` component.
    This means that we'll use the `filter` input to filter the available tags by `title`
    and `text` tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `limit` input can be set to any number. This input is used to limit the
    number of filtered tags that could be displayed within the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `position` input should be set to a valid `DOMRect` object that contains
    the top and left properties. They will be used to position our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tagSelected` output property is used to emit an event once the user has
    clicked on a tag within the list of tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following accessor property is bound to the host element''s display style
    property. It will control whether the component is displayed or hidden. We only
    display the component if the filter is valid and the filtered tags contain at
    least one tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two accessor properties use host bindings to set the `top` and
    `left` styles of our host element based on the `position` input of the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s inject `TagsService` into our component so we can access the list of
    available tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to use the `OnInit` life cycle hook to set up a subscription to the
    `TagService` change observable. This way, we''ll get access to the initial list
    of tags as well as any changes in the list. After we receive a new list of tags,
    we will need to reapply the filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the method that will be called from the template if a tag
    is clicked. We''ll just re-emit that tag using the `tagSelected` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filterTags` method is responsible for filtering and limiting our tag list
    based on the filter and limit input properties and the available tags from `TagsService`.
    As a result, it will store the filtered and limited list in the `filteredTags`
    member field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If the input properties filter or limit changes, we will need to reapply our
    filtering method. By implementing the `ngOnChanges` life cycle hook, we can easily
    manage this requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we should unsubscribe from the `TagsService` change observable if
    the `TagsSelect` component is destroyed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The template for our component is rather simple. Let''s look at the view template
    that is stored under `tags/tags-select/tags-select.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We used the `NgFor` directive to iterate over all the tags within the `filteredTags`
    member. If a tag is clicked, we will need to execute the `onTagClicked` method
    and pass the tag of the current iteration. In the listing, we'll only display
    the tag title that should help the user identify the tag they would like to use.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have built all the pieces that we need to enable smooth tag entering
    for our users. Let's patch our `Editor` component again to include our changes.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating tag input within the editor component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the first step, we should amend our `Editor` component to utilize the `TagInputManager`
    class. We need to delegate the user input inside the content-editable element
    to the tag input manager so it can detect any tag entering. Then, we'll use the
    information from `TagInputManager` to control a `TagsSelector` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the required changes to be made inside the `Component`
    class located under `ui/editor/editor.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In our `@Component` annotation, we added the `TagsSelect` component to the directives
    property so we could use the component within the template.
  prefs: []
  type: TYPE_NORMAL
- en: To help us do all the low-level processing for tag entry, we used `TagInputManager`
    and created a new instance of it within the component constructor.
  prefs: []
  type: TYPE_NORMAL
- en: We have now created two methods for handling `keypress` and `keydown` events
    coming from our content-editable element. These methods delegate the events to
    `TagInputManager`, which will handle all of the processing to extract a text tag
    and the position of the caret.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we added a method that will be called once a tag is clicked within
    the `TagsSelect` component. Here, we simply replaced the text tag that is currently
    entered with the text representation of the tag that was clicked. This provides
    a naive implementation of some sort of autocomplete. After we added the text representation
    of the clicked tag to the content-editable element, we reset `TagInputManager`
    to clear its state.
  prefs: []
  type: TYPE_NORMAL
- en: The only bit left now is to to edit the template of the `Editor` component in
    order to include the `TagsSelect` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ui/editor/editor.html` file, we need to make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `NgIf` directive helps us avoid the component from being created if tags
    are not enabled within the editor.
  prefs: []
  type: TYPE_NORMAL
- en: We set the `filter` and `position` input of the `TagsSelect` component from
    the data we have in our `TagInputManager` instance.
  prefs: []
  type: TYPE_NORMAL
- en: On the emitted `tagSelected` event of the `TagsSelect` component, we called
    the `onTagSelected` method on the `Editor` component we created a moment ago.
  prefs: []
  type: TYPE_NORMAL
- en: That's all we need to do with the template of the `Editor` component.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing up our tagging system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Congratulations! You've now successfully implemented the first of the three
    usability components.
  prefs: []
  type: TYPE_NORMAL
- en: With the help of a `TagInputManager` class, we offloaded heavy low-level handling
    of user input and the processing of the user caret position. Then, we created
    a component to display the available tags to the user and provided a way for them
    to select a tag by clicking on it. In our `Editor` component, we used the `TagInputManager`
    class together with the `TagsSelect` component to enable the smooth entering of
    tags while editing comments and other areas where we've enabled tagging.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve covered the following concepts in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: We processed complex user input within a designated manager class to offload
    logic from our components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used host bindings to set positional style attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We implemented fully reactive components that rely on observables and don't
    create side effects during change detection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned to use our computer mouse and keyboard with great efficiency.
    Using keyboard shortcuts, different click actions and contextual mouse menus support
    us nicely when performing tasks. However, there is one pattern that has gained
    more attention again in applications lately, given the current mobile and touch
    devices hype. Drag and drop actions are a very intuitive and logical way to express
    actions such as moving or copying items. One task performed on user interfaces
    benefits from drag and drop particularly, which is ordering items within a list.
    If we need to order items via action menus, it gets very confusing. Moving items
    step by step using the up and down buttons works great, but it takes a lot of
    time. If you can drag items around and drop them in a place where you'd like them
    to be reordered, you can sort a list of items extremely fast.
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we will build the required elements to enable drag and drop selectively.
    We will use the drag and drop feature to enable users to reorder their task lists.
    By developing reusable directives to provide this functionality, we can enable
    the feature at any other spot within our application later on.
  prefs: []
  type: TYPE_NORMAL
- en: To implement our directives, we will make use of the HTML5 drag and drop API,
    which is supported in all the major browsers at the time of writing this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we would like to reuse our drag and drop behavior on multiple components,
    we will use directives for the implementation. We are going to create two directives
    in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Draggable directive**: This directive should be attached to components, which
    should be enabled for dragging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Draggable drop zone directive**: This directive should be attached to components
    that will act as a drop target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll also implement a feature where we can be selective about what can be dragged
    where. For this, we will use a type attribute on our draggable directives as well
    an accepted type attribute on our drop zones.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the draggable directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `draggable` directive will be attached to the element that can be dragged
    onto other elements. Let''s get started with creating a new directive class under
    `draggable/draggable.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using the `@Component` annotation, we've now used the `@Directive`
    annotation to let Angular know that the following class is a directive class.
    By setting the HTML attribute `draggable` to `true`, we tell the browser that
    we're considering this element a draggable element.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The big difference of using directives in comparison to components is that they
    don't embrace a view but only behavior. Therefore, it's also possible to use many
    directives on the same element, which is not possible with components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the input for our newly created component class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `draggableData` input is used to specify the data that represents the element
    which can be dragged. This data will be serialized to JSON and transferred to
    our drop zones once a drag action is completed.
  prefs: []
  type: TYPE_NORMAL
- en: By specifying a draggable type, we can be more selective when the element is
    dragged over a drop zone. Within the drop zone, we can have a counterpart that
    controls what types are acceptable to be dropped.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally to our input, we also want to use a host binding to set a special
    class if the element is currently dragged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This binding will set a `draggable--dragging` class, which will apply some special
    styles that will make it easy to recognize that an element is dragged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to handle two events within our directive to implement the behavior
    of a draggable element. The following DOM events are triggered by the drag and
    drop DOM API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dragstart`: This event is emitted on elements that are grabbed and moved across
    the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dragend`: If the previously initiated dragging of the element is ended, because
    of a successful drop or a release outside of a valid drop target, this DOM event
    will be triggered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the implementation of `HostListener` for the `dragstart` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s discuss the different actions we will perform in the implementation
    of our host listener:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to access the DOM event object in our host listener. If we were
    to create this binding within the template, we would probably need to write something
    similar to this: `(dragstart)="onDragStart($event)"`. Within event bindings, we
    can make use of the synthetic variable `$event`, which is a reference to the event
    that would have triggered the event binding. If we were to create an event binding
    on our host element using the `@HostListener` annotation, we would need to construct
    the parameter list for the binding using the second argument of the decorator.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first action in our event listener is to set the desired `effectAllowed`
    property on the `dataTransfer` object. Currently, we only support the `move` effect
    as our main concern is to reorder tasks within the task list using drag and drop.
    The drag and drop API is very system-specific, but usually there are different
    drag effects if a user holds a modifier key (such as *Ctrl* or *Shift*) while
    initiating the dragging. Within our `draggable` directive, we can force the `move`
    effect for all drag actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next code snippet, we will set the data that should be transferred by
    dragging. It's important to understand the core purpose of the drag and drop API.
    It does not only provide a way to implement drag and drop for elements solely
    in your DOM, but it also supports the dragging of files and other objects into
    your browser. Because of this, the API undergoes some constraints, where one of
    them is making it impossible to transfer data other than simple string values.
    In order for us to transfer complex objects, we will serialize the data from the
    `draggableData` input using `JSON.stringify`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another limitation caused by some security constraints within the API is that
    data can only be read after a successful drop. This means that we cannot inspect
    the data if the user is just hovering over an element. However, we need to know
    some facts about the data when hovering drop zones. We need to know the type of
    the draggable element when entering a drop zone so we can make the drop zone signal
    if the type is accepted. We're using a small workaround for this issue. The drag
    and drop API hides the data when we drag data over a drop target. However, it
    tells us what type of data it is. Knowing this fact, we can use the `setData`
    function to encode our draggable type. Accessing the data keys only is considered
    secure and therefore can be done in all drop zone events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we'll set the dragging flag to `true`, which will cause the class binding
    to revalidate and add the `draggable--dragging` class to the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After dealing with the `dragstart` event, we only need to handle the `dragend`
    event to complete our `Draggable` directive. The only thing we do within the `onDragEnd`
    method that is bound to the `dragend` event is set the dragging member to false.
    This will cause the `draggable--dragging` class to be removed from the host element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: That's it for the behavior of our `Draggable` directive. Now we need to create
    its counterpart directive to provide the behavior of a drop zone.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a drop target directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Drop zones will act as containers where draggable elements can be dropped.
    For this, we''ll create a new directive called `DraggableDropZone` under `draggable/draggable-drop-zone.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s nothing special about this `@Directive` annotation. We used an attribute
    selector so it can be attached using a `draggableDropZone` attribute on any HTML
    element. Using the following input, we can specify what types of draggable elements
    we accept in this drop zone. This will help the user identify whether they are
    able to drop off the draggable elements when approaching the drop zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon successful drops into the drop zone, we will need to emit an event so
    that the components using our drag and drop functionality can react accordingly.
    For this purpose, let''s create a `dropDraggable` output property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `over` member field will store the state if an accepted element is in the
    process of being dragged over the drop zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method will be used to check whether our drop zone should accept
    any given drag and drop event by checking against our `dropAcceptType` member.
    If you remember the security problems we needed to work around with when creating
    the `Draggable` directive, you will understand why this determination is rather
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We can only read the types of the data within `dataTransfer` objects for certain
    events, where the data itself is hidden until a successful `drop` event is occurred.
    To bypass this security limitation, we've encoded the draggable type information
    into a data key itself. Since we can list all the data types safely, it's not
    too hard to extract the encoded draggable type information. We will search for
    a data type key that starts with `"draggable-type"` and then split it by the column
    character. The value after the column character is our type information, which
    we will then compare against the `dropAcceptType` directive input property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use two events to determine whether a draggable element is moved to
    our drop zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dragenter`: This is fired by an element if another element is dragged over
    it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dragleave`: This is fired by an element if the previously entered element
    has left again'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s one problem with the preceding events, which is that they actually
    bubble, and we will receive a `dragleave` event if the dragged element is moved
    to a child element within our drop zone. Because of the bubbling, we then also
    receive `dragenter` and `dragleave` events from the child elements. This is not
    desired in our case, and we need to build some functionality to improve this behavior.
    We will make use of a counter member field `dragEnterCount`, which will count
    up to all the `dragenter` events and count down to `dragleave` events. This way,
    we can now say that only on `dragleave` events, where the counter becomes zero,
    we will actually leave the inside of our drop zone. Let''s look at the following
    diagram that illustrates the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a drop target directive](img/image00332.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Visualization of important variables and functions for our calculations
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement this logic to build a proper enter and leave behavior of our
    drop zone within the `draggable/draggable-drop-zone.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Within both the events, we first check whether the event is carrying a `dataTransfer`
    object of which we accept the type. After validating the type using our `typeIsAccepter`
    method, we deal with the counter and set the `over` member field if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to handle another event that is important for drag and drop functionality,
    which is the `dragover` event. Within the `dragover` event, we can set the accepted
    `dropEffect` of the current dragging action. This will tell our browser that the
    initiated dragging action from our draggable is suitable for this drop zone. It''s
    also important that we prevent the default browser behavior so there''s nothing
    in the way of our custom drag and drop behavior. Let''s add an other function
    to cover those concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to handle the most important event in the drop zone, which
    is the `drop` event that is triggered if a user drops a draggable into our drop
    zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: After checking whether the dropped element is of an accepted type, we can now
    go ahead and read the `dataTransfer` object data from the event. This data was
    previously set by the `Draggable` directive and needs to be deserialized using
    `JSON.parse`.
  prefs: []
  type: TYPE_NORMAL
- en: Since the drop was successful, we can reset our `dragEnterCount` member and
    set the `over` flag to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will emit the deserialized data from the draggable element using
    our `dropDraggable` output property.
  prefs: []
  type: TYPE_NORMAL
- en: That's all we need to have a highly reusable drag and drop behavior that we
    can now attach to any components within our application where we feel the need.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating drag and drop in task list component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now use the `Draggable` and `DraggableDropZone` directives in our `TaskList`
    component so we can enable the reordering of tasks using drag and drop.
  prefs: []
  type: TYPE_NORMAL
- en: The way we're going to do this is by attaching both the directives to the task
    elements within the `TaskList` component template, where we'll render them. Yeah,
    that's right! We want to make our `Task` component a draggable but also a drop
    zone at the same time. This way, we can drop tasks into other tasks, and this
    gives us the foundation for reordering. What we will do is reorder the list in
    a drop so that the dropped task will be squeezed into the position right before
    the task where it was dropped.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s apply the directives to the `<ngc-task>` element in the `TaskList`
    component template, namely `task-list/task-list.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Alright, using the preceding attributes, we have made our tasks not only a draggable,
    but also a drop zone. By specifying both `draggableType` and `dropAcceptType`
    to the `"task"` string, we are telling our drag and drop behavior that these task
    elements can be dropped into other task elements. Our `DraggableDropZone` directive
    is set to emit a `dropDraggable` event whenever a valid draggable is dropped off.
    To handle dropped tasks, we can simply use this event and create a binding to
    a method in our `TaskList` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what we need to change within our `Component` class, located under
    `task-list/task-list.js`, to make this work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s elaborate on the behavior we''ll see within the `onTaskDrop` method
    that is bound to the `DropZone`''s `dropDraggable` event in our template:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you check the template again, you would see that we bound to the `onTaskDrop`
    method with the following expression: `(dropDraggable)="onTaskDrop($event, task)"`.
    Since the drop zone emitted an event with de-serialized data that was bound using
    the draggable input property `draggableData`, we can safely assume that we will
    receive a copy of the task that was dropped into the drop zone. As a second parameter
    to our binding, we added the local view variable `task`, which is actually the
    task that acts as the drop zone. Therefore, we can say that the first parameter
    of our `onTaskDrop` method represents the source, while the second represents
    the target task.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a first check in our method, we compare the source position with the target
    position, and if they match, we can assume that the task was dropped by itself
    and we don't need to perform any further actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can get the source and target task indices within our tasks array and
    execute a nested splice so that we can remove the source from its old position
    within the array and add it right before the position of the target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All that's left to do now is recalculate the position fields of the tasks so
    that they reflect the reordered array. We can do this easily by using `Array.prototype.map`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the last step, we need to notify our parent component that we've updated
    the task list. We can simply use the `taskUpdated` event to do so. We have used
    that same event when tasks were added or removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How great is that? We have successfully implemented drag and drop on our task
    list to provide a very usable feature to reorder tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Recapitulate on drag and drop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the use of the low-level drag and drop API, using events and `dataTransfer`
    objects, we have implemented two directives that can now be used to execute smooth
    drag and drop functionality within our application wherever we desire.
  prefs: []
  type: TYPE_NORMAL
- en: With almost no effort, we have implemented our drag and drop behavior on the
    task list to provide a nice feature to reorder the tasks within the list. The
    only thing we needed to do, besides hooking up the directives, was to implement
    a method where we could reorder the tasks based on the information from the `DraggableDropZone`
    event.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have worked with the following concepts in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: We learned the basics of HTML5 drag and drop API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We used the `dataTransfer` object to securely transfer data within drag and
    drop events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Built reusable behavior patterns using directives.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enriched the standard drag and drop API by providing our own custom selection
    mechanisms using a custom data type that encodes draggable-type information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To infinity and beyond!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Displaying a simple list with an average size does not come with a lot of challenges.
    As soon as the lists starts to grow, challenges start to appear. We can easily
    overwhelm a user with a very long list. Long lists can also have a performance
    impact on our application, especially when it displays dynamic content.
  prefs: []
  type: TYPE_NORMAL
- en: One way to address the challenge faced when displaying long lists is to provide
    pagination. However, pages do not always translate very well. While using pagination
    on a desktop device with a mouse seems very intuitive, it becomes cumbersome on
    mobile devices with touch support.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll look at a different approach that can help us mitigate
    the performance implications of long lists while providing a smooth experience
    on mobile devices. We are using a pattern sometimes referred to as infinite scrolling.
    The goal is to display only enough items within the list to fill the screen, and
    load more items on demand if the user scrolls down.
  prefs: []
  type: TYPE_NORMAL
- en: To implement such a behavior, we could write a wrapper component that will provide
    an infinite scroll pane and use content insertion to embrace our list. However,
    we will use a different approach to implement our infinite scroll behavior and
    build a custom template directive such as `NgFor`.
  prefs: []
  type: TYPE_NORMAL
- en: The asterisk syntax and templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have used the `NgFor` and `NgIf` directives quite a lot so far using the
    asterisk (`*`) symbol to indicate we're dealing with a directive that creates
    a template. However, we haven't looked at the anatomy of the asterisk template
    syntax. Imagine that it will create some sort of syntactic sugar for our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out this example of using the `NgFor` directive with the asterisk template
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The template parser of Angular will handle all the attributes that start with
    an asterisk in a special way. The preceding example is an easier and more concise
    writing style of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Both the preceding examples are absolutely identical. Template directives, such
    as `NgFor` or `NgIf`, make use of HTML template elements, which we've briefly
    discussed in [Chapter 1](part0014.xhtml#aid-DB7S1 "Chapter 1. Component-Based
    User Interfaces"), *Component-Based User Interfaces*. The reason that the Angular
    common directives `NgFor`, `NgIf`, and `NgSwitch` use HTML template elements is
    actually quite obvious if you think about their nature. All three directives need
    to insert and remove large regions of our DOM dynamically. `NgIf`, for example,
    inserts or removes the element it's attached to, based on a condition. By leveraging
    template elements, this can be supported by the browser's native functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you compare the examples discussed here, it's obvious that the first writing
    style is much simpler to deal with. Asking you to write a separate template element
    every time you'd want to use `NgFor` or `NgIf` would be quite a pain. This is
    the only reason why the asterisk syntax exists, its raison d'être if you like.
    Instead of writing a template element directly, we can use an asterisk on an attribute
    and Angular will transform the HTML portion into a template element for us.
  prefs: []
  type: TYPE_NORMAL
- en: The `NgFor` directive uses a `TemplateRef` dependency, which can be injected
    into the constructor of the directive, to instantiate the template or multiple
    instances of it, as desired. The `[ngForOf]` property binding is generated during
    de-sugaring by appending the word `Of` within the `NgFor` expression to the directive
    name, `ngFor`. The binding is created by the `NgFor` directive, which accepts
    an input, `ngForOf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Angular would de-sugar this into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: That's just the way Angular de-sugars the asterisk template syntax. It's a shortcut
    to attach directives as well as one input bindings to template elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s still one thing that might look confusing, which is the variable attribute
    in the template. Let''s look at another example of using the `NgFor` directive
    by aliasing the exposed local variables of a directive like the current index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This example will be de-sugared to the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: So we can now tell from de-sugaring that additional aliases or mappings will
    get created as variable mappings in our template element. The index that is exposed
    within the code of the `NgFor` directive class as a local view variable is mapped
    to a local view variable within the instantiated content of the template.
  prefs: []
  type: TYPE_NORMAL
- en: So what's going on with the local view variable `n` within our instantiated
    templates? Why can we access `n`, when there's just one variable attribute without
    any value that would tell us where it's mapped to?
  prefs: []
  type: TYPE_NORMAL
- en: We have learned that when we use hash symbol attributes on regular elements,
    we create a local view reference. We can use this reference as an identifier in
    the view directly, or by querying using `@ViewChild`. However, when the view compiler
    of Angular discovers what looks like a local view reference on a template, the
    behavior is a bit different.
  prefs: []
  type: TYPE_NORMAL
- en: What is invisible to us is that Angular actually implies a default value for
    variable attributes on template elements that don't have an attribute value. It
    will create a mapping for a local view variable called `$implicit`. You can think
    of `$implicit` as a default value that can be exposed in directives as local view
    variables and will provide some ease of use when dealing with template elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would also be totally valid to write the preceding example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `NgFor` directive is exposing a local view variable `$implicit`, which
    is a reference to the current value associated with the instance during the iteration
    over the array it receives within the `ngForOf` input. Using a plain variable
    attribute without a value, Angular will default a mapping to `$implicit`. Because
    we don't want to write this mapping all the time ourselves, we can just specify
    an empty variable attribute and Angular will assume it for us.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an infinite scroll directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we now know a bit more about template elements and how Angular deals with
    the asterisk syntax, we can actually create our own copy of `NgFor`, which is
    additionally dealing with the behavior of infinite scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file for our directive under `infinite-scroll/infinite-scroll.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We start off by declaring a regular directive that is sensitive to the attribute
    selector `ngcInfiniteScroll`. The preceding code excerpt only shows the relevant
    code for the template element handling we discussed in the previous topic. There
    are some code parts that we will cover later on in this topic. You can see that
    we used an input property `ngcInfiniteScrollOf`, which is used to pass in the
    list of times used within the infinite scrolling. For inserted template instances,
    we set the local view variable `$implicit` to the actual item within the list
    we were iterating over.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss how we get to all of the surrounding code shortly, but first
    let''s take a look at how we could use this directive within a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code, as per the mechanisms described in the previous topic,
    will de-sugar into the following template element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: So what we can tell now is that the items array will be placed as a property
    binding onto our template element. The same element also contains the `InfiniteScroll`
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: After discussing how the directive will be used and how we can get the required
    input into the directive, let's look at the implementation details that enable
    the infinite scroll behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our directive needs to deal with quite a lot of concerns. Let''s check out
    a high-level requirement list:'
  prefs: []
  type: TYPE_NORMAL
- en: It needs to dynamically create new child views based on the template element
    and also remove child views that are no longer required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It needs to detect changes on the input property `ngcInfiniteScrollOf`, which
    is bound to an array within the template. It's not sufficient to use a simple
    identity check, because we'd like to create a comparison of the previous array
    to the new array and only perform view changes based on the differences. For this
    purpose, we will need to implement the `DoCheck` life cycle callback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It needs to store a count of items that should be displayed initially, and by
    detecting scroll events, the displayed item count should increase so more items
    could be made visible. At the same time, scrolling should trigger the change detection
    so that we can create new instances of the template within the view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the constructor of our directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We needed to use quite a lot of injected dependencies in order to perform all
    the operations required to fulfill the outlined requirements of our directive:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ViewContainerRef` dependency helps us create new embedded views based on
    our template element as well as detach or completely remove existing views.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TemplateRef` dependency is a reference to the template element, and we
    can use it in conjunction with the `ViewContainerRef` dependency in order to create
    new instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IterableDiffers` dependency is used to create a diff of our input property,
    which is the array of items we're concerned about in our infinite scroll repeater.
    It supports us in finding the created, removed, and deleted items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ChangeDetectorRef` dependency is used to trigger change detection manually
    when we actually need it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the first step, we used `Object.assign` to store all our function parameters
    in the instance of the directive. Then, we set two-member variables that will
    store information related to the number of items that should be displayed and
    also the number of displayed items we should increase upon scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it for the constructor. We also need to perform some actions after
    the view within our directive has been initialized. We''ll use the `ngOnInit`
    life cycle hook for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at these two lines of code in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The way our infinite scrolling works is that it detects whether the scrollable
    parent element has already scrolled to the bottom. If that's the case, we'd need
    to render more items from the list. In order to check whether our parent element
    has already scrolled to the bottom, we will need a reference to it. As scroll
    events don't bubble, we need to be very precise where to monitor them. That's
    the reason why we use a utility function to scan the DOM tree to find the next
    scrollable parent element. The `findScrollableParent` function looks for the first
    parent element that has scrollbars or the window object. You can check the source
    code of this chapter if you'd like to see the internals of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we've added an event handler to the found scrollable parent element and
    registered our internal `onScroll` method as a callback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting change within our template directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s look at the complete code of the `ngcInfiniteScrollOf` property
    setter, which we have briefly looked at already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Our property setter will be called by Angular every time the `ngcInfiniteScrollOf`
    input property changes. Since this property is bound by the de-sugaring of the
    asterisk template syntax to the list we refer to within our template, we can assume
    that the value will always be an array or a similar iterable structure.
  prefs: []
  type: TYPE_NORMAL
- en: Besides storing the new value from the input property onto our directive instance,
    we also lazy initialize a member field called `differ`. Using the `find` method
    on the `IterableDiffers` object, we can obtain a factory that matches the type
    of iterable you're dealing with (in our case, this will be plain arrays). On the
    obtained factory, we can then call the `create` method to create a new differ.
    The `create` method expects a `ChangeDetectorRef` object to be passed. Luckily,
    we have that readily available through an injection within the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The differ will help us in a later step to detect changes between the existing
    value of our array and an updated one. We can then perform additions, removals,
    and movements in a very performant way.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call the `diff` method on `IterableDiffer`, it will return a new `IterableDiffer`
    object that contains all the changes relative to the previous `IterableDiffer`
    object. In a differ, we can then call one of the following methods to iterate
    over the relevant `CollectionChangeRecord`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`forEachItem`: This iterates over each `CollectionChangeRecord` within the
    differ by providing a callback function. The first argument to the callback will
    be a change record.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEachPreviousItem`: This only iterates over each `CollectionChangeRecord`
    within the differ that already existed in the previous differ.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEachAddedItem`: This only iterates over each change record that was added
    from the previous diff to the current one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEachMovedItem`: This only iterates over each change record that was moved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEachRemovedItem`: This only iterates over change records that were removed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `CollectionChangeRecord` objects contain the following three main properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`item`: A reference to the item within the list which we''re observing for
    changes using the differ'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`previousIndex`: The index of the item within the list before the `differ`
    iterable happened'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currentIndex`: The index of the item within the list after the `differ` iterable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also solely tell from the constellation of `previousIndex` and `currentIndex`
    what happened to the item. The following methods are present on an `IterableDiffer`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Added items**: This can be identified if `previousIndex` is null and `currentIndex`
    is set to a valid number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Moved items**: This can be identified if `previousIndex` and `currentIndex`
    are both set to a valid number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Removed items**: This can be identified if `previousIndex` is set to a valid
    number but `currentIndex` is set to `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s look at the `onScroll` method, which will be invoked by the scroll
    event callback of the scrollable container element. In this method, we need to
    handle the logic of our behavior that should be executed when a user scrolls down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In the `onScroll` method, we first checked whether the scrollbar of the scrollable
    parent element has already scrolled to the bottom. If that's the case, we can
    assume that we should display more items from our list.
  prefs: []
  type: TYPE_NORMAL
- en: We incremented the `showItemCount` member by the default `increment` value,
    which we have set to `3`, and after modifying the number of displayed items, we
    used the change detector to mark our subtree structure to be checked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we would like to use the differ that we have lazy initialized within
    our input setter to detect changes and perform any actions manually, we will need
    to implement the `DoCheck` life cycle callback on our directive. By implementing
    this, we will disable the default change detection of Angular and implement our
    own way to deal with changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: First, we used the differ to obtain a change record set from the current `infiniteScrollOf`
    array to the previous one. The differ will actually always store the previous
    value, so we only need to pass it the current value. The change records will then
    help us to perform different actions for added, removed, and moved items. It's
    also important to note that we did not use the whole list here to create a diff,
    but a slice of the list where our `showItemCount` member comes into play. This
    will only make the list that we're concerned about available in our infinite scroll
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing embedded views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If there are any changes detected by the differ, we can call the `applyChanges`
    method, which deals with the details of how to perform view updates with changed
    items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at the innards of the `applyChanges` method. It needs to be called
    from the `OnChange` life cycle hook with a parameter that reflects the record
    changes within the observed input array called `infiniteScrollOf`. In the constant
    `recordViewTuples`, we stored all the change records that were either moved or
    removed completely. Now you can call the `bulkRemove` method by passing the `recordViewTuples`
    array. The `bulkRemove` method will either detach the view, in case there is movement,
    or completely remove the view. The returned value is a list that will contain
    only the tuples that were moved. We stored these within a constant called `insertTuples`.
    Because they were detached from the view container, we will need to reattach them
    at a different position within the view container.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can go ahead and add all the records to the `insertTuples` array that
    were added according to the latest diff. The `insertTuples` array now contains
    all the moved as well as added records.
  prefs: []
  type: TYPE_NORMAL
- en: Using this list, we call the `bulkInsert` method, which will reinsert moved
    views and create new embedded views for added records. As a result, we get a list
    of all the inserted records (moved and added), where each record also contains
    a view property that points to the inserted view.
  prefs: []
  type: TYPE_NORMAL
- en: The last step within our `applyChanges` method should now ring a bell. We iterated
    through the list of newly inserted views and set the local view variable `$implicit`
    on the view context. This way, we can set the required variable that is used to
    create the default variable mappings on our template elements, as discussed in
    the previous topic.
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand how we can instantiate new views from our template element,
    move views around, and remove existing views, we need to understand the view container.
    The `ViewContainerRef` dependency is provided to our directive or component using
    injection in the constructor. It stores a list of views and provides some methods
    to add new and remove existing views. Each component within Angular contains one
    view container. We can then access the methods on the view container in order
    to programmatically modify the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four main methods in `ViewContainerRef` that we''re interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `createEmbeddedView` | This method will create a new embedded view using
    a template reference and insert the newly created view at a given index within
    the view container. Embedded views are views instantiated from template elements.The
    following are its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`templateRef`: The first parameter should be the template reference, which
    should be instantiated into an embedded view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context`: This is an optional context object, which will be available for
    the instantiated template view. All properties within the context can be used
    within the view template as local view variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index`: The optional index parameter can be used to place the instantiated
    view at a given position within the view container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method returns the created embedded view. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `detach` | The `detach` method will remove an embedded view from the view
    container at a given index without destroying the view so it can be reattached
    later using the `insert` method.The following is its parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index`: This is the index of the embedded view, which should be detached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method returns the detached embedded view. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `remove` | The `remove` method will completely remove an embedded view from
    the view container and also destroy the view. A view that has been destroyed can''t
    simply be reattached using the `insert` method.The following is its parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index`: This is the index of the embedded view, which should be removed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method returns the removed embedded view. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `insert` | This method will insert an existing view into the view container.The
    following are its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`viewRef`: The embedded view that should be inserted into the view container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index`: The optional index parameter that can be used to place the embedded
    view at a given position within the view container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method returns the inserted embedded view. |
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly look at the `bulkRemove` and `bulkInsert` methods to see how
    we can use the view container to modify the containing view upon changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We use `ViewContainerRef` to detach views in case the record contains a valid
    `currentIndex` field. If that's the case, we know that we are dealing with a view
    that will be moved. We use the `detach` method to exclude the view from its position
    within the view container, but this will not destroy the view. It's important
    to note here that we stored the returned view from the `detach` method onto the
    tuple before we added it to the `movedTuples` list. This way, we were able to
    identify it later as a moved item, and we could use the view to reattach it using
    the `insert` method on the view container.
  prefs: []
  type: TYPE_NORMAL
- en: In the case where there's no valid `currentIndex`, we are dealing with an element
    that was removed from the list. In such cases, we'd need to use the `remove` method
    to completely destroy the view and remove it from the view container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll call the `bulkInsert` method with any moved or inserted views. Let''s
    also look at the code of this method briefly to see how we can handle view updates
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: If the tuple contains a `view` property, we know we have previously detached
    it from a different position. We are using the insert method of the view container
    to reattach it at the new position using the information from `CollectionChangeRecord`.
  prefs: []
  type: TYPE_NORMAL
- en: If there's no `view` property, we are dealing with a newly added record. In
    that case, we simply use the `createEmbeddedView` method to create a new template
    instance. For the context parameter, we need to pass a new empty object. However,
    we've updated the context object already within our `applyChanges` method. There,
    we added the `$implicit` local view variable for every created view.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all we need for our `InfiniteScroll` directive, and we can now add
    it to the templates where we''re planning to use this functionality. Let''s use
    it within the task list by adding the directive to the directive list of the `TaskList`
    component within the `task-list/task-list.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can simply edit the task list template in `task-list/task-list.html`
    and replace the `NgFor` directive with our `InfiniteScroll` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: That's all we need to use our infinite scroll functionality. This is highly
    reusable, and we can place it wherever we'd like to use it instead of the regular
    `NgFor` repeater.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing our infinite scroll directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this topic, we created an infinite scrolling behavior by implementing a template
    directive similar to `NgFor`. We replaced the `NgFor` directive in our task list
    to use the `InfiniteScroll` directive instead. Now we don't display all the tasks
    right at the beginning, but as soon as the user starts to scroll, new tasks appear.
    In scenarios where we rely on a list that is partially loaded from the server,
    our directive could even be extended so it could request for more items from the
    server on demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve covered the following subtopics here:'
  prefs: []
  type: TYPE_NORMAL
- en: The asterisk syntax and de-sugaring to template elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The local view variable, `$implicit`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the `OnChange` life cycle hook to provide custom change detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `IterableDiffer` to analyze the difference of changes within our array
    input property and handling `CollectionChangeRecord` objects to react on changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ViewContainerRef` to update the view of a component programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `TemplateRef` as a reference to the template element within template directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built three components to enhance the usability of our application.
    Users can now make use of tags to easily annotate comments with navigable items
    that provide summaries to the subject. They can use drag and drop to reorder tasks
    and benefit from an infinite scroll behavior on the task list.
  prefs: []
  type: TYPE_NORMAL
- en: Usability is a key asset in today's applications, and by providing highly encapsulated
    and reusable components to address usability concerns, we can make our lives a
    lot easier when building those applications. Thinking in terms of components when
    dealing with usability is a very good thing, which not only eases development,
    but also establishes consistency. The consistency itself then plays a major role
    in making an application usable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to create some nifty components to manage time
    within our task management system. This will also include some new user input
    components to enable simple work time-entry fields.
  prefs: []
  type: TYPE_NORMAL
