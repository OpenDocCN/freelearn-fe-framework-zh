- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Libraries for Large-Scale Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you start learning how to use different libraries to develop large-scale
    and enterprise-ready applications with Vue.js 3, you need to understand these
    individual libraries and the various features they are bundled with to help you
    navigate through building scalable and enterprise-ready applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the essential aspects of Vuex, Axios, and Vue
    Router and how to integrate them with Vue 3 to develop an enterprise application.
    This background information will put you in a better position to grasp the terms
    and concepts of these libraries and help you understand how to build and scale
    an enterprise-ready application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring large-scale Vuex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring with the repository pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a repository folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring Vue navigation with Vue Router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you’ve mastered each of these topics, you will be ready to get started
    with building your first enterprise-ready application with Vue 3.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with this chapter, we recommend reading through [*Chapter 1*](B17237_01.xhtml#_idTextAnchor015),
    *Getting Started with Vue.js 3*, and its overview of Vue 3 and the Composition
    API, which will be intensively used in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring large-scale Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Vuex** is the state management library for Vue applications. It serves as
    a central store for all the components in a Vue application. It is also a library
    implementation tailored specifically to Vue.js to take advantage of its granular
    reactivity system for efficient updates.'
  prefs: []
  type: TYPE_NORMAL
- en: Significant benefits can be derived when using Vuex for the state management
    of a Vue application. Still, it can easily be misused and overwhelmed if not adequately
    structured—especially when building a large-scale enterprise application—due to
    the size of the project and the number of components and features that will be
    introduced in the project.
  prefs: []
  type: TYPE_NORMAL
- en: To tackle this structure problem, we will introduce you to different structures
    to arrange your Vuex store and the law of predictability discussed in [*Chapter
    4*](B17237_04.xhtml#_idTextAnchor112), *Architecture for Large-Scale Web Applications*,
    to accommodate large-scale Vue applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss Vuex states, getters, mutations, and actions.
  prefs: []
  type: TYPE_NORMAL
- en: Practically, the usual way to structure your Vuex store is to have every piece
    of code inside a single `index.js` file called a **single state tree**. This method
    works perfectly for a small project and helps to avoid navigating through different
    files to find a single method.
  prefs: []
  type: TYPE_NORMAL
- en: However, when developing an enterprise project using Vuex, using single state
    trees becomes very bloated and difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce this large file and split the file into different features, Vuex allows
    us to divide our store into **Vuex modules**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive in, the Vue community has introduced a new state management
    system called Pinia that fixes the problems of Vuex and is directly compatible
    with Vue 3\. As of the time of writing, Pinia was still in the development and
    beta phase. You can learn more about Pinia and how to integrate it into your Vue
    3 application here: [https://pinia.vuejs.org/](https://pinia.vuejs.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Vuex modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Vuex module is a way to split our store based on features, where each module
    can contain its states, getters, actions, mutations, and even nested modules.
  prefs: []
  type: TYPE_NORMAL
- en: This method allows us to split our store into features and create different
    files and folders to arrange the store correctly.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll learn how we can split our store into features in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming our *Pinterest* application will have different states such as photos,
    users, comments, and so on, we can split the store into separate modules as opposed
    to having it in a single file.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vuex modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As stated in the previous section, using Vuex modules comes with great benefits,
    and we will stick to it throughout this book. Firstly, let’s look at the folder
    structure of our Vuex module store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code block, we have created different modules
    to wrap our Vuex state, actions, and mutations respectively. It can be useful
    to structure our project into different features.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to structure our Vuex store for enterprise projects,
    let’s discuss how to access and manage the store from a component in Vue in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Vuex state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First and most importantly, let’s discuss states and how we can manage the state
    of a module Vuex store.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Vuex state** is the data you stored inside your Vuex store and can be
    accessed anywhere in your Vue application.'
  prefs: []
  type: TYPE_NORMAL
- en: The Vuex state follows the single-state-tree pattern. This single object contains
    all your application-level states. It serves as the “single source of truth”.
    But, since we’re adopting modularity to manage our enterprise-ready application,
    we are going only to learn how to access and manage our module states.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how to create a simple Vuex state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In addition, you can access a Vuex store outside of components. For example,
    you access Vuex inside of Vue services, helper files, and so on. However, in the
    next section, we will explore different ways to access our state in the components.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing state without mapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assuming this is our store for all photos in our *Pinterest* application and
    we have that `photos` state, how do we access it in our components?
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the `Photos` array, we will use our module name with the store name,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The previous code snippet shows how to access a moduled store by creating a
    new `Photos` component and displaying all the photos in the photo’s state.
  prefs: []
  type: TYPE_NORMAL
- en: To access the `Photos` state array, we used the name of the module it belongs
    to and accessed the state property *before* the `photos` array.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’re going to explore how to access the Vuex state using the mapping
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the state with mapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best way to access the store is to use **Vuex state maps**, ([https://vuex.vuejs.org/guide/state.html#the-mapstate-helper](https://vuex.vuejs.org/guide/state.html#the-mapstate-helper)),
    which we will use throughout this book. You c[an go to the official Vuex](https://vuex.vuejs.org/)
    documentation ([https://vuex.vuejs.org/](https://vuex.vuejs.org/)) to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vuex mappers is great when your components need to make use of multiple
    store-state properties or getters. Declaring all these states and getters can
    get repetitive and verbose, and that’s exactly what a Vuex mapper tends to solve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take an example of creating a simple `Photos` component and using the
    Vuex state to display different images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet creates a `Photos` component, loops through the data from
    our Vuex state, and displays the images in the store.
  prefs: []
  type: TYPE_NORMAL
- en: There you have it.
  prefs: []
  type: TYPE_NORMAL
- en: We will use this method in further discussion with actions, mutations, and getters.
    You should *never* forget the names of your modules.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a fair understanding of the Vuex state and modules and how we will
    structure our enterprise and large-scale Vuex application for easy maintainability
    and accessibility.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss getters and how we can manipulate our Vuex state using **Vuex
    getters** and map getters in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Vuex getters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vuex getters are very useful for manipulating the Vuex state. Sometimes, you
    might want to filter or sort the Vuex state before returning the data to the components.
  prefs: []
  type: TYPE_NORMAL
- en: Vuex allows us to create getters that manipulate the state just as computed
    properties in Vue will do. It also caches the result and updates the cache when
    data changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In each module, we will define its specific getters to manipulate the state
    in that module. For example, we will create a getter to filter photos based on
    user ID in our `Photos` module, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet shows how to create a getter that filters all the
    photos added by a particular user whose ID is passed to the `getters` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s access the getter in our component using the `map` helper. See
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Vuex getters are a great way to manipulate and manage Vuex states before they
    go out to our components and can come in handy for filtering, sorting, updating,
    and deleting records from our Vuex state.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss **Vuex mutations** and how we can use them in an enterprise-ready
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Vuex mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only way to change the state of a Vuex state is by committing a mutation.
  prefs: []
  type: TYPE_NORMAL
- en: A Vuex mutation is similar to an event. It takes a string called `type` and
    a function called `handler`. The `handler` function is where you perform the mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we’re still working with our *Pinterest* photo store, we can add a
    new `Photo` object to our state with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will look at accessing the Vuex mutation module. We can access it
    using Vuex map helpers, which is the recommended way for enterprise projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we can call the `addPhoto()` method anywhere in our component, pass
    the `Photo` object as the only argument, and let Vuex do its thing.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the most comprehensive place to use Vuex mutations is in **Vuex
    actions**. In the next section, we will discuss Vuex actions in detail and demonstrate
    how they can be used in enterprise applications.
  prefs: []
  type: TYPE_NORMAL
- en: Vuex actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vuex actions are similar to Vuex mutations, but instead, they are asynchronous
    and are primarily used to commit Vuex mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Vuex actions can make API calls to our backend server and commit the response
    to our Vuex state using Vuex mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, to make an API call with Vuex actions, we will do it directly
    inside the store, as the following code snippet shows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our *Pinterest* photo example, we will have a store similar to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, to dispatch the action in our component, we will stick with using Vuex
    maps to dispatch the action and retrieve a new photo corresponding to the ID passed
    into the `getPhoto()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have covered a lot on building large-scale applications with Vuex,
    and we have elucidated Vuex modules, states, getters, mutations, and actions and
    how to apply them in building enterprise-ready applications.
  prefs: []
  type: TYPE_NORMAL
- en: To further solve the problem of structure, we will introduce you to the use
    of the **repository pattern** in arranging your Vuex store, structuring all your
    API calls into a repository, and accessing them in your Vuex actions.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring with the repository pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building a large-scale, enterprise-ready Vue application, you must get
    the project’s structure right from the ground up.
  prefs: []
  type: TYPE_NORMAL
- en: Separating your Vuex store into individual modules based on an application’s
    features is excellent and provides direct access to files, making debugging and
    maintenance a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: Using this method alone poses a problem. Your Vuex actions become extremely
    large with many API calls, extracting API data, and handling errors all happening
    in the Vuex actions.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the repository pattern helps eliminate this bloated code base and
    separates the API calls and management from Vuex.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will first get an overview of the repository pattern. Then,
    we will create a repository folder for our Vue application.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, before we explore how to use the repository pattern in Vuex, let’s
    get a clear overview of the repository pattern and what can be achieved with it.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the repository pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The repository pattern is a significant pattern used in creating an enterprise-level
    application, either the frontend or the backend of any enterprise application.
  prefs: []
  type: TYPE_NORMAL
- en: It restricts us from working directly with data in the application and creating
    a new layer for database operations, business logic, and the application UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of a few reasons you should use the repository pattern
    in your frontend development, especially when building enterprise applications:'
  prefs: []
  type: TYPE_NORMAL
- en: The data access code is reusable everywhere across the entire project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is effortless to implement the domain logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can unit-test your business logic quickly without any form of tight coupling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It aids in the decoupling of business logic and the application UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency injection** (**DI**) is good when writing testable enterprise
    code, and repository patterns help you achieve DI even in your frontend projects.'
  prefs: []
  type: TYPE_NORMAL
- en: DI
  prefs: []
  type: TYPE_NORMAL
- en: DI is a programming technique that makes a class independent of its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In the repository pattern, you write an encapsulated code base by hiding the
    details of how your data is retrieved and processed in your Vuex store.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the repository pattern, we will follow the *Consuming APIs Using
    the Repository Pattern in Vue.js* article I wrote ([https://medium.com/backenders-club/consuming-apis-using-the-repository-pattern-in-vue-js-e64671b27b09](https://medium.com/backenders-club/consuming-apis-using-the-repository-pattern-in-vue-js-e64671b27b09)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To consume our backend APIs in Vue.js using the repository pattern, let’s demonstrate
    doing so with an example. Let’s assume we have a Vuex store action making different
    API calls, such as the one in the following code snippet, and we want to implement
    the repository pattern on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can follow the upcoming steps to improve the Vuex store by implementing
    the repository pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a repository folder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, create a folder in the root directory or `src` folder by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We will call ours `repositories`. This folder will contain all your repositories
    and the HTTP client configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a clients folder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a `Clients` folder inside the newly created `repositories` folder.
    What will be inside this folder are the different HTTP clients used.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, due to the nature of the project, some projects might require several
    HTTP clients to make API calls due to different reasons. One can be a fallback
    if the default refuses to connect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, creating a `Clients` folder is crucial to configure all the HTTP clients
    at once. Run the following command to create one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Creating an xxxClient.js class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create a class file corresponding to the HTTP client you are using.
    The naming is subjective, and for `AxiosClient.js` file and put it in all default
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Axios
  prefs: []
  type: TYPE_NORMAL
- en: Axios is a promise-based HTTP client for Node.js and the browser. It can run
    in the browser and Node.js with the same code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create the folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In summary, you might want to use many HTTP clients, so you create different
    `xxxClient.js` files for each with their specific configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Axios, these are my default configurations just for this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can add more default configurations for Axios in the preceding file and
    export the Axios instance.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an individual repository class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we will create an individual repository based on the number of features
    we have in our enterprise application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we are building a *Pinterest* clone application, and we are sure
    the application will have the **Photos** and **Users** features. So, we can start
    by creating a repository for the mentioned features by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These repositories will contain all API calls for the individual features. We
    will start by creating a **Create, Read, Update,** and **Delete** (**CRUD**) operation
    for the respective repositories to give us an overview. In contrast, we will update
    the repositories as we progress along in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `PhotoRepository.js` file and add the following scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to open the `UserRespository.js` file and add the following
    scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have created two repositories for our *Pinterest* clone application, and
    any API-related code will go into the individual repository.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RepositoryFactory.js class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a `RepositoryFactory` factory class inside the `repositories` folder
    by running the following command to export all the different individual repositories
    you may have created so that they’re easy to use anywhere across your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, paste in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have improved our Vuex store by creating repositories, let’s see
    how to use these in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using the repository pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see how to utilize the repositories we have created in our Vuex store.
    Open your Vuex store `photos` file created earlier and replace the `getPhoto`
    action method with the following code to utilize the repository pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using the repository pattern eliminates the need to handle errors, manipulate
    the data retrieved from the API in the Vuex store, and only return the actual
    data needed in Vuex. This approach also utilizes the **Don’t Repeat Yourself**
    (**DRY**) principle of software engineering as the repositories can be used across
    the project by creating a new one.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring doesn’t end when you have your HTTP API calls sorted out with repository
    patterns. It extends to the way you arrange your navigation. The navigation file
    should not be bloated with a large code base that’s difficult to understand.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will arrange and structure our navigation using Vue
    Router to ensure maintainability and scalability in our enterprise project.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring Vue navigation with Vue Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building an enterprise-ready application, it’s evident that the navigation
    system will be massive since there will be many navigations, routes, and pages.
  prefs: []
  type: TYPE_NORMAL
- en: This section will show you how to structure Vue Router in your enterprise project
    properly. To achieve this, we will use the *split-by-feature* approach to organizing
    Vue Router so that it’s easy to navigate, as we achieved with Vuex earlier in
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This approach will create a structure where public and private routes will be
    separated, and more routes can also be separated individually.
  prefs: []
  type: TYPE_NORMAL
- en: The folder structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The folder will comprise an index file, a public file, and a private file containing
    all the routes belonging to each category.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the root of your `src` folder, create a `router` folder and create the following
    files inside the folder by typing in the following commands one after the other
    in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The current folder structure is pretty straightforward, and we will customize
    it more as we progress with the book. Here’s what each file will contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index.js`: This file will contain the `beforeEach` logic and assembling of
    all the other routes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public.js`: This file will contain all the public-facing routes that do not
    need restrictions, such as the login page, registration page, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private.js`: This file will contain all the private routes used for authenticated
    users and many restrictions and metadata'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`combine.js`: This file will combine private and public files and make it easy
    to concatenate it with the main router file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s create an index file to contain the setup of our newly created project.
  prefs: []
  type: TYPE_NORMAL
- en: The index.js file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The index file is the powerhouse. Open the `index.js` file and add the following
    code to export all the routes created in the public and private files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In Vue Router, there are two different history modes mostly in use when developing
    Vue applications with Vue Router:'
  prefs: []
  type: TYPE_NORMAL
- en: Hash mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML5 mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This uses a `#` (hash) symbol before the actual URL to simulate a full URL so
    that the page won’t be reloaded when the URL changes. This is possible because
    the pages or sections after the hash never get sent to the server. The implication
    is that it does not impact the SEO of the page but is the default setup for Vue
    Router.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As seen in the preceding example, this is created using the `createWebHistory()`
    function, and it is the recommended method for enterprise and production-ready
    applications. It requires a bit of tedious configuration on the server for it
    to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: The combine.js file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a single utility file that combines all the routes in a single file
    to be exported to the main router file. Open the file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After adding the routes to the utility file, we will import them into the `main.js`
    file, as shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the router to Vue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lastly, we will add our router to the Vue instance, as shown in the next snippet.
    Open the `main.js` file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As we progress in this book, we will revisit the `public.js` and `private.js`
    files to add more routes based on the *Pinterest* clone application we develop.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter started by exploring the different libraries to develop large-scale
    and enterprise-ready applications with Vue.js 3\. We discussed the individual
    libraries and their different features in detail to foster our understanding of
    building scalable and enterprise-ready applications. We also covered the essentials
    of Vuex, discussing how to structure our large-scale Vuex store by splitting Vuex
    actions, modules, getters, and states using the split-by-feature approach.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discussed the essentials of **separation of concerns** (**SoC**) by
    using the repository pattern to split large Vuex actions into individual repositories
    and make our enterprise application maintainable. The repository pattern is essential
    in creating an enterprise application, and we demonstrated how to implement it
    in Vue 3.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we discussed how to structure Vue Router to avoid bloated and large
    router files as it will be difficult to maintain when the project becomes larger.
    We discussed strategic patterns to split the Vue Router files into different files
    to enable maintainability and ease of debugging.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deeper into scaling the performance of enterprise
    Vue 3 applications. We will explore different performance and scalability hacks
    to build an enterprise-ready Vue 3 application, such as asynchronous components’
    loading/lazy loading, tree shaking, image compression, and so on. You will learn
    how to properly increase the performance of your Vue 3 application by applying
    the tricks in the next chapter to develop large-scale applications with maintainability
    and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Large-Scale Apps and Scaling Performance in Vue.js 3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will learn best practices in building large-scale applications,
    with scalability and performance as first-class citizens. In addition, you will
    learn and explore different techniques in scaling large application performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B17237_03.xhtml#_idTextAnchor087), [*Scaling Performance in Vue.js
    3*](https://epic.packtpub.services/index.php?module=oss_Chapters&action=DetailView&record=e17b2903-7123-3af0-d559-61d6c930c89c)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B17237_04.xhtml#_idTextAnchor112), [*Architecture for Large-Scale
    Web*](https://epic.packtpub.services/index.php?module=oss_Chapters&action=DetailView&record=2a7a717b-e1bb-58f4-e12f-61d6c9e83477)
    *Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
