- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Recapping Anti-Pattern Principles
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾反模式原则
- en: In this short final chapter, we’ll briefly revisit the crucial insights from
    the book and furnish additional resources for you to delve deeper into the realm
    of React and software design.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的最后一章中，我们将简要回顾本书的关键见解，并为您提供更多资源，以便您更深入地探索React和软件设计领域。
- en: The primary objective of this book was to unearth common anti-patterns often
    encountered in React code bases, especially within large-scale React applications.
    We delved into potential remedies and techniques to rectify these issues. The
    examples throughout the narrative were drawn either from my prior projects or
    are related to domains with which developers are likely to be familiar – such
    as shopping carts, user profiles, and network requests, to name a few.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的主要目标是挖掘在React代码库中经常遇到的常见反模式，尤其是在大型React应用程序中。我们探讨了纠正这些问题的潜在补救措施和技术。叙述中的例子要么来自我的先前项目，要么与开发者可能熟悉的领域相关——例如购物车、用户资料和网络请求，仅举几例。
- en: I championed a step-by-step and incremental delivery approach, guiding you from
    an initial, less-than-ideal implementation toward a polished version, making one
    small improvement at a time. We embarked on organizing a typical React application,
    ventured into the realm of frontend testing through **test-driven development**
    (**TDD**), and initiated our journey with common refactoring techniques. Thereafter,
    we navigated the challenging waters of data/state management in React, elucidated
    common design principles, and explored compositional strategies. A slew of chapters
    were dedicated to constructing full examples from scratch, including a drop-down
    list, a shopping cart, and a weather application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我倡导一种逐步和渐进的交付方法，引导您从一个最初不太理想的实现逐步过渡到一个精炼的版本，每次只进行一点小的改进。我们开始组织一个典型的React应用程序，通过**测试驱动开发**（**TDD**）进入前端测试领域，并从常见的重构技术开始我们的旅程。此后，我们
    navigated the challenging waters of data/state management in React，阐明了常见的设计原则，并探讨了组合策略。一系列章节都是从头开始构建完整示例，包括下拉列表、购物车和天气应用程序。
- en: During this expedition, we discovered numerous handy tips, such as how to stub
    network requests in both Cypress and Jest, apply the strategy design pattern to
    a JavaScript model, and employ **Anti-Corruption Layers** (**ACLs**) in real-world
    code scenarios.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次探险中，我们发现了许多实用的技巧，例如如何在Cypress和Jest中模拟网络请求，将策略设计模式应用于JavaScript模型，以及在现实世界的代码场景中采用**反腐败层**（**ACLs**）。
- en: The techniques discussed in this book may not be groundbreaking or novel; indeed,
    many are well established. However, their application in the React ecosystem has
    remained underexplored. I earnestly hope that this book has adeptly bridged that
    gap, reintroducing these invaluable design principles and patterns to the React
    community, thereby facilitating a smoother coding experience for developers in
    the long term.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本书讨论的技术可能不是突破性的或新颖的；事实上，许多都是已经确立的。然而，它们在React生态系统中的应用尚未得到充分探索。我真诚地希望这本书已经成功地填补了这一差距，重新引入这些宝贵的原则和模式到React社区中，从而在长期内为开发者提供更流畅的编码体验。
- en: 'In this chapter, we’ll revisit the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾以下主题：
- en: Revisiting common anti-patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾常见的反模式
- en: Skimming through design patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概览设计模式
- en: Revisiting foundational design principles
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾基础设计原则
- en: Recapping techniques and practices
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾技术和实践
- en: Revisiting common anti-patterns
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾常见的反模式
- en: We explored numerous anti-patterns in the preceding chapters. Recognizing an
    anti-pattern is the initial step toward rectifying it. Let’s briefly recap what
    we’ve learned thus far.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们探讨了众多反模式。识别反模式是纠正它的第一步。让我们简要回顾一下到目前为止我们所学的知识。
- en: Props drilling
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Props钻取
- en: Props drilling emerges when a prop traverses through multiple component levels,
    only to be employed in a deeper-level component, rendering intermediate components
    unnecessarily privy to this prop. This practice can lead to convoluted and hard-to-maintain
    code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个prop穿越多个组件层级，最终在更深层次的组件中使用，导致中间组件不必要地了解这个prop时，就会产生Props钻取。这种做法可能导致代码复杂且难以维护。
- en: '*Solution*: Employing the Context API to create a central store and functions
    to access this store allows the component tree to access props when needed without
    prop-drilling.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*解决方案*：使用Context API创建一个中心存储和访问此存储的函数，允许组件树在需要时访问props，而无需prop-drilling。'
- en: Long props list/big component
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长props列表/大组件
- en: A component that accepts an extensive list of props or harbors a large amount
    of logic can become a behemoth, hard to understand, reuse, or maintain. This anti-pattern
    infringes upon the **Single Responsibility Principle** (**SRP**), which advocates
    that a component or module should only have one reason to change.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接受大量属性或包含大量逻辑的组件可能成为一个庞然大物，难以理解、重用或维护。这种反模式违反了**单一职责原则**（SRP），该原则主张组件或模块只应有一个改变的理由。
- en: '*Solution*: Dismantling the component into smaller, more digestible components
    and segregating concerns can ameliorate this issue. Each component should embody
    a clear, singular responsibility. Custom Hooks also serve as a potent means to
    simplify the code within a component and reduce its size.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*解决方案*：将组件拆分成更小、更易于消化的组件，并分离关注点可以改善这个问题。每个组件应体现一个清晰、单一的责任。自定义钩子也是简化组件内代码和减少其大小的有效手段。'
- en: Business leakage
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务泄露
- en: Business leakage transpires when business logic is implanted within components
    that should remain purely presentational, which can complicate application management
    and reduce component reusability.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当业务逻辑被植入应保持纯展示性的组件中时，就会发生业务泄露，这可能会复杂化应用管理并降低组件的可重用性。
- en: '*Solution*: Extricating business logic from presentation logic using custom
    Hooks or relocating the business logic to a separate module or layer can address
    this issue. Employing an ACL can be an effective technique to rectify this issue.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*解决方案*：使用自定义钩子或将其业务逻辑移至单独的模块或层，可以解决此问题。采用访问控制列表（ACL）可以是一种有效的技术来纠正这个问题。'
- en: Complicated logic in views
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图中的复杂逻辑
- en: The embedding of complex logic within view components can muddle the code, making
    it arduous to read, comprehend, and maintain. Views should remain as uncluttered
    as possible, solely responsible for rendering data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图组件中嵌入复杂的逻辑会使代码变得混乱，难以阅读、理解和维护。视图应尽可能保持简洁，仅负责渲染数据。
- en: '*Solution*: Relocating complex logic to custom Hooks, utility functions, or
    a separate business logic layer can help keep view components clean and manageable.
    Initially, breaking down components into smaller ones, and then gradually segregating
    the logic into appropriate places can be beneficial.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*解决方案*：将复杂逻辑移至自定义钩子、实用函数或单独的业务逻辑层，可以帮助保持视图组件的整洁和可管理性。最初，将组件分解成更小的部分，然后逐步将逻辑分离到适当的位置可能是有益的。'
- en: Lack of tests (at each level)
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺乏测试（在每个级别）
- en: The absence of adequate unit, integration, or end-to-end tests to ascertain
    application functions, as anticipated, can usher in bugs, regressions, and code
    that’s challenging to refactor or extend.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏足够的单元测试、集成测试或端到端测试来验证应用功能，正如预期的那样，可能会导致错误、回归以及难以重构或扩展的代码。
- en: '*Solution*: Adopting a robust testing strategy encompassing unit testing, integration
    testing, and end-to-end testing, coupled with practices such as TDD, can ensure
    code correctness and ease of maintenance.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*解决方案*：采用包括单元测试、集成测试和端到端测试在内的强大测试策略，结合TDD等实践，可以确保代码的正确性和易于维护。'
- en: Code duplications
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码重复
- en: Reiterating similar code across multiple components or sections of the application
    can complicate code-base maintenance and augment the likelihood of bugs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个组件或应用的多个部分中重复类似的代码会复杂化代码库的维护，并增加出现错误的可能性。
- en: '*Solution*: Adhering to the **Don’t Repeat Yourself** (**DRY**) principle and
    abstracting common functionality into shared utility functions, components, or
    Hooks can help curtail code duplication and enhance code maintainability.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*解决方案*：遵循**不要重复自己**（DRY）原则，将常见功能抽象为共享的实用函数、组件或钩子，可以帮助减少代码重复并提高代码的可维护性。'
- en: Having dissected common anti-patterns, it’s now imperative to delve into the
    design principles that act as antidotes to these prevalent issues. These principles
    not only provide solutions but also guide you toward writing cleaner, more efficient
    code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析了常见的反模式之后，现在迫切需要深入研究作为这些普遍问题解毒剂的设计原则。这些原则不仅提供了解决方案，还指导你编写更干净、更高效的代码。
- en: Skimming through design patterns
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览设计模式
- en: There are effective patterns to counter anti-patterns in React, and interestingly,
    some of these patterns extend beyond the React context, being useful in broader
    scenarios. Let’s swiftly revisit these patterns.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有有效的模式可以对抗React中的反模式，有趣的是，其中一些模式超出了React的上下文，在更广泛的场景中也有用。让我们迅速回顾这些模式。
- en: Higher-order components
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶组件
- en: '**Higher-order components** (**HOCs**) are a potent pattern in React for reusing
    component logic. HOCs are functions that accept a component and return a new component
    augmented with additional properties or behaviors. By leveraging HOCs, you can
    extract and share common behaviors across your components, aiding in mitigating
    issues such as props drilling and code duplications.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**高阶组件**（**HOCs**）是React中用于重用组件逻辑的有效模式。HOCs是接受一个组件并返回一个新组件的函数，该新组件具有额外的属性或行为。通过利用HOCs，您可以在组件之间提取和共享常见的行为，有助于减轻属性钻取和代码重复等问题。'
- en: Render props
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染属性
- en: The **render props** pattern encompasses a technique for sharing code between
    React components using a prop whose value is a function. It’s a method to pass
    a function as a prop to a component, and that function returns a React element.
    This pattern can be instrumental in alleviating issues such as long props lists
    and big components by promoting reuse and composition.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**渲染属性**模式包括一种在React组件之间通过一个值是函数的prop共享代码的技术。这是一种将函数作为prop传递给组件的方法，该函数返回一个React元素。这种模式可以通过促进重用和组合来缓解诸如长属性列表和大型组件等问题。'
- en: Headless components
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无头组件
- en: Headless components are those that manage behavior and logic but do not render
    the UI, bestowing the consumer with control over the rendering. They separate
    behavior logic from presentation logic, which can be a viable solution to business
    leakage and complicated logic in views, making components more flexible and maintainable.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 无头组件是指那些管理行为和逻辑但不渲染UI的组件，赋予消费者对渲染的控制权。它们将行为逻辑与展示逻辑分离，这可以成为解决业务泄漏和视图中的复杂逻辑的有效方案，使组件更加灵活和易于维护。
- en: Data modeling
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据建模
- en: Data modeling entails organizing and defining your data, which aids in understanding
    and managing the data within your application, thereby simplifying the logic within
    your components. This principle can be employed to tackle complicated logic in
    views and business logic leakage.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 数据建模涉及组织和定义您的数据，这有助于理解和管理您应用程序中的数据，从而简化组件内的逻辑。这个原则可以用来解决视图中的复杂逻辑和业务逻辑泄漏问题。
- en: Layered architecture
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层架构
- en: Layered architecture involves segregating concerns and organizing code such
    that each layer has a specific responsibility. This separation can lead to a more
    organized and manageable code base, addressing issues such as business leakage
    and complicated logic in views.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构涉及将关注点分离和组织代码，以便每一层都有特定的责任。这种分离可以导致更组织化和可管理的代码库，解决诸如业务泄漏和视图中的复杂逻辑等问题。
- en: 'As a reminder, *Figure 13**.1* depicts this layered architecture. In a layered
    architecture, each layer contains numerous modules, each dedicated to specific
    tasks within the overall application. This includes modules for data retrieval
    (the **Fetcher** module, shown in *Figure 13**.1*), adapters to interface with
    external services such as social media logins and payment gateways (the **Adaptor**
    gateway, shown in *Figure 13**.1*), as well as components for analytics and security-related
    functions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，*图13**.1*展示了这种分层架构。在分层架构中，每一层包含多个模块，每个模块都致力于整体应用中的特定任务。这包括用于数据检索的模块（*图13**.1*中显示的**Fetcher**模块），以及与外部服务（如社交媒体登录和支付网关）接口的适配器（*图13**.1*中显示的**Adaptor**网关），以及用于分析和安全相关功能的组件：
- en: '![Figure 13.1: Layered architecture in a React application](img/B31103_13_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1：React应用程序中的分层架构](img/B31103_13_01.jpg)'
- en: 'Figure 13.1: Layered architecture in a React application'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：React应用程序中的分层架构
- en: We conducted a comprehensive case study on this topic in [*Chapter 11*](B21103_11.xhtml#_idTextAnchor286),
    delving deeply into the evolution of the system and pinpointing the appropriate
    circumstances for applying such an architectural style.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第11章*](B21103_11.xhtml#_idTextAnchor286)中对这个主题进行了全面的案例研究，深入探讨了系统的演变，并确定了应用这种架构风格的最佳时机。
- en: Context as an interface
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文作为接口
- en: Utilizing context as an interface allows components to interact with data without
    the need to pass props down multiple levels. This strategy can alleviate props
    drilling and long props lists, rendering the component tree more readable and
    maintainable.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 利用上下文作为接口，允许组件在不需要向下传递多个层级属性的情况下与数据交互。这种策略可以减轻属性钻取和长属性列表的问题，使组件树更易于阅读和维护。
- en: With a solid grasp of foundational and design principles, it’s time to explore
    techniques that will arm you with the practical knowledge to implement these principles
    in your daily coding endeavors.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在牢固掌握基础和设计原则的基础上，是时候探索那些能让你在日常编码实践中运用这些原则的实用技术了。
- en: Revisiting foundational design principles
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾基础设计原则
- en: Besides React-specific patterns, we’ve discussed several higher-level design
    principles throughout various chapters. These principles serve as guidelines applicable
    to various aspects of your work, be it React, data modeling, event testing, or
    scripts that facilitate integration. They are not confined to a particular context,
    and embracing them can significantly enhance your coding approach across different
    domains.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了React特定的模式外，我们在各个章节中讨论了几个高级设计原则。这些原则作为指导方针，适用于你工作的各个方面，无论是React、数据建模、事件测试，还是促进集成的脚本。它们并不局限于特定情境，采纳它们可以显著提升你在不同领域的编码方法。
- en: Single Responsibility Principle
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: The SRP advocates that a class or component should only harbor one reason to
    change. Adhering to the SRP can lead to more maintainable and understandable code,
    mitigating issues such as big components and complicated logic in views.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）主张一个类或组件应该只有一个改变的理由。遵循SRP可以导致更可维护和易于理解的代码，减轻如大型组件和复杂的视图逻辑等问题。
- en: We’ve explored this principle at various levels, from carving out a smaller
    component from a larger one, to creating a new Hook, and up to significant refactoring
    such as integrating an ACL into a weather application. It’s worth noting that
    whenever you find yourself entangled within a large component, the SRP remains
    your most trustworthy ally.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从多个层面探讨了这一原则，从从较大的组件中分离出较小的组件，到创建新的Hook，再到重大的重构，如将ACL集成到天气应用中。值得注意的是，无论何时你发现自己陷入大型组件的困境，单一职责原则（SRP）始终是你最可靠的盟友。
- en: Dependency Inversion Principle
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: The **Dependency Inversion Principle** (**DIP**) emphasizes depending on abstractions,
    not concretions, which leads to a decoupling of high-level and low-level structures.
    This principle can be utilized to manage business logic leakage and promote a
    clean **separation of** **concerns** (**SoC**).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**（DIP）强调依赖于抽象，而不是具体实现，这导致高级和低级结构的解耦。这一原则可以用来管理业务逻辑泄漏，并促进清晰的**关注点分离**（SoC）。'
- en: Don't Repeat Yourself
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要重复自己
- en: The DRY principle is about minimizing repetition within code. By adhering to
    the DRY principle, you can minimize code duplication, making your code base easier
    to maintain and extend.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: DRY原则是关于最小化代码中的重复。通过遵循DRY原则，你可以最小化代码重复，使代码库更容易维护和扩展。
- en: Anti-Corruption Layers
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防腐层
- en: An ACL serves as a barrier between different parts or layers of an application,
    creating a stable interface. Implementing an ACL can be a potent strategy to manage
    business leakage and ensure a clean SoC.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ACL充当应用程序不同部分或层之间的屏障，创建一个稳定的接口。实现ACL可以是一种强大的策略来管理业务泄漏并确保清晰的SoC。
- en: 'An ACL proves to be especially beneficial when your code needs to interact
    with other systems in any capacity, a scenario that often arises when collaborating
    with different teams—a common occurrence in many setups. By establishing a clear
    system boundary through ACL, we can mitigate the impact of changes in other systems
    on our own, thereby maintaining better control over our application and alleviating
    potential integration challenges. *Figure 13**.2* illustrates how an ACL is applied
    in React:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码需要以任何方式与其他系统交互时，访问控制列表（ACL）特别有益，这种情况在与其他团队协作时经常出现——这在许多设置中是常见的。通过ACL建立清晰的系统边界，我们可以减轻其他系统变化对我们自身的影响，从而更好地控制我们的应用程序，缓解潜在的集成挑战。*图13.2*展示了如何在React中应用ACL：
- en: "![Figure\uFEFF 13.2: Applying an ACL in React](img/B31103_13_02.jpg)"
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2：在React中应用ACL](img/B31103_13_02.jpg)'
- en: 'Figure 13.2: Applying an ACL in React'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：在React中应用ACL
- en: Using composition
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用组合
- en: Composition is a core principle in React that empowers developers to build components
    from other components, promoting reuse and simplicity. Employing composition can
    alleviate various issues, including long props lists, big components, and code
    duplications, leading to a more maintainable and organized code base.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是React的核心原则之一，它赋予开发者从其他组件构建组件的能力，从而促进重用和简化。采用组合可以缓解各种问题，包括长的属性列表、大型组件和代码重复，从而使得代码库更加可维护和组织。
- en: Understanding these anti-patterns, design patterns, and principles is crucial
    for managing the complexity of a frontend code base. However, the techniques and
    practices are equally important as they represent the hands-on work developers
    engage in on a daily basis.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些反模式、设计模式和原则对于管理前端代码库的复杂性至关重要。然而，技术和实践同样重要，因为它们代表了开发者每天实际参与的工作。
- en: Recapping techniques and practices
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾技术和实践
- en: We have placed significant emphasis on the importance of testing and making
    incremental improvements. This approach not only maintains high code quality but
    also cultivates a well-rounded developer – honing critical thinking skills and
    the ability to focus on solving one problem at a time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强调了测试的重要性和逐步改进。这种方法不仅保持了高代码质量，而且培养了一位全面的开发者——磨练批判性思维技能和一次专注于解决一个问题的能力。
- en: Writing user acceptance tests
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写用户验收测试
- en: '**User acceptance testing** (**UAT**) is a pivotal part of the development
    process that ensures your application aligns with its specifications and functions
    as desired. Implementing UAT can aid in identifying issues early in the development
    process, ensuring your application is on the right trajectory.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户验收测试**（**UAT**）是开发过程中的一个关键部分，确保你的应用程序符合其规范并按预期工作。在开发早期实施 UAT 可以帮助及早发现问题，确保你的应用程序处于正确的轨道上。'
- en: 'As depicted in *Figure 13**.3*, we emphasize that tests should be written from
    the end user’s perspective, focusing on delivering customer value rather than
    on implementation details. This is especially pertinent when you commence the
    implementation of a feature at a higher level:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 13.3* 所示，我们强调测试应该从最终用户的角度编写，关注交付客户价值而不是实现细节。这在你在更高层次开始实现一个功能时尤其相关：
- en: "![F\uFEFFigure 13.3: User acceptance tests](img/B31103_13_03.jpg)"
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3：用户验收测试](img/B31103_13_03.jpg)'
- en: 'Figure 13.3: User acceptance tests'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3：用户验收测试
- en: Test-Driven Development
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: 'TDD is a software engineering technique where tests are penned before code
    that needs to be tested. The process is primarily segmented into the following
    iterative development cycles: write a test, make the test pass, and then refactor.
    TDD can significantly help in ensuring that your code base is functional and bug-free,
    addressing the lack of tests at each level.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 是一种软件工程技术，其中测试是在需要测试的代码之前编写的。这个过程主要分为以下迭代开发周期：编写测试，使测试通过，然后重构。TDD 可以显著帮助确保你的代码库是功能性的且无错误的，解决每个级别的测试不足问题。
- en: Refactoring and common code smells
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构和常见代码异味
- en: Refactoring entails enhancing the design of existing code without altering its
    external behavior. Being cognizant of common code smells and continuously refactoring
    your code can lead to a healthier, more maintainable code base. This technique
    can be instrumental in tackling issues such as code duplication, complicated logic
    in views, and business leakage, among others.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重构涉及在不改变其外部行为的情况下改进现有代码的设计。意识到常见的代码异味并持续重构你的代码可以导致更健康、更易于维护的代码库。这项技术对于解决代码重复、视图中的复杂逻辑和业务泄露等问题非常有用。
- en: Now that we’ve navigated through common anti-patterns, elucidated design principles,
    and explored techniques, it’s time to look beyond this book. The following section
    provides a list of recommended readings that will further deepen your understanding
    and hone your skills in the domain of React, TypeScript, and software design principles.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了常见的反模式，阐明了设计原则，并探讨了技术，是时候超越这本书的内容了。以下部分提供了一系列推荐阅读，这些阅读将进一步深化你对 React、TypeScript
    和软件设计原则领域的理解，并磨练你的技能。
- en: Additional resources
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: As we draw the curtains on the contents of this book, the journey toward mastering
    React and avoiding common pitfalls is far from over. The landscape of web development,
    particularly with frameworks such as React, is ever-evolving. Continuous learning
    and adaptation are the keystones of staying relevant and proficient.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们结束这本书的内容时，通往掌握 React 和避免常见陷阱的旅程还远未结束。尤其是与 React 这样的框架一起，Web 开发的领域始终在不断发展。持续学习和适应是保持相关性和熟练的关键。
- en: The following section is crafted to provide you with additional avenues for
    learning and exploration. These books are meticulously chosen to extend your understanding
    and introduce you to broader or complementary concepts in software development.
    Each book opens up a new dimension of knowledge, ensuring your growth trajectory
    remains steep and rewarding. So, as you step forward from here, let these resources
    be your companions in the continuous journey of learning and mastering the art
    of web development.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分旨在为您提供额外的学习和探索途径。这些书籍经过精心挑选，旨在扩展您的理解，并介绍软件开发中更广泛或补充的概念。每一本书都开启了一个新的知识维度，确保您的成长轨迹保持陡峭且富有成效。因此，当您从这里迈步向前时，让这些资源成为您在持续学习与掌握网络开发艺术之旅中的伴侣。
- en: 'I would like to recommend a few seminal books that can further deepen your
    understanding and appreciation of good design, architecture, and development practices
    in the realm of web applications, with a particular focus on React and TypeScript:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我想推荐几本开创性的书籍，这些书籍可以进一步深化您对网络应用领域良好设计、架构和开发实践的理解和欣赏，特别是关注React和TypeScript：
- en: '*Refactoring: Improving the Design of Existing Code* by Martin Fowler'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《重构：改善既有代码的设计》* by 马丁·福勒'
- en: Martin Fowler’s cornerstone work on refactoring is a repository of knowledge
    on how to enhance the structure of your code while preserving its functionality
    and bug-free nature. It’s a must-read for anyone aspiring to hone their refactoring
    skills.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 马丁·福勒关于重构的基石之作，是关于如何增强代码结构同时保持其功能性和无错误性的知识库。对于任何希望磨练重构技能的人来说，这是一本必读之作。
- en: '*Clean Code: A Handbook of Agile Software Craftsmanship* by Robert Martin'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《代码整洁之道》* by 罗伯特·马丁'
- en: Robert Martin’s *Clean Code* is a hallmark in the software development world.
    It delves into various practices and principles of penning clean, maintainable
    code, which is crucial for long-term success in complex projects.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 罗伯特·马丁的《代码整洁之道》是软件开发世界的一个里程碑。它深入探讨了编写整洁、可维护代码的各种实践和原则，这对于复杂项目的长期成功至关重要。
- en: '*Patterns of Enterprise Application Architecture* by Martin Fowler'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《企业应用架构模式》* by 马丁·福勒'
- en: Expand your architectural vistas with this book, which dissects various patterns
    crucial for designing robust and scalable enterprise applications. It’s a significant
    read to grasp the bigger picture of application architecture, extending beyond
    the frontend realm.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这本书，您可以扩展您的架构视野，它剖析了设计稳健和可扩展企业应用的关键模式。这是一本重要的读物，可以帮助您把握应用架构的更大图景，超越了前端领域。
- en: '*Test-Driven Development with React and TypeScript* by Juntao Qiu'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用React和TypeScript进行测试驱动开发》* by 丘俊涛'
- en: Immerse yourself in the world of TDD with a focus on React and TypeScript. This
    book navigates you through the principles of TDD and how it can markedly improve
    the quality, maintainability, and robustness of your code.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 沉浸在TDD的世界中，专注于React和TypeScript。这本书将引导您了解TDD的原则，以及它如何显著提高代码的质量、可维护性和稳健性。
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I want to extend my heartfelt gratitude for your dedication and passion for
    honing your craft and striving for technical excellence. It’s individuals such
    as you, thirsty for knowledge and improvement, that propel our industry forward.
    As you turn over this last page, remember that the journey doesn’t end here; in
    fact, it unfolds a new chapter of exploration and application in your real-world
    projects.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我想对您对磨练技艺和追求技术卓越的奉献和热情表示衷心的感谢。正是像您这样渴望知识和进步的人，推动了我们的行业向前发展。当您翻过最后一页时，请记住，旅程并没有结束；事实上，它为您在现实世界项目中的应用和探索开启了新的篇章。
- en: The essence of growth lies in the application and the continuous effort to apply
    what you’ve learned to challenge norms and strive for better solutions. This book
    aims to provide you with a solid foundation, but the real magic happens when you
    take these concepts, experiment with them, and integrate them into your daily
    work.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 成长的精髓在于应用，以及将所学知识不断应用于挑战规范和追求更好解决方案的持续努力。本书旨在为您提供坚实的基础，但真正的魔法发生在您将这些概念应用于实践、实验并将它们融入日常工作之中时。
- en: I sincerely appreciate your time spent traversing these pages and engaging with
    the material. It’s my earnest wish that you carry forward this momentum, dive
    deeper, and continue to enrich the React community with your contributions. As
    you embark on the next phase of your journey, I wish you the best of luck. May
    your code be clean, your solutions innovative, and your journey rewarding.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我衷心感谢您花时间浏览这些页面并与材料互动。我真诚地希望您能继续保持这种势头，深入研究，并继续通过您的贡献丰富 React 社区。随着您踏上旅程的下一阶段，我祝愿您好运。愿您的代码整洁，您的解决方案创新，您的旅程充满回报。
- en: Thank you, and good luck on your onward journey of continuous learning and improvement!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您，祝您在持续学习和改进的旅程中一切顺利！
