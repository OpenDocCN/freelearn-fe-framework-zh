<html><head></head><body>
  <div id="_idContainer213" class="Basic-Text-Frame">
    <h1 class="chapterNumber">24</h1>
    <h1 id="_idParaDest-282" class="chapterTitle">Showing Progress</h1>
    <p class="normal">This chapter is all about communicating progress to the user. React Native has different components that are used to handle the different types of progress that you want to communicate. First, you’ll learn why you need to communicate progress in the app. Then, you’ll learn how to implement progress indicators and progress bars. And finally, you’ll see specific examples that show you how to use progress indicators with navigation while data loads and progress bars to communicate the current position in a series of steps.</p>
    <p class="normal">The following sections are covered in this chapter: </p>
    <ul>
      <li class="bulletList">Understanding progress and usability</li>
      <li class="bulletList">Indicating progress</li>
      <li class="bulletList">Measuring progress</li>
      <li class="bulletList">Exploring navigation indicators</li>
      <li class="bulletList">Step progress</li>
    </ul>
    <h1 id="_idParaDest-283" class="heading-1">Technical requirements</h1>
    <p class="normal">You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter21"><span class="url">https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter2</span></a><span class="url">4</span>.</p>
    <h1 id="_idParaDest-284" class="heading-1">Understanding progress and usability</h1>
    <p class="normal">Imagine that you have a microwave oven that has no window and makes no sound. The only way to interact <a id="_idIndexMarker840"/>with it is by pressing a button labeled “cook.” As absurd as this device sounds, it’s what many software users face: no indication of progress. Is the microwave cooking anything? If so, how do we know when it will be done?</p>
    <p class="normal">One way to improve the microwave situation is to add a beep sound. This way, the user gets feedback after pressing the cook button. You’ve overcome one hurdle, but the user is still left asking, “When will my food be ready?” Before you go out of business, you had better add some sort of progress measurement display, such as a timer.</p>
    <p class="normal">It’s not that UI programmers don’t understand the basic principles of this usability concern; it’s just that <a id="_idIndexMarker841"/>they have stuff to do, and this sort of thing simply slips through the cracks in terms of priority. In React Native, there are components to give the user indeterminate progress feedback and precise progress measurements. It’s always a good idea to make these things a top priority if you want a good user experience.</p>
    <p class="normal">Now that you understand the role of progress in usability, it’s time to learn how to indicate progress in your React Native UIs.</p>
    <h1 id="_idParaDest-285" class="heading-1">Indicating progress</h1>
    <p class="normal">In this section, you’ll learn how to use the <code class="inlineCode">ActivityIndicator</code> component. As its name suggests, you render <a id="_idIndexMarker842"/>this component when you need to indicate to the user that something is happening. The actual progress may be indeterminate, but at least you have a standardized way to show that something is happening, despite there being no results to display yet.</p>
    <p class="normal">Let’s create an example so that you can see what this component looks like. Here’s the <code class="inlineCode">App</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-title">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title">View</span>, <span class="hljs-title">ActivityIndicator</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-native"</span>;
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">"./styles"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">App</span>() {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">View</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.container}</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">ActivityIndicator</span><span class="hljs-tag"> </span><span class="hljs-attr">size</span><span class="hljs-tag">=</span><span class="hljs-string">"large"</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">The <code class="inlineCode">&lt;ActivityIndicator /&gt;</code> component is <a id="_idIndexMarker843"/>platform-agnostic. Here’s how it looks on iOS:</p>
    <figure class="mediaobject"> <img src="../Images/B19636_24_01.png" alt="Picture 1"/></figure>
    <p class="packt_figref">Figure 24.1: An activity indicator on iOS</p>
    <p class="normal">It renders an animated spinner in the middle of the screen. This is the large spinner, as specified in the <code class="inlineCode">size</code> property. The <code class="inlineCode">ActivityIndicator</code> spinner can also be small, which makes more sense <a id="_idIndexMarker844"/>if you’re rendering it inside another smaller element. </p>
    <p class="normal">Now, let’s take a look at how this looks on an Android device:</p>
    <figure class="mediaobject"> <img src="../Images/B19636_24_02.png" alt="Picture 2"/></figure>
    <p class="packt_figref">Figure 24.2: An activity indicator on Android</p>
    <p class="normal">The spinner looks different, as it should, but your app conveys the same thing on both platforms: you’re waiting for something.</p>
    <p class="normal">This example <a id="_idIndexMarker845"/>spins forever. But don’t worry: there’s a more realistic progress indicator example coming up that shows you how to work with navigation and loading API data.</p>
    <h1 id="_idParaDest-286" class="heading-1">Exploring navigation indicators</h1>
    <p class="normal">Earlier in this chapter, you were introduced to the <code class="inlineCode">ActivityIndicator</code> component. In this section, you’ll learn how it can be used when navigating an application that loads data. For example, the user navigates from page or screen one to page two. However, page two needs <a id="_idIndexMarker846"/>to fetch data from the API that it can display to the user. So, while this network call is happening, it makes more sense to display a progress indicator instead of a screen devoid of useful information.</p>
    <p class="normal">Doing this is actually kind of tricky because you have to make sure that the data that’s required by the screen is fetched from the API each time the user navigates to the screen. Your goals should be as follows:</p>
    <ul>
      <li class="bulletList">Have the <code class="inlineCode">Navigator</code> component automatically fetch API data for the scene that’s about to be rendered.</li>
      <li class="bulletList">Use the promise that’s returned by the API call as a means to display the spinner and hide it once the promise has been resolved.</li>
    </ul>
    <p class="normal">Since your components probably don’t care about whether a spinner is displayed or not, let’s implement this as a generic <code class="inlineCode">Wrapper</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title">LoadingWrapper</span>(<span class="hljs-params">{ children }: Props</span>) {
  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title">useState</span>(<span class="hljs-literal">true</span>);
  <span class="hljs-title">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title">setLoading</span>(<span class="hljs-literal">false</span>);
    }, <span class="hljs-number">1000</span>);
  }, []);
  <span class="hljs-keyword">if</span> (loading) {
    <span class="hljs-keyword">return</span> (
      <span class="hljs-tag">&lt;</span><span class="hljs-name">View</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.container}</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;</span><span class="hljs-name">ActivityIndicator</span><span class="hljs-tag"> </span><span class="hljs-attr">size</span><span class="hljs-tag">=</span><span class="hljs-string">"large"</span><span class="hljs-tag"> /&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
    );
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> children;
  }
}
</code></pre>
    <p class="normal">This <code class="inlineCode">LoadingWrapper</code> component takes a <code class="inlineCode">children</code> component and returns it (read renders) under a <code class="inlineCode">loading</code> condition. It has a <code class="inlineCode">useEffect()</code> hook with a timeout, and when it resolves, it changes the <code class="inlineCode">loading</code> state to <code class="inlineCode">false</code>. As you can see, the <code class="inlineCode">loading</code> state determines <a id="_idIndexMarker847"/>whether the spinner or the <code class="inlineCode">children</code> component is rendered.</p>
    <p class="normal">With the <code class="inlineCode">LoadingWrapper</code> component in place, let’s take a look at the first screen component that you’ll use with <code class="inlineCode">react-navigation</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">First</span> = (<span class="hljs-params">{ navigation }: Props</span>) =&gt; (
  <span class="hljs-tag">&lt;</span><span class="hljs-name">LoadingWrapper</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">View</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.container}</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">Button</span><span class="hljs-tag"> </span><span class="hljs-attr">title</span><span class="hljs-tag">=</span><span class="hljs-string">"Second"</span><span class="hljs-tag"> </span><span class="hljs-attr">onPress</span><span class="hljs-tag">=</span><span class="hljs-string">{()</span><span class="hljs-tag"> =&gt;</span> navigation.navigate("Second")} /&gt;
      <span class="hljs-tag">&lt;</span><span class="hljs-name">Button</span><span class="hljs-tag"> </span><span class="hljs-attr">title</span><span class="hljs-tag">=</span><span class="hljs-string">"Third"</span><span class="hljs-tag"> </span><span class="hljs-attr">onPress</span><span class="hljs-tag">=</span><span class="hljs-string">{()</span><span class="hljs-tag"> =&gt;</span> navigation.navigate("Third")} /&gt;
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">LoadingWrapper</span><span class="hljs-tag">&gt;</span>
);
</code></pre>
    <p class="normal">This component renders a layout that’s wrapped with the <code class="inlineCode">LoadingWrapper</code> component we created earlier. It wraps the whole screen so that a spinner is displayed while the <code class="inlineCode">setTimeout</code> method is pending. This is a useful approach to hiding extra logic in one place and reusing it on every page. Instead of the <code class="inlineCode">setTimeout</code> method, in a real app, you can pass additional props to the <code class="inlineCode">LoadingWrapper</code> and have full control of <code class="inlineCode">loading</code> state from that screen itself.</p>
    <h1 id="_idParaDest-287" class="heading-1">Measuring progress</h1>
    <p class="normal">The downside of just indicating that progress is being made is that there’s no end in sight for the <a id="_idIndexMarker848"/>user. This leads to a feeling of unease, like when you’re waiting for food to cook in a microwave with no timer. When you know how much progress has been made and how much is left to go, you feel better. That is why it’s always better to use a deterministic progress bar whenever possible.</p>
    <p class="normal">Unlike the <code class="inlineCode">ActivityIndicator</code> component, there’s no platform-agnostic component in React Native for progress bars. So, we’ll use the <code class="inlineCode">react-native-progress</code> library for rendering progress bars.</p>
    <div class="note">
      <p class="normal">In the past, React-Native had special components for showing progress bars for iOS and Android, but due to React-Native size optimization, the Meta team is working on moving such components to separate packages. So, <code class="inlineCode">ProgressViewIOS</code> and <code class="inlineCode">ProgressBarAndroid</code> have been moved outside of the React-Native library.</p>
    </div>
    <p class="normal">Now, let’s <a id="_idIndexMarker849"/>build the <code class="inlineCode">ProgressBar</code> component that the application will use:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title">Progress</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react-native-progress"</span>;
type <span class="hljs-title">ProgressBarProps</span> = {
  <span class="hljs-attr">progress</span>: number;
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">ProgressBar</span>(<span class="hljs-params">{ progress }: ProgressBarProps</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">View</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.progress}</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">Text</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.progressText}</span><span class="hljs-tag">&gt;</span>{Math.round(progress * 100)}%<span class="hljs-tag">&lt;/</span><span class="hljs-name">Text</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">Progress.Bar</span><span class="hljs-tag"> </span><span class="hljs-attr">width</span><span class="hljs-tag">=</span><span class="hljs-string">{200}</span><span class="hljs-tag"> </span><span class="hljs-attr">useNativeDriver</span><span class="hljs-tag"> </span><span class="hljs-attr">progress</span><span class="hljs-tag">=</span><span class="hljs-string">{progress}</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">The <code class="inlineCode">ProgressBar</code> component accepts the <code class="inlineCode">progress</code> property and renders the label and progress bar. The <code class="inlineCode">&lt;Progress.Bar /&gt;</code> component accepts a set of props, but we need only <code class="inlineCode">width</code>, <code class="inlineCode">progress</code>, and <code class="inlineCode">useNativeDriver</code> (for better animation). Now, let’s put this component to use in the <code class="inlineCode">App</code> component:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title">MeasuringProgress</span>() {
  <span class="hljs-keyword">const</span> [progress, setProgress] = <span class="hljs-title">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-title">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
       <span class="hljs-keyword">let</span> <span class="hljs-attr">timeoutRef</span>: <span class="hljs-title">NodeJS</span>.<span class="hljs-property">Timeout</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">function</span> <span class="hljs-title">updateProgress</span>() {
         <span class="hljs-title">setProgress</span>(<span class="hljs-function">(</span><span class="hljs-params">currentProgress</span><span class="hljs-function">) =&gt;</span> {
        <span class="hljs-keyword">if</span> (currentProgress &lt; <span class="hljs-number">1</span>) {
          <span class="hljs-keyword">return</span> currentProgress + <span class="hljs-number">0.01</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
      });
    timeoutRef = <span class="hljs-built_in">setTimeout</span>(updateProgress, <span class="hljs-number">100</span>);
    }
    <span class="hljs-title">updateProgress</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      timeoutRef &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(timeoutRef);
    };
  }, []);
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">View</span><span class="hljs-tag"> </span><span class="hljs-attr">style</span><span class="hljs-tag">=</span><span class="hljs-string">{styles.container}</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">ProgressBar</span><span class="hljs-tag"> </span><span class="hljs-attr">progress</span><span class="hljs-tag">=</span><span class="hljs-string">{progress}</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">View</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">Initially, the <code class="inlineCode">&lt;ProgressBar&gt;</code> component is rendered at 0%. In the <code class="inlineCode">useEffect()</code> hook, the <code class="inlineCode">updateProgress()</code> function uses <a id="_idIndexMarker850"/>a timer to simulate a real process that you want to show the progress of. </p>
    <div class="note">
      <p class="normal">In the real world, you’ll probably never use a simulation of timers. However, there are specific scenarios where this approach might be valuable, such as when displaying statistical data or monitoring the progress of file uploads to servers. In these situations, even though you’re not relying on a direct timer, you will still have access to a current progress value that you can use.</p>
    </div>
    <p class="normal">Here’s what the screen looks like:</p>
    <figure class="mediaobject"> <img src="../Images/B19636_24_03.png" alt="Picture 3"/></figure>
    <p class="packt_figref">Figure 24.3: The progress bar</p>
    <p class="normal">Showing a quantitative <a id="_idIndexMarker851"/>measure of progress is important so that users can gauge how long something will take. In the next section, you’ll learn how to use step progress bars to show the user where they are in terms of navigating screens.</p>
    <h1 id="_idParaDest-288" class="heading-1">Step progress</h1>
    <p class="normal">In this final example, you’ll build an app that displays the user’s progress through a predefined number of steps. For example, it might make sense to split a form into several logical <a id="_idIndexMarker852"/>sections and organize them in such a way that, as the user completes one section, they move to the next step. A progress bar would be helpful feedback for the user.</p>
    <p class="normal">You’ll insert a progress bar into the navigation bar, just below the title, so that the user knows how far they’ve gone and how far is left to go. You’ll also reuse the <code class="inlineCode">ProgressBar</code> component that you used earlier in this chapter.</p>
    <p class="normal">Let’s take a look at the result first. There are four screens in this app that the user can navigate. Here’s what the <strong class="screenText">First</strong> page (scene) looks like:</p>
    <figure class="mediaobject"><img src="../Images/B19636_24_04.png" alt="Picture 4"/> </figure>
    <p class="packt_figref">Figure 24.4: The first screen</p>
    <p class="normal">The progress <a id="_idIndexMarker853"/>bar under the title reflects the fact that the user is 25% through the navigation. Let’s see what the <strong class="screenText">Third</strong> screen looks like:</p>
    <figure class="mediaobject"><img src="../Images/B19636_24_05.png" alt="Picture 5"/> </figure>
    <p class="packt_figref">Figure 24.5: The third screen</p>
    <p class="normal">The progress is <a id="_idIndexMarker854"/>updated to reflect where the user is in the route stack. Let’s take a look at the <code class="inlineCode">App</code> component here: <a href="https://github.com/PacktPublishing/React-and-React-Native-5E/blob/main/Chapter21/step-progress-new/App.tsx"><span class="url">https://github.com/PacktPublishing/React-and-React-Native-5E/blob/main/Chapter21/step-progress-new/App.tsx</span></a>.</p>
    <p class="normal">This app has four screens. The components that render each of these screens are stored in the <code class="inlineCode">routes</code> constant, which is then used to configure the stack navigator using <code class="inlineCode">createNativeStackNavigator()</code>. The reason for creating the <code class="inlineCode">routes</code> array is so that it can be used by the <code class="inlineCode">progress</code> parameter that is passed by <code class="inlineCode">initialParams</code> to every route. To calculate the progress, we take the current route index as a value of the route’s length. </p>
    <p class="normal">For example, <code class="inlineCode">Second</code> is in the number 2 position (an index of 1 + 1) and the length of the <a id="_idIndexMarker855"/>array is 4. This will set the progress bar to 50%.</p>
    <p class="normal">Also, the <strong class="screenText">Next</strong> and <strong class="screenText">Previous</strong> buttons’ calls to <code class="inlineCode">navigation.navigate()</code> have to pass <code class="inlineCode">routeName</code>, so we added the <code class="inlineCode">nextRouteName</code> and <code class="inlineCode">prevRouteName</code> variables to the <code class="inlineCode">screenOptions</code> handler.</p>
    <p class="Heading">Summary</p>
    <p class="normal">In this chapter, you learned how to show your users that something is happening behind the scenes. First, we discussed why showing progress is important for the usability of an application. Then, we implemented a basic screen that indicated progress was being made. After that, we implemented a <code class="inlineCode">ProgressBar</code> component, which is used to measure specific progress amounts.</p>
    <p class="normal">Indicators are good for indeterminate progress. We implemented navigation that showed progress indicators while network calls were pending. In the final section, we implemented a progress bar that showed the user where they were in a predefined number of steps.</p>
    <p class="normal">In the next chapter, we’ll look at React Native maps and geolocation data in action.</p>
  </div>
</body></html>