- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Creating a Router-First Line-of-Business App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建以路由器为第一线的业务应用
- en: '**Line-of-Business** (**LOB**) applications are the bread and butter of the
    software development world. As defined on Wikipedia, LOB is a general term that
    refers to a product or a set of related products that serve a particular customer
    transaction, or business need. LOB apps present an excellent opportunity to demonstrate
    a variety of features and functionality, without getting into the contorted or
    specialized scenarios that large enterprise applications usually need to address.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**业务线应用**（**LOB**）是软件开发世界的核心。如维基百科所定义，LOB是一个通用术语，指的是一个或一系列相关产品，它们服务于特定的客户交易或业务需求。LOB应用提供了展示各种功能和特性的绝佳机会，而无需涉及大型企业应用通常需要解决的扭曲或专业场景。'
- en: The Pareto principle, also known as the 80-20 rule, states that we can accomplish
    80% of our goals with 20% of the overall effort. We will be applying the 80-20
    rule to the design and architecture of our LOB app. Given the common use cases
    LOB apps cover, they are, in a sense, perfect for the 80-20 learning experience.
    With only 20% of the effort, you can learn about 80% of the things you will need
    to deliver high-quality experiences to your users.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 帕累托原则，也称为80-20法则，表明我们可以用总体努力的20%完成80%的目标。我们将把80-20法则应用于我们的业务应用的设计和架构。鉴于业务应用覆盖的常见用例，它们在某种程度上非常适合80-20的学习体验。只需付出20%的努力，你就可以了解80%你需要知道的事情，以便为用户提供高质量的用户体验。
- en: LOB apps have a curious property to them. If you end up building a semi-useful
    app, the demand for it grows, uncontrollably, and you quickly become the victim
    of your success. It's challenging to balance the architectural needs of a project;
    you want to avoid potentially devastating under-engineering and, on the flip side,
    also avoid costly over-engineering for an app that will never need it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 业务应用有一个奇特的特点。如果你最终构建了一个半有用的应用，对其的需求将不受控制地增长，你很快就会成为你成功的受害者。平衡项目的架构需求是一项挑战；你想要避免潜在的毁灭性低工程，同时，在另一方面，也避免为永远不会需要它的应用进行昂贵的过度工程。
- en: In this chapter, I'm going to introduce you to router-first architecture, the
    80-20 design solution to address the challenges of delivering a modern web application
    in an incremental and iterative manner.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向你介绍路由器优先架构，80-20设计解决方案，以增量迭代的方式解决交付现代Web应用所面临的挑战。
- en: As you read in *Chapter 1*, *Introduction to Angular and Its Concepts*, software
    architecture doesn't stay static. It's essential to experiment with new ideas
    by using coding-katas, proofs-of-concept apps, and reference projects, to get
    better at creating more flexible architectures.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在*第一章*，*Angular及其概念简介*中阅读的那样，软件架构不会保持静止。通过使用编码练习、概念验证应用和参考项目来实验新想法，对于提高创建更灵活架构的能力是至关重要的。
- en: In this and the remaining chapters of the book, we'll set up a new application
    with rich features that can meet the demands of an LOB application with a scalable
    architecture and engineering best practices that will help you start small and
    be able to grow your solution quickly if there's demand. We will follow the Router-first
    design pattern, relying on reusable components to create a grocery store LOB named
    LemonMart. We'll discuss the idea of designing around major data entities, and
    the importance of completing high-level mock-ups for your application before you
    start to implement various conditional navigation elements, which may change significantly
    during the design phase.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和本书剩余的章节中，我们将设置一个具有丰富功能的新应用，它可以满足具有可扩展架构和工程最佳实践的业务应用需求。这将帮助你从小规模开始，并在有需求时能够快速扩展你的解决方案。我们将遵循路由器优先的设计模式，依靠可重用组件来创建一个名为LemonMart的杂货店业务应用。我们将讨论围绕主要数据实体进行设计的理念，以及在开始实现各种条件导航元素之前完成高级原型的重要性，这些元素在设计阶段可能会发生重大变化。
- en: 'In this chapter, you will learn to do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Apply the 80-20 solution to software development
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将80-20解决方案应用于软件开发
- en: Learn how to build router-first apps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何构建路由器优先的应用
- en: Begin your creation of the LemonMart app you'll expand over the remainder of
    this book
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始创建你将在本书剩余部分扩展的LemonMart应用
- en: Create effective branding, as well as custom and material iconography
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建有效的品牌，以及定制和材料图标
- en: Achieve sub-second first-paint with lazy loading
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用懒加载实现亚秒级首次绘制
- en: Create a walking skeleton
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个行走骨架
- en: Reduce repetition using a common testing module
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用公共测试模块减少重复
- en: Design around major data entities
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕主要数据实体进行设计
- en: Recognize the importance of high-level UX design
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识到高级用户体验设计的重要性
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the following linked repository. The repository contains the final and completed
    state of the code. You can verify your progress at the end of this chapter by
    looking for the end-of-chapter snapshot of code under the `projects` folder.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书样本代码的最新版本可在以下链接的 GitHub 存储库中找到。该存储库包含代码的最终和完成状态。您可以在本章结束时通过查找 `projects` 文件夹下的代码章节快照来验证您的进度。
- en: '*For Chapter 7*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*第七章*：'
- en: Clone the repo [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart
    )
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆存储库 [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
- en: Execute `npm install` on the root folder to install dependencies
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下执行 `npm install` 以安装依赖项
- en: 'The code sample for this chapter is under the sub-folder:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该章节的代码示例位于子文件夹：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run the Angular app for this chapter, execute:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的 Angular 应用程序，请执行以下操作：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To run Angular unit tests for this chapter, execute:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的 Angular 单元测试，请执行以下操作：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To run Angular e2e tests for this chapter, execute:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行本章的 Angular e2e 测试，请执行以下操作：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To build a production-ready Angular app for this chapter, execute:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为本章构建一个生产就绪的 Angular 应用程序，请执行以下操作：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the `dist/ch7` folder at the root of the repository will contain the
    compiled result.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，存储库根目录下的 `dist/ch7` 文件夹将包含编译结果。
- en: Beware that the source code in the book or on GitHub may not always match the
    code generated by the Angular CLI. There may also be slight differences in implementation
    between the code in the book and what's on GitHub, because the ecosystem is ever-evolving.
    It is natural for the sample code to change over time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，书中或 GitHub 上的源代码可能并不总是与 Angular CLI 生成的代码相匹配。由于生态系统不断演变，书中代码与 GitHub 上的代码在实现上可能存在细微差异。随着时间的推移，样本代码发生变化是自然的。
- en: Also, on GitHub, expect to find corrections, fixes to support newer versions
    of libraries, or side-by-side implementations of multiple techniques for you to
    observe. You are only expected to implement the ideal solution recommended in
    the book. If you find errors or have questions, please create an issue or submit
    a pull request on GitHub for the benefit of all readers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 GitHub 上，您可以期待找到更正、修复以支持库的新版本，或者观察多种技术的并行实现。您只需实现书中推荐的理想解决方案。如果您发现错误或有疑问，请为所有读者创建一个
    GitHub 上的问题或提交一个拉取请求。
- en: You may read more about updating Angular in *Appendix C*, *Keeping Angular and
    Tools Evergreen*. You can find this appendix online from [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)
    or at [https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *附录 C* 中了解更多关于更新 Angular 的信息，即 *保持 Angular 和工具常青*。您可以从 [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)
    或 [https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen)
    在线找到此附录。
- en: Let's start by covering the philosophy behind the design and architecture of
    our apps.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解我们应用程序设计和架构背后的哲学开始。
- en: The 80-20 solution
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 80-20 解决方案
- en: 'Whether we develop apps at home, for passion projects, or at the office, for
    work, we must remain mindful of our purpose: to deliver value. If we don''t deliver
    value with our passion projects, then we won''t feel fulfilled or happy. If we
    fail to deliver value at work, we may not get paid.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是在家开发应用程序、出于激情项目，还是在办公室工作，我们都必须保持清醒的头脑：我们的目的是提供价值。如果我们不能通过我们的激情项目提供价值，那么我们不会感到满足或快乐。如果我们无法在工作场所提供价值，我们可能得不到报酬。
- en: 'Delivering a modern web application is difficult. There are numerous challenges
    that we need to overcome to be successful:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 提供现代网络应用程序是困难的。我们需要克服许多挑战才能成功：
- en: Deliver iteratively and incrementally
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步迭代交付
- en: Be scalable
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有可扩展性
- en: Serve dozens of screen and input types
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持数十种屏幕和输入类型
- en: Be usable
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于使用
- en: Be accessible
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于访问
- en: Manage a team
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理一个团队
- en: Groom a prioritized backlog
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整理优先级较高的待办事项列表
- en: Ensure acceptance criteria are clear, concise, and concrete
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保验收标准清晰、简洁、具体
- en: If you've ever led a project or tried to implement and deliver a project on
    your own, you'll have realized that there's just never enough time and resources
    to cover the wide variety of stakeholder, team, and technical needs on any given
    project. Remember that the Pareto principle, also known as the 80-20 rule, implies
    that we can accomplish 80% of our goals with 20% of the overall effort.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经领导过一个项目或者尝试过独立实施并交付一个项目，你就会意识到在任何特定项目中，时间和资源总是不足以覆盖广泛的利益相关者、团队和技术需求。记住帕累托法则，也称为80-20法则，它意味着我们可以用总体努力的20%完成80%的目标。
- en: If we apply the 80-20 rule to our work, we can maximize our output, quality,
    and happiness. Line-of-business applications are the bread and butter of our industry.
    Applying the 80-20 rule, we can surmise that most of us are likely to earn most
    of our income by delivering such applications. Therefore, we should keep our engineering
    overhead to a minimum, and reduce the delivery risk of our project. By limiting
    experimentation in production code, we create a predictable environment for our
    team members, and only introduce changes that we had a chance to vet in proof-of-concept
    or small apps.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将80-20法则应用于我们的工作，我们可以最大化我们的产出、质量和幸福感。业务线应用是我们行业的核心。应用80-20法则，我们可以推断出我们中的大多数人很可能通过交付这样的应用来赚取大部分收入。因此，我们应该将我们的工程开销保持在最低，并减少项目的交付风险。通过限制生产代码中的实验，我们为团队成员创造了一个可预测的环境，并且只引入我们在概念验证或小型应用中有机会审查过的变化。
- en: Our 80-20 strategy, combined with discipline, can help us deliver the same project
    in the same time with more features and better quality. By treating our careers
    as marathons and not a series of sprints, you can find yourself in a position
    of delivering high-quality solutions, project after project, without feeling burned
    out.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的80-20策略，结合纪律，可以帮助我们在相同的时间内交付相同的项目，拥有更多功能和更好的质量。将我们的职业生涯视为马拉松而不是一系列冲刺，你可以发现自己处于一个不断交付高质量解决方案、项目接项目的位置，而不会感到疲惫不堪。
- en: Understanding Line-of-Business apps
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解业务线应用
- en: 'Line-of-business applications are, according to Wikipedia, a "set of critical
    computer applications perceived as vital to running an enterprise." LOB apps are
    what most developers end up developing, even though we may think we develop small
    apps or large enterprise apps. Consider the following illustration, which demonstrates
    the kinds of apps we might develop, placed on an axis relative to their size and
    scope:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科，业务线应用是一组“被认为对运营企业至关重要的关键计算机应用。”业务线应用是大多数开发者最终会开发的应用，即使我们可能认为我们开发的是小型应用或大型企业应用。考虑以下插图，它展示了我们可能开发的应用类型，这些应用根据其规模和范围放置在轴上：
- en: '![](img/B14094_07_01.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_07_01.png)'
- en: 'Figure 7.1: Relative size and scope of four kinds of apps'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：四种类型应用的大小和范围相对关系
- en: 'From my perspective, we think about four kinds of apps when we begin developing
    software:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从我的角度来看，当我们开始开发软件时，我们会考虑四种类型的应用：
- en: Small apps
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型应用
- en: LOB apps
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务线应用
- en: Large enterprise apps
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型企业应用
- en: Billion user scale apps
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亿级用户规模的应用
- en: Billion user scale apps are completely niche implementations that rarely have
    needs that align with the vast majority of apps that are out there. For this reason,
    we must classify these apps as outliers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 亿级用户规模的应用是完全的细分市场实现，很少需要与大量现有应用的需求相匹配。因此，我们必须将这些应用归类为异常值。
- en: Small apps start small. Architecturally, they're likely to be initially under-engineered.
    As you add features and team members to work on a small app, at some point, you're
    going to run into trouble. As your team size and feature set grow, or the overall
    complexity of the app increases, the architectural needs of the application grow
    exponentially.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 小型应用从小开始。在架构上，它们很可能是最初设计不足的。随着你向小型应用添加功能和团队成员，在某个时候，你将会遇到麻烦。随着你的团队规模和功能集的增长，或者应用的总体复杂性增加，应用的架构需求呈指数增长。
- en: 'Once you cross the inflection point of the amount of complexity your architecture
    can bear, you''re left with a costly reengineering effort to get back on track.
    See the following graph, illustrating this idea:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你超过了你的架构能够承受的复杂性的拐点，你就只剩下了一个昂贵的重构努力来回到正轨。参见以下图表，说明了这个概念：
- en: '![](img/B14094_07_02.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_07_02.png)'
- en: 'Figure 7.2: Architectural journey of a small app'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：小型应用的架构之旅
- en: 'The area under the feature line represents under-engineering, which introduces
    risk to your project. The area above the feature line shows the required engineering
    overhead to support the features needed. In comparison, large enterprise apps
    start with a massive over-engineering effort, as shown in the following diagram:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 特性线下的区域代表过度简化，这会给你的项目带来风险。特性线上的区域显示了支持所需功能所需的工程开销。相比之下，大型企业应用从大规模的过度工程努力开始，如下面的图所示：
- en: '![](img/B14094_07_03.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_07_03.png)'
- en: 'Figure 7.3: Architectural journey of a large enterprise app'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：大型企业应用的架构之旅
- en: As time goes on and the overall complexity of the system increases, large enterprise
    apps can also face a similar inflection point, where the original architecture
    can become inadequate. With careful planning and management, you can avoid trouble
    and protect the significant initial investment made. Such large enterprise apps
    require hundreds of developers, with multiple levels of managers and architects,
    to execute successfully. Similar to billion-user scale apps, these apps can also
    have niche architectural needs. In between the small apps and the large enterprise
    apps that we develop lie LOB apps.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移和系统整体复杂性的增加，大型企业应用也可能面临一个类似的转折点，此时原始架构可能变得不足。通过仔细规划和管理工作，你可以避免麻烦并保护所做出的重大初始投资。这类大型企业应用需要数百名开发者，以及多个级别的经理和架构师来成功执行。与亿级用户规模的应用类似，这些应用也可能有特定的架构需求。在我们开发的小型应用和大型企业应用之间，存在着LOB应用。
- en: '![](img/B14094_07_04.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_07_04.png)'
- en: 'Figure 7.4: Dynamic nature of software evolution'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：软件演变的动态性
- en: As shown in the preceding diagram, small apps can grow and morph into LOB apps,
    and large enterprise apps can become under-utilized as users ignore the features
    that they never need, but keep the app to serve a singular purpose as a LOB app.
    In either case, despite our best efforts, we ultimately end up delivering an inefficient
    solution for the problem we're solving. None of us have a crystal ball to see
    the future, and planning and engineering can only do so much for us in an unpredictable
    business setting; we need to rely on the 80-20 rule to come up with an architecture
    that is flexible to change, but adequate to meet most business requirements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，小型应用可以增长并转变为LOB应用，而大型企业应用可能会因为用户忽视他们从未需要的功能而未被充分利用，但仍然作为LOB应用服务于单一目的。在任何情况下，尽管我们尽了最大努力，但我们最终可能为解决我们的问题提供了一个低效的解决方案。我们都没有水晶球来预见未来，规划和工程在不可预测的商业环境中只能为我们做这么多；我们需要依靠80-20规则来制定一个灵活且能够满足大多数商业需求的架构。
- en: Router-first architecture aims to maintain optimal architectural overhead, so
    that in the rush to deliver all required features, costly re-engineering or late-stage
    crunch can be avoided. Let's see how.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以路由器为首要架构的目标是保持最佳架构开销，以便在匆忙交付所有必需功能时，可以避免昂贵的重新工程或后期冲刺。让我们看看如何做到这一点。
- en: Disciplined and balanced approach
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严谨和平衡的方法
- en: We covered the *what* of software development, but we must also consider the
    *why*, *when*, *where*, and *who*, before we can get to the *how*. When we develop
    apps for learning or passion projects, we usually end up under-engineering our
    projects. If your passion project somehow becomes an overnight success, then it
    becomes costly to maintain or keep adding features to your app. In this case,
    you're likely to face a choice to either bear the cost of ongoing maintenance,
    or rewrite your application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了软件开发中的“是什么”，但我们必须考虑“为什么”、“何时”、“何地”和“谁”，然后我们才能到达“如何”。当我们为学习或激情项目开发应用时，我们通常会过度简化我们的项目。如果你的激情项目意外地一夜成名，那么维护或继续添加应用功能可能会变得成本高昂。在这种情况下，你可能会面临一个选择，即承担持续维护的成本，或者重写你的应用程序。
- en: When we develop apps for work, we tend to be more conservative, and we're likely
    to over-engineer our solution. However, if you only code for work, then you're
    likely to experiment in production-bound code. It is dangerous to experiment in
    a codebase with other team members. You may be introducing a new pattern, without
    your team understanding the consequences of your choices. You're also less likely
    to be aware of mid-to long-term risks or benefits of the technologies you are
    introducing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们为工作开发应用时，我们往往更加保守，我们可能会过度工程我们的解决方案。然而，如果你只为工作编码，那么你可能会在生产代码中进行实验。在与其他团队成员共享的代码库中进行实验是危险的。你可能会引入一种新的模式，而你的团队可能不了解你选择的结果。你也不太可能意识到你引入的技术在中等或长期风险或收益。 '
- en: Reckless experimentation can also have a severe negative impact on your team
    members. In a team of senior and experienced software engineers, you can likely
    get away with experimenting in a moving car. However, we are likely to have team
    members of varying backgrounds and learning styles on our teams. Some of us have
    computer science degrees, some of us are lone wolves, and some of us depend a
    bit too much on Stack Overflow. Some of us work at companies that are great at
    supporting professional growth, but some of us work at places that won't even
    give you a day to learn something new. So, when we are experimenting, we must
    consider our environment; otherwise we can cause our colleagues to work overtime or
    feel helpless and frustrated.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 草率实验也可能对您的团队成员产生严重的负面影响。在一个由资深和经验丰富的软件工程师组成的团队中，您可能在移动车辆中进行实验。然而，我们团队中可能有着不同背景和学习风格的成员。我们中的一些人有计算机科学学位，一些人是独行侠，一些人对Stack
    Overflow过于依赖。我们中的一些人在支持职业发展的公司工作，但一些人在不会给您一天时间学习新东西的地方工作。因此，当我们进行实验时，我们必须考虑我们的环境；否则，我们可能会让我们的同事加班或感到无助和沮丧。
- en: 'With a disciplined and balanced approach, we can reduce the number of bugs
    delivered, avoid costly rework, and work with a group of people who are all moving
    in the same direction. We also need the right architecture, tools, and patterns/practices
    to deliver successfully. In summary, our approach must consider:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 采用有纪律和平衡的方法，我们可以减少交付的缺陷数量，避免昂贵的返工，并与所有朝同一方向前进的人一起工作。我们还需要正确的架构、工具和模式/实践来成功交付。总之，我们的方法必须考虑：
- en: The size of our app
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应用的大小
- en: The reason we are developing the app
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们开发应用的原因
- en: The skill level of developers
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者的技能水平
- en: Iterative and incremental delivery
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代和增量交付
- en: Constant forward flow of features
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性的持续向前流动
- en: All the cloud things
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有云相关事物
- en: 'Ideally, we need to maintain optimal engineering overhead. Our architecture
    should support our short-term needs while being extensible, so we can pivot in
    different directions if our mid-or long-term needs change without having to rewrite
    large swaths of code. Consider the following diagram, in contrast to the ones
    about small and large enterprise apps in the previous section:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们需要保持最佳工程开销。我们的架构应该支持我们的短期需求，同时具有可扩展性，这样我们就可以在长期或中期需求发生变化时，无需重写大量代码，而在不同方向上进行调整。考虑以下图表，与上一节中关于小型和大型企业应用的图表进行对比：
- en: '![](img/B14094_07_05.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_07_05.png)'
- en: 'Figure 7.5: Ideal architectural journey of a LOB app'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：LOB应用的理想架构之旅
- en: Router-first architecture aims to help you find the balance in the engineering
    overhead, feature delivery, and flexibility of your codebase. However, you must
    bring the discipline yourself.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以路由器优先的架构旨在帮助您在工程开销、功能交付和代码库的灵活性之间找到平衡。然而，你必须自己带来纪律。
- en: '![](img/B14094_07_003.png) or Shu Ha Ri is a concept that can help bring discipline
    to your work. It is a way of thinking that instructs you first to master the basics
    without worrying about the underlying theory, then master the theory, and finally
    be able to adapt what you mastered to your needs. However, if you skip steps 1
    or 2, you are going to find yourself adapting the wrong thing in the wrong way.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/B14094_07_003.png) 或 Shu Ha Ri 是一个可以帮助您在工作中建立纪律的概念。这是一种思维方式，指导您首先掌握基础知识，而不必担心底层理论，然后掌握理论，最后能够根据您的需求调整您所掌握的内容。然而，如果您跳过步骤1或2，您可能会发现自己以错误的方式调整了错误的内容。'
- en: Having covered the *what*, *why*, *when*, *where*, and *who*, let's jump into
    the *how* in the next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了*什么*、*为什么*、*何时*、*何地*和*谁*之后，让我们在下一节中跳入*如何*。
- en: Router-first architecture
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器优先架构
- en: 'Router-first architecture is a way to:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器优先架构是一种方法：
- en: '**Enforce** high-level thinking'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制**进行高级思维'
- en: '**Ensure** consensus on features, *before* you start coding'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保**在开始编码之前就功能达成共识'
- en: '**Plan** for your codebase/team to grow'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规划**您的代码库/团队的增长'
- en: '**Introduce** little engineering overhead'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引入**小的工程开销'
- en: 'There are seven steps to implementing router-first architecture:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实施路由器优先架构的七个步骤：
- en: Develop a roadmap and scope (*Chapter 7*)
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制定路线图和范围（*第7章*）
- en: Design with lazy loading in mind (*Chapter 7*)
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑懒加载进行设计（*第7章*）
- en: Implement a walking-skeleton navigation experience (*Chapter 7*)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实施步行骨架导航体验（*第7章*）
- en: Achieve a stateless, data-driven design (*Chapters 7* and *10*)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现无状态、数据驱动的架构（*第7章*和*第10章*）
- en: Enforce a decoupled component architecture (*Chapters 8*, *11*, and *12*)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强制采用解耦的组件架构（*第8章*、*第11章*和*第12章*）
- en: Differentiate between user controls and components (*Chapter 11*)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 区分用户控件和组件（*第11章*）
- en: Maximize code reuse with TypeScript and ES features (*Chapters 8*, *10*, *11*,
    and *12*)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用TypeScript和ES功能最大化代码复用（*第8章*、*第10章*、*第11章*和*第12章*）
- en: Each step will be covered in more detail in this and coming chapters, as noted
    previously. Before we go over these steps at a high level, let's first cover feature
    modules in Angular, which are an important fundamental technical concept.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个步骤将在本章和后续章节中更详细地介绍。在我们从高层次概述这些步骤之前，让我们首先介绍Angular中的功能模块，这是一个重要的基本技术概念。
- en: Feature modules
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能模块
- en: In *Chapter 1*, *Introduction to Angular and Its Concepts*, we covered Angular's
    architecture at a high level and introduced the concepts of lazy loading and routing.
    Feature modules are a key component in implementing lazy loading. There are two
    kinds of modules, the root module and feature modules. Modules are implemented
    by the class `NgModule`. An `NgModule` contains all the necessary metadata to
    render components and inject services. A component without a module doesn't do
    much.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章*，*Angular及其概念简介*中，我们以高层次介绍了Angular的架构，并介绍了懒加载和路由的概念。功能模块是实现懒加载的关键组件。有两种类型的模块：根模块和功能模块。模块通过`NgModule`类实现。`NgModule`包含渲染组件和注入服务所需的所有必要元数据。没有模块的组件几乎不起作用。
- en: 'An Angular application is defined by an `NgModule` that sits at the root of
    the application. This is called the root module. The root module is responsible
    for rendering what appears in the `<app-root>` element in your `index.html` file.
    Locate the root module in the following diagram:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Angular应用程序由一个位于应用程序根部的`NgModule`定义。这被称为根模块。根模块负责渲染`index.html`文件中的`<app-root>`元素中显示的内容。在以下图中定位根模块：
- en: '![](img/B14094_07_06.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_07_06.png)'
- en: 'Figure 7.6: Major architectural components of Angular'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：Angular的主要架构组件
- en: An NgModule can contain many other NgModules. An Angular app only has one root
    module, so by definition every other NgModule becomes a feature module. In the
    preceding diagram, you can see that you can organize a group of components (**Cmp**)
    and services (**Svc**) into feature modules. Grouping functionality into modules
    allows us to organize our code into chunks, which can be separated from the initial
    payload of our application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个NgModule可以包含许多其他NgModules。Angular应用程序只有一个根模块，因此根据定义，每个其他NgModule都成为功能模块。在前面的图中，你可以看到可以将一组组件（**Cmp**）和服务（**Svc**）组织到功能模块中。将功能分组到模块中允许我们将代码组织成块，这些块可以与应用程序的初始负载分离。
- en: This idea of root and feature modules represents a parent/child relationship,
    which is a concept that extends to other functionality and frameworks. For example,
    note that the preceding diagram injects a root router into the root module. A
    root router can have child routes. Child routes can be configured to load feature
    modules. Similarly, NgRx has root and feature module-level stores to organize
    the state data of your application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 根模块和功能模块的概念代表了父/子关系，这是一个扩展到其他功能和框架的概念。例如，注意前面的图中将根路由注入到根模块中。根路由可以有子路由。子路由可以配置为加载功能模块。同样，NgRx有根模块和功能模块级别的存储来组织应用程序的状态数据。
- en: 'For all intents and purposes, any mention of a sub-module, child module, or
    a feature module in this book refers to the same thing: a module that is not the
    root module.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就本书而言，任何提及的子模块、子模块或功能模块都指的是同一件事：不是根模块的模块。
- en: Feature modules and child routes allows for a separation of concerns between
    major components of your application. Two teams can work on two different modules
    without interfering with each other. This separation means that any dependency
    required by a feature module must be explicitly added to the imports, declarations,
    or providers of that module. This can seem repetitive and annoying, when sharing
    code between modules, but it is a necessary evil.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 功能模块和子路由允许将应用程序的主要组件之间的关注点分离。两个团队可以同时工作在不同的模块上，而不会相互干扰。这种分离意味着任何功能模块所需的依赖项都必须明确添加到该模块的导入、声明或提供者中。当在模块之间共享代码时，这可能会显得重复且令人烦恼，但这是必要的恶行。
- en: In Angular, by default, services are singletons – one instance per module. Before
    importing a service that's already imported to the root module into a feature
    module, consider if this is truly the desired behavior. A service that is provided
    in the root module is available to be imported in a feature module without needing
    to be provided again. Providing a service in the root and feature modules will
    result in having multiple instances of that service in memory, which breaks your
    expectation that, by default, services are singletons. In *Chapter 8*, *Designing
    Authentication and Authorization*, you will see this in action when we implement
    the `AuthService`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，默认情况下，服务是单例的——每个模块一个实例。在将已导入根模块的服务导入功能模块之前，考虑这是否真的是期望的行为。在根模块中提供的服务可以在功能模块中导入，而无需再次提供。在根模块和功能模块中提供服务会导致内存中有多个该服务的实例，这打破了默认情况下服务是单例的预期。在*第8章*，*设计身份验证和授权*中，当我们实现`AuthService`时，你将看到这一行为的具体实现。
- en: 'With the introduction of the Ivy rendering engine in Angular 9, the road is
    paved to create self-describing components. Self-describing components do not
    need an NgModule to be useful. With future versions of Angular it will be possible
    to implement simple apps without the whole ceremony (read: boilerplate code) of modules.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Angular 9中Ivy渲染引擎的引入，创建自描述组件的道路已经铺平。自描述组件不需要NgModule就能发挥作用。随着Angular未来版本的推出，将能够实现无需整个仪式（即：样板代码）的简单应用。
- en: Now, let's go over the seven steps of router-first architecture at a high level.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从高层次上概述一下路由优先架构的七个步骤。
- en: Developing a roadmap and scope
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制定路线图和确定范围
- en: Developing a roadmap and establishing the scope of your project early on is
    critical to getting the high-level architecture right. Creating a backlog, wireframes,
    mock-ups and interactive prototypes will help you define the map before getting
    on the road and capture the vision concretely. It is important to remember to
    bring tools only when necessary. Don't start with Photoshop, when a piece of paper
    and a pencil will do. If stakeholders and team members understand what is being
    developed, then it will be possible to deliver your solution iteratively and incrementally.
    However, don't fall into the perfection trap. Save the tweaking and furniture
    rearranging for after the fundamentals are in place and agreed upon.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目早期就制定路线图和确定项目范围对于确保高级架构的正确性至关重要。创建待办事项列表、线框图、原型和交互式原型将帮助你确定路线图，在开始之前捕捉到具体愿景。重要的是要记住，只有在必要时才携带工具。不要一开始就使用Photoshop，一张纸和一支铅笔就足够了。如果利益相关者和团队成员了解正在开发的内容，那么就有可能迭代和逐步交付你的解决方案。然而，不要陷入完美的陷阱。在基本要素到位并获得一致同意之后，再进行微调和家具调整。
- en: Document every artifact you create. Later in the chapter we cover how you can
    leverage GitHub Wikis to store your artifacts.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 记录你创建的每一个工件。在本章的后面部分，我们将介绍如何利用GitHub Wikis来存储你的工件。
- en: Later in this chapter, we will go over how to develop a roadmap and a technique
    to define your scope, building on the roadmap building techniques covered in *Chapter 3*,
    *Creating a Basic Angular App*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将介绍如何制定路线图和定义范围的技术，这些技术是在*第3章*，*创建基本的Angular应用*中介绍的路线图构建技术的基础上进行的。
- en: Designing with lazy loading in mind
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以懒加载为设计理念
- en: First-paint matters, a lot! According to Google Analytics data gathered by the
    Angular Team in 2018, 53% of mobile users abandoned a website when load times
    exceeded 3 seconds. During the same time period most websites were consumed on mobile
    devices, around 70%+ in the US and 90%+ in China. As we covered in *Chapter 5*,
    *Delivering High-Quality UX with Material*, UI libraries and static assets can
    add significant size to your application. Given that most content is consumed
    on mobile, it's very important to defer the loading of non-critical assets.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首次绘制非常重要！根据Angular团队在2018年收集的Google Analytics数据，53%的移动用户在加载时间超过3秒时放弃了网站。在同一时间段内，大多数网站都是在移动设备上被消费的，在美国约为70%以上，在中国约为90%以上。正如我们在*第5章*，*使用Material提供高质量UX*中所述，UI库和静态资产可以显著增加你的应用程序的大小。鉴于大多数内容都是在移动设备上被消费的，延迟加载非关键资产非常重要。
- en: We defer loading of assets by divvying up the parts of our Angular application
    into feature modules. This way Angular can load only the assets that are necessary
    to render the current screen and dynamically download further resources as they
    are needed. A good way to divide your application into feature modules is by defining
    the various user roles your application may use. User roles normally indicate
    the job function of a user, such as a manager or data-entry specialist. In technical
    terms, they can be thought of as a group of actions that a particular class of
    user is allowed to execute. After all, a data-entry specialist won't ever see
    most of the screens that a manager can, so why deliver those assets to those users
    and slow down their experience?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将我们的Angular应用程序的部分划分为功能模块来延迟加载资源。这样，Angular只能加载渲染当前屏幕所需的资源，并在需要时动态下载进一步的资源。将你的应用程序划分为功能模块的一个好方法是通过定义应用程序可能使用的各种用户角色。用户角色通常表示用户的职能，例如经理或数据录入专员。从技术角度来说，它们可以被视为一组特定类别的用户被允许执行的操作。毕竟，数据录入专员永远不会看到经理可以看到的大多数屏幕，那么为什么要把这些资源提供给这些用户并减慢他们的体验呢？
- en: Lazy loading is critical in creating a scalable application architecture, allowing
    you to deliver high-quality and efficient products. Lazy loading is a low-hanging
    fruit that we will tackle as a baseline design goal. It can be costly to implement
    lazy loading after the fact.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载对于创建可扩展的应用程序架构至关重要，它允许你交付高质量和高效的产品。懒加载是一个低垂的果实，我们将将其作为基本设计目标来处理。在事后实现懒加载可能会很昂贵。
- en: Starting with Angular 9, it is possible to lazy load individual components.
    Angular 9's Ivy rendering engine enables self-describing and standalone components.
    Components that do not require all the bootstrapping that an Angular application
    requires have the potential to revolutionize and simplify how we design applications.
    However, it is not yet feasible to design apps this way. Expect future versions
    of Angular to introduce public APIs that make it easy to use the new features,
    reducing the need to carefully design feature modules early on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Angular 9 开始，可以懒加载单个组件。Angular 9 的 Ivy 渲染引擎使得组件具有自描述性和独立性。那些不需要Angular应用程序所需的所有引导的组件有可能彻底改变并简化我们设计应用程序的方式。然而，目前还无法以这种方式设计应用程序。期待Angular的未来版本引入公共API，使其能够轻松使用新功能，减少早期精心设计功能模块的需求。
- en: Later in this chapter, you will learn about how to implement lazy loading using
    feature modules.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，你将学习如何使用功能模块实现懒加载。
- en: Implementing a walking-skeleton
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个行走骨架
- en: Configuring lazy loading can be tricky, which is why it is essential to nail
    down a walking-skeleton navigation experience early on. Implementing a clickable
    version of your app will help you gather feedback from users early on. That way,
    you'll be able to work out fundamental workflow and integration issues quickly.
    Additionally, you'll be able to establish a concrete representation of the scope
    of your current development effort. Developers and stakeholders alike will be
    able to better visualize how the end product will look.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 配置懒加载可能很棘手，这就是为什么在早期就确定行走骨架导航体验至关重要。实现一个可点击的应用程序版本将帮助你尽早收集用户反馈。这样，你将能够快速解决基本的工作流程和集成问题。此外，你将能够确立当前开发工作的具体范围。开发人员和利益相关者都将能够更好地可视化最终产品的外观。
- en: A walking-skeleton also sets the stage for multiple teams to work in tandem.
    Multiple people can start developing different feature modules or components at
    the same time, without worrying about how the puzzle pieces are going to come
    together later on. By the end of this chapter, you will have completed implementing
    the walking-skeleton of the sample app LemonMart.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 行走骨架也为多个团队协同工作奠定了基础。多个人可以同时开始开发不同的功能模块或组件，而不必担心这些拼图碎片将来如何拼合在一起。到本章结束时，你将完成实现示例应用程序
    LemonMart 的行走骨架。
- en: Achieve a stateless, data-driven design
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现无状态、数据驱动的架构
- en: As highlighted in *Chapter 10*, *RESTful APIs and Full-Stack Implementation*,
    stateless design in full-stack architecture is critical to implementing a maintainable
    application. As covered in *Chapter 1*, *Introduction to Angular and Its Concepts*,
    and later in *Chapter 12*, *Recipes – Master/Detail, Data Tables, and NgRx*, the
    flux pattern and NgRx make it possible to achieve an immutable state for your
    application. However, the flux pattern is likely to be overkill for most applications.
    NgRx itself leverages a lot of the core technologies present in RxJS.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 10 章“RESTful API 和全栈实现”中强调的那样，在全栈架构中实现无状态设计对于构建可维护的应用程序至关重要。如第 1 章“Angular
    简介及其概念”和第 12 章“食谱 - 主/详细、数据表和 NgRx”中所述，Flux 模式和 NgRx 使得为应用程序实现不可变状态成为可能。然而，Flux
    模式对于大多数应用程序来说可能过于复杂。NgRx 本身利用了 RxJS 中许多核心技术。
- en: We are going to use RxJS and the reactive programming paradigm to implement
    a minimal, stateless, and data-driven pattern for our application. Identifying
    major data entities, such as invoices or people, that your users will work with
    is going to help you avoid over-engineering your application. Designing around
    major data entities will inform API design early on, and help define `BehaviorSubject`
    data anchors that you will use to achieve a stateless, data-driven design. That
    design will, in turn, ensure a decoupled component architecture, as detailed in
    *Chapter 6*, *Forms, Observables, and Subjects*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 RxJS 和响应式编程范式来实现一个最小化、无状态和以数据驱动的模式来构建我们的应用程序。识别用户将要操作的主要数据实体，例如发票或人员，将帮助您避免过度设计应用程序。围绕主要数据实体进行设计将在早期就指导
    API 设计，并帮助定义您将用于实现无状态、数据驱动设计的 `BehaviorSubject` 数据锚点。这种设计反过来将确保一个解耦的组件架构，如第 6
    章“表单、Observables 和 Subjects”中详细所述。
- en: By defining observable data anchors, you can ensure that data across various
    components will be kept in sync. By writing functional reactive code, leveraging
    RxJS features, and not storing state in components, we can implement immutable
    data streams.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义可观察的数据锚点，您可以确保各个组件之间的数据保持同步。通过编写功能响应式代码，利用 RxJS 功能，并在组件中不存储状态，我们可以实现不可变的数据流。
- en: We will cover how to design the data models for your application in *Chapter
    10*, *RESTful APIs and Full-Stack Implementation*, and will continue using these
    models in the following chapters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 10 章“RESTful API 和全栈实现”中介绍如何设计应用程序的数据模型，并在接下来的章节中继续使用这些模型。
- en: Enforce a decoupled component architecture
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制实施解耦的组件架构
- en: As we discussed in *Chapter 1*, *Introduction to Angular and Its Concepts*,
    decoupling components of your architecture is critical in ensuring a maintainable
    codebase. In Angular, you can decouple components by leveraging `@Input` and `@Output`
    bindings and Router orchestration.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在第 1 章“Angular 简介及其概念”中讨论的那样，解耦架构中的组件对于确保代码库的可维护性至关重要。在 Angular 中，您可以通过利用
    `@Input` 和 `@Output` 绑定以及路由编排来实现组件的解耦。
- en: Bindings will help you maintain a simple hierarchy of components, and avoid
    using dynamic templates in situations where static designs are more effective,
    such as the creation of multi-page forms.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定将帮助您维护一个简单的组件层次结构，并在静态设计更有效的情况下避免使用动态模板，例如创建多页表单。
- en: Router outlets and auxiliary paths allow you to compose your view using the
    router. Resolvers can help load data by consuming router parameters. Auth guards
    can help control access to various modules and components. Using router links,
    you can dynamically customize elements that a user will see in an immutable and
    predictable way, similar to the way we designed and developed data anchors in
    the previous step.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 路由出口和辅助路径允许您使用路由来组合视图。解析器可以通过消耗路由参数来帮助加载数据。身份验证守卫可以帮助控制对各种模块和组件的访问。使用路由链接，您可以以动态和可预测的方式定制用户将看到的元素，类似于我们在上一步中设计和开发数据锚点的方式。
- en: If you ensure every component is responsible for loading its own data, then
    you can compose components via URLs. However, overusing the router can in itself
    become an anti-pattern. If a parent component logically owns a child component,
    then the effort to decouple them will be wasted.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确保每个组件都负责加载自己的数据，那么您可以通过 URL 来组合组件。然而，过度使用路由本身可能成为一种反模式。如果一个父组件在逻辑上拥有一个子组件，那么解耦它们的努力将是徒劳的。
- en: In *Chapter 6*, *Forms, Observables, and Subjects*, you learned how to enable
    component interactions using `BehaviorSubject`. In *Chapter 11*, *Recipes – Reusability,
    Routing, and Caching*, you will learn how to implement `@Input` and `@Output`
    bindings and in the upcoming chapters you will learn about how to implement router
    features.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 章“表单、可观察对象和主题”中，你学习了如何使用 `BehaviorSubject` 启用组件交互。在第 11 章“食谱 - 可重用性、路由和缓存”中，你将学习如何实现
    `@Input` 和 `@Output` 绑定，在接下来的章节中，你将学习如何实现路由功能。
- en: Differentiate between user controls and components
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分用户控件和组件。
- en: Another important idea is differentiating user controls from components. A user
    control is like a custom date input, or a custom star rater. It is often highly
    interactive and dynamic code that ends up being highly coupled, convoluted, and
    complicated code. Such controls may use Angular features no one has ever heard
    of before, which are most likely not covered in this book.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的观点是区分用户控件和组件。用户控件就像自定义日期输入或自定义星级评分器。它通常是高度交互性和动态的代码，最终会变成高度耦合、复杂和复杂的代码。这样的控件可能会使用到之前没有人听说过的
    Angular 特性，这些特性很可能在本书中没有涉及。
- en: A component is more like a form with fields, which may contain simple date inputs
    or a star rater. Because forms encapsulate business functionality, their code
    must be easy to read and understand. Your code should stick to Angular basics,
    so the code is stable and easy to maintain, like most of the code that is presented
    in this book.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 组件更像是带有字段的表单，可能包含简单的日期输入或星级评分器。因为表单封装了业务功能，所以其代码必须易于阅读和理解。你的代码应遵循 Angular 基础，这样代码就稳定且易于维护，就像本书中展示的大多数代码一样。
- en: By differentiating between user controls and components you can make better
    decisions when deciding what kind of code you want to make reusable. Creating
    reusable code is costly. If you create the right reusable code, you can save time
    and resources. If you create the wrong reusable code, then you can waste a lot
    of time and resources.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过区分用户控件和组件，你可以在决定想要创建哪种可重用代码时做出更好的决策。创建可重用代码是有成本的。如果你创建了正确的可重用代码，你可以节省时间和资源。如果你创建了错误的可重用代码，那么你可能会浪费大量的时间和资源。
- en: Wire-framing allows you to identify reusable elements early on. User controls
    will help keep user interaction code separate from business logic. Well-crafted
    component reuse will enable you to encapsulate domain-specific behavior, and share it
    later.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计允许你早期识别可重用元素。用户控件将帮助将用户交互代码与业务逻辑分离。精心设计的组件重用将使你能够封装特定领域的行怍，并在以后共享。
- en: It's important to identify self-contained user controls that encapsulate unique
    behaviors that you wish to create for your app. User controls will likely be created
    as directives or components that have data-binding properties and tightly coupled
    controller logic and templates.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 识别封装你希望为你的应用程序创建的独特行为的自包含用户控件是很重要的。用户控件很可能会以指令或具有数据绑定属性和紧密耦合的控制器逻辑和模板的组件的形式创建。
- en: Components, on the other hand, leverage router life cycle events to parse parameters
    and perform CRUD operations on data. Identifying these component reuses early
    on will result in creating more flexible components that can be reused in multiple
    contexts (as orchestrated by the router), maximizing code reuse.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，组件利用路由生命周期事件来解析参数并在数据上执行 CRUD 操作。早期识别这些组件重用将导致创建更多灵活的组件，这些组件可以在多个上下文中重用（由路由器编排），从而最大化代码重用。
- en: We will cover how to create reusable components and user controls in *Chapter
    11*, *Recipes – Reusability, Routing, and Caching*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 11 章“食谱 - 可重用性、路由和缓存”中介绍如何创建可重用组件和用户控件。
- en: Maximize code reuse with TypeScript and ES
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 TypeScript 和 ES 最大化代码重用。
- en: It's essential to remember the underlying features of the language you work
    with before you consider the features offered by Angular, RxJS, and all the libraries
    you use. There are decades of software engineering fundamentals that you can leverage
    to write readable and maintainable code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑 Angular、RxJS 以及你使用的所有库提供的功能之前，记住你所使用语言的底层特性是至关重要的。你可以利用数十年的软件工程基础来编写可读性和可维护性强的代码。
- en: 'First and foremost is the DRY principle. It stands for don''t repeat yourself.
    So, don''t copy-paste code. Don''t just change a variable or two. Proactively
    refactor your code to make your functions stateless and reusable. In a few words:
    don''t repeat yourself, don''t repeat yourself, and don''t repeat yourself.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先最重要的是DRY原则，即不要重复自己。所以，不要复制粘贴代码。不要只是更改一个或两个变量。积极重构你的代码，使你的函数无状态和可重用。简而言之：不要重复自己，不要重复自己，不要重复自己。
- en: Leverage object-oriented design. Move behavior to classes; if your person has
    a `fullName` property, don't re-implement the same logic in a dozen different
    places, but implement it once in the `person` class. This means you will need
    to become familiar with hydration, also known as injecting a JSON object into
    a newly instantiated class, and serialization using `toJSON`. It is important
    not to abuse OOP. You should still remain stateless, and functional, by avoiding
    storing state in class parameters.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 利用面向对象设计。将行为移动到类中；如果你的`person`对象有一个`fullName`属性，不要在十几个不同的地方重新实现相同的逻辑，而是在`person`类中实现一次。这意味着你需要熟悉水合（也称为将JSON对象注入新实例化的类）以及使用`toJSON`进行序列化。重要的是不要过度使用面向对象编程。你应该通过避免在类参数中存储状态，保持无状态和函数式。
- en: You can truly unleash the power of OO design by leveraging generics, inheritance,
    and abstract classes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用泛型、继承和抽象类，你可以真正发挥面向对象设计的威力。
- en: TypeScript introduces the concept of interfaces to JavaScript. Interfaces are
    a concept mostly reserved for statically typed languages. An interface represents
    an abstract notion of what an object can do, without specifying any implementation
    details. Furthermore, an interface can be used to document the shape of data.
    For example, you can write a partial interface of a third-party API to document
    the fields you're interested in consuming. When other developers read your code,
    they have an inherent understanding of the structure of the data they're consuming,
    without having to read documentation on another website.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript将接口的概念引入JavaScript。接口主要是一个静态类型语言的保留概念。接口代表了一个对象可以做什么的抽象概念，而不指定任何实现细节。此外，接口可以用来记录数据的形状。例如，你可以编写第三方API的部分接口来记录你感兴趣消费的字段。当其他开发者阅读你的代码时，他们可以本能地理解他们消费的数据结构，而无需阅读另一个网站上的文档。
- en: Interfaces also allow you to morph the shape of your data in a well-defined
    manner. So, you can write a transform function to transform the shape of external
    data into internal data. TypeScript will catch any errors you may make. Taking
    this concept further, you can also use interfaces to flatten data. If the data
    you receive has a multi-entity relational structure, you can flatten the relationship
    to decouple the design of the data from your UI code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接口还允许你以定义良好的方式改变数据结构。因此，你可以编写一个转换函数来将外部数据结构转换为内部数据结构。TypeScript会捕获你可能犯的任何错误。进一步来说，你也可以使用接口来简化数据。如果你接收到的数据具有多实体关系结构，你可以简化这种关系，从而将数据设计从你的UI代码中解耦。
- en: Don't overly flatten your data. Arrays and simple shapes for common objects
    are okay, such as a name object or commonly used domain-specific object.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过度简化你的数据。对于常见的对象，如姓名对象或常用领域特定对象，数组和简单形状都是可以的。
- en: You should also avoid string literals in your code. Writing business logic where
    you compare `'apples' !== 'Oranges'` results in unmaintainable code. You should
    leverage `enums` in TypeScript, so your code isn't subject to the spelling mistakes
    of coders or changing business requirements. So `'oranges' === Fruit.Organes`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该避免在代码中使用字符串字面量。在比较 `'apples' !== 'Oranges'` 的业务逻辑中编写代码会导致难以维护的代码。你应该在TypeScript中利用枚举（`enums`），这样你的代码就不会受到程序员拼写错误或业务需求变化的影响。所以
    `'oranges' === Fruit.Organes`。
- en: Beyond TypeScript and ECMAScript, Angular also offers helpful functions for
    you to reuse logic. Angular validators, pipes, route resolvers, and route guards
    all allow you to share code across components and templates.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了TypeScript和ECMAScript之外，Angular还提供了有用的函数，供你重用逻辑。Angular验证器、管道、路由解析器和路由守卫都允许你在组件和模板之间共享代码。
- en: 'The following chapters will demonstrate the aforementioned concepts:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将演示上述概念：
- en: '*Chapter 8*, *Designing Authentication and Authorization*'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第8章*，*设计身份验证和授权*'
- en: '*Chapter 10*, *RESTful APIs and Full-Stack Implementation*'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第10章*，*RESTful API和全栈实现*'
- en: '*Chapter 11*, *Recipes – Reusability, Routing, and Caching*'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第11章*，*食谱 – 可重用性、路由和缓存*'
- en: '*Chapter 12*, *Recipes – Master/Detail, Data Tables, and NgRx*'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第12章*，*食谱 – 主/详细、数据表和NgRx*'
- en: Next, let's start by creating, LemonMart™, a fully featured line-of-business
    app that you can use as a template to kickstart your next professional project.
    LemonMart is a robust and realistic project that can support feature growth and
    different backend implementations, and it comes with a complete and configurable
    authentication and authorization solution out of the box.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们先创建 LemonMart™，这是一个功能齐全的业务线应用，你可以将其用作启动下一个专业项目的模板。LemonMart 是一个强大且现实的项目，可以支持功能增长和不同的后端实现，并且它自带完整且可配置的认证和授权解决方案。
- en: Since its introduction, LemonMart has served more than 160,000 lemons to over
    14,000 developers. Zesty! ![](img/B14094_07_001.png)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 LemonMart 上市以来，它已经为超过 14,000 名开发者提供了超过 160,000 个柠檬。真美味！![图片](img/B14094_07_001.png)
- en: You can always clone the finished project from GitHub, [https://www.github.com/duluca/lemon-mart](https://www.github.com/duluca/lemon-mart),
    whenever you need it. Let's jump right into it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时从 GitHub 克隆完成的项目，[https://www.github.com/duluca/lemon-mart](https://www.github.com/duluca/lemon-mart)，无论何时你需要它。让我们直接进入正题。
- en: Creating LemonMart
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 LemonMart
- en: LemonMart will be a mid-sized line-of-business application with over 90 code
    files. We will start our journey by creating a new Angular app, with routing and
    Angular Material configured from the get-go.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: LemonMart 将是一个中等规模的业务线应用，拥有超过 90 个代码文件。我们将从创建一个新的 Angular 应用程序开始，从一开始就配置了路由和
    Angular Material。
- en: It is presumed that you have installed all the requisite software mentioned
    in *Chapter 2*, *Setting Up Your Development Environment*. If you have not, execute
    the following commands for your OS to configure your environment.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经安装了 *第 2 章* 中提到的所有必需的软件，*设置你的开发环境*。如果没有，请根据你的操作系统执行以下命令来配置你的环境。
- en: 'On Windows PowerShell, execute:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows PowerShell 中，执行：
- en: '[PRE5]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On macOS Terminal, execute:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 终端上，执行：
- en: '[PRE6]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For more information refer to [https://github.com/duluca/web-dev-environment-setup](https://github.com/duluca/web-dev-environment-setup).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参考 [https://github.com/duluca/web-dev-environment-setup](https://github.com/duluca/web-dev-environment-setup)。
- en: Creating a router-first app
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个路由优先的应用
- en: 'With the router-first approach, we want to enable routing early on in our application:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用路由优先的方法，我们希望在应用早期就启用路由：
- en: You can create the new application, with routing already configured, by executing
    this command.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过执行以下命令创建一个新应用，其中已经配置了路由。
- en: 'Ensure that `@angular/cli` is not installed globally, or you may run into errors:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保没有全局安装 `@angular/cli`，否则你可能会遇到错误：
- en: '[PRE7]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Starting with Angular 9, you may use `--strict` to turn on TypeScript features
    like `noImplicitAny`, `noImplicitReturns`, `noFallthroughCasesInSwitch`, and `strictNullChecks`.
    These options will decrease the chances of making coding mistakes, but result
    in more verbose code. In my opinion, that is a good thing, and this option is
    highly recommended for production-bound applications.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 Angular 9 开始，你可以使用 `--strict` 来启用 TypeScript 功能，如 `noImplicitAny`、`noImplicitReturns`、`noFallthroughCasesInSwitch`
    和 `strictNullChecks`。这些选项将减少编码错误的机会，但会导致代码更加冗长。在我看来，这是一个好事，并且这个选项非常推荐用于生产环境的应用。
- en: 'A new `AppRoutingModule` file has been created for us:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们创建了一个新的 `AppRoutingModule` 文件：
- en: '[PRE8]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will be defining routes inside the routes array. Note that the routes array
    is passed in to be configured as the root routes for the application; the default
    root route is `/`.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在路由数组内部定义路由。请注意，路由数组被传递进来以配置为应用的根路由；默认的根路由是 `/`。
- en: 'When configuring your `RouterModule`, you can pass in additional options to
    customize the default behavior of the Router, such as when you attempt to load
    a route that you''re already on. Normally, if the route you''re attempting to
    navigate to is the same as the current one, the router wouldn''t take any action.
    However, if you wanted the router to refresh the page, you would customize the
    default behavior of the router, such as with `RouterModule.forRoot(routes, { onSameUrlNavigation:
    ''reload'' })`. With this setting in place, if you navigate to the same URL that
    you are on, you will force a reload of the current component.'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '当配置你的 `RouterModule` 时，你可以传递额外的选项来定制 Router 的默认行为，例如当你尝试加载一个你已经处于其中的路由时。通常情况下，如果你尝试导航到的路由与当前路由相同，路由器不会采取任何行动。然而，如果你想让路由器刷新页面，你可以定制路由器的默认行为，例如使用
    `RouterModule.forRoot(routes, { onSameUrlNavigation: ''reload'' })`。启用此设置后，如果你导航到与当前相同的
    URL，你将强制重新加载当前组件。'
- en: 'Finally, `AppRoutingModule` is registered with `AppModule`, as shown:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`AppRoutingModule` 与 `AppModule` 注册，如下所示：
- en: '[PRE9]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Configuring Angular and VS Code
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Angular 和 VS Code
- en: 'To quickly apply configuration steps covered in *Chapters 2-6* run the following
    commands:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速应用第 2-6 章中涵盖的配置步骤，请运行以下命令：
- en: The following scripts do not require you to use VS Code. If you wish to use
    another IDE like WebStorm, the `npm` scripts that are configured will run equally
    well.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本不需要你使用 VS Code。如果你希望使用其他 IDE，如 WebStorm，配置的 `npm` 脚本同样可以很好地运行。
- en: 'Install the Angular VS Code task:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Angular VS Code 任务：
- en: '[PRE10]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Apply the Angular VS Code configuration:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用 Angular VS Code 配置：
- en: '[PRE11]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Install the npm Scripts for the Docker task:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Docker 任务的 npm 脚本：
- en: '[PRE12]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Apply the npm Scripts for the Docker configuration:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用 Docker 配置的 npm 脚本：
- en: '[PRE13]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Implement an npm script to build your application in production mode named `build:prod`
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `build:prod` 的 npm 脚本来在生产模式下构建你的应用。
- en: '[PRE14]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These settings are continually tweaked to adapt to the ever-evolving landscape
    of extensions, plug-ins, Angular, and VS Code. Always make sure to install a fresh
    version of the task by re-running the `install` command to get the latest version.
    Alternatively, you can use the Angular Evergreen extension for VS Code, to run
    the configuration commands with one click.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置不断调整以适应扩展、插件、Angular 和 VS Code 的不断变化。始终确保通过重新运行 `install` 命令来安装任务的最新版本。或者，你可以使用
    VS Code 的 Angular Evergreen 扩展来一键运行配置命令。
- en: 'Note that if the preceding configuration scripts fail to execute, then the
    following npm scripts will also fail. In this case, you have two options: revert
    your changes and ignore these scripts, or manually implement these scripts as
    covered in earlier chapters (or as demonstrated on GitHub).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果前面的配置脚本执行失败，那么以下 npm 脚本也会失败。在这种情况下，你有两个选择：撤销你的更改并忽略这些脚本，或者手动实现这些脚本，如前几章所述（或如
    GitHub 上所示）。
- en: Execute `npm run style:fix`
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `npm run style:fix`。
- en: Execute `npm run lint:fix`
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `npm run lint:fix`。
- en: Execute `npm start` and ensure you're running on `http://localhost:5000`, instead
    of the default port `4200`
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `npm start` 并确保你正在运行在 `http://localhost:5000`，而不是默认端口 `4200`。
- en: Refer to *Chapter 2*, *Setting Up Your Development Environment*, for further
    configuration details.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 参考第 2 章，*设置你的开发环境*，以获取更多配置细节。
- en: You may optionally setup npm Scripts for AWS ECS, which is used in *Chapter
    13*, *Highly Available Cloud Infrastructure on AWS*, by using `mrm-task-npm-aws`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择使用 `mrm-task-npm-aws` 为 AWS ECS 设置 npm 脚本，这在第 13 章，*AWS 上的高可用云基础设施*中有所介绍。
- en: 'For more information on the mrm tasks refer to:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 mrm 任务更多信息，请参考：
- en: '[https://github.com/expertly-simple/mrm-task-angular-vscode](https://github.com/expertly-simple/mrm-task-angular-vscode)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/expertly-simple/mrm-task-angular-vscode](https://github.com/expertly-simple/mrm-task-angular-vscode)'
- en: '[https://github.com/expertly-simple/mrm-task-npm-docker](https://github.com/expertly-simple/mrm-task-npm-docker)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/expertly-simple/mrm-task-npm-docker](https://github.com/expertly-simple/mrm-task-npm-docker)'
- en: '[https://github.com/expertly-simple/mrm-task-npm-aws](https://github.com/expertly-simple/mrm-task-npm-aws)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/expertly-simple/mrm-task-npm-aws](https://github.com/expertly-simple/mrm-task-npm-aws)'
- en: Configuring Material and Styles
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置材料和样式。
- en: 'We will also need to set up Angular Material and configure a theme to use,
    as covered in *Chapter 5*, *Delivering High-Quality UX with Material*:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设置 Angular Material 并配置一个要使用的主题，如第 5 章，*使用 Material 提供高质量 UX* 中所述：
- en: 'Install Angular Material:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Angular Material：
- en: '[PRE15]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In `material.module.ts`, define a `const` `modules` array and export `MatButtonModule`,
    `MatToolbarModule`, and `MatIconModule`, removing `CommonModule`
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `material.module.ts` 中定义一个 `const` `modules` 数组并导出 `MatButtonModule`、`MatToolbarModule`
    和 `MatIconModule`，移除 `CommonModule`。
- en: In `app.modules.ts`, import `FlexLayoutModule` so Angular Flex Layout can be
    activated
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app.modules.ts` 中导入 `FlexLayoutModule` 以激活 Angular Flex Layout。
- en: 'Append common CSS to `styles.css` as shown in the following code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码将常用 CSS 添加到 `styles.css` 中：
- en: '[PRE16]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Update your application's title in `index.html`
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `index.html` 中更新你的应用标题。
- en: Refer to *Chapter 5*, *Delivering High-Quality UX with Material*, for further
    configuration details.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 参考第 5 章，*使用 Material 提供高质量 UX*，以获取更多配置细节。
- en: We will apply custom branding to the app later in this chapter. Next, let's
    start designing our line-of-business application.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后面部分应用自定义品牌到应用中。接下来，让我们开始设计我们的业务线应用。
- en: Designing LemonMart
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计 LemonMart。
- en: It is important to build a rudimentary roadmap to follow, from the database
    to the frontend, while also avoiding over-engineering. This initial design phase
    is critical to the long-term health and success of your project, where any existing
    silos between teams must be broken down and an overall technical vision well understood
    by all members of the team. This is easier said than done, and there are volumes
    of books written on the topic.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库到前端的过程中，构建一个基本的路线图来遵循，同时避免过度设计，这一点非常重要。这个初始设计阶段对你的项目的长期健康和成功至关重要，其中必须打破团队之间现有的隔阂，并确保所有团队成员都充分理解整体技术愿景。这说起来容易做起来难，关于这个话题已经有许多书籍被撰写。
- en: In engineering, there's no one right answer to a problem, so it is important
    to remember that no one person can ever have all the answers, nor a crystal-clear
    vision. It is important that technical and non-technical leaders create a safe
    space with opportunities for open discussion and experimentation as part of the
    culture. The humility and empathy that comes along with being able to court such
    uncertainty as a team is as important as any single team member's technical capability.
    Every team member must be comfortable with checking their egos at the door because
    our collective goal will be to grow and evolve an application to ever-changing
    requirements during the development cycle. You will know that you have succeeded
    if individual parts of the software you created are easily replaceable by anyone.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在工程领域，没有一种正确答案可以解决所有问题，因此记住没有人能够拥有所有答案，也没有人能够拥有清晰明确的愿景，这一点非常重要。在文化中，技术和非技术领导者创建一个安全的空间，提供开放讨论和实验的机会，这一点非常重要。作为一个团队，能够共同面对这种不确定性所带来的谦逊和同理心，与任何单个团队成员的技术能力一样重要。每个团队成员都必须舒适地放下他们的自我，因为我们的共同目标是在开发周期中不断增长和演变一个能够满足不断变化需求的应用程序。如果你知道你成功了，那么你创建的软件的各个部分将很容易被任何人替换。
- en: So, let's start by developing a roadmap and identifying the scope of our application.
    For this, we will be defining user roles and then building a site map, to create
    a vision of how our app might work.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先开发一个路线图，并确定我们应用程序的范围。为此，我们将定义用户角色，然后构建一个网站图，以形成一个关于我们的应用程序可能如何工作的愿景。
- en: Identifying user roles
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定用户角色
- en: The first step of our design will be to think about who is using the application
    and why.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的第一步将是思考谁在使用这个应用程序以及为什么。
- en: 'We envision four user states, or roles, for LemonMart:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设想了LemonMart的四种用户状态或角色：
- en: Authenticated; any authenticated user would have access to their profile
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证；任何认证用户都将能够访问其个人资料
- en: Cashier, whose sole role is to check out customers
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收银员，其唯一角色是结账客户
- en: Clerk, whose sole role is to perform inventory-related functions
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会计，其唯一角色是执行与库存相关的功能
- en: Manager, who can perform all actions a cashier and a clerk can perform but also
    have access to administrative functions
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经理，可以执行收银员和会计可以执行的所有操作，同时还可以访问管理功能
- en: With this in mind, we can start to create a high-level design for our app.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以开始为我们的应用程序创建一个高级设计。
- en: Identifying high-level modules with a site map
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用网站图确定高级模块
- en: 'Develop a high-level site map of your application, as shown:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个高级网站图，如下所示：
- en: '![](img/B14094_07_07.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_07_07.png)'
- en: 'Figure 7.7: Landing pages for users'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：用户登录页面
- en: 'I used MockFlow.com''s SiteMap tool to create the site map shown: [https://sitemap.mockflow.com](https://sitemap.mockflow.com).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了MockFlow.com的网站图工具创建了显示的网站图：[https://sitemap.mockflow.com](https://sitemap.mockflow.com)。
- en: 'Upon first examination, three high-level modules emerge as lazy-loading candidates:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在初步检查后，有三个高级模块被认为是懒加载的候选者：
- en: '**Point of Sale (POS)**'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**销售点（POS**）'
- en: '**Inventory**'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**库存**'
- en: '**Manager**'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**经理**'
- en: 'The Cashier will only have access to the **POS** module and component. The
    Clerk will only have access to the **Inventory** module, which will include additional
    screens for the **Stock Entry**, **Products**, and **Categories** management components:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 收银员只能访问**POS**模块和组件。会计只能访问**库存**模块，该模块将包括**库存录入**、**产品**和**类别**管理组件的附加屏幕：
- en: '![](img/B14094_07_08.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_07_08.png)'
- en: 'Figure 7.8: Inventory pages'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：库存页面
- en: 'Finally, the **Manager** will be able to access all three modules with the
    **Manager** module, including user management and receipt lookup components:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**经理**将能够通过**经理**模块访问所有三个模块，包括用户管理和收据查找组件：
- en: '![](img/B14094_07_09.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_07_09.png)'
- en: 'Figure 7.9: Manager pages'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：经理页面
- en: There'll be great benefits from enabling lazy loading for all three modules;
    since Cashiers and Clerks will never use components belonging to other user roles,
    there's no reason to send those bytes down to their devices. This means as the
    **Manager** module gains more advanced reporting features, or new roles are added
    to the application, the **POS** module will be unaffected by the bandwidth and
    memory impact of an otherwise growing application.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 启用所有三个模块的懒加载将带来巨大的好处；由于收银员和店员永远不会使用属于其他用户角色的组件，没有必要将这些字节发送到他们的设备上。这意味着随着**Manager**模块获得更多高级报告功能，或者新角色被添加到应用程序中，**POS**模块将不会受到其他增长应用程序带宽和内存影响的冲击。
- en: This means fewer support calls, and consistent performance on the same hardware
    for a much longer period of time.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着更少的支持电话，以及更长时间在同一硬件上的一致性能。
- en: Generating router-enabled modules
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成具有路由功能的模块
- en: 'Now that we have our high-level components defined as **Manager**, **Inventory**,
    and **POS**, we can define them as modules. These modules will be different from
    the ones you''ve created so far, for routing and Angular Material. We can create
    the user profile as a component on the app module; however, note that user profile
    will only ever be used for already-authenticated users, so it makes sense to define
    a fourth module only meant for authenticated users in general. This way, you will
    ensure that your app''s first payload remains as minimal as possible. In addition,
    we will create a Home component to contain the landing experience for our app
    so that we can keep implementation details out of `app.component`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将高级组件定义为**Manager**、**Inventory**和**POS**，我们可以将它们定义为模块。这些模块将不同于您迄今为止创建的模块，因为它们用于路由和Angular
    Material。我们可以在应用模块上创建用户配置文件作为组件；然而，请注意，用户配置文件将仅用于已认证的用户，因此定义一个仅针对一般认证用户的第四个模块是有意义的。这样，您将确保您的应用的第一批数据尽可能最小化。此外，我们将创建一个主页组件来包含我们应用的着陆体验，这样我们就可以将实现细节从`app.component`中分离出来：
- en: 'Generate `manager`, `inventory`, `pos`, and `user` modules, specifying their
    target module and routing capabilities:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成`manager`、`inventory`、`pos`和`user`模块，指定它们的目标模块和路由功能：
- en: '[PRE17]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As discussed in *Chapter 2*, *Setting Up Your Development Environment*, if you
    have configured `npx` to automatically recognize `ng` as a command, you can save
    some more keystrokes because you won't have to append `npx` to your commands every
    time. Do not globally install `@angular/cli`.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如同在*第二章*，*设置您的开发环境*中讨论的那样，如果您已经配置了`npx`以自动识别`ng`作为命令，那么您可以节省一些按键，因为您不必每次都附加`npx`到您的命令中。不要全局安装`@angular/cli`。
- en: Note the abbreviated command structure, where `ng generate module manager` becomes
    `ng g m manager`, and similarly, `--module` becomes `-m`.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意简化的命令结构，其中`ng generate module manager`变为`ng g m manager`，同样，`--module`变为`-m`。
- en: Verify that you don't have CLI errors.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认您没有CLI错误。
- en: Note that using `npx` on Windows may throw an error such as `Path must be a
    string. Received undefined`. This error doesn't seem to have any effect on the
    successful operation of the command, which is why it is critical to always inspect
    what the CLI tool generated.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在Windows上使用`npx`可能会抛出一个错误，例如`Path must be a string. Received undefined`。这个错误似乎对命令的成功执行没有影响，这就是为什么始终检查CLI工具生成的输出是至关重要的。
- en: 'Verify that the folder and the files are created:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认文件夹和文件已被创建：
- en: '[PRE18]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Examine how `ManagerModule` has been wired.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`ManagerModule`是如何连接的。
- en: 'A feature module implements an `@NgModule` similar to `app.module`. The biggest
    difference is that a feature module does not implement the `bootstrap` property,
    which is required for your root module to initialize your Angular app:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 功能模块实现了一个类似于`app.module`的`@NgModule`。最大的区别是功能模块不实现`bootstrap`属性，这是您的根模块初始化Angular应用所必需的：
- en: '[PRE19]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Since we have specified the `-m` option, the module has been imported into
    `app.module`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们指定了`-m`选项，模块已经被导入到`app.module`中：
- en: '[PRE20]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In addition, because we also specified the `--routing` option, a routing module
    has been created and imported into `ManagerModule`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为我们还指定了`--routing`选项，一个路由模块已经被创建并导入到`ManagerModule`中：
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that `RouterModule` is being configured using `forChild`, as opposed to
    `forRoot`, which was the case for the `AppRouting` module. This way, the router
    understands the proper relationship between routes defined in different modules'
    contexts and can correctly prepend `/manager` to all child routes in this example.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`RouterModule` 正在使用 `forChild` 进行配置，而不是 `forRoot`，这在 `AppRouting` 模块中是案例。这样，路由器可以正确理解不同模块上下文中定义的路由之间的关系，并可以在本例中将
    `/manager` 前缀正确地添加到所有子路由。
- en: The CLI doesn't respect your `tslint.json` settings. If you have correctly configured
    your VS Code environment with Prettier, your code styling preferences will be
    applied as you work on each file or globally when you run the `prettier` command.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 不尊重您的 `tslint.json` 设置。如果您已正确配置了 VS Code 环境并使用 Prettier，则您的代码样式首选项将在您处理每个文件时应用，或在运行
    `prettier` 命令时全局应用。
- en: Be sure to run your `style:fix` and `lint:fix` commands before moving on. Now,
    let's design how the landing page for LemonMart will look and work.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保运行您的 `style:fix` 和 `lint:fix` 命令。现在，让我们设计 LemonMart 的着陆页的外观和工作方式。
- en: Designing the home route
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计主页路由
- en: 'Consider the following mock-up as the landing experience for LemonMart:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下模拟图视为 LemonMart 的着陆体验：
- en: '![](img/B14094_07_10.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_07_10.png)'
- en: 'Figure 7.10: LemonMart landing experience'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10：LemonMart 着陆体验
- en: Unlike the `LocalCastWeather` app, we don't want all this markup to be in the
    `App` component. The `App` component is the root element of your entire application;
    therefore, it should only contain elements that will persistently appear throughout
    your application. In the following annotated mock-up, the toolbar marked as **1**
    will be persistent throughout the app.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `LocalCastWeather` 应用不同，我们不希望所有这些标记都放在 `App` 组件中。`App` 组件是您整个应用的根元素；因此，它应该只包含将在您的应用中持续出现的元素。在以下注释的模拟图中，标记为
    **1** 的工具栏将在整个应用中保持不变。
- en: 'The area marked as **2** will house the `home` component, which itself will
    contain a login user control, marked as **3**:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为 **2** 的区域将包含 `home` 组件，它本身将包含一个登录用户控件，标记为 **3**：
- en: '![](img/B14094_07_11.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_07_11.png)'
- en: 'Figure 7.11: LemonMart layout structure'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11：LemonMart 布局结构
- en: It's best practice to create your default or landing component as a separate
    element in Angular. This helps reduce the amount of code that must be loaded and
    logic executed in every page, but it also results in a more flexible architecture
    when utilizing the router.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，将默认或着陆组件作为单独的元素创建是最佳实践。这有助于减少必须加载和执行的代码量以及逻辑，但这也使得在利用路由器时具有更灵活的架构。
- en: 'Generate the `home` component with inline template and styles:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联模板和样式生成 `home` 组件：
- en: '[PRE22]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that a component with an inline template and a style is also referred to
    as a **Single File Component** or an **SFC**.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，具有内联模板和样式的组件也被称为 **单文件组件** 或 **SFC**。
- en: Now, you are ready to configure the router.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好配置路由器。
- en: Setting up default routes
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置默认路由
- en: 'Let''s get started with setting up a simple route for LemonMart. We need to
    set up the `/` route (also known as the empty route) and the `/home` routes to
    display the `HomeComponent`. We also need a wildcard route to capture all undefined
    routes and display a `PageNotFoundComponent`, which also needs to be created:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设置 LemonMart 的简单路由。我们需要设置 `/` 路由（也称为空路由）和 `/home` 路由以显示 `HomeComponent`。我们还需要一个通配符路由来捕获所有未定义的路由并显示
    `PageNotFoundComponent`，这也需要创建：
- en: 'Configure your `home` route:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 `home` 路由：
- en: '[PRE23]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We first define a path for `'home'` and inform the router to render `HomeComponent`
    by setting the `component` property. Then, we set the default path of the application
    `''` to be redirected to `'/home'`. By setting the `pathMatch` property, we always
    ensure that this very specific instance of the `home` route will be rendered as
    the landing experience.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先为 `'home'` 定义一个路径，并通过设置 `component` 属性通知路由器渲染 `HomeComponent`。然后，我们将应用的默认路径
    `''` 设置为重定向到 `'/home'`。通过设置 `pathMatch` 属性，我们始终确保这个非常具体的 `home` 路由实例将被渲染为着陆体验。
- en: Create a `pageNotFound` component with an inline template
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有内联模板的 `pageNotFound` 组件
- en: 'Configure a wildcard route for `PageNotFoundComponent`:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `PageNotFoundComponent` 配置通配符路由：
- en: '[PRE24]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This way, any route that is not matched will be directed to the `PageNotFoundComponent`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，任何未匹配的路由都将被重定向到 `PageNotFoundComponent`。
- en: RouterLink
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RouterLink
- en: 'When a user lands on the `PageNotFoundComponent`, we would like them to be
    redirected to the `HomeComponent` using the `routerLink` direction:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户到达 `PageNotFoundComponent` 时，我们希望他们使用 `routerLink` 指令重定向到 `HomeComponent`：
- en: 'On `PageNotFoundComponent`, replace the inline template to link back to `home`
    using `routerLink`:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PageNotFoundComponent` 上，替换内联模板以使用 `routerLink` 链接到 `home`：
- en: '[PRE25]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This navigation can also be done via an `<a href>` tag implementation; however,
    in more dynamic and complicated navigation scenarios, you will lose features such
    as automatic active link tracking or dynamic link generation.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此导航也可以通过 `<a href>` 标签实现；然而，在更动态和复杂的导航场景中，您将失去诸如自动活动链接跟踪或动态链接生成等特性。
- en: The Angular bootstrap process will ensure that `AppComponent` is inside the
    `<app-root>` element in your `index.html`. However, we must manually define where
    we would like `HomeComponent` to render, to finalize the router configuration.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 引导过程将确保 `AppComponent` 在您的 `index.html` 中的 `<app-root>` 元素内。然而，我们必须手动定义我们希望
    `HomeComponent` 渲染的位置，以完成路由配置。
- en: Router outlet
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由出口
- en: '`AppComponent` is considered a root element for the root router defined in
    `app-routing.module`, which allows us to define outlets within this root element
    to dynamically load any content we wish using the `<router-outlet>` element:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppComponent` 被视为在 `app-routing.module` 中定义的根路由的根元素，这允许我们在该根元素内定义出口，以便使用 `<router-outlet>`
    元素动态加载我们希望的内容：'
- en: Configure `AppComponent` to use inline template and styles, deleting any existing
    content in the html and css files
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 `AppComponent` 使用内联模板和样式，删除 html 和 css 文件中任何现有的内容
- en: Add the toolbar for your application
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的应用程序添加工具栏
- en: Add the name of your application as a button link so that it takes the user
    to the home page when clicked on
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您应用程序的名称作为按钮链接添加，以便点击时将用户带到主页
- en: 'Add `<router-outlet>` for the content to render:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为内容渲染添加 `<router-outlet>`：
- en: '[PRE26]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, the contents of `home` will render inside `<router-outlet>`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`home` 的内容将在 `<router-outlet>` 内渲染。
- en: Branding, customization, and Material icons
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 品牌化、定制和 Material 图标
- en: In order to construct an attractive and intuitive toolbar, we must introduce
    some iconography and branding to the app so that the users can easily navigate
    through the app with the help of familiar icons.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个吸引人且直观的工具栏，我们必须向应用程序引入一些图标和品牌，以便用户可以在熟悉图标的帮助下轻松地浏览应用程序。
- en: Branding
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 品牌化
- en: In terms of branding, you should ensure that your web app has a custom color
    palette and integrates with desktop and mobile browser features to bring forward
    your app's name and iconography.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在品牌化方面，您应该确保您的网络应用程序有一个自定义的色彩调色板，并与桌面和移动浏览器功能集成，以突出显示您的应用程序名称和图标。
- en: Color palette
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 色彩调色板
- en: 'Pick a color palette using the Material Color tool, as discussed in *Chapter
    5*, *Delivering High-Quality UX with Material*. Here''s the one I picked for LemonMart:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第 5 章*使用 Material 提供高质量 UX*中讨论的 Material Color 工具选择一个色彩调色板。这是我为 LemonMart
    选择的一个：
- en: '[https://material.io/resources/color/#!/?view.left=0&view.right=0&primary.color=2E7D32&secondary.color=C6FF00](https://material.io/resources/color/#!/?view.left=0&view.right=0&primary.color=2E7D32&secondary.color=C6FF00).'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://material.io/resources/color/#!/?view.left=0&view.right=0&primary.color=2E7D32&secondary.color=C6FF00](https://material.io/resources/color/#!/?view.left=0&view.right=0&primary.color=2E7D32&secondary.color=C6FF00)。'
- en: Rename `custom-theme.scss` to `lemonmart-theme.scss`
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `custom-theme.scss` 重命名为 `lemonmart-theme.scss`
- en: Update `angular.json` with the new theme file name
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的主题文件名更新 `angular.json`
- en: '[PRE27]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Configure your custom theme with the chosen color palette
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所选的色彩调色板配置您的自定义主题
- en: You can also grab LemonMart-related assets from GitHub at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从 GitHub 获取 LemonMart 相关资产：[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)。
- en: For the Local Weather app, we replaced the `favicon.ico` file to brand our app
    in the browser. While this would've been enough ten years ago, today's devices
    vary wildly, and each platform can leverage optimized assets to better represent
    your web app within their operating systems. Next, let's implement a more robust
    favicon.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地天气应用程序，我们替换了 `favicon.ico` 文件以在浏览器中品牌化我们的应用程序。虽然这在十年前就足够了，但今天的设备种类繁多，每个平台都可以利用优化的资产来更好地在其操作系统中代表您的网络应用程序。接下来，让我们实现一个更健壮的favicon。
- en: Implementing browser manifest and icons
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现浏览器清单和图标
- en: 'You need to ensure that the browser shows the correct title text and icon in
    a **Browser** tab. Further, a manifest file should be created that implements
    specific icons for various mobile operating systems, so that if a user pins your
    website, a desirable icon is displayed similar to other app icons on a phone.
    This will ensure that if a user favorites or pins your web app on their mobile
    device''s home screen, they''ll get a native-looking app icon:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保浏览器在**浏览器**标签中显示正确的标题文本和图标。此外，还应创建一个实现各种移动操作系统的特定图标的manifest文件，这样如果用户将您的网站固定，就会显示类似于手机上其他应用图标的期望图标。这将确保如果用户在移动设备的首页上收藏或固定您的网络应用，他们将获得原生外观的应用图标：
- en: Create or obtain an SVG version of your website's logo from a designer or a
    site like [https://www.flaticon.com](https://www.flaticon.com )
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从设计师或类似[https://www.flaticon.com](https://www.flaticon.com)的网站上创建或获取您网站标志的SVG版本
- en: In this case, I will be using the likeness of the Eureka Lemon:![](img/B14094_07_12.png)
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我将使用Eureka柠檬的相似图像：![Eureka柠檬的相似图像](img/B14094_07_12.png)
- en: 'Figure 7.12: LemonMart''s signature logo'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.12：LemonMart的标志性标志
- en: 'When using images you find on the internet, pay attention to applicable copyrights.
    In this case, I have purchased a license to be able to publish this lemon logo,
    but you may grab your own copy at the following URL, given that you provide the
    required attribution to the author of the image: [https://www.flaticon.com/free-icon/lemon_605070](https://www.flaticon.com/free-icon/lemon_605070).'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用您在网上找到的图片时，请注意适用的版权。在这种情况下，我已购买许可证以能够发布这个柠檬标志，但您可以在以下URL获取您自己的副本，前提是您向图片的作者提供所需的归属：[https://www.flaticon.com/free-icon/lemon_605070](https://www.flaticon.com/free-icon/lemon_605070)。
- en: Generate the `favicon.ico` and manifest files using a tool such as [https://realfavicongenerator.net](https://realfavicongenerator.net
    )
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用诸如[https://realfavicongenerator.net](https://realfavicongenerator.net)之类的工具生成`favicon.ico`和manifest文件
- en: Adjust settings for iOS, Android, Windows Metro, and macOS Safari to your liking
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整iOS、Android、Windows Metro和macOS Safari的设置以符合您的喜好
- en: Ensure that you set a version number, as favicons can be notorious with caching;
    a random version number will ensure that users always get the latest version
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您设置一个版本号，因为favicon可能会因缓存而出名；一个随机的版本号将确保用户总是获得最新版本
- en: Download and extract the generated `favicons.zip` file into your `src` folder
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并解压生成的`favicons.zip`文件到您的`src`文件夹
- en: 'Edit the `angular.json` file to include the new assets in your app:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`angular.json`文件以将新资源包含到您的应用中：
- en: '[PRE28]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Insert the generated code in the `<head>` section of your `index.html`:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的代码插入到您的`index.html`的`<head>`部分：
- en: '[PRE29]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Please put the preceding HTML after your favicon declaration, but before your
    style imports. The order does matter. Browsers load data top down. You want your
    application's icon to be parsed before the user has to wait for CSS files to be
    downloaded.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请在favicon声明之后、样式导入之前放置前面的HTML。顺序很重要。浏览器从上到下加载数据。您希望应用程序的图标在用户等待下载CSS文件之前被解析。
- en: Ensure that your new favicon displays correctly
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的新favicon显示正确
- en: Once your basic branding work has been completed, consider if you'd like to
    establish a more unique look and feel with theming.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成基本品牌工作，请考虑是否想通过主题化建立更独特的视觉和感觉
- en: Custom themes
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义主题
- en: 'You may further customize Material''s look and feel, to achieve a unique experience
    for your app, by leveraging tools listed on [https://material.io/tools](https://material.io/tools)
    and some other tools that I have discovered, which are listed as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过利用[https://material.io/tools](https://material.io/tools)上列出的工具以及我发现的某些其他工具来进一步自定义Material的外观和感觉，以实现您应用独特的体验，这些工具如下列所示：
- en: Material Theme Editor (retired as of March 2020) is a plugin for the popular
    design app Sketch on macOS to create a theme that is more than skin deep. An alternative
    tool is yet to be announced, but you can find resources you can continue to use
    in the meantime on the blog post linked at [https://material.io/tools/theme-editor](https://material.io/tools/theme-editor)
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Material Theme Editor（自2020年3月已停用）是适用于macOS上流行的设计应用Sketch的插件，用于创建比皮肤更深层次的主题。一个替代工具尚未宣布，但您可以在以下链接的博客文章中找到您可以继续使用的资源：[https://material.io/tools/theme-editor](https://material.io/tools/theme-editor)
- en: Material Theme Builder is an alternative to build custom themes that work in the
    browser on Glitch.com at [https://material-theme-builder.glitch.me](https://material-theme-builder.glitch.me
    )
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Material Theme Builder是构建在Glitch.com上工作的自定义主题的替代方案，网址为[https://material-theme-builder.glitch.me](https://material-theme-builder.glitch.me)
- en: Material Design Theme Palette Generator will generate the necessary code to define
    your custom color palette to create truly unique themes at [http://mcg.mbitson.com](http://mcg.mbitson.com
    )
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材料设计主题调色板生成器将在[http://mcg.mbitson.com](http://mcg.mbitson.com)生成定义您自定义颜色调色板的必要代码，以创建真正独特的主题。
- en: Color Blender helps with finding midway points between two colors, which is
    useful when defining in-between colors for the color swatches, located at [https://meyerweb.com/eric/tools/color-blend](https://meyerweb.com/eric/tools/color-blend
    )
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色混合器有助于在两种颜色之间找到中间点，这在定义颜色样本之间的中间颜色时很有用，位于[https://meyerweb.com/eric/tools/color-blend](https://meyerweb.com/eric/tools/color-blend)。
- en: There is a wealth of information on [https://material.io](https://material.io)
    on the in-depth philosophy behind Material design, with great sections on things
    like the color system, [https://material.io/design/color/the-color-system.html](https://material.io/design/color/the-color-system.html),
    which dives deep into selecting the right color palette for your brand and other
    topics such as creating a dark theme for your app.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://material.io](https://material.io)上有很多关于Material设计背后深入哲学的信息，包括关于色彩系统[https://material.io/design/color/the-color-system.html](https://material.io/design/color/the-color-system.html)的精彩部分，深入探讨了为您的品牌选择正确的调色板以及其他主题，例如为您的应用创建深色主题。
- en: It is very important to distinguish your brand from other apps or your competitors.
    Creating a high-quality custom theme will be a time-consuming process; however,
    the benefits of creating a great first impression with your users are considerable.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 区分您的品牌与其他应用或竞争对手非常重要。创建高质量的定制主题将是一个耗时的过程；然而，给用户留下深刻第一印象的好处是相当可观的。
- en: Next, we will show you how you can add custom icons to your Angular apps.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向您展示如何将自定义图标添加到您的Angular应用中。
- en: Custom icons
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义图标
- en: 'Now, let''s add your custom branding inside your Angular app. You will need
    the svg icon you used to create your favicon:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在您的Angular应用中添加您的自定义品牌。您需要用于创建favicon的svg图标：
- en: Place the image under `src/assets/img/icons`, named `lemon.svg`
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图片放在`src/assets/img/icons`下，命名为`lemon.svg`。
- en: In `app.module.ts`, import `HttpClientModule` to `AppComponent` so that the
    `.svg` file can be requested over HTTP
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app.module.ts`中，将`HttpClientModule`导入到`AppComponent`，以便可以通过HTTP请求`.svg`文件。
- en: 'Update `AppComponent` to register the new svg file as an icon:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`AppComponent`以注册新的svg文件作为图标：
- en: '[PRE30]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the icon to the toolbar:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图标添加到工具栏：
- en: '[PRE31]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now let's add the remaining icons for menu, user profile, and logout.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加剩余的菜单、用户资料和注销图标。
- en: Material icons
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 材料图标
- en: Angular Material works out of the box with the Material Design icon font, which
    is automatically imported into your app as a web font in your `index.html`. It
    is possible to self-host the font; however, if you go down that path, you don't
    get the benefit if the user's browser has already cached the font from when they
    visited another website, which could save the speed and latency of downloading
    a 42-56 KB file in the process. The complete list of icons can be found at [https://material.io/icons/](https://material.io/icons/).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material与Material Design图标字体无缝配合，该字体作为网络字体自动导入到您的`index.html`应用中。您可以自托管该字体；然而，如果您选择这条路，当用户的浏览器已经从访问另一个网站时缓存了字体，您将无法获得好处，这可能会在下载42-56
    KB文件的过程中节省速度和延迟。完整的图标列表可以在[https://material.io/icons/](https://material.io/icons/)找到。
- en: 'Now let''s update the toolbar with some icons and set up the home page with
    a minimal template for a fake login button:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新工具栏并设置主页，使用最小模板创建一个假登录按钮：
- en: 'Ensure that the Material icons `<link>` tag has been added to `index.html`:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Material图标`<link>`标签已添加到`index.html`。
- en: '[PRE32]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Instructions on how to self-host can be found under the **Self Hosting** section
    at [http://google.github.io/material-design-icons/#getting-icons](http://google.github.io/material-design-icons/#getting-icons).
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如何自托管的说明可以在[http://google.github.io/material-design-icons/#getting-icons](http://google.github.io/material-design-icons/#getting-icons)的**自托管**部分找到。
- en: Once configured, working with Material icons is easy.
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦配置完成，使用Material图标就变得简单。
- en: On `AppComponent`, update the toolbar to place a **Menu** button to the left
    of the title.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppComponent`上，更新工具栏以将**菜单**按钮放置在标题左侧。
- en: Add the `fxFlex` directive so that the remaining icons are right aligned.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`fxFlex`指令，以便剩余的图标右对齐。
- en: 'Add user profile and logout icons:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加用户资料和注销图标：
- en: '[PRE33]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'On `HomeComponent`, add a minimal template for a login experience, replacing any
    existing content:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HomeComponent`中，添加一个用于登录体验的最小模板，替换任何现有内容：
- en: '[PRE34]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Your app should look similar to this screenshot:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用应该看起来与这张截图相似：
- en: '![](img/B14094_07_13.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_07_13.png)'
- en: 'Figure 7.13: LemonMart with minimal login'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13：LemonMart的最小化登录
- en: There's still some work to be done, in terms of implementing and showing/hiding
    the menu, profile, and logout icons, given the user's authentication status. We
    will cover this functionality in *Chapter 8*, *Designing Authentication and Authorization*.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现和显示/隐藏菜单、个人资料和注销图标方面，根据用户的认证状态，还有一些工作要做。我们将在*第8章*，*设计认证和授权*中介绍这一功能。
- en: In order to debug the router, get a visualization of your routers, and tightly
    integrate Chrome debugging features using Angular Augury, see *Appendix A,* *Debugging
    Angular*.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试路由，获取你的路由的可视化，并使用Angular Augury紧密集成Chrome调试功能，请参阅*附录A*，*调试Angular*。
- en: Now that you've set up basic routing for your app, we can move on to setting
    up lazily loaded modules with subcomponents. If you're not familiar with troubleshooting
    and debugging Angular, please refer to the *Appendix A**, Debugging Angular*,
    before moving forward.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为你的应用设置了基本的路由，我们可以继续设置带有子组件的lazy加载模块。如果你不熟悉Angular的故障排除和调试，请在继续之前参考*附录A*，*调试Angular*。
- en: Feature modules with lazy loading
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有lazy加载的功能模块
- en: 'There are two ways resources are loaded: eagerly or lazily. When the browser
    loads up the `index.html` for your app, it starts processing it top to bottom.
    First the `<head>` element is processed, then the `<body>`. For example, the CSS
    resources we defined in the `<head>` of our app will be downloaded before our
    app is rendered, because our Angular app is defined as a `<script>` in the `<body>`
    of the HTML file.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 资源有两种加载方式：eager或lazy。当浏览器加载你的应用的`index.html`时，它从上到下开始处理。首先处理`<head>`元素，然后是`<body>`。例如，我们在应用的`<head>`中定义的CSS资源将在应用渲染之前下载，因为我们的Angular应用在HTML文件的`<body>`中定义为`<script>`。
- en: When you use the command `ng build`, Angular leverages the webpack module bundler
    to combine all the JavaScript, HTML, and CSS into minified and optimized JavaScript
    bundles.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用命令`ng build`时，Angular利用webpack模块打包器将所有JavaScript、HTML和CSS组合成最小化和优化的JavaScript包。
- en: If you don't leverage lazy loading in Angular, the entire contents of your app
    will be eagerly loaded. The user won't see the first screen of your app until
    all screens are downloaded and loaded.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在Angular中使用lazy加载，你的应用的所有内容都将被eager加载。用户将不会看到你的应用的第一屏，直到所有屏幕都下载并加载完成。
- en: Lazy loading allows the Angular build process, working in tandem with webpack,
    to separate your web application into different JavaScript files called chunks.
    We can enable this chunking by separating out portions of the application into
    feature modules. Feature modules and their dependencies can be bundled into separate
    chunks. Remember that the root module and its dependencies will always be in the
    first chunk that is downloaded. So, by chunking our application's JavaScript bundle
    size, we keep the size of the initial chunk at a minimum. With a minimal first
    chunk, no matter how big your application grows, the time to first meaningful
    paint remains constant. Otherwise, your app would take longer and longer to download
    and render as you add more features and functionality to it. Lazy loading is critical
    to achieving a scalable application architecture.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Lazy加载允许Angular构建过程与webpack协同工作，将你的Web应用分离成不同的JavaScript文件，称为chunks。我们可以通过将应用的部分功能分离成功能模块来启用这种chunking。功能模块及其依赖可以被捆绑到单独的chunks中。记住，根模块及其依赖将始终在下载的第一个chunk中。因此，通过chunking我们应用的JavaScript包大小，我们保持初始chunk的大小最小。有了最小化的初始chunk，无论你的应用如何增长，首次有意义的绘制时间保持不变。否则，随着你向应用添加更多功能和功能，你的应用将需要更长的时间来下载和渲染。Lazy加载对于实现可扩展的应用架构至关重要。
- en: 'Consider the following graphic to determine which routes are eagerly loaded
    and which ones are lazily loaded:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图形以确定哪些路由是eager加载的，哪些是lazy加载的：
- en: '![](img/B14094_07_14.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_07_14.png)'
- en: 'Figure 7.14: Angular router eager vs lazy loading'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14：Angular路由的 eager 加载与 lazy 加载
- en: 'The `rootRouter` defines three routes: `a`, `b`, and `c`. `/master` and `/detail`
    represent named router outlets, which are covered in *Chapter 12*, *Recipes –
    Master/Detail, Data Tables, and NgRx*. Route `a` is the default route for the
    app. Routes `a` and `c` are connected to the `rootRouter` with a solid line, whereas
    route `b` is connected using a dashed line. In this context, route `b` is configured
    as a lazy-loaded route. This means that route `b` will dynamically load a feature
    module, called **BModule**, that contains its `childRouter`. This `childRouter`
    can define any number of components, even reusing route names that were reused
    elsewhere. In this case, `b` defines three additional routes: `d`, `e`, and `f`.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`rootRouter` 定义了三条路由：`a`、`b` 和 `c`。`/master` 和 `/detail` 代表了命名的路由出口，这在 *第12章*、*食谱
    – 主/详情、数据表和 NgRx* 中有详细说明。路由 `a` 是应用的默认路由。路由 `a` 和 `c` 用实线连接到 `rootRouter`，而路由
    `b` 则使用虚线连接。在这种情况下，路由 `b` 被配置为懒加载路由。这意味着路由 `b` 将动态加载一个名为 **BModule** 的功能模块，该模块包含其
    `childRouter`。这个 `childRouter` 可以定义任意数量的组件，甚至可以复用其他地方已经复用的路由名称。在这种情况下，`b` 定义了三条额外的路由：`d`、`e`
    和 `f`。'
- en: 'Consider the example router definition for the `rootRouter`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 `rootRouter` 的示例路由定义：
- en: '[PRE35]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note that the definitions for routes `d`, `e`, and `f` do not exist in the
    `rootRouter`. See the example router definition for the `childRouter`:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，路由 `d`、`e` 和 `f` 的定义在 `rootRouter` 中不存在。请参阅 `childRouter` 的示例路由定义：
- en: '[PRE36]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see the routes defined in the `childRouter` are independent of the
    ones defined in the `rootRouter`. Child routes exist in a hierarchy, where `/b`
    is the parent path. To navigate to the `DComponent`, you must use the path `/b/d`,
    whereas, to navigate to `CComponent`, you can just use `/c`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`childRouter` 中定义的路由与 `rootRouter` 中定义的路由是独立的。子路由存在于一个层次结构中，其中 `/b` 是父路径。要导航到
    `DComponent`，您必须使用路径 `/b/d`，而要导航到 `CComponent`，您只需使用 `/c` 即可。
- en: Given this example configuration, every component defined in the `rootRouter`
    and their dependencies would be in the first chunk of our app, and thus eagerly
    loaded. The first chunk would include the components `A`, `Master`, `Detail`,
    `C`, and `PageNotFound`. The second chunk would contain the components `D`, `E`,
    and `F`. This second chunk would not be downloaded or loaded until the user navigated
    to a path starting with `/b`; thus, it's lazily loaded.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个示例配置，`rootRouter` 中定义的每个组件及其依赖项都会在我们的应用的第一块中，因此会预先加载。第一个块将包括组件 `A`、`Master`、`Detail`、`C`
    和 `PageNotFound`。第二个块将包含组件 `D`、`E` 和 `F`。这个第二个块将不会在用户导航到以 `/b` 开头的路径之前下载或加载；因此，它是懒加载的。
- en: In the book I only cover the well-established method of lazily loaded feature
    modules. Check out John Papa's blog post on creating lazily loading components
    at [https://johnpapa.net/angular-9-lazy-loading-components/](https://johnpapa.net/angular-9-lazy-loading-components/).
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在书中，我只介绍了已建立的方法，即懒加载功能模块。请查看 John Papa 的博客文章，关于在 [https://johnpapa.net/angular-9-lazy-loading-components/](https://johnpapa.net/angular-9-lazy-loading-components/)
    创建懒加载组件。
- en: We will now go over how to set up a feature module with components and routes.
    We will also use Augury to observe the effects of our various router configurations.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将介绍如何设置带有组件和路由的功能模块。我们还将使用 Augury 来观察我们各种路由配置的效果。
- en: Configuring feature modules with components and routes
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置带有组件和路由的功能模块
- en: 'The manager module needs a landing page, as shown in this mock-up:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 管理模块需要一个着陆页，如图所示：
- en: '![](img/B14094_07_15.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_07_15.png)'
- en: 'Figure 7.15: Manager''s dashboard'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15：管理员的仪表板
- en: 'Let''s start by creating the home screen for the `ManagerModule`:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建 `ManagerModule` 的主屏幕开始：
- en: 'Create the `ManagerHome` component:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `ManagerHome` 组件：
- en: '[PRE37]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In order to create the new component under the `manager` folder, we must prefix
    `manager/` in front of the component name. In addition, we specify that the component
    should be imported and declared with the `ManagerModule`. Since this is another
    landing page, it is unlikely to be complicated enough to require separate HTML
    and CSS files. You can use `--inline-style` (alias `-s`) and/or `--inline-template`
    (alias `-t`) to avoid creating additional files.
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了在 `manager` 文件夹下创建新的组件，我们必须在组件名称前加上 `manager/` 前缀。此外，我们指定该组件应该用 `ManagerModule`
    导入和声明。由于这是一个另一个着陆页，它可能不会复杂到需要单独的 HTML 和 CSS 文件。您可以使用 `--inline-style`（别名 `-s`）和/或
    `--inline-template`（别名 `-t`）来避免创建额外的文件。
- en: 'Verify that your folder structure looks as follows:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认您的文件夹结构如下：
- en: '[PRE38]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Configure the `ManagerHome` component''s route with `manager-routing.module`,
    similar to how we configured the `Home` component with `app-route.module`:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `manager-routing.module` 配置 `ManagerHome` 组件的路由，类似于我们如何使用 `app-route.module`
    配置 `Home` 组件：
- en: '[PRE39]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that `http://localhost:5000/manager` doesn't actually resolve to a component
    yet, because our Angular app isn't aware that `ManagerModule` exists. Let's first
    try the brute-force, eager-loading approach to import `ManagerModule` and register
    the manager route with our app.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`http://localhost:5000/manager` 实际上还没有解析到组件，因为我们的 Angular 应用不知道 `ManagerModule`
    的存在。让我们首先尝试强制、急切加载的方法来导入 `ManagerModule` 并将管理路由注册到我们的应用中。
- en: Eager loading
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 急切加载
- en: 'Let''s start by eagerly loading the `ManagerModule`, so we can see how importing
    and registering routes in the root module doesn''t result in a scalable solution:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先急切加载 `ManagerModule`，这样我们可以看到在根模块中导入和注册路由并不会导致可扩展的解决方案：
- en: 'Import the `ManagerModule` in `app.module.ts`:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app.module.ts` 中导入 `ManagerModule`：
- en: '[PRE40]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You will note that `http://localhost:5000/manager` still doesn't render its
    `home` component.
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到 `http://localhost:5000/manager` 仍然没有渲染其 `home` 组件。
- en: Use **Augury** to debug the router state, as shown:![](img/B14094_07_16.png)
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **Augury** 调试路由状态，如图所示：![图片](img/B14094_07_16.png)
- en: 'Figure 7.16: Router tree with eager loading'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.16：急切加载的路由树
- en: 'Note that at the time of publishing, Augury''s support for the Ivy rendering
    engine is not great. In order to reliably view the **Router Tree** tab, you need
    to disable Ivy. You can do so by adding the following setting to the `tsconfig.app.json`
    file in your project:'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在发布时，Augury 对 Ivy 渲染引擎的支持并不好。为了可靠地查看 **路由树** 选项卡，你需要禁用 Ivy。你可以在项目的 `tsconfig.app.json`
    文件中添加以下设置：
- en: '[PRE41]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You will need to restart your Angular app and reload Augury for changes to take
    effect. However, getting the pretty diagram is not worth accidentally shipping
    your app with Ivy disabled. Be careful with this one!
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你需要重新启动你的 Angular 应用并重新加载 Augury 以使更改生效。然而，得到一个漂亮的图表并不值得意外地将你的应用与 Ivy 禁用一起发布。请小心处理这个问题！
- en: It seems as if the `/manager` path is correctly registered and pointed at the
    correct component, `ManagerHomeComponent`. The issue here is that the `rootRouter`
    configured in `app-routing.module` isn't aware of the `/manager` path, so the
    `**` path is taking precedence and rendering the `PageNotFoundComponent` instead.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看起来 `/manager` 路径已正确注册并指向正确的组件，`ManagerHomeComponent`。这里的问题是，在 `app-routing.module`
    中配置的 `rootRouter` 并不知道 `/manager` 路径，所以 `**` 路径优先级更高，导致渲染了 `PageNotFoundComponent`。
- en: 'Implement the `''manager''` path in `app-routing.module.ts` and assign `ManagerHomeComponent`
    to it, so we can see what happens:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app-routing.module.ts` 中实现 `'manager'` 路径，并将其分配给 `ManagerHomeComponent`，这样我们就可以看到会发生什么：
- en: '[PRE42]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![](img/B14094_07_17.png)'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B14094_07_17.png)'
- en: 'Figure 7.17: Manager home renders with duplicate path registration'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.17：重复路径注册导致的 Manager 主页渲染
- en: As shown in the image above, `http://localhost:5000/manager` renders correctly,
    by displaying manager-home works! However, when you debug the router state through
    Augury, note that the `ManagerHomeComponent` is registered twice. This is because
    both the `rootRouter` and the `childRouter` registrations are being picked up.
    To avoid this issue, we would have to centralize all path creation in the `rootRouter`
    and not use child routers.
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如上图所示，`http://localhost:5000/manager` 正确渲染，显示 manager-home 正常工作！然而，当你通过 Augury
    调试路由状态时，请注意 `ManagerHomeComponent` 被注册了两次。这是因为 `rootRouter` 和 `childRouter` 的注册都被选中了。为了避免这个问题，我们不得不在
    `rootRouter` 中集中创建所有路径，并且不使用子路由。
- en: Centralizing all paths in the `rootRouter` doesn't scale well, because it forces
    all developers to maintain a single master file to import and configure every
    module. It is ripe for merge conflicts and frustrating exchanges between team
    members. As a file grows larger, the chances of introducing a bug increase exponentially,
    where the same route could unintentionally be registered multiple times.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将所有路径集中到 `rootRouter` 中并不具有良好的可扩展性，因为它强迫所有开发者维护一个单独的主文件来导入和配置每个模块。这很容易导致合并冲突和团队成员之间的挫败感。随着文件变大，引入错误的可能性会呈指数级增加，同一个路由可能会无意中注册多次。
- en: It is possible to engineer a solution to divide up the modules into multiple
    files. Instead of the standard `*-routing.module`, you could implement a new routes
    array in `ManagerModule` and import it to the `rootRouter`. Let's fix the duplicate
    registration issue.
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以设计一个解决方案，将模块分割成多个文件。你可以在 `ManagerModule` 中实现一个新的路由数组，并将其导入到 `rootRouter` 中。让我们修复重复注册的问题。
- en: In `manager.module.ts`, remove `ManagerRoutingModule` from the imports array.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `manager.module.ts` 中，从导入数组中移除 `ManagerRoutingModule`。
- en: 'In `manager.module.ts`, implement a `Routes` array and set an empty path for
    the component `ManagerHomeComponent` as shown:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `manager.module.ts` 中实现一个 `Routes` 数组，并为组件 `ManagerHomeComponent` 设置一个空路径，如下所示：
- en: '[PRE43]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In `app-routing.module.ts`, import the array you just created and assign it
    to the `children` property of the `''manager''` path:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app-routing.module.ts` 中，导入你刚刚创建的数组，并将其分配给 `'manager'` 路径的 `children` 属性：
- en: '[PRE44]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Don't forget to remove the `component` property and the import for `ManagerHomeModule`.
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记移除 `component` 属性和 `ManagerHomeModule` 的导入。
- en: 'Let''s inspect the **Router Tree** on Augury again to see if we resolved the
    duplicate registration issue:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Augury 再次检查 **Router 树**，看看是否解决了重复注册的问题：
- en: '![](img/B14094_07_18.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_07_18.png)'
- en: 'Figure 7.18: Router Tree with children routes'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18：带有子路由的 Router 树
- en: The provided solution works. There are no duplicate registrations, because we
    stopped using the `childRouters` in `manager-routing.module.ts`. In addition,
    we maintained some separation of concerns, by not importing `ManagerHomeComponent`
    outside of `ManagerModule`, resulting in a more scalable solution. However, as
    the app grows, we must still register all modules with `app.module.ts`. As a result,
    feature modules are still tightly coupled to the root module in potentially unpredictable
    ways. Further, this code can't be chunked, because the feature module is directly
    imported in `app.module.ts`, so the TypeScript compiler sees it as a required
    dependency.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的解决方案是有效的。因为没有重复注册，因为我们停止在 `manager-routing.module.ts` 中使用 `childRouters`。此外，我们通过不在
    `ManagerModule` 之外导入 `ManagerHomeComponent` 来保持关注点的分离，从而得到一个更可扩展的解决方案。然而，随着应用的成长，我们仍然必须使用
    `app.module.ts` 注册所有模块。因此，功能模块仍然以可能不可预测的方式紧密耦合到根模块。此外，这段代码不能被分割，因为功能模块直接在 `app.module.ts`
    中导入，所以 TypeScript 编译器将其视为一个必需的依赖项。
- en: Next, let's transform our configuration into a lazily loading one.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将我们的配置转换成懒加载配置。
- en: Lazy loading
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒加载
- en: Now that you understand how eager loading of modules works, you will be able
    to better understand the code we are about to write, which may otherwise seem
    like black magic, and magical (also known as misunderstood) code always leads
    to spaghetti architectures.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了模块的急切加载是如何工作的，你将能够更好地理解我们即将编写的代码，否则它可能看起来像是黑魔法，而魔法（也称为误解）代码总是导致意大利面式架构。
- en: 'We will now evolve the eager loading solution to be a lazy loading one. In
    order to load routes from a different module, we know we can''t simply import
    them, otherwise they will be eagerly loaded. The answer lies in configuring a
    route using the `loadChildren` attribute with an inline import statement informing
    the router how to load a feature module in `app-routing.module.ts`:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将把急切加载的解决方案演变成懒加载。为了从不同的模块加载路由，我们知道我们不能简单地导入它们，否则它们将被急切加载。答案在于使用 `loadChildren`
    属性配置一个路由，并使用内联导入语句通知路由器如何在 `app-routing.module.ts` 中加载功能模块：
- en: Ensure that any module you intend to lazy load is not imported in `app.module.ts`,
    so remove the `ManagerModule` from the `imports`.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你打算懒加载的任何模块都没有在 `app.module.ts` 中导入，因此从 `imports` 中移除 `ManagerModule`。
- en: Remove the `Routes` array added to `ManagerModule`.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `ManagerModule` 中移除添加的 `Routes` 数组。
- en: Add back the `ManagerRoutingModule` to `imports` in `ManagerModule`.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ManagerRoutingModule` 添加回 `ManagerModule` 中的 `imports`。
- en: 'In `app-routing.module.ts`, implement or update the `''manager''` path with
    the `loadChildren` attribute:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app-routing.module.ts` 中，实现或更新 `'manager'` 路径的 `loadChildren` 属性：
- en: '[PRE45]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Lazy loading is achieved via a clever trick that avoids using an import statement
    at the file level. A function delegate is set to the `loadChildren` property,
    which contains an inline import statement defining the location of the feature
    module file, such as `./manager/manager.module`, allowing us to refer to `ManagerModule`
    in a type-safe manner without actually fully loading it. The inline import statement
    can be interpreted during the build process to create a separate JavaScript chunk
    that can be downloaded only when needed. `ManagerModule` then acts as if its own
    Angular app and manages all its children dependencies and routes.
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过一个巧妙的技巧实现了懒加载，避免了在文件级别使用导入语句。将一个函数委托设置到 `loadChildren` 属性，该属性包含一个内联导入语句，定义了功能模块文件的路径，例如
    `./manager/manager.module`，这样我们就可以以类型安全的方式引用 `ManagerModule`，而无需实际完全加载它。内联导入语句可以在构建过程中被解释，以创建一个单独的
    JavaScript 块，只有在需要时才下载。`ManagerModule` 因此表现得像它自己的 Angular 应用，并管理所有子依赖项和路由。
- en: 'Update the `manager-routing.module` routes, considering that `manager` is now
    their root route:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`manager-routing.module`路由，考虑到`manager`现在是它们的根路由：
- en: '[PRE46]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We can now update the route for `ManagerHomeComponent` to a more meaningful
    `'home'` path. This path won't clash with the one found in `app-routing.module`,
    because in this context, `'home'` resolves to `'manager/home'` and, similarly,
    where `path` is empty, the URL will look like `http://localhost:5000/manager`.
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以更新`ManagerHomeComponent`的路由到一个更有意义的`'home'`路径。这个路径不会与`app-routing.module`中找到的路径冲突，因为在这个上下文中，`'home'`解析为`'manager/home'`，同样地，当`path`为空时，URL将看起来像`http://localhost:5000/manager`。
- en: Restart your `ng serve` or `npm start` command, so Angular can chunk the app
    properly.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动`ng serve`或`npm start`命令，以便Angular可以正确地分割应用。
- en: Navigate to `http://localhost:5000/manager`.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`http://localhost:5000/manager`。
- en: Confirm that lazy loading is working by looking at Augury, as follows:![](img/B14094_07_19.png)
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查看Augury来确认懒加载是否正常工作，如下所示：![图片](img/B14094_07_19.png)
- en: 'Figure 7.19: Router tree with lazy loading'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.19：具有懒加载的路由树
- en: The root node for `ManagerHomeComponent` is now named **manager [Lazy]**.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManagerHomeComponent`的根节点现在命名为**manager [Lazy]**。'
- en: We have successfully set up a feature module with lazy loading. Next, let's
    implement the walking skeleton for LemonMart.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功设置了一个具有懒加载的功能模块。接下来，让我们为LemonMart实现行走骨架。
- en: Completing the walking skeleton
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成行走骨架
- en: Using the site map we created for LemonMart earlier in the chapter, we need
    to complete the walking skeleton navigation experience for the app. In order to
    create this experience, we will need to create some buttons to link all modules
    and components together. We will go at this module by module.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在本章早期为LemonMart创建的网站图，我们需要完成应用的行走骨架导航体验。为了创建这种体验，我们需要创建一些按钮来链接所有模块和组件。我们将按模块逐一进行。
- en: 'Before we start, update the login button on the `HomeComponent` to navigate
    to the `''manager''` path using the `routerLink` attribute and rename the button:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，更新`HomeComponent`上的登录按钮，使用`routerLink`属性将其导航到`'manager'`路径，并重命名按钮：
- en: '[PRE47]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, we can navigate to the `ManagerHome` component by clicking on the **Login**
    button.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过点击**登录**按钮来导航到`ManagerHome`组件。
- en: The manager module
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理器模块
- en: Since we already enabled lazy loading for `ManagerModule`, let's go ahead and
    complete the rest of the navigational elements for it.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在`ManagerModule`中启用了懒加载，让我们继续完成其余的导航元素。
- en: 'In the current setup, `ManagerHomeComponent` renders in the `<router-outlet>`
    defined in `AppComponent`''s template, so when the user navigates from `HomeComponent`
    to `ManagerHomeComponent`, the toolbar implemented in `AppComponent` remains in
    place. See the following mock-up for **Manager''s Dashboard**:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前设置中，`ManagerHomeComponent`在`AppComponent`的模板中定义的`<router-outlet>`中渲染，所以当用户从`HomeComponent`导航到`ManagerHomeComponent`时，`AppComponent`中实现的工具栏仍然在位。参见以下**管理器仪表板**的模拟图：
- en: '![](img/B14094_07_20.png)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_07_20.png)'
- en: 'Figure 7.20: App-wide and feature module toolbars'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20：全局和功能模块工具栏
- en: The app-wide toolbar remains in place no matter where we navigate to. You can
    imagine that we can implement a similar toolbar for the feature module that persists
    throughout `ManagerModule`. So, the navigational buttons **User Management** and
    **Receipt Look-up** would always be visible. This allows us to create a consistent
    UX for navigating subpages across modules.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们导航到哪里，全局工具栏都保持不变。你可以想象我们可以为功能模块实现一个类似的工具栏，它在`ManagerModule`中持续存在。因此，导航按钮**用户管理**和**收据查找**将始终可见。这允许我们在模块之间导航子页面时创建一致的UX。
- en: 'To implement a secondary toolbar, we need to replicate the parent-child relationship
    between `AppComponent` and `HomeComponent`, where the parent implements the toolbar
    and a `<router-outlet>` so that children elements can be rendered in there:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个次要的工具栏，我们需要复制`AppComponent`和`HomeComponent`之间的父子关系，其中父组件实现工具栏和一个`<router-outlet>`，以便子元素可以在这里渲染：
- en: 'Start by creating the base `manager` component:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建基本的`manager`组件：
- en: '[PRE48]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `--flat` option skips directory creation and places the component directly
    under the `manager` folder, just like `app.component` residing directly under
    the `app` folder.
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`--flat`选项将跳过目录创建，并将组件直接放置在`manager`文件夹下，就像`app.component`直接位于`app`文件夹下一样。
- en: 'In `ManagerComponent`, implement a navigational toolbar with `activeLink` tracking:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ManagerComponent`中，实现一个带有`activeLink`跟踪的导航工具栏：
- en: '[PRE49]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It must be noted that feature modules don't automatically have access to services
    or components created in parent modules. This is an important default behavior
    to preserve a decoupled architecture. However, there are certain cases where it
    is desirable to share some amount of code. In this case, `mat-toolbar` needs to
    be reimported. Since the `MatToolbarModule` is already loaded in `src/app/material.module.ts`,
    we can just import this module into `manager.module.ts` and there will not be
    a performance or memory penalty for doing so.
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 必须注意，功能模块不会自动访问在父模块中创建的服务或组件。这是一个重要的默认行为，以保持解耦架构。然而，在某些情况下，共享一定量的代码是有益的。在这种情况下，需要重新导入`mat-toolbar`。由于`MatToolbarModule`已经在`src/app/material.module.ts`中加载，我们只需将此模块导入到`manager.module.ts`中，这样就不会有性能或内存的惩罚。
- en: 'Ensure `ManagerComponent` is declared and `MaterialModule` is imported in `ManagerModule`:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在`ManagerModule`中声明了`ManagerComponent`并导入了`MaterialModule`：
- en: '[PRE50]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create components for the subpages:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建子页面的组件：
- en: '[PRE51]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create the parent-children routing. We know that we need the following routes
    to be able to navigate to our subpages, as follows:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建父子路由。我们知道我们需要以下路由来导航到我们的子页面，如下所示：
- en: '[PRE52]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In order to target the `<router-outlet>` defined in `ManagerComponent`, we
    need to create a parent route first and then specify routes for the subpages:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 为了针对在`ManagerComponent`中定义的`<router-outlet>`，我们需要首先创建一个父路由，然后指定子页面的路由：
- en: '[PRE53]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You should now be able to navigate through the app. When you click on the **Login
    as Manager** button, you will be taken to the page shown here. The clickable targets
    are highlighted, as shown:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够导航到应用中。当你点击**登录为经理**按钮时，你将被带到这里显示的页面。可点击的目标被突出显示，如下所示：
- en: '![](img/B14094_07_21.png)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_07_21.png)'
- en: 'Figure 7.21: Manager''s Dashboard with all router links highlighted'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21：所有路由链接高亮的经理仪表板
- en: If you click on **LemonMart**, you will be taken to the home page. If you click
    on **Manager's Dashboard**, **User Management**, or **Receipt Lookup**, you will
    be navigated to the corresponding subpage, while the active link will be bold
    and underlined on the toolbar.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**LemonMart**，你将被带到主页。如果你点击**经理仪表板**、**用户管理**或**收据查找**，你将被导航到相应的子页面，而活动链接将在工具栏上加粗并下划线。
- en: User module
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户模块
- en: 'Upon login, users will be able to access their profiles and view a list of
    actions they can access in the LemonMart app through a side navigation menu. In
    *Chapter 8*, *Designing Authentication and Authorization*, when we implement authentication
    and authorization, we will be receiving the role of the user from the server.
    Based on the role of the user, we will be able to automatically navigate or limit
    the options users can see. We will implement these components in this module so
    that they will only be loaded once a user is logged in. For the purpose of completing
    the walking skeleton, we will ignore authentication-related concerns:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，用户将能够访问他们的个人资料，并通过侧边导航菜单查看他们在LemonMart应用中可以访问的操作列表。在*第8章*，*设计身份验证和授权*中，当我们实现身份验证和授权时，我们将从服务器接收用户的角色。根据用户的角色，我们将能够自动导航或限制用户可以看到的选项。我们将在这个模块中实现这些组件，以便它们只在用户登录后加载。为了完成行走骨架，我们将忽略与身份验证相关的问题：
- en: 'Create the necessary components:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建必要的组件：
- en: '[PRE54]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Implement routing.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现路由。
- en: 'Start with implementing the lazy loading in `app-routing.module.ts`:'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从在`app-routing.module.ts`中实现懒加载开始：
- en: '[PRE55]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Ensure that the `PageNotFoundComponent` route is always the last route in `app-routing.module`.
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保在`app-routing.module`中，`PageNotFoundComponent`路由总是最后一个路由。
- en: 'Now implement the child routes in `user-routing.module.ts`:'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在在`user-routing.module.ts`中实现子路由：
- en: '[PRE56]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We are implementing routing for `NavigationMenuComponent`, because it'll be
    directly used as an HTML element. In addition, since `UserModule` doesn't have
    a landing page, there's no default path defined.
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在为`NavigationMenuComponent`实现路由，因为它将被直接用作HTML元素。此外，由于`UserModule`没有登录页面，因此没有定义默认路径。
- en: 'In `AppComponent`, wire up the user and logout icons:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppComponent`中，连接用户和注销图标：
- en: '[PRE57]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Icon buttons can be cryptic, so it's a good idea to add tooltips to them. In
    order for tooltips to work, switch from the `mat-icon-button` directive to the
    `mat-mini-fab` directive and ensure that you import `MatTooltipModule` in `material.module.ts`.
    In addition, ensure that you add `aria-label` for icon-only buttons so that users
    with disabilities relying on screen readers can still navigate your web application.
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图标按钮可能难以理解，因此为它们添加工具提示是个好主意。为了使工具提示正常工作，从`mat-icon-button`指令切换到`mat-mini-fab`指令，并确保在`material.module.ts`中导入`MatTooltipModule`。此外，确保为仅图标按钮添加`aria-label`，以便依赖屏幕阅读器的残疾用户仍然可以导航你的Web应用。
- en: Ensure that the app works.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保应用正常运行。
- en: 'You''ll note that the two buttons are too close to each other, as follows:'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到两个按钮距离太近，如下所示：
- en: '![](img/B14094_07_22.png)'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B14094_07_22.png)'
- en: 'Figure 7.22: Toolbar with icons'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.22：带有图标的工具栏
- en: 'You can fix the icon layout issue by adding `fxLayoutGap="8px"` to `<mat-toolbar>`;
    however, now the lemon logo is too far apart from the app name, as shown:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过向`<mat-toolbar>`添加`fxLayoutGap="8px"`来解决图标布局问题；然而，现在柠檬标志与应用名称的距离太远，如下所示：
- en: '![](img/B14094_07_23.png)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_07_23.png)'
- en: 'Figure 7.23: Toolbar with padded icons'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.23：带有填充图标的工具栏
- en: 'The logo layout issue can be fixed by merging the icon and the button:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过合并图标和按钮可以解决标志布局问题：
- en: '[PRE58]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As shown in the following screenshot, the grouping fixes the layout issue:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，分组解决了布局问题：
- en: '![](img/B14094_07_24.png)'
  id: totrans-505
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_07_24.png)'
- en: 'Figure 7.24: Toolbar with grouped and padded elements'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.24：带有分组和填充元素的工具栏
- en: This is more desirable from a UX perspective also; now users can go back to
    the home page by clicking on the lemon as well.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户体验角度来看，这也是更受欢迎的；现在用户可以通过点击柠檬回到主页。
- en: POS and inventory modules
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POS和库存模块
- en: Our walking skeleton presumes the role of the manager. To be able to access
    all components we are about to create, we need to enable the manager to be able
    to access POS and inventory modules.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的行走骨架扮演着管理者的角色。为了能够访问我们即将创建的所有组件，我们需要使管理者能够访问POS和库存模块。
- en: 'Update `ManagerComponent` with two new buttons:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ManagerComponent`中添加两个新按钮：
- en: '[PRE59]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that these router links will navigate us out of the realm of the `ManagerModule`,
    so it is normal for the manager-specific secondary toolbar to disappear.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些路由链接将带我们离开`ManagerModule`的领域，因此管理者特定的辅助工具栏消失是正常的。
- en: Now, it'll be up to you to implement the last two remaining modules. For the
    two new modules, I provide high-level steps and refer you to a previous module
    you can model the new one on. If you get stuck refer to the `projects/ch7` folder
    on the GitHub project at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的最后两个模块将由你来实现。对于这两个新模块，我提供了高级步骤，并建议你参考之前的模块来构建新的模块。如果你遇到困难，请参考GitHub项目[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)中的`projects/ch7`文件夹。
- en: POS module
  id: totrans-514
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POS模块
- en: '`PosModule` is very similar to the `UserModule`, except that `PosModule` was
    a default path. The `PosComponent` will be the default component. This has the
    potential to be a complicated component with some subcomponents, so don''t use
    inline templates or styles:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '`PosModule`与`UserModule`非常相似，除了`PosModule`是一个默认路径。`PosComponent`将是默认组件。这可能会是一个复杂的组件，包含一些子组件，因此不要使用内联模板或样式：'
- en: Create the `PosComponent`
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`PosComponent`
- en: Register `PosComponent` as the default path
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PosComponent`注册为默认路径
- en: Configure lazy loading for `PosModule`
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`PosModule`配置懒加载
- en: Ensure that the app works
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保应用正常运行
- en: Now let's implement the inventory module.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现库存模块。
- en: Inventory module
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 库存模块
- en: '`InventoryModule` is very similar to `ManagerModule`, as shown:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryModule`与`ManagerModule`非常相似，如下所示：'
- en: '![](img/B14094_07_25.png)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_07_25.png)'
- en: 'Figure 7.25: Inventory Dashboard mock-up'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.25：库存仪表板原型
- en: Create a base `Inventory` component
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基本的`Inventory`组件
- en: Register the `MaterialModule`
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册`MaterialModule`
- en: Create **Inventory Home**, **Stock Entry**, **Products**, and **Categories**
    components
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建**库存主页**、**库存录入**、**产品**和**分类**组件
- en: Configure parent-children routes in `inventory-routing.module.ts`
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`inventory-routing.module.ts`中配置父子路由
- en: Configure lazy loading for `InventoryModule`
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`InventoryModule`配置懒加载
- en: Implement a secondary toolbar for internal `InventoryModule` navigation in `InventoryComponent`
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`InventoryComponent`中实现内部`InventoryModule`导航的辅助工具栏
- en: 'Ensure that the app works, as shown:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保应用如所示正常运行：
- en: '![](img/B14094_07_26.png)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_07_26.png)'
- en: 'Figure 7.26: LemonMart Inventory Dashboard'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.26：LemonMart库存仪表板
- en: Now that the walking skeleton of the app is completed, it is important to inspect
    the router tree to ensure that lazy loading has been configured correctly and
    modules aren't unintentionally being eagerly loaded.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用的行走骨架已经完成，检查路由树以确保正确配置了懒加载并且模块没有意外地被急切加载是很重要的。
- en: Inspect the router tree
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查路由树
- en: 'Navigate to the base route of the app and use Augury to inspect the router
    tree, as illustrated:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到应用的基路由，并使用Augury检查路由树，如图所示：
- en: '![](img/B14094_07_27.png)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_07_27.png)'
- en: 'Figure 7.27: Router tree with lazy loading'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.27：具有懒加载的路由树
- en: Everything but the initially required components should be denoted with the
    **[Lazy]** attribute. If, for some reason, routes are not denoted with **[Lazy]**,
    chances are that they are mistakenly being imported in `app.module.ts` or some
    other component.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最初所需的组件之外，所有其他组件都应该用**[Lazy]**属性标记。如果出于某种原因，路由没有用**[Lazy]**标记，那么它们很可能是错误地被导入到`app.module.ts`或其他组件中。
- en: In your router tree, you may notice that `ProfileComponent` and `LogoutComponent`
    are eagerly loaded, whereas the `UserModule` is correctly labeled as **[Lazy]**.
    Even multiple visual inspections through the tooling and the codebase may leave
    you searching for the culprit. However, if you run a global search for `UserModule`,
    you'll quickly discover that it was being imported into `app.module.ts`. When
    running CLI commands, your module may inadvertently get re-imported into `app.module.ts`,
    so keep an eye out for this!
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的路由树中，你可能注意到`ProfileComponent`和`LogoutComponent`是急切加载的，而`UserModule`被正确标记为**[Lazy]**。即使通过工具和代码库进行多次视觉检查，也可能让你寻找罪魁祸首。然而，如果你全局搜索`UserModule`，你会很快发现它被导入到`app.module.ts`中。在运行CLI命令时，你的模块可能会意外地重新导入到`app.module.ts`中，所以请注意这一点！
- en: 'To be on the safe side, inspect your `app.module.ts` file and be sure to remove
    any import statements for modules or components that are not at the root level.
    Your file should look like the following one:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，检查你的`app.module.ts`文件，并确保删除任何非根级别的模块或组件的导入语句。你的文件应该看起来像以下这样：
- en: '[PRE60]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If you disabled Ivy while debugging your routes with Augury, now's the time
    to re-enable it.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Augury调试路由时禁用了Ivy，现在是时候重新启用它了。
- en: It is expected that the reader resolves any testing errors before moving on.
    Ensure that `npm test` and `npm run e2e` execute without errors.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 预期读者在继续之前解决任何测试错误。确保`npm test`和`npm run e2e`执行时没有错误。
- en: Common testing module
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共测试模块
- en: Now that we have a lot of modules to deal with, it becomes tedious to configure
    the imports and providers for each spec file individually. For this purpose, I
    recommend creating a common testing module to contain generic configuration that
    you can reuse across the board.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有很多模块要处理，为每个spec文件单独配置导入和提供者变得很繁琐。为此，我建议创建一个公共测试模块来包含通用的配置，你可以在各个地方重用它。
- en: First start by creating a new `.ts` file
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的`.ts`文件
- en: Create `common/common.testing.ts`.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`common/common.testing.ts`。
- en: Populate it with common testing providers, fakes, and modules.
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用常见的测试提供者、模拟和模块填充它。
- en: 'I have provided fake implementations of `ObservableMedia`, `MatIconRegistry`,
    and `DomSanitizer`, along with arrays for `commonTestingProviders` and `commonTestingModules`:'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我已经提供了`ObservableMedia`、`MatIconRegistry`和`DomSanitizer`的模拟实现，以及`commonTestingProviders`和`commonTestingModules`的数组：
- en: '[PRE61]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now let''s see a sample use of this shared configuration file:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这个共享配置文件的一个示例用法：
- en: '[PRE62]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Most other modules will just need `commonTestingModules` to be imported.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数其他模块只需要导入`commonTestingModules`。
- en: Stop! Did you ensure all your unit tests are passing? To ensure that your tests
    are always passing implement a CI pipeline in CircleCI, as demonstrated in *Chapter
    4*, *Automated Testing, CI, and Releasing to Production*.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 停！你确保了所有单元测试都通过了吗？为了确保你的测试始终通过，在CircleCI中实现一个CI管道，如*第4章*中所示，*自动化测试、CI和发布到生产*。
- en: With your tests up and running, the walking skeleton for LemonMart is completed.
    Now, let's look ahead and start thinking about what kinds of data entities we
    might be working with.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的测试运行起来后，LemonMart的行走骨架就完成了。现在，让我们展望未来，开始思考我们可能会处理哪些数据实体。
- en: Designing around major data entities
  id: totrans-557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 围绕主要数据实体进行设计
- en: The fourth step in router-first architecture is achieving a stateless, data-driven
    design. To achieve this, it helps a lot to organize your APIs around major data
    components. This will roughly match how you consume data in various components in
    your Angular application. We will start off by defining our major data components
    by creating a rough data **entity relationship diagram** (**ERD**). In *Chapter
    10*, *RESTful APIs and Full-Stack Implementation*, we will design and implement
    an API for the user data entity using Swagger.io and Express.js.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 路由优先架构的第四步是实现无状态、数据驱动的设计。为了实现这一点，围绕主要数据组件组织你的API非常有帮助。这大致符合你在Angular应用程序的各种组件中消耗数据的方式。我们将从定义我们的主要数据组件开始，创建一个粗略的数据**实体关系图**（**ERD**）。在*第10章*，*RESTful
    API和全栈实现*中，我们将使用Swagger.io和Express.js设计和实现用户数据实体的API。
- en: Defining entities
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义实体
- en: Let's start by taking a stab at what kind of entities you would like to store
    and how these entities might relate to one another.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先尝试确定你希望存储哪些类型的实体以及这些实体之间可能如何相互关联。
- en: 'Here''s a sample design for LemonMart, created using [draw.io](http://draw.io):'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是LemonMart的一个示例设计，使用[draw.io](http://draw.io)创建的：
- en: '![](img/B14094_07_28.png)'
  id: totrans-562
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_07_28.png)'
- en: 'Figure 7.28: ERD for LemonMart'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.28：LemonMart的ERD
- en: At this moment, whether your entities are stored in a SQL or NoSQL database
    is inconsequential. My suggestion is to stick to what you know, but if you're
    starting from scratch, a NoSQL database like MongoDB will offer the most flexibility
    as your implementation and requirements evolve.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时刻，无论你的实体存储在SQL还是NoSQL数据库中，这并不重要。我的建议是坚持你所知道的，但如果你是从头开始的，那么像MongoDB这样的NoSQL数据库将提供最大的灵活性，因为你的实现和需求会不断演变。
- en: Generally speaking, you will need CRUD APIs for each entity. Considering these
    data elements, we can also imagine some user interfaces around these CRUD APIs.
    Let's do that next.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，你将为每个实体需要CRUD API。考虑到这些数据元素，我们也可以想象围绕这些CRUD API的一些用户界面。让我们接下来做这件事。
- en: High-level UX design
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级用户体验设计
- en: Mock-ups are important in determining what kind of components and user controls
    we will need throughout the app. Any user control or component that will be used
    across components will need to be defined at the root level and others scoped
    with their own modules.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 原型对于确定整个应用程序中需要哪些组件和用户控件非常重要。任何将在组件间使用的用户控件或组件都需要在根级别定义，其他则在其自己的模块中定义。
- en: 'Earlier in this chapter, we identified the sub modules and designed landing
    pages for them to complete the walking skeleton. Now that we have defined the
    major data components, we can complete mock-ups for the rest of the app. When
    designing screens at a high level, keep several things in mind:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们确定了子模块并为他们设计了着陆页以完成行走骨架。现在我们已经定义了主要数据组件，我们可以为应用程序的其余部分完成原型设计。在设计高级屏幕时，请记住以下几点：
- en: Can a user complete common tasks required for their role with as little navigation
    as possible?
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户能否以尽可能少的导航完成他们角色所需的基本任务？
- en: Can users readily access all information and functionality of the app through
    visible elements on the screen?
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户能否通过屏幕上的可见元素轻松访问应用程序的所有信息和功能？
- en: Can a user search for the data they need easily?
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户能否轻松搜索他们所需的数据？
- en: Once a user finds a record of interest, can they drill down into detail records
    or view related records with ease?
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦用户找到了感兴趣的记录，他们能否轻松地深入到详细记录或查看相关记录？
- en: Is that pop-up alert really necessary? You know users won't read it, right?
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那个弹出警告真的有必要吗？你知道用户不会阅读它，对吧？
- en: Keep in mind that there's no one right way to design any user experience, which
    is why when designing screens, you should always keep modularity and reusability
    in mind.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，没有一种设计用户体验的正确方法，这就是为什么在设计屏幕时，你应该始终考虑模块化和可重用性。
- en: Creating an artifacts Wiki
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建工件维基
- en: As mentioned earlier in the chapter, it is important to document every artifact
    you create. Wikis offer a way to create living documentation that can be collaboratively
    updated or edited. While Slack, Teams, email, and whiteboards offer good collaboration
    opportunities, their ephemeral nature leaves a lot to be desired.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，记录你创建的每个工件是很重要的。维基提供了一个创建可协作更新或编辑的活文档的方法。虽然Slack、Teams、电子邮件和白板提供了良好的协作机会，但它们的短暂性质还有很多需要改进的地方。
- en: 'So, as you generate various design artifacts, such as mock-ups or design decisions,
    take care to post them on a wiki reachable by all team members:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你生成各种设计工件，如原型或设计决策时，请确保将它们发布在所有团队成员都能访问的维基上：
- en: On GitHub, switch over to the **Wiki** tab
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub上，切换到**Wiki**标签页
- en: You may check out my sample wiki at [https://github.com/duluca/lemon-mart/wiki](https://github.com/duluca/lemon-mart/wiki),
    as shown:![](img/B14094_07_29.png)
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以查看我的示例Wiki，[https://github.com/duluca/lemon-mart/wiki](https://github.com/duluca/lemon-mart/wiki)，如图所示：![](img/B14094_07_29.png)
- en: 'Figure 7.29: GitHub.com LemonMart wiki'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.29：GitHub.com LemonMart wiki
- en: When creating a wiki page, ensure that you cross-link between any other documentation
    available, such as **Readme**
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建Wiki页面时，确保你在任何其他可用的文档之间进行交叉链接，例如**Readme**
- en: Note that GitHub shows subpages on the wiki under **Pages**
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，GitHub在**Pages**下显示Wiki的子页面
- en: However, an additional summary is helpful, such as the **Design Artifacts**
    section, since some people may miss the navigational element on the right
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，一个额外的概览也很有帮助，例如**设计工件**部分，因为有些人可能会错过右侧的导航元素
- en: As you complete mock-ups, post them on the wiki
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着你完成原型，将它们发布在Wiki上
- en: 'You can see a summary view of the wiki here:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到Wiki的概览视图：
- en: '![](img/B14094_07_30.png)'
  id: totrans-586
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_07_30.png)'
- en: 'Figure 7.30: Summary view of LemonMart mock-ups'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.30：LemonMart原型的概览视图
- en: Now that your artifacts are in a centralized place, it is accessible by all
    team members. They can add, edit, update, or groom the content. This way your
    wiki becomes useful, living documentation of the information that your team needs,
    as opposed to a piece of documentation you feel like you're being forced to create.
    Raise your hand if you've ever found yourself in that situation!
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的工件集中在一个地方，所有团队成员都可以访问。他们可以添加、编辑、更新或整理内容。这样，你的Wiki就变成了团队所需信息的有用、活生生的文档，而不是你感觉被迫创建的文档。如果你曾经发现自己处于那种情况，请举手！
- en: '![](img/B14094_07_002.png)'
  id: totrans-589
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_07_002.png)'
- en: Next, integrate your mock-ups into your app, so you can collect early feedback
    from your stakeholders and test out the flow of your application.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将你的原型整合到你的应用中，这样你可以收集利益相关者的早期反馈并测试你应用流程。
- en: Leveraging mock-ups in your app
  id: totrans-591
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在你的应用中利用原型
- en: 'Place the mock-ups in the walking skeleton app so that testers can better envision
    the functionality that is yet to be developed. See an example of this idea in
    action here:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 将原型放在可步行骨架应用中，以便测试人员可以更好地设想尚未开发的功能。在这里可以看到这个想法的一个示例：
- en: '![](img/B14094_07_31.png)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_07_31.png)'
- en: 'Figure 7.31: Using mock-ups in the UI to verify flow of app'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.31：在UI中使用原型验证应用流程
- en: This will also be helpful when designing and implementing your authentication
    and authorization workflow. With the mock-ups completed, we can now continue the
    implementation of LemonMart's authentication and authorization workflow in *Chapter
    8*, *Designing Authentication and Authorization*.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 这在设计和实施你的身份验证和授权流程时也会很有帮助。原型完成之后，我们现在可以继续在*第8章*，*设计身份验证和授权*中实施LemonMart的身份验证和授权流程。
- en: Summary
  id: totrans-596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you mastered how to effectively use the Angular CLI to create
    major Angular components and scaffolds. You became familiar with the 80-20 rule.
    You created the branding of your app, leveraging custom and built-in Material
    iconography. You learned how to debug complicated router configurations with Augury.
    Finally, you began building router-first apps, defining user roles early on, designing
    with lazy loading in mind, and nailing down a walking-skeleton navigation experience
    early on. We went over designing around major data entities. We also covered the
    importance of completing and documenting high-level UX design of our entire app
    so that we can properly design a great conditional navigation experience.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你掌握了如何有效地使用Angular CLI创建主要的Angular组件和脚手架。你熟悉了80-20规则。你创建了你的应用品牌，利用自定义和内置的Material图标。你学习了如何使用Augury调试复杂的路由配置。最后，你开始构建以路由为首要考虑的应用，早期定义用户角色，考虑到懒加载进行设计，并在早期确定一个可步行骨架的导航体验。我们讨论了围绕主要数据实体进行设计。我们还涵盖了完成并记录我们整个应用的高级UX设计的重要性，这样我们就可以正确地设计一个出色的条件导航体验。
- en: 'To recap, in order to pull off a router-first implementation, you need to do
    this:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，为了实现以路由为首要考虑的实施，你需要做以下这些：
- en: Develop a roadmap and scope
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制定路线图和范围
- en: Design with lazy loading in mind
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到懒加载进行设计
- en: Implement a walking-skeleton navigation experience
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个可步行骨架的导航体验
- en: Achieve a stateless, data-driven design
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现无状态、数据驱动的设计
- en: Enforce a decoupled component architecture
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强制实现解耦的组件架构
- en: Differentiate between user controls and components
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 区分用户控件和组件
- en: Maximize code reuse with TypeScript and ES6
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用TypeScript和ES6最大化代码重用
- en: In this chapter, you executed steps 1-3; in the next four chapters, you will
    execute steps 4-7\. In *Chapter 8*, *Designing Authentication and Authorization*,
    we will tap into OOP design and inheritance and abstraction, along with a deep
    dive into security considerations and designing a conditional navigation experience.
    In *Chapter 10*, *RESTful APIs and Full-Stack Implementation*, you will see a
    concrete full-stack implementation using the Minimal MEAN stack. *Chapter 11*,
    *Recipes – Reusability, Routing, and Caching*, and *Chapter 12*, *Recipes – Master/Detail,
    Data Tables, and NgRx*, we will tie everything together by sticking to a decoupled
    component architecture, smartly choosing between creating user controls and components,
    and maximizing code reuse with various TypeScript, RxJS, and Angular coding techniques.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你执行了步骤1-3；在接下来的四个章节中，你将执行步骤4-7。在*第8章*，*设计身份验证和授权*中，我们将深入探讨面向对象设计、继承和抽象，以及深入考虑安全性和设计条件导航体验。在*第10章*，*RESTful
    API和全栈实现*中，你将看到使用最小MEAN栈的具体全栈实现。*第11章*，*食谱 – 可重用性、路由和缓存*，以及*第12章*，*食谱 – 主/详细信息、数据表和NgRx*，我们将通过坚持解耦组件架构、明智地选择创建用户控件和组件，以及使用各种TypeScript、RxJS和Angular编码技术最大化代码重用来整合一切。
- en: Further reading
  id: totrans-607
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Ha, Not Ready to Ri: The Shu Ha Ri Approach to Agile Development*, Brian Sjoberg,
    Ken Furlong, July 29, 2015, [https://www.excella.com/insights/ha-not-ready-to-ri-the-shu-ha-ri-approach-to-agile-development](https://www.excella.com/insights/ha-not-ready-to-ri-the-shu-ha-ri-approach-to-agile-development).'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ha, Not Ready to Ri: The Shu Ha Ri Approach to Agile Development*，Brian Sjoberg，Ken
    Furlong，2015年7月29日，[https://www.excella.com/insights/ha-not-ready-to-ri-the-shu-ha-ri-approach-to-agile-development](https://www.excella.com/insights/ha-not-ready-to-ri-the-shu-ha-ri-approach-to-agile-development).'
- en: '*Angular 9: Lazy Loading Components*, John Papa, February 16, 2020, [https://johnpapa.net/angular-9-lazy-loading-components/](https://johnpapa.net/angular-9-lazy-loading-components/).'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Angular 9: Lazy Loading Components*，John Papa，2020年2月16日，[https://johnpapa.net/angular-9-lazy-loading-components/](https://johnpapa.net/angular-9-lazy-loading-components/).'
- en: Webpack module bundler, [https://webpack.js.org/](https://webpack.js.org/).
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack 模块打包器，[https://webpack.js.org/](https://webpack.js.org/).
- en: Questions
  id: totrans-611
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Answer the following questions as best as you can to ensure that you've understood
    the key concepts from this chapter without Googling. Do you need help answering
    the questions? See *Appendix D*, *Self-Assessment Answers* online at [https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)
    or visit [https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment).
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能好地回答以下问题，以确保你已理解本章的关键概念，而无需使用Google。你需要帮助回答这些问题吗？请参阅*附录D*，*自我评估答案*，在线位于[https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)或访问[https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment).
- en: What is the Pareto principle?
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是帕累托原则？
- en: What are the main goals of router-first architecture?
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由优先架构的主要目标是什么？
- en: What is the difference between the root module and a feature module?
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根模块和功能模块之间有什么区别？
- en: What are the benefits of lazy loading?
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 懒加载有哪些好处？
- en: Why create a walking skeleton of your application?
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么需要创建应用程序的行走骨架？
