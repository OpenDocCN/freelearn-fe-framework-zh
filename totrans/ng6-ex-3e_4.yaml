- en: Personal Trainer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人教练
- en: The *7 Minute Workout* app has been an excellent opportunity for us to learn
    about Angular. Working through the app, we have covered a number of Angular constructs.
    Still, there are areas such as Angular form support and client-server communication
    that remain unexplored. This is partially due to the fact that 7 Minute Workout,
    from a functional standpoint, has limited touch points with the end user. Interactions
    are limited to starting, stopping, and pausing the workout. Also, the app neither
    consumes nor produces any data (except workout history).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟训练*应用程序为我们了解Angular提供了一个极好的机会。在处理应用程序的过程中，我们已经覆盖了许多Angular结构。然而，像Angular表单支持和客户端-服务器通信这样的领域仍然未被探索。这部分原因是，从功能角度来看，7分钟训练与最终用户的接触点有限。交互仅限于开始、停止和暂停训练。此外，应用程序既不消耗也不产生任何数据（除了训练历史）。'
- en: In this chapter, we plan to delve deeper into one of the two aforementioned
    areas, Angular form support. Keeping up with the health and fitness theme (no
    pun intended), we plan to build a *Personal Trainer* app. The new app will be
    an extension to *7 Minute Workout*, allowing us to build our own customized workout
    plans that are not limited to the *7 Minute Workout* plans we already have.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们计划深入探讨上述两个领域之一，即Angular表单支持。保持健康和健身主题（无意中打趣），我们计划构建一个*个人教练*应用程序。新应用程序将是*7分钟训练*的扩展，允许我们构建自己的定制训练计划，这些计划不仅限于我们已有的*7分钟训练*计划。
- en: This chapter is dedicated to understanding Angular forms and how to put them
    to use as we build out our *Personal Trainer* app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于理解Angular表单以及如何在构建*个人教练*应用程序时使用它们。
- en: 'The topics that we will cover in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: '**Defining Personal Trainer requirements**: Since we are building a new app
    in this chapter, we start with defining the app requirements.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义个人教练需求**：由于我们在本章中构建了一个新应用程序，因此我们首先定义应用程序需求。'
- en: '**Defining the Personal Trainer model**: Any app design starts with defining
    its model. We define the model for *Personal Trainer*, which is similar to the
    *7 Minute Workout* app built earlier.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义个人教练模型**：任何应用程序设计都始于定义其模型。我们为*个人教练*定义了模型，这与之前构建的*7分钟训练*应用程序类似。'
- en: '**Defining the Personal Trainer layout and navigation**: We define the layout,
    navigation patterns, and views for the new app. We also set up a navigation system
    that is integrated with Angular routes and the main view.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义个人教练布局和导航**：我们定义了新应用程序的布局、导航模式和视图。我们还设置了一个与Angular路由和主视图集成的导航系统。'
- en: '**Adding support pages**: Before we focus on the form capability and build
    a Workout component, we build some supporting components for workout and exercise
    listing.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加支持页面**：在我们专注于表单功能并构建训练组件之前，我们构建了一些用于训练和运动列表的支持组件。'
- en: '**Defining the Workout Builder component structure**: We lay out the Workout
    Builder components that we will use to manage workouts.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义训练构建器组件结构**：我们规划出我们将使用的训练构建器组件来管理训练计划。'
- en: '**Building forms**: We make extensive use of HTML forms and input elements
    to create custom workouts. In the process, we will learn more about Angular Forms.
    The concepts that we cover include:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建表单**：我们广泛使用HTML表单和输入元素来创建自定义训练计划。在这个过程中，我们将学习更多关于Angular表单的知识。我们涵盖的概念包括：'
- en: '**Form types**: The two types of form that can be built with Angular are template-driven
    and reactive. We''re working with both template-driven and reactive forms in this
    chapter.'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表单类型**：可以使用Angular构建两种类型的表单：模板驱动和响应式。在本章中，我们正在使用模板驱动和响应式表单。'
- en: '**ngModel**: This provides two-way data binding for template driven forms and
    allows us to track changes and validate form input.'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ngModel**：这为模板驱动的表单提供了双向数据绑定，并允许我们跟踪更改和验证表单输入。'
- en: '**Reactive Form Controls**: These include the form builder, form control, form
    group, and form array. These are used to construct forms programmatically.'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式表单控件**：这些包括表单构建器、表单控件、表单组和表单数组。这些用于以编程方式构建表单。'
- en: '**Data formatting**: These are the CSS classes that permit us to style our
    feedback to the user.'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据格式化**：这些是允许我们为用户反馈添加样式的CSS类。'
- en: '**Input validation**: We will learn about the validation capabilities of Angular
    forms.'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入验证**：我们将了解Angular表单的验证功能。'
- en: The Personal Trainer app - the problem scope
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人教练应用程序 - 问题范围
- en: The *7 Minute Workout* app is good, but what if we could create an app that
    allows us to build more such workout routines customized to our fitness level
    and intensity requirements? With this flexibility, we can build any type of workout,
    whether it is 7 minutes, 8 minutes, 15 minutes, or any other variations. The opportunities
    are limitless.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟锻炼*应用程序很好，但如果我们能创建一个允许我们构建更多此类锻炼程序的应用程序，这些程序根据我们的健身水平和强度需求定制，会怎样呢？有了这种灵活性，我们可以构建任何类型的锻炼，无论是7分钟、8分钟、15分钟还是其他任何变化。机会是无限的。'
- en: With this premise, let's embark on the journey of building our own *Personal
    Trainer* app that helps us to create and manage training/workout plans according
    to our specific needs. Let's start with defining the requirements for the app.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，让我们开始构建自己的*个人教练*应用程序的旅程，这个应用程序可以帮助我们根据我们的具体需求创建和管理训练/锻炼计划。让我们从定义应用程序的需求开始。
- en: The new *Personal Trainer* app will now encompass the existing *7 Minute Workout*
    app. The component that supports workout creation will be referred to as Workout
    Builder. The *7 Minute Workout* app itself will also be referred to as Workout
    Runner. In the coming chapters, we will fix *Workout Runner*, allowing it to run
    any workout created using *Workout Builder*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 新的*个人教练*应用程序将包括现有的*7分钟锻炼*应用程序。支持锻炼创建的组件将被称为锻炼构建器。*7分钟锻炼*应用程序本身也将被称为锻炼运行器。在接下来的章节中，我们将修复*锻炼运行器*，使其能够运行使用*锻炼构建器*创建的任何锻炼。
- en: Personal Trainer requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人教练需求
- en: 'Based on the notion of managing workouts and exercises, these are some of the
    requirements that our *Personal Trainer* app should fulfill:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基于管理和锻炼的概念，以下是我们*个人教练*应用程序应该满足的一些需求：
- en: The ability to list all available workouts.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有可用锻炼的能力
- en: 'The ability to create and edit a workout. While creating and editing a workout,
    it should have:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和编辑锻炼的能力。在创建和编辑锻炼时，它应该具备：
- en: The ability to add workout attributes including name, title, description, and
    rest duration
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加锻炼属性的能力，包括名称、标题、描述和休息时长
- en: The ability to add/remove multiple exercises for workouts
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为锻炼添加/删除多个锻炼的能力
- en: The ability to order exercises in the workout
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在锻炼中排列锻炼的能力
- en: The ability to save workout data
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存锻炼数据的能力
- en: The ability to list all available exercises.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有可用锻炼的能力
- en: 'The ability to create and edit an exercise. While creating and editing an exercise,
    it should have:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和编辑锻炼的能力。在创建和编辑锻炼时，它应该具备：
- en: The ability to add exercise attributes such as name, title, description, and
    procedure
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加锻炼属性的能力，如名称、标题、描述和程序
- en: The ability to add pictures for the exercise
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为锻炼添加图片的能力
- en: The ability to add related videos for the exercise
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为锻炼添加相关视频的能力
- en: The ability to add audio clues for the exercise
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为锻炼添加音频提示的能力
- en: All the requirements seem to be self-explanatory, so let's start with the design
    of the application. As customary, we first need to think about the model that
    can support these requirements.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有要求似乎都很直观，所以让我们从应用程序的设计开始。按照惯例，我们首先需要考虑可以支持这些需求的模型。
- en: The Personal Trainer model
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人教练模型
- en: No surprises here! The Personal Trainer model itself was defined when we created
    the *7 Minute Workout* app. The two central concepts of workout and exercise hold
    good for *Personal Trainer* too.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 没有惊喜！个人教练模型本身是在创建*7分钟锻炼*应用程序时定义的。锻炼和锻炼的两个核心概念对*个人教练*同样适用。
- en: The only problem with the existing workout model is that it is in the directory
    for `workout-runner`. This means that in order to use it, we will have to import
    it from that directory. It makes more sense to move the model into the `core`
    folder so that it is clear that it can be used across features. We'll do that
    in this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的锻炼模型唯一的问题是它位于`workout-runner`目录中。这意味着为了使用它，我们必须从该目录导入它。将模型移动到`core`文件夹中更有意义，这样就可以清楚地知道它可以跨功能使用。我们将在本章中这样做。
- en: Getting started with the code for Personal Trainer
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始编写个人教练的代码
- en: First, download the base version of the new *Personal Trainer* app from `checkpoint4.1`
    in the GitHub repository for the book.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从GitHub仓库中书的`checkpoint4.1`下载新的*个人教练*应用程序的基础版本。
- en: 'The code is available on GitHub [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)
    for everyone to download. Checkpoints are implemented as branches in GitHub. The
    branch to download is as follows: `GitHub Branch: checkpoint4.1`. If you are not
    using Git, download the snapshot of Checkpoint 4.1 (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.1.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.1.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '代码可在 GitHub [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)
    上供大家下载。检查点作为 GitHub 上的分支实现。要下载的分支如下：`GitHub Branch: checkpoint4.1`。如果你不使用 Git，可以从以下
    GitHub 位置下载 Checkpoint 4.1 的快照（ZIP 文件）：[https://github.com/chandermani/angular6byexample/archive/checkpoint4.1.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.1.zip)。在首次设置快照时，请参考
    `trainer` 文件夹中的 `README.md` 文件。'
- en: 'This code has the complete *7 Minute Workout (Workout Runner)* app. We have
    added some more content to support the new *Personal Trainer* app. Some of the
    relevant updates are:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含了完整的 *7 分钟健身 (Workout Runner)* 应用。我们添加了一些更多内容来支持新的 *个人教练* 应用。一些相关的更新包括：
- en: Adding the new `WorkoutBuilder` feature. This feature contains implementations
    pertaining to *Personal Trainer*.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的 `WorkoutBuilder` 功能。这个功能包含与 *个人教练* 相关的实现。
- en: Updating the layout and styles of the app.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新应用布局和样式。
- en: Adding some components and HTML templates with placeholder content for *Personal
    Trainer* in the `workout-builder` folder under `trainer/src/app`.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `trainer/src/app` 目录下的 `workout-builder` 文件夹中添加一些组件和带有占位符内容的 HTML 模板，用于 *个人教练*。
- en: Defining a new route to the `WorkoutBuilder` feature. We will cover setting
    up this route within the app in the coming section.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个新的路由到 `WorkoutBuilder` 功能。我们将在下一节中介绍如何在应用中设置此路由。
- en: As we just mentioned, moving the existing  `model.ts` file into the `core` folder.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们刚才提到的，将现有的 `model.ts` 文件移动到 `core` 文件夹。
- en: Let's discuss how we will be using the model.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论我们将如何使用模型。
- en: Using the Personal Trainer model in Workout Builder services
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 `trainer/src/app` 目录下的 `workout-builder` 文件夹中使用个人教练模型。
- en: In the last chapter, we dedicated a complete section to learning about Angular
    services, and one thing we found out was that services are useful for sharing
    data across controllers and other Angular constructs. Open the `model.ts` file
    present in the `core` folder under `app`. In this class, we essentially do not
    have any data, but a blueprint that describes the shape of the data. The plan is
    to use services to expose this model structure.  We have already done that in
    Workout Runner. Now, we will do the same in Workout Builder.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章，我们专门用一节来介绍学习 Angular 服务，我们发现服务对于在控制器和其他 Angular 构造之间共享数据很有用。打开位于 `app`
    目录下 `core` 文件夹中的 `model.ts` 文件。在这个类中，我们实际上没有任何数据，而是一个描述数据形状的蓝图。计划使用服务来公开这个模型结构。我们已经在
    Workout Runner 中做到了这一点。现在，我们将在 Workout Builder 中做同样的事情。
- en: 'The `model.ts` file has been moved into the `core` folder as it is shared across
    the *Workout Builder* and *Workout Runner* apps. Note: in `checkpoint4.1` we have
    updated the import statements in `workout-runner.component.ts` , `workout-audio.component.ts`, and `workout-history-tracker-service.ts` to
    reflect this change.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`model.ts` 文件已被移动到 `core` 文件夹，因为它在 *Workout Builder* 和 *Workout Runner* 应用之间是共享的。注意：在
    `checkpoint4.1` 中，我们已经更新了 `workout-runner.component.ts`、`workout-audio.component.ts`
    和 `workout-history-tracker-service.ts` 中的导入语句，以反映这一变化。'
- en: In Chapter 2, *Building Our First App - 7 Minute Workout*, we reviewed the class
    definitions in the model file: `Exercise`, `ExercisePlan`, and `WorkoutPlan`**.**
    As we then mentioned, these three classes constitute our base model. We will now
    start using this base model in our new app.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章，“构建我们的第一个应用 - 7 分钟健身”，我们回顾了模型文件中的类定义：`Exercise`、`ExercisePlan` 和 `WorkoutPlan`**。**
    正如我们当时提到的，这三个类构成了我们的基础模型。我们现在将开始在新的应用中使用这个基础模型。
- en: That's all on the model design front. The next thing we are going to do is define
    the structure for the new app.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型设计方面就这些了。接下来我们要做的是为新应用定义结构。
- en: The Personal Trainer layout
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人教练布局
- en: 'The skeleton structure of *Personal Trainer* looks like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*个人教练* 的骨架结构如下所示：'
- en: '![](img/00027.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00027.jpeg)'
- en: 'This has the following components:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含以下组件：
- en: 'Top Nav: This contains the app branding title and history link.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部导航：这包含应用品牌标题和历史链接。
- en: 'Sub Nav: This has navigation elements that change based on the active component.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子导航：这包含根据活动组件变化的导航元素。
- en: 'Left Nav: This contains elements that are dependent upon the active component.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧导航：这包含依赖于活动组件的元素。
- en: 'Content Area: This is where the main view for our component will display. This
    is where most of the action happens. We will create/edit exercises and workouts
    and show a list of exercises and workouts here.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容区域：这是我们的组件主视图将显示的地方。这是大多数动作发生的地方。我们将创建/编辑练习和锻炼，并在这里显示练习和锻炼的列表。
- en: Look at the source code files; there is a new folder `workout-builder` under
    `trainer/src/app`. It has files for each component that we described previously,
    with some placeholder content. We will be building these components as we go along
    in this chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 查看源代码文件；在 `trainer/src/app` 下有一个新的文件夹 `workout-builder`。它为之前描述的每个组件都有文件，其中包含一些占位符内容。我们将随着本章的进行构建这些组件。
- en: However, we first need to link up these components within the app. This requires
    us to define the navigation patterns for the Workout Builder app and accordingly
    define the app routes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们首先需要在应用程序中链接这些组件。这需要我们定义锻炼构建器应用程序的导航模式，并相应地定义应用程序路由。
- en: Personal Trainer navigation with routes
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有路由的个人教练导航
- en: 'The navigation pattern that we plan to use for the app is the list-detail pattern.
    We will create list pages for the exercises and workouts available in the app.
    Clicking on any list item takes us to the detailed view for the item where we
    can perform all CRUD operations (create/read/update/delete). The following routes
    adhere to this pattern:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划为应用程序使用的导航模式是列表-详情模式。我们将为应用程序中可用的练习和锻炼创建列表页面。点击任何列表项将带我们到项目的详细视图，在那里我们可以执行所有
    CRUD 操作（创建/读取/更新/删除）。以下路由遵循此模式：
- en: '| **Route** | **Description** |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **路由** | **描述** |'
- en: '| `/builder` | This just redirects to **builder/workouts** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `/builder` | 这只是重定向到 `builder/workouts` |'
- en: '| `/builder/workouts` | This lists all the available workouts. It is the landing
    page for *Workout Builder* |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/workouts` | 这列出了所有可用的锻炼。这是 *锻炼构建器* 的着陆页 |'
- en: '| `/builder/workout/new` | This creates a new workout |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/workout/new` | 这创建一个新的锻炼 |'
- en: '| `/builder/workout/:id` | This edits an existing workout with the specific
    ID |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/workout/:id` | 这编辑具有特定 ID 的现有锻炼 |'
- en: '| `/builder/exercises` | This lists all the available exercises |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/exercises` | 这列出了所有可用的练习 |'
- en: '| `/builder/exercise/new` | This creates a new exercise |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/exercise/new` | 这创建一个新的练习 |'
- en: '| `/builder/exercise/:id` | This edits an existing exercise with the specific
    ID |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/exercise/:id` | 这编辑具有特定 ID 的现有练习 |'
- en: Getting started with Personal Trainer navigation
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用个人教练导航
- en: At this point, if you look at the route configuration in `app-routing.module.ts`
    in the `src/app` folder, you will find one new route definition, `builder`**:**
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果您查看 `src/app` 文件夹中的 `app-routing.module.ts` 中的路由配置，您将找到一个新路由定义，`builder`：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And if you run the application, you will see that the start screen shows another
    link, Create a Workout:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行应用程序，您将看到启动屏幕显示了另一个链接，创建一个锻炼：
- en: '![](img/00028.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00028.jpeg)'
- en: 'Behind the scenes, we have added another router link for this link into `start.component.html`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，我们已将另一个路由链接添加到 `start.component.html`：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And if you click on this link, you will be taken to the following view:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击此链接，您将被带到以下视图：
- en: '![](img/00029.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00029.jpeg)'
- en: 'Again, behind the scenes we have added  `workout-builder.component.ts` to the
    `trainer/src/app/workout-builder` folder with the following inline template:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在幕后，我们已将 `workout-builder.component.ts` 添加到 `trainer/src/app/workout-builder`
    文件夹中，并具有以下内联模板：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And this view is displayed on the screen under the header using the router
    outlet in our `app.component.html` template:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这个视图在标题下通过我们的 `app.component.html` 模板中的路由出口显示：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have wrapped this component (along with the other files we have stubbed out
    for this feature) in a new module named `workout-builder.module.ts:`
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此组件（以及我们为此功能伪造的其他文件）包裹在一个名为 `workout-builder.module.ts` 的新模块中：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The only thing that might look different here from the other modules that we
    have created is that we are importing `CommonModule` instead of `BrowserModule`.
    This avoids importing the whole of `BrowserModule` a second time, which would
    generate an error when we get to implementing lazy loading for this module.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，与其他我们创建的模块相比，唯一可能看起来不同的地方是，我们导入的是 `CommonModule` 而不是 `BrowserModule`。这避免了第二次导入整个
    `BrowserModule`，这在我们实现此模块的懒加载时会产生错误。
- en: 'Finally, we have added an import for this module to `app.module.ts`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 `app.module.ts` 中添加了对该模块的导入：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, nothing surprising here. These are the basic component building and routing
    patterns that we introduced in the previous chapters. Following these patterns,
    we should now begin to think about adding the additional navigation outlined previously
    for our new feature. However, before we jump into doing that, there are a couple
    of things we need to consider.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里没有什么令人惊讶的。这些都是我们在前几章中介绍的基本组件构建和路由模式。遵循这些模式，我们现在应该开始考虑为我们的新功能添加之前概述的附加导航。然而，在我们着手做这件事之前，还有一些事情我们需要考虑。
- en: First, if we start adding our routes to the `app.routing-module.ts` file, then
    the number of routes stored there will grow. These new routes for *Workout Builder*
    will also be intermixed with the routes for *Workout Runner***.** While the number
    of routes we are now adding might seem insignificant, over time this could get
    to be a maintenance problem.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们开始将我们的路由添加到 `app.routing-module.ts` 文件中，那么存储在那里的路由数量将会增加。这些新的 *Workout
    Builder* 路由也将与 *Workout Runner* 的路由混合在一起**。虽然我们现在添加的路由数量可能看起来微不足道，但长期来看，这可能会成为一个维护问题。
- en: Second, we need to take into consideration that our application now consists
    of two features—*Workout Runner* and *Workout Builder*. We should be thinking
    about ways to separate these features within our application so that they can
    be developed independently of each other.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要考虑的是，我们的应用程序现在由两个功能组成——*Workout Runner* 和 *Workout Builder*。我们应该思考如何在我们的应用程序中分离这些功能，以便它们可以独立于彼此开发。
- en: Put differently, we want **loose coupling** between the features that we build.
    Using this pattern allows us to swap out a feature within our application without
    affecting the other features. For example, somewhere down the line we may want
    to convert the *Workout Runner* into a mobile app but leave the *Workout Builder*
    intact as a web-based application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们希望我们构建的功能之间有**松散耦合**。使用这种模式允许我们在不影响其他功能的情况下，在我们的应用程序中替换掉一个功能。例如，在某个时候，我们可能希望将
    *Workout Runner* 转换为移动应用，但保留 *Workout Builder* 作为基于网络的程序。
- en: Going back to the first chapter, we emphasized that this ability to separate
    our components from each other is one of the key advantages of using the **component
    design pattern** that Angular implements. Fortunately, Angular's router gives
    us the ability to separate out our routing into logically organized **routing
    configurations** that closely match the features in our application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第一章，我们强调了这种将我们的组件彼此分离的能力是使用 Angular 实现的 **组件设计模式** 的关键优势之一。幸运的是，Angular 的路由器为我们提供了将我们的路由分离成逻辑上组织良好的
    **路由配置** 的能力，这些配置与应用程序中的功能紧密匹配。
- en: In order to accomplish this separation, Angular allows us to use **child routing**,
    where we can isolate the routing for each of our features. In this chapter, we
    will use **child routing** to separate out the routing for *Workout Builder*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种分离，Angular 允许我们使用 **子路由**，这样我们就可以隔离我们每个功能的路由。在本章中，我们将使用 **子路由** 来分离 *Workout
    Builder* 的路由。
- en: Introducing child routes to Workout Builder
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 *Workout Builder* 引入子路由
- en: Angular supports our goal of isolating the routing for our new *Workout Builder*
    by providing us with the ability to create a hierarchy of router components within
    our application. We currently have just one router component, which is in the
    root component of our application. But Angular allows us to add what are called
    **child router components** under our root component. This means that one feature
    can be ignorant of the routes the other is using and each is free to adapt its routes
    in response to changes within that feature.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 通过提供在应用程序中创建路由组件层次结构的能力来支持我们隔离新 *Workout Builder* 路由的目标。我们目前只有一个路由组件，它位于我们应用程序的根组件中。但
    Angular 允许我们在根组件下添加所谓的 **子路由组件**。这意味着一个功能可以无视另一个功能使用的路由，每个功能都可以自由地根据该功能内部的变化调整其路由。
- en: 'Getting back to our application, we can use **child routing** in Angular to
    match the routing for the two features of our application with the code that will
    be using them. So in our application, we can structure the routing into the following
    routing hierarchy for our *Workout Builder* (at this point, we are leaving the
    *Workout Runner* as is to show the before and after comparison):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的应用程序，我们可以使用 Angular 的 **子路由** 来匹配我们应用程序两个功能的路由与将使用它们的代码。因此，在我们的应用程序中，我们可以将路由结构化为以下路由层次结构，用于我们的
    *Workout Builder*（在这个阶段，我们将 *Workout Runner* 保持原样，以展示前后对比）：
- en: '![](img/00030.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00030.jpeg)'
- en: With this approach, we can create a logical separation of our routes by feature
    and make them easier to manage and maintain.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，我们可以通过功能对路由进行逻辑分离，使它们更容易管理和维护。
- en: So, let's get started by adding child routing to our application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始通过向我们的应用程序添加子路由来启动。
- en: 'From this point on in this section, we''ll be adding to the code that we downloaded
    earlier for this chapter. If you want to see the complete code for this next section,
    you can download it from `checkpoint 4.2` in the GitHub repository. If you want
    to work along with us as we build out the code for this section, still be sure
    to add the changes in `styles.css` in the `trainer/src` folder that are part of
    this checkpoint, since we won''t be discussing them here. Also be sure and add
    the files for exercise(s) ,workout(s), and navigation from the `trainer/src/app/workout-builder`
    folder in the repository. At this stage, these are just stub files, which we will
    implement later in this chapter. However, you will need these stub files here
    in order to implement navigation for the *Workout Builder* module. The code is
    available for everyone to download on GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: `GitHub Branch: checkpoint4.2` . If you are not using Git, download the
    snapshot of `Checkpoint 4.2` (a ZIP file) from the following GitHub location:
    [https://github.com/chandermani/angular6byexample/archive/checkpoint4.2.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.2.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '从本节此点开始，我们将添加本章之前下载的代码。如果您想查看下一节的完整代码，可以从GitHub仓库中的`checkpoint 4.2`下载。如果您想在我们构建本节代码时一起工作，请确保添加`trainer/src`文件夹中包含此检查点的`styles.css`中的更改，因为我们在这里不会讨论它们。同时，请确保添加来自仓库中`trainer/src/app/workout-builder`文件夹的练习（exercise）、锻炼（workout）和导航文件。在这个阶段，这些只是占位符文件，我们将在本章的后面实现它们。然而，您需要这些占位符文件来实现*锻炼构建器*模块的导航。代码可在GitHub上供所有人下载，网址为[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)。检查点作为GitHub上的分支实现。要下载的分支如下：`GitHub
    Branch: checkpoint4.2`。如果您不使用Git，可以从以下GitHub位置下载`Checkpoint 4.2`的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/archive/checkpoint4.2.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.2.zip)。在首次设置快照时，请参阅`trainer`文件夹中的`README.md`文件。'
- en: Adding the child routing component
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加子路由组件
- en: 'In the `workout-builder` directory, add a new TypeScript file named `workout-builder.routing.module.ts`
    with the following imports:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-builder`目录下，添加一个名为`workout-builder.routing.module.ts`的新TypeScript文件，并包含以下导入：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we are importing the components we just mentioned; they will
    be part of our *Workout Builder* (exercise, exercises, workout, and workouts).
    Along with those imports, we are also importing `NgModule` from the Angular core
    module and `Routes` and `RouterModule` from the Angular router module. These imports
    will give us the ability to add and export child routes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在导入刚才提到的组件；它们将成为我们*锻炼构建器*（exercise、exercises、workout和workouts）的一部分。与这些导入一起，我们还从Angular核心模块中导入`NgModule`，从Angular路由模块中导入`Routes`和`RouterModule`。这些导入将使我们能够添加和导出子路由。
- en: We are not using the Angular CLI here because it does not have a standalone
    blueprint for creating a routing module. However, you can have the CLI create
    a routing module at the time that you create a module using the `--routing` option.
    In this case, we already had an existing module created so we couldn't use that
    flag. See [https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/routing.md](https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/routing.md)
    for more details about how to do this.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里没有使用Angular CLI，因为它没有创建路由模块的独立蓝图。然而，您可以在创建模块时使用`--routing`选项让CLI创建路由模块。在这种情况下，我们已经有了一个现有的模块创建，所以不能使用该标志。有关如何操作的更多详细信息，请参阅[https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/routing.md](https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/routing.md)。
- en: 'Then, add the following route configuration to the file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下路由配置添加到文件中：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first configuration, `path: ''builder''`, sets the base URL for the child
    routes so that each of the child routes prepends it. The next configuration identifies
    the `WorkoutBuilder` component as the feature area root component for the child
    components in this file. This means it will be the component in which each of
    the child components is displayed using `router-outlet`. The final configuration
    is a list of one or more children that defines the routing for the child components.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个配置，`path: ''builder''`，设置了子路由的基本URL，以便每个子路由都将其作为前缀。下一个配置将`WorkoutBuilder`组件标识为该文件中子组件的特征区域根组件。这意味着它将是使用`router-outlet`显示每个子组件的组件。最后的配置是一个或多个子组件的列表，它定义了子组件的路由。'
- en: 'One thing to note here is that we have set up `Workouts` as the default for
    the child routes with the following configuration:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，我们已经使用以下配置将`Workouts`设置为子路由的默认值：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This configuration indicates that if someone navigates to `builder`, they will
    be redirected to the `builder/workouts` route. The `pathMatch: ''full''` setting
    means that the match will only be made if the path after workout/builder is an
    empty string. This prevents the redirection from happening if the routes are something
    else, such as `workout/builder/exercises` or any of the other routes we have configured
    within this file.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '此配置表示，如果有人导航到`builder`，他们将被重定向到`builder/workouts`路由。`pathMatch: ''full''`设置意味着只有当workout/builder之后的路径是一个空字符串时，才会进行匹配。这防止了如果路由是其他内容（如`workout/builder/exercises`或我们在该文件中配置的其他任何路由）时发生重定向。'
- en: 'Finally, add the following class declaration preceded by an `@NgModule` decorator
    that defines imports and exports for our module:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加以下类声明，前面加上`@NgModule`装饰器，该装饰器定义了模块的导入和导出：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This import is very similar to the one in `app.routing-module.ts`, with one
    difference: instead of `RouterModule.forRoot`, we are using `RouterModule.forChild`.
    The reason for the difference may seem self-explanatory: we are creating child
    routes, not the routes in the root of the application, and this is how we signify
    that. Under the hood, however, there is a significant difference. This is because
    we cannot have more than one router service active in our application. `forRoot`
    creates the router service but `forChild` does not.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导入与`app.routing-module.ts`中的导入非常相似，只有一个区别：我们使用的是`RouterModule.forChild`而不是`RouterModule.forRoot`。这种差异的原因可能看起来很明显：我们正在创建子路由，而不是应用程序根目录中的路由，这就是我们表示的方式。然而，在底层，有一个显著的区别。这是因为我们的应用程序中不能有多个活动的路由服务。`forRoot`创建路由服务，但`forChild`不创建。
- en: Updating the WorkoutBuilder component
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新WorkoutBuilder组件
- en: 'We next need to update the `WorkoutBuilder` component to support our new child
    routes. To do so, change the `@Component` decorator for Workout Builder to:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新`WorkoutBuilder`组件以支持我们新的子路由。为此，将`Workout Builder`的`@Component`装饰器更改为：
- en: Remove the `selector`
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除`selector`
- en: Add a `<abe-sub-nav-main>` custom element to the template
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中添加一个`<abe-sub-nav-main>`自定义元素
- en: Add a `<router-outlet>` tag to the template
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中添加一个`<router-outlet>`标签
- en: 'The decorator should now look like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器现在应该看起来像以下这样：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are removing the selector because `WorkoutBuilderComponent` will not be embedded
    in the application root, `app.component.ts`. Instead, it will be reached from
    `app.routing-module.ts` through routing. And while it will handle incoming routing
    requests from `app.routes.ts`, it will in turn be routing them to the other components
    contained in the Workout Builder feature.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在移除选择器，因为`WorkoutBuilderComponent`将不会嵌入到应用程序根目录`app.component.ts`中。相反，它将通过路由从`app.routing-module.ts`访问。虽然它将处理来自`app.routes.ts`的传入路由请求，但它将反过来将它们路由到Workout
    Builder功能中包含的其他组件。
- en: And those components will display their views using the `<router-outlet>` tag
    that we have just added to the `WorkoutBuilder` template. Given that the template
    for `Workout BuilderComponent` will be simple, we are using an inline `template`
    instead of a `templateUrl`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件将使用我们刚刚添加到`WorkoutBuilder`模板中的`<router-outlet>`标签来显示它们的视图。鉴于`Workout BuilderComponent`的模板将是简单的，我们使用内联`template`而不是`templateUrl`。
- en: Typically, for a component's view we recommend using a `templateUrl` that points
    to a separate HTML template file. This is especially true when you anticipate
    that the view will involve more than a few lines of HTML. In that situation, it
    is much easier to work with a view inside its own HTML file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于组件的视图，我们建议使用指向单独HTML模板文件的`templateUrl`。当你预计视图将涉及超过几行HTML时，这一点尤其正确。在这种情况下，在它自己的HTML文件中处理视图要容易得多。
- en: We are also adding an `<abe-sub-nav-main>` element that will be used to create
    a secondary top-level menu for navigating within the *Workout Builder* feature.
    We'll discuss that a little later in this chapter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个`<abe-sub-nav-main>`元素，它将被用来创建一个用于在*Workout Builder*功能中导航的二级顶级菜单。我们将在本章稍后讨论这一点。
- en: Updating the Workout Builder module
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新Workout Builder模块
- en: 'Now, let''s update `WorkoutBuilderModule`.  First, add the following import
    to the file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新`WorkoutBuilderModule`。首先，将以下导入添加到文件中：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It imports the child routing that we just set up.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它导入了我们刚刚设置的子路由。
- en: 'Next, update the `@NgModule` decorator to add `workoutBuilderRoutingModule`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新`@NgModule`装饰器以添加`workoutBuilderRoutingModule`：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, add the imports and declarations for the new navigation components
    that can be found in `checkpoint4.2`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加可在`checkpoint4.2`中找到的新导航组件的导入和声明：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Updating App Routing module
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新App路由模块
- en: 'One last step: return to `app.routing-module.ts` and remove the import of the
    `WorkoutBuilderComponent` and the route definition that points to the builder:`{
    path: ''builder'', component: WorkoutBuilderComponent },`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '最后一步：回到`app.routing-module.ts`，移除对`WorkoutBuilderComponent`的导入以及指向构建器的路由定义：`{
    path: ''builder'', component: WorkoutBuilderComponent },`。'
- en: Be sure to leave the import of the `WorkoutBuilderModule`  in `app.module.ts`
    unchanged. We'll discuss removing that in the next section when we cover lazy
    loading.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保在`app.module.ts`中保持对`WorkoutBuilderModule`的导入不变。我们将在下一节讨论懒加载时讨论移除它。
- en: Putting it all together
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: From the previous chapter, we already know how to set up root routing for our
    application. But now, what we have instead of root routing is area or feature
    routing that contains child routes. We have been able to achieve the separation
    of concerns we discussed earlier, so that all the routes related to the *Workout
    Builder* are now separately contained in their own routing configuration. This
    means that we can manage all the routing for *Workout Builder* in the `WorkoutBuilderRoutes`
    component without affecting other parts of the application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章，我们已经知道如何设置应用程序的根路由。但现在，我们有的不是根路由，而是包含子路由的区域或功能路由。我们已经能够实现之前讨论的关注点分离，因此现在所有与*Workout
    Builder*相关的路由都分别包含在其自己的路由配置中。这意味着我们可以在`WorkoutBuilderRoutes`组件中管理所有与*Workout Builder*相关的路由，而不会影响应用程序的其他部分。
- en: 'We can see how the router combines the routes in `app.routes.ts` with the default
    route in `workout-builder.routes.ts`, if we now navigate from the start page to
    the Workout Builder:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在从起始页面导航到Workout Builder，我们可以看到路由器是如何将`app.routes.ts`中的路由与`workout-builder.routes.ts`中的默认路由组合起来的。
- en: '![](img/00031.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00031.jpeg)'
- en: If we look at the URL in the browser, it is `/builder/workouts`. You'll recall
    that the router link on the start page is `['/builder']`. So how did the router
    take us to this location?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中查看URL，它是`/builder/workouts`。你可能还记得，起始页面上的路由链接是`['/builder']`。那么路由器是如何带我们到这个位置的？
- en: 'It does it this way: when the link is clicked, the Angular router first looks
    to `app-routing.module.ts` for the `builder` path because that file contains the
    configuration for the root routes in our application. The router does not find
    that path because we have removed it from the routes in that file.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它这样做：当点击链接时，Angular路由器首先在`app-routing.module.ts`中查找`builder`路径，因为该文件包含我们应用程序根路由的配置。路由器找不到该路径，因为我们已经从该文件的路由中移除了它。
- en: However, `WorkoutBuilderModule` has been imported into our `AppModule` and that
    module in turn imports `workoutBuilderRoutingModule`. The latter file contains
    the child routes that we just configured. The router finds that `builder` is the
    parent route in that file and so it uses that route. It also finds the default
    setting that redirects to the child path `workouts` in the event that the `builder`
    path ends with an empty string, which it does in this case.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`WorkoutBuilderModule`已被导入到我们的`AppModule`中，而该模块又导入`workoutBuilderRoutingModule`。后一个文件包含我们刚刚配置的子路由。路由器发现该文件中的`builder`是父路由，因此它使用该路由。它还发现默认设置，在`builder`路径以空字符串结束的情况下（在本例中就是这样），将重定向到子路径`workouts`。
- en: If you look at the screen, you will see it is displaying the view for `Workouts`
    (and not as previously *Workout Builder*). This means that the router has successfully
    routed the request to `WorkoutsComponent`, which is the component for the default
    route in the child route configuration that we set up in `workoutBuilderRoutingModule`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看屏幕，您会看到它正在显示`Workouts`视图（而不是之前的*Workout Builder*）。这意味着路由器已成功将请求路由到`WorkoutsComponent`，这是我们在`workoutBuilderRoutingModule`中设置的子路由配置中的默认路由组件。
- en: 'This process of route resolution is illustrated here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了路由解析的过程：
- en: '![](img/00032.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00032.jpeg)'
- en: One final thought on child routing. When you look at our child routing component, `workout-builder.component.ts`,
    you will see that it has no references to its parent component, `app.component.ts`
    (as we mentioned earlier, the `<selector>` tag has been removed, so  `WorkoutBuilderComponent` 
    is not being embedded in the root component). This means that we have successfully
    encapsulated `WorkoutBuilderComponent` (and all of its related components that
    are imported in the `WorkoutBuilderModule`) in a way that will allow us to move
    all of it elsewhere in the application, or even into a new application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后关于子路由的一点思考。当您查看我们的子路由组件`workout-builder.component.ts`时，您会看到它没有对其父组件`app.component.ts`的引用（正如我们之前提到的，`<selector>`标签已被移除，因此`WorkoutBuilderComponent`没有被嵌入到根组件中）。这意味着我们已经成功地将`WorkoutBuilderComponent`（以及所有在`WorkoutBuilderModule`中导入的相关组件）封装起来，这样我们就可以将其移动到应用程序的任何其他位置，甚至可以移动到一个新的应用程序中。
- en: Now, it's time for us to move on to converting our routing for the Workout Builder
    to use lazy loading and building out its navigation menus. If you want to see
    the completed code for this next section, you can download it from the companion
    codebase in `checkpoint 4.3`. Again, if you are working along with us as we build
    the application, be sure and update the `styles.css` file, which we are not discussing
    here.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是我们将Workout Builder的路由转换为使用懒加载并构建其导航菜单的时候了。如果您想查看下一节完成的代码，可以从`checkpoint
    4.3`的配套代码库中下载。再次提醒，如果您在我们构建应用程序的同时工作，请确保更新`styles.css`文件，这里我们未对其进行讨论。
- en: 'The code is also available for everyone to download on GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: `GitHub Branch: checkpoint4.3` (folder - `trainer`). If you are not using
    Git, download the snapshot of `Checkpoint 4.3` (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.3.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.3.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '代码也已在GitHub上供所有人下载，链接为[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)。检查点作为GitHub上的分支实现。要下载的分支如下：`GitHub
    Branch: checkpoint4.3`（文件夹 - `trainer`）。如果您不使用Git，可以从以下GitHub位置下载`Checkpoint 4.3`的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/archive/checkpoint4.3.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.3.zip)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。'
- en: Lazy loading of routes
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由的懒加载
- en: When we roll out our application, we expect that our users will be accessing
    the Workout Runner every day (and we know that this will be the case for you!).
    But, we anticipate that they will only occasionally be using the Workout Builder
    to construct their exercises and workout plans. It would therefore be nice if
    we could avoid the overhead of loading the Workout Builder when our users are
    just doing their exercises in the Workout Runner. Instead, we would prefer to
    load Workout Builder only on demand when a user wants to add to or update their
    exercises and workout plans. This approach is called lazy loading. Lazy loading
    allows us to employ an asynchronous approach when loading our modules. This means
    that we can load just what is required to get the application started and then
    load other modules as we need them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们推出我们的应用程序时，我们预计我们的用户将每天访问*Workout Runner*（我们知道这对你来说也是这样！）。但是，我们预计他们只会偶尔使用*Workout
    Builder*来构建他们的锻炼和训练计划。因此，如果我们能在用户只在*Workout Runner*中做锻炼时避免加载*Workout Builder*的开销，那就太好了。相反，我们更希望用户在想要添加或更新他们的锻炼和训练计划时才按需加载Workout
    Builder。这种方法被称为懒加载。懒加载允许我们在加载模块时采用异步方法。这意味着我们可以只加载启动应用程序所需的资源，然后根据需要加载其他模块。
- en: Under the hood, when we use the Angular CLI to build and serve our application,
    it uses WebPack's bundling and chunking capabilities to accomplish lazy loading.
    We'll be discussing these capabilities as we work through how to implement lazy
    loading in our application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，当我们使用Angular CLI构建和提供我们的应用程序时，它使用WebPack的打包和分块功能来实现懒加载。我们将随着在应用程序中实现懒加载的过程来讨论这些功能。
- en: So in our *Personal Trainer*, we want to change the application so that it only
    loads the **Workout Builder** on demand. And the Angular router allows us to do
    just that using lazy loading.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的*个人教练*应用程序中，我们希望改变应用程序，使其仅在需要时才加载**Workout Builder**。Angular路由器允许我们通过懒加载来实现这一点。
- en: 'But before we get started implementing lazy loading, let''s take a look at
    our current application and how it is loading our modules. With the developer
    tools open in the Sources tab, start up the application; when the start page appears
    in your browser, if you look under the webpack node in the source tree, you will
    see that all the files in the application have loaded, including both the *Workout
    Runner* and *Workout Builder* files:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现懒加载之前，让我们先看看我们的当前应用程序以及它是如何加载我们的模块的。在“源”标签页中打开开发者工具，启动应用程序；当启动页面出现在你的浏览器中时，如果你在源树中的webpack节点下查看，你会看到应用程序中的所有文件都已加载，包括*Workout
    Runner*和*Workout Builder*文件：
- en: '![](img/00033.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00033.jpeg)'
- en: So, even though we may just want to use the *Workout Runner*, we have to load
    the *Workout Builder* as well. In a way, this makes sense if you think of our
    application as a **Single Page Application** (**SPA**). In order to avoid round
    trips to the server, an SPA will typically load all the resources that will be
    needed to use the application when it is first started up by a user. But in our
    case, the important point is that we do not need the *Workout Builder* when the
    application is first loaded. Instead, we would like to load those resources only
    when the user decides that they want to add or change a workout or exercise.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使我们可能只想使用*Workout Runner*，我们也必须加载*Workout Builder*。从某种意义上说，如果你将我们的应用程序视为**单页应用程序**（SPA），这就有道理了。为了避免往返服务器，SPA通常会在用户首次启动应用程序时加载所有将需要的资源。但在我们的情况下，重要的点是我们在应用程序首次加载时不需要*Workout
    Builder*。相反，我们希望在用户决定添加或更改锻炼或练习时才加载这些资源。
- en: So, let's get started with making that happen.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始实现这一目标。
- en: 'First, modify `app.routing-module.ts` to add the following route configuration
    for `WorkoutBuilderModule`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，修改`app.routing-module.ts`以添加以下路由配置`WorkoutBuilderModule`：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice that the `loadChildren` property is:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`loadChildren`属性是：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This configuration provides the information that will be needed to load and
    instantiate `WorkoutBuilderModule`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置提供了加载和实例化`WorkoutBuilderModule`所需的信息。
- en: 'Next go back to `workout-builder-routing.module.ts` and change the `path` property
    to an empty string:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来回到`workout-builder-routing.module.ts`，将`path`属性更改为空字符串：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are making this change because we are now setting the path (`builder`) to
    the `WorkoutBuilderRoutes` in the new configuration for them that we added in
    `app.routing-module.ts`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行此更改是因为我们现在将路径（`builder`）设置为`WorkoutBuilderRoutes`，这是我们在`app.routing-module.ts`中添加的新配置。
- en: Finally go back to `app-module.ts`  and remove the `WorkoutBuilderModule` import
    in the `@NgModule` configuration in that file. What this means is that instead
    of loading the **Workout Builder** feature when the application first starts,
    we only load it when a user accesses the route to *Workout Builder*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，回到`app-module.ts`文件，并从该文件的`@NgModule`配置中移除`WorkoutBuilderModule`导入。这意味着，我们不是在应用程序首次启动时加载**锻炼构建者**功能，而是在用户访问*锻炼构建者*路由时才加载它。
- en: 'Let''s go build and run the application again using `ng serve`. In the Terminal
    window, you should see something like the following output:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用`ng serve`构建和运行应用程序。在终端窗口中，你应该会看到以下类似的输出：
- en: '![](img/00034.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00034.jpeg)'
- en: What's interesting here is the last line that shows a separate file for the
    `workout.builder.module` called `workout-builder.module.chunk.js.`. **WebPack**
    has used what is called code splitting to carve out our workout builder module
    into a separate chunk. This chunk will not be loaded in our application until
    it is needed (that is, when the router navigates to `WorkoutBuilderModule`).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是最后一行，它显示了名为`workout.builder.module`的单独文件，即`workout-builder.module.chunk.js`。**WebPack**使用了所谓的代码拆分，将我们的锻炼构建者模块分割成单独的块。这个块将在需要时（即，当路由导航到`WorkoutBuilderModule`时）才被加载到我们的应用程序中。
- en: 'Now, keeping the Sources tab open in the Chrome developer tools bring up the
    application in the browser again. When the start page loads, only the files related
    to the *Workout Runner* appear and not those related to the *Workout Builder*,
    as shown here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Chrome开发者工具中保持“源”标签页打开，再次在浏览器中打开应用程序。当起始页面加载时，只有与*锻炼运行者*相关的文件出现，而没有与*锻炼构建者*相关的文件，如图所示：
- en: '![](img/00035.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00035.jpeg)'
- en: 'Then, if we clear the Network tab and click on the Create a Workout link, we''ll
    see the `workout-builder.module` chunk load:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们清除“网络”标签页并点击“创建锻炼”链接，我们将看到`workout-builder.module`块被加载：
- en: '![](img/00036.gif)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00036.gif)'
- en: This means that we have achieved encapsulation of our new feature and with asynchronous
    routing we are able to use lazy loading to load all its components only when needed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们已经实现了新功能的封装，并且通过异步路由，我们能够使用懒加载仅在需要时加载所有组件。
- en: Child and asynchronous routing make it straightforward to implement applications
    that allow us to have our cake and eat it too. On one hand, we can build SPAs
    with powerful client-side navigation, while on the other hand we can also encapsulate
    features in separate child routing components and load them only on demand.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 儿童和异步路由使得实现既能拥有蛋糕又能吃掉蛋糕的应用程序变得简单。一方面，我们可以构建具有强大客户端导航的单页应用（SPAs），另一方面，我们还可以将功能封装在独立的子路由组件中，并在需要时才加载它们。
- en: This power and flexibility of the Angular router give us the ability to meet
    user expectations by closely mapping our application's behavior and responsiveness
    to the ways they will use the application. In this case, we have leveraged these
    capabilities to achieve what we set out to do: immediately load *Workout Runner *so
    that our users can get to work on their exercises right away, but avoid the overhead
    of loading *Workout Builder *and instead only serve it when a user wants to build
    a workout.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种Angular路由的强大和灵活性使我们能够通过将应用程序的行为和响应性紧密映射到用户使用应用程序的方式，来满足用户期望。在这种情况下，我们利用了这些能力来实现我们的目标：立即加载*锻炼运行者*，以便我们的用户可以立即开始锻炼，同时避免加载*锻炼构建者*的开销，并且只在用户想要构建锻炼时才提供它。
- en: Now that we have the routing configuration in place in the *Workout Builder*,
    we will turn our attention to building out the sub-level and left navigation;
    this will enable us to use this routing. The next sections cover implementing
    this navigation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将路由配置设置在*锻炼构建者*中，我们将把注意力转向构建子级和左侧导航；这将使我们能够使用这种路由。接下来的几节将介绍如何实现这种导航。
- en: Integrating sub- and side-level navigation
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成子级和侧级导航
- en: The basic idea around integrating sub- and side-level navigation into the app
    is to provide context-aware sub-views that change based on the active view. For
    example, when we are on a list page as opposed to editing an item, we may want
    to show different elements in the navigation. An e-commerce site is a great example
    of this. Imagine Amazon's search result page and product detail page. As the context
    changes from a list of products to a specific product, the navigation elements
    that are loaded also change.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将子级和侧级导航集成到应用程序中的基本思想是提供上下文感知的子视图，这些视图根据活动视图而变化。例如，当我们处于列表页面而不是编辑项目时，我们可能希望在导航中显示不同的元素。电子商务网站是这种情况的一个很好的例子。想象一下亚马逊的搜索结果页面和产品详情页面。当上下文从产品列表变为特定产品时，加载的导航元素也会发生变化。
- en: Sub-level navigation
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子级导航
- en: 'We''ll start by adding sub-level navigation to the *Workout Builder*. We have
    already imported our `SubNavMainComponent` into the *Workout Builder*. But, currently
    it is just displaying placeholder content:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将在 *Workout Builder* 中添加子级导航。我们已将 `SubNavMainComponent` 导入到 *Workout Builder*
    中。但，目前它只是显示占位符内容：
- en: '![](img/00037.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00037.jpeg)'
- en: 'We''ll now replace that content with three router links: Home, New Workout,
    and New Exercise.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将替换该内容为三个路由链接：主页、新建锻炼和新建练习。
- en: 'Open the `sub-nav-main.component.html` file and change the HTML in it to the
    following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `sub-nav-main.component.html` 文件，将其中的 HTML 更改为以下内容：
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, rerun the application and you will see the three navigation links. If
    we click on the New Exercise link button, we will be routed to `ExerciseComponent`
    and its view will appear in the Router Outlet in the *Workout Builder* view:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新运行应用程序，您将看到三个导航链接。如果我们点击“新建练习”链接按钮，我们将被路由到 `ExerciseComponent`，其视图将在 *Workout
    Builder* 视图的 Router Outlet 中显示：
- en: '![](img/00038.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: The New Workout link button will work in a similar fashion; when clicked on,
    it will take the user to the `WorkoutComponent` and display its view in the router
    outlet. Clicking on the Home link button will return the user to the `WorkoutsComponent` and
    view.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 新建锻炼链接按钮将以类似的方式工作；当点击时，它将用户带到 `WorkoutComponent` 并在路由出口中显示其视图。点击主页链接按钮将用户返回到
    `WorkoutsComponent` 并查看。
- en: Side navigation
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侧边导航
- en: Side-level navigation within the *Workout Builder* will vary depending on the
    child component that we navigate to. For instance, when we first navigate to the
    *Workout Builder*, we are taken to the Workouts screen because the `WorkoutsComponent` route
    is the default route for the *Workout Builder*. That component will need side
    navigation; it will allow us to select to view a list of workouts or a list of
    exercises.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Workout Builder* 中的侧级导航将根据我们导航到的子组件而有所不同。例如，当我们第一次导航到 *Workout Builder* 时，我们将被带到
    Workouts 屏幕，因为 `WorkoutsComponent` 路由是 *Workout Builder* 的默认路由。该组件将需要侧边导航；它将允许我们选择查看锻炼列表或练习列表。
- en: 'The component-based nature of Angular gives us an easy way to implement these
    context-sensitive menus. We can define new components for each of the menus and
    then import them into the components that need them. In this case, we have three
    components that will need side menus: **Workouts**, **Exercises**, and **Workout**.
    The first two of these components can actually use the same menu so we really
    only need two side menu components: `LeftNavMainComponent`, which will be like
    the preceding menu and will be used by the `Exercises` and `Workouts` components,
    and `LeftNavExercisesComponent`, which will contain a list of existing exercises
    and will be used by the `Workouts` component.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 的组件化特性为我们提供了一个简单的方法来实现这些上下文敏感的菜单。我们可以为每个菜单定义新的组件，然后将它们导入到需要它们的组件中。在这种情况下，我们有三个组件需要侧边菜单：**Workouts**、**Exercises**
    和 **Workout**。其中前两个组件实际上可以使用相同的菜单，所以我们实际上只需要两个侧边菜单组件：`LeftNavMainComponent`，它将类似于前面的菜单，将被
    `Exercises` 和 `Workouts` 组件使用，以及 `LeftNavExercisesComponent`，它将包含现有练习的列表，并将被 `Workouts`
    组件使用。
- en: We already have files for the two menu components, including template files,
    and have imported them into `WorkoutBuilderModule`. We will now integrate these
    into the components that need them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了两个菜单组件的文件，包括模板文件，并将它们导入到 `WorkoutBuilderModule` 中。我们现在将它们集成到需要它们的组件中。
- en: 'First, modify the `workouts.component.html` template to add the selector for
    the menu:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，修改 `workouts.component.html` 模板以添加菜单的选择器：
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, replace the placeholder text in the `left-nav-main.component.html` with
    the navigation links to `WorkoutsComponent` and `ExercisesComponent`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`left-nav-main.component.html`中的占位文本替换为指向`WorkoutsComponent`和`ExercisesComponent`的导航链接：
- en: '[PRE19]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the application and you should see the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，你应该会看到以下内容：
- en: '![](img/00039.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.jpeg)'
- en: Follow the exact same steps to complete the side menu for the `Exercises` component.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 按照完全相同的步骤完成`Exercises`组件的侧菜单。
- en: We won't show the code for this menu here, but you can find it in the `workout-builder/exercises`
    folder under `trainer/src/app` in `checkpoint 4.3` of the GitHub repository.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会展示这个菜单的代码，但你可以在GitHub仓库的`checkpoint 4.3`中的`trainer/src/app`目录下的`workout-builder/exercises`文件夹中找到它。
- en: 'For the menu for the Workout screen, the steps are the same except that you
    should change `left-nav-exercises.component.html` to the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于锻炼屏幕的菜单，步骤相同，但你应该将`left-nav-exercises.component.html`更改为以下内容：
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will use this template as the starting point for building out a list of exercises
    that will appear on the left-hand side of the screen and can be selected for inclusion
    in a workout.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用此模板作为构建屏幕左侧将出现并可以选择包含在锻炼中的锻炼列表的起点。
- en: Implementing workout and exercise lists
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现锻炼和锻炼列表
- en: Even before we start implementing the Workout and Exercise list pages, we need
    a data store for exercise and workout data. The current plan is to have an in-memory
    data store and expose it using an Angular service. In Chapter 5, *Supporting Server
    Data Persistence*, where we talk about server interaction, we will move this data
    to a server store for long-term persistence. For now, the in-memory store will
    suffice. Let's add the store implementation.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现锻炼和锻炼列表页面之前，我们需要一个用于锻炼和锻炼数据的存储库。当前的计划是使用内存中的存储库并通过Angular服务公开它。在第5章*支持服务器数据持久性*中，我们将讨论服务器交互，我们将把此数据移动到服务器存储库以实现长期持久性。目前，内存存储库就足够了。让我们添加存储库实现。
- en: WorkoutService as a workout and exercise repository
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将WorkoutService作为锻炼和锻炼仓库
- en: 'The plan here is to create a `WorkoutService` instance that is responsible
    for exposing the exercise and workout data across the two applications. The main
    responsibilities of the service include:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的计划是创建一个`WorkoutService`实例，该实例负责在两个应用程序之间公开锻炼和锻炼数据。该服务的主要职责包括：
- en: '**Exercise-related CRUD operations**: Get all exercises, get a specific exercise
    based on its name, create an exercise, update an exercise, and delete it'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与锻炼相关的CRUD操作**：获取所有锻炼，根据名称获取特定锻炼，创建锻炼，更新锻炼，以及删除它'
- en: '**Workout-related CRUD operations**: These are similar to the exercise-related
    operations, but targeted toward the workout entity'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与锻炼相关的CRUD操作**：这些操作与与锻炼相关的操作类似，但针对的是锻炼实体'
- en: 'The code is available to download on GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    The branch to download is as follows: **GitHub Branch: checkpoint4.4** (folder—`trainer`).
    If you are not using Git, download the snapshot of `Checkpoint 4.4` (a ZIP file)
    from the following GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.4.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.4.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure to update the `styles.css` file, which we are not discussing here. Because
    some of the files in this section are rather long, rather than showing the code
    here, we are also going to suggest at times that you simply copy the files into
    your solution.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可在GitHub上下载，网址为[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)。要下载的分支如下：**GitHub分支：checkpoint4.4**（文件夹—`trainer`）。如果你不使用Git，可以从以下GitHub位置下载`Checkpoint
    4.4`的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/archive/checkpoint4.4.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.4.zip)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。再次提醒，如果你在我们构建应用程序的同时工作，请确保更新`styles.css`文件，这里我们不做讨论。因为本节中的一些文件相当长，我们有时会建议你直接将文件复制到你的解决方案中。
- en: 'Locate `workout-service.ts` in the `trainer/src/core` folder. The code in that
    file should look like the following, except for the implementation of the two
    methods `setupInitialExercises` and `setupInitialWorkouts`, which we have left
    out because of their length:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在`trainer/src/core`文件夹中定位`workout-service.ts`。该文件中的代码应该如下所示，除了省略了长度较长的两个方法`setupInitialExercises`和`setupInitialWorkouts`：
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we have mentioned before, the implementation of an Angular service is straightforward.
    Here, we are declaring a class with the name `WorkoutService` and decorating it
    with `@Injectable` . Within the `@Injectable` decorator, we have  sets the `provided-in`
    property to `CoreModule`.  This registers `WorkoutService` as a provider with
    Angular's **Dependency Injection** framework and makes it available throughout
    our application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Angular服务的实现很简单。在这里，我们声明了一个名为`WorkoutService`的类，并用`@Injectable`装饰它。在`@Injectable`装饰器中，我们将`provided-in`属性设置为`CoreModule`。这会将`WorkoutService`注册为Angular依赖注入框架的一个提供者，并使其在整个应用程序中可用。
- en: In the class definition, we first create two arrays: one for `Workouts` and
    one for `Exercises`. These arrays are of types `WorkoutPlan` and `Exercise` respectively,
    and we therefore need to import `WorkoutPlan` and `Exericse` from `model.ts` to
    get the type definitions for them.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义中，我们首先创建两个数组：一个用于`Workouts`，一个用于`Exercises`。这两个数组分别是`WorkoutPlan`和`Exercise`类型，因此我们需要从`model.ts`导入`WorkoutPlan`和`Exercise`以获取它们的类型定义。
- en: The constructor calls two methods to set up the Workouts and Services List.
    At the moment, we are just using an in-memory store that populates these lists
    with data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数调用两个方法来设置训练和服务的列表。目前，我们只是使用一个内存存储，用数据填充这些列表。
- en: The two methods, `getExercises` and `getWorkouts`, as the names suggest, return
    a list of exercises and workouts respectively. Since we plan to use the in-memory
    store to store workout and exercise data, the `Workouts` and `Exercises` arrays
    store this data. As we go along, we will be adding more functions to the service.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，两个方法`getExercises`和`getWorkouts`分别返回一个锻炼和训练列表。由于我们计划使用内存存储来存储训练和锻炼数据，`Workouts`和`Exercises`数组存储这些数据。随着我们的进行，我们将在服务中添加更多功能。
- en: Time to build out the components for the workout and exercise lists!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候构建训练和锻炼列表的组件了！
- en: Workout and exercise list components
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练和锻炼列表组件
- en: 'First, open the `workouts.component.ts` file in the `trainer/src/app/workout-builder/workouts`
    folder and update the imports as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`trainer/src/app/workout-builder/workouts`文件夹中打开`workouts.component.ts`文件，并按如下方式更新导入：
- en: '[PRE22]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This new code imports the Angular  `Router` as well as `WorkoutService` and
    the `WorkoutPlan` type.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这段新代码导入了Angular的`Router`、`WorkoutService`以及`WorkoutPlan`类型。
- en: 'Next, replace the class definition with the following code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，用以下代码替换类定义：
- en: '[PRE23]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code adds a constructor into which we are injecting the `Router` and the
    `WorkoutService`. The `ngOnInit` method then calls the `getWorkouts` method on
    the `WorkoutService` and populates a `workoutList`  array with a list of `WorkoutPlans`
    returned from that method call. We'll use that `workoutList` array to populate
    the list of workout plans that will display in the `Workouts` component's view.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在构造函数中添加了`Router`和`WorkoutService`的注入。然后`ngOnInit`方法调用`WorkoutService`的`getWorkouts`方法，并用从该方法调用返回的`WorkoutPlans`列表填充`workoutList`数组。我们将使用这个`workoutList`数组来填充将在`Workouts`组件视图中显示的训练计划列表。
- en: You'll notice that we are putting the code for calling `WorkoutService` into
    the `ngOnInit` method. We want to avoid placing this code in the constructor.
    Eventually, we will be replacing the in-memory store that this service uses with
    a call to an external data store and we do not want the instantiation of our component
    to be affected by this call. Adding these method calls to the constructor would
    also complicate testing the component.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们将调用`WorkoutService`的代码放入了`ngOnInit`方法中。我们不想在构造函数中放置这段代码。最终，我们将用对外部数据存储的调用替换掉这个服务使用的内存存储，我们不希望组件的实例化受到这个调用的影响。将这些方法调用添加到构造函数中也会使组件的测试变得复杂。
- en: To avoid such unintended side effects, we instead place the code in the `ngOnInit`
    method. This method implements one of Angular's life cycle hooks, `OnInit`, which
    Angular calls after creating an instance of the service. This way, we rely on
    Angular to call this method in a predictable way that does not affect the instantiation
    of the component.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种意外的副作用，我们将其代码放置在`ngOnInit`方法中。该方法实现了Angular的生命周期钩子之一`OnInit`，Angular在创建服务实例后调用此方法。这样，我们依赖Angular以可预测的方式调用此方法，而不会影响组件的实例化。
- en: Next, we'll make almost identical changes to the `Exercises` component. As with
    the `Workouts` component, this code injects the workout service into our component.
    This time, we then use the workout service to retrieve the exercises.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对`Exercises`组件进行几乎相同的更改。与`Workouts`组件一样，这段代码将锻炼服务注入到我们的组件中。这次，我们使用锻炼服务来检索锻炼内容。
- en: Because it so similar to what we just showed you for the `Workouts` component,
    we won't show that code here. Just add it from the `workout-builder/exercises`
    folder in  `checkpoint 4.4`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它与我们在`Workouts`组件中刚刚展示的内容非常相似，所以我们在这里不会展示那段代码。只需从`checkpoint 4.4`中的`workout-builder/exercises`文件夹添加即可。
- en: Workout and exercise list views
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锻炼和锻炼列表视图
- en: Now, we need to implement the list views that have so far been empty!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要实现迄今为止一直为空的列表视图！
- en: In this section, we will be updating the code from `checkpoint 4.3` with what
    is found in `checkpoint 4.4`. So if you are coding along with us, simply follow
    the steps laid out in this section. If you want to see the finished code, then
    just copy the files from `checkpoint 4.4` into your solution.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更新`checkpoint 4.3`中的代码，以包含`checkpoint 4.4`中的内容。所以如果你正在与我们一起编码，只需遵循本节中概述的步骤。如果你想查看完成的代码，只需将`checkpoint
    4.4`中的文件复制到你的解决方案中即可。
- en: Workouts list views
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锻炼列表视图
- en: 'To get the view working, open `workouts.component.html` and add the following
    markup:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使视图工作，打开`workouts.component.html`并添加以下标记：
- en: '[PRE24]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are using one of the Angular core directives, `ngFor`, to loop through the
    list of workouts and display them in a list on the page. We add the `*` sign in
    front of `ngFor` to identify it as an Angular directive. Using a `let` statement,
    we assign `workout` as a local variable that we use to iterate through the workout
    list and identify the values to be displayed for each workout (for example, `workout.title`).
    We then use one of our custom pipes, `orderBy`, to display a list of workouts
    in alphabetical order by title. We are also using another custom pipe, `secondsToTime`,
    to format the time displayed for the total workout duration.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Angular核心指令之一`ngFor`来遍历锻炼列表并在页面上显示它们。我们在`ngFor`前面添加`*`符号来标识它为Angular指令。使用`let`语句，我们将`workout`分配为本地变量，我们使用它来遍历锻炼列表并识别每个锻炼要显示的值（例如，`workout.title`）。然后，我们使用我们的自定义管道之一`orderBy`来按标题字母顺序显示锻炼列表。我们还使用另一个自定义管道`secondsToTime`来格式化显示的总锻炼时长。
- en: If you are coding along with us, you will need to move the `secondsToTime` pipe
    into the shared folder and include it in the `SharedModule`. Then, add `SharedModule`
    to `WorkoutBuilderModule` as an additional import. That change has already been
    made in `checkpoint 4.4` in the GitHub repository.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在与我们一起编码，你需要将`secondsToTime`管道移动到共享文件夹中，并将其包含在`SharedModule`中。然后，将`SharedModule`添加到`WorkoutBuilderModule`中作为额外的导入。这个更改已经在GitHub仓库中的`checkpoint
    4.4`中完成。
- en: 'Finally, we bind the click event to the following `onSelect` method that we
    add to our component:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将点击事件绑定到我们添加到组件中的以下`onSelect`方法：
- en: '[PRE25]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This sets up navigation to the workout details page. This navigation happens
    when we click on an item in the workout list. The selected workout name is passed
    as part of the route`/URL` to the workout detail page.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了导航到锻炼详情页。当我们在锻炼列表中点击一个项目时发生此导航。选定的锻炼名称作为路由`/URL`的一部分传递到锻炼详情页。
- en: 'Go ahead and refresh the builder page (`/builder/workouts`); one workout is
    listed, the 7 Minute Workout. Click on the tile for that workout. You''ll be taken
    to the Workout screen and the workout name, `7MinWorkout`, will appear at the
    end of the URL:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，刷新一下构建页面（`/builder/workouts`）；有一个锻炼列表，7分钟锻炼。点击该锻炼的磁贴。你将被带到锻炼屏幕，并且锻炼名称`7MinWorkout`将出现在URL的末尾：
- en: '![](img/00040.jpeg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00040.jpeg)'
- en: The Workout screen
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 锻炼屏幕
- en: Exercises list views
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锻炼列表视图
- en: 'We are going to follow the same approach for the `Exercises` list view as we
    did for the `Workouts` list view, except that in this case, we will actually be
    implementing two views: one for the `Exercises` component (which will display
    in the main content area when a user navigates to that component) and one for
    the `LeftNavExercisesComponent` exercises context menu (which will display when
    the user navigates to the `Workouts` component to create or edit a workout).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循与`Workouts`列表视图相同的方法来处理`Exercises`列表视图，只是在这种情况下，我们将实际实现两个视图：一个用于`Exercises`组件（当用户导航到该组件时将在主要内容区域显示）和一个用于`LeftNavExercisesComponent`练习上下文菜单（当用户导航到`Workouts`组件以创建或编辑锻炼时将显示）。
- en: For the `Exercises` component, we will follow an approach that is almost identical
    to what we did to display a list of workouts in the `Workouts` component. So,
    we won't show that code here. Just add the files for `exercises.component.ts`
    and `exercises.component.html` from `checkpoint 4.4`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Exercises`组件，我们将遵循与我们在`Workouts`组件中显示锻炼列表几乎相同的方法。所以我们不会在这里展示那段代码。只需从`checkpoint
    4.4`添加`exercises.component.ts`和`exercises.component.html`文件即可。
- en: When you are done copying the files, click on the Exercises link in the left
    navigation to load the 12 exercises that you have already configured in `WorkoutService`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成文件复制后，点击左侧导航中的“练习”链接来加载你在`WorkoutService`中已经配置的12个练习。
- en: As with the `Workouts` list, this sets up the navigation to the exercise detail
    page. Clicking on an item in the exercises list takes us to the exercise detail
    page. The selected exercise name is passed as part of the route`/URL` to the exercise
    detail page.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Workouts`列表一样，这设置了导航到锻炼详情页的设置。点击练习列表中的项目将带我们到锻炼详情页。选定的练习名称作为路由`/URL`的一部分传递到锻炼详情页。
- en: In the final list view, we will add a list of exercises that will display in
    the left context menu for the *Workout Builder* screen. This view is loaded in
    the left navigation when we create or edit a workout. Using Angular's component-based
    approach, we will update the `leftNavExercisesComponent` and its related view
    to provide this functionality. Again we won't show that code here. Just add the
    files for `left-nav-exercises.component.ts` and `left-nav-exercises.component.html`
    from the `trainer/src/app/navigation` folder in `checkpoint 4.4`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终列表视图中，我们将添加一个将在*Workout Builder*屏幕的左侧上下文菜单中显示的练习列表。当我们创建或编辑锻炼时，此视图将在左侧导航中加载。使用Angular的基于组件的方法，我们将更新`leftNavExercisesComponent`及其相关视图以提供此功能。我们在这里不会展示那段代码。只需从`trainer/src/app/navigation`文件夹中的`checkpoint
    4.4`添加`left-nav-exercises.component.ts`和`left-nav-exercises.component.html`文件即可。
- en: Once you are done copying those files, click on the New Workout button on the
    sub-navigation menu in the *Workout Builder* and you will now see a list of exercises
    displayed in the left navigation menu—exercises that we have already configured
    in `WorkoutService`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 完成那些文件的复制后，点击*Workout Builder*中的子导航菜单上的“新建锻炼”按钮，你现在将看到在左侧导航菜单中显示的练习列表——这些是我们已经在`WorkoutService`中配置好的练习。
- en: Time to add the ability to load, save, and update exercise/workout data!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加加载、保存和更新锻炼/锻炼数据的能力了！
- en: Building a workout
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立锻炼
- en: The core functionality *Personal Trainer* provides centers around workout and
    exercise building. Everything is there to support these two functions. In this
    section, we focus on building and editing workouts using Angular.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*Personal Trainer*的核心功能围绕着锻炼和锻炼构建。所有这些都是为了支持这两个功能。在本节中，我们专注于使用Angular构建和编辑锻炼。'
- en: The `WorkoutPlan` model has already been defined, so we are aware of the elements
    that constitute a workout. The *Workout Builder* page facilitates user input and
    lets us build/persist workout data.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutPlan`模型已经定义，因此我们了解构成锻炼的元素。*Workout Builder*页面简化了用户输入，并允许我们构建/持久化锻炼数据。'
- en: 'Once complete, the *Workout Builder* page will look like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，*Workout Builder*页面将看起来像这样：
- en: '![](img/00041.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00041.jpeg)'
- en: The page has a left navigation that lists all the exercises that can be added
    to the workout. Clicking on the arrow icon on the right adds the exercise to the
    end of the workout.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 页面有一个左侧导航，列出了可以添加到锻炼中的所有练习。点击右侧的箭头图标将练习添加到锻炼的末尾。
- en: The center area is designated for workout building. It consists of exercise
    tiles laid out in order from top to bottom and a form that allows the user to
    provide other details about the workout such as name, title, description, and
    rest duration.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 中心区域被指定为健身建筑区域。它由从上到下排列的锻炼瓷砖和一个允许用户提供有关锻炼的其他详细信息（如名称、标题、描述和休息时长）的表单组成。
- en: 'This page operates in two modes:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面以两种模式运行：
- en: 'Create/New: This mode is used for creating a new workout. The URL is `#/ builder/workout/new`.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建/新建：此模式用于创建新的锻炼。URL是`#/builder/workout/new`。
- en: 'Edit: This mode is used for editing the existing workout. The URL is `#/ builder/workout/:id`,
    where `:id` maps to the name of the workout.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑：此模式用于编辑现有的锻炼。URL是`#/builder/workout/:id`，其中`:id`映射到锻炼的名称。
- en: With this understanding of the page elements and layout, it's time to build
    each of these elements. We will start with left nav (navigation).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了页面元素和布局之后，现在是时候构建这些元素中的每一个了。我们将从左侧导航（导航）开始。
- en: Finishing left nav
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成左侧导航
- en: At the end of the previous section, we updated the left navigation view for
    the `Workout` component to show a list of exercises. Our intention was to let
    the user click on an arrow next to an exercise to add it to the workout. At the
    time, we deferred implementing the `addExercise` method in the `LeftNavExercisesComponent`
    that was bound to that click event. Now, we will go ahead and do that.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节结束时，我们更新了`Workout`组件的左侧导航视图，以显示锻炼列表。我们的意图是让用户点击一个练习旁边的箭头将其添加到锻炼中。当时，我们推迟了在`LeftNavExercisesComponent`中实现与该点击事件绑定的`addExercise`方法。现在，我们将继续这样做。
- en: We have a couple of options here. The `LeftNavExercisesComponent` is a child
    component of the `WorkoutComponent`, so we can implement child/parent inter-component
    communication to accomplish that. We covered this technique in the previous chapter
    while working on *7 Minute Workout*.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几个选择。`LeftNavExercisesComponent`是`WorkoutComponent`的子组件，因此我们可以实现子/父组件间通信来完成这个任务。我们在上一章中讨论了这项技术，当时我们在处理*7分钟锻炼*。
- en: However, adding an exercise to the workout is part of a larger process of building
    the workout and using child/parent inter-component communication would make the
    implementation of the `AddExercise` method differ from the other functionality
    that we will be adding going forward.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将练习添加到锻炼是构建锻炼的更大过程的一部分，使用子/父组件间通信会使`AddExercise`方法的实现与其他我们将要添加的功能有所不同。
- en: For this reason, it makes more sense to follow another approach for sharing
    data, one that we can use consistently throughout the process of building a workout.
    That approach involves using a service. As we get into adding the other functionality
    for creating an actual workout, such as save/update logic and implementing the
    other relevant components, the benefits of going down the service route will become
    increasingly clear.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，遵循另一种数据共享方法更有意义，这种方法我们可以一致地用于构建锻炼的整个过程中。这种方法涉及使用服务。当我们开始添加创建实际锻炼的其他功能，例如保存/更新逻辑和实现其他相关组件时，走服务路线的好处将越来越明显。
- en: So, we introduce a new service into the picture: `WorkoutBuilderService`. The
    ultimate aim of `WorkoutBuilderService` service is to coordinate between `WorkoutService`
    (which retrieves and persists the workout) and the components (such as `LeftNavExercisesComponent`
    and others we will add later), while the workout is being built, hence reducing
    the amount of code in `WorkoutComponent` to the bare minimum.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们引入了一个新的服务：`WorkoutBuilderService`。`WorkoutBuilderService`服务的最终目标是协调在构建锻炼过程中`WorkoutService`（检索和持久化锻炼）和组件（如`LeftNavExercisesComponent`以及我们稍后将要添加的其他组件）之间的关系，从而将`WorkoutComponent`中的代码量减少到最低。
- en: Adding WorkoutBuilderService
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加`WorkoutBuilderService`
- en: '`WorkoutBuilderService` monitors the state of the workout that a user of the
    application is building. It:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService`监控应用程序用户正在构建的锻炼状态。它：'
- en: Tracks the current workout
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪当前锻炼
- en: Creates a new workout
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的锻炼
- en: Loads the existing workout
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载现有锻炼
- en: Saves the workout
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存锻炼
- en: Copy `workout-builder-service.ts` from the `workout-builder/builder-services` folder
    under `trainer/src/app` in `checkpoint 4.5`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 从`trainer/src/app`下的`workout-builder/builder-services`文件夹中的`checkpoint 4.5`复制`workout-builder-service.ts`
- en: 'The code is also available for everyone to download on GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: `GitHub Branch: checkpoint4.5` (folder—`trainer`). If you are not using
    Git, download the snapshot of `Checkpoint 4.5` (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.5.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.5.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure to update the `styles.css` file, which we are not discussing here.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '代码也可在GitHub上供所有人下载，链接为[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)。检查点作为GitHub上的分支实现。要下载的分支如下：`GitHub
    Branch: checkpoint4.5`（文件夹—`trainer`）。如果您不使用Git，可以从以下GitHub位置下载`Checkpoint 4.5`的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/archive/checkpoint4.5.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.5.zip)。在首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。再次提醒，如果您在我们构建应用程序的同时工作，请确保更新`styles.css`文件，这里我们不做讨论。'
- en: 'While we normally make services available application-wide,  `WorkoutBuilderService`
    will only be used in the *Workout Builder* feature. Therefore, instead of registering
    it with the providers in `AppModule`, we have registered it in the provider array
    of `WorkoutBuilderModule` as follows (after adding it as an import at the top
    of the file):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们通常使服务在应用程序范围内可用，但`WorkoutBuilderService`将仅用于`Workout Builder`功能。因此，我们不是在`AppModule`的提供者中注册它，而是在`WorkoutBuilderModule`的提供者数组中注册它，如下所示（在文件顶部添加导入之后）：
- en: '[PRE26]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Adding it as a provider here means that it will only be loaded when the *Workout
    Builder* feature is being accessed and it cannot be reached outside this module.
    This means that it can be evolved independently of other modules in the application
    and can be modified without affecting other parts of the application.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 将其作为提供者在这里意味着它仅在访问`Workout Builder`功能时加载，并且不能从该模块外部访问。这意味着它可以独立于应用程序中的其他模块进行发展，并且可以修改而不会影响应用程序的其他部分。
- en: Let's look at some of the relevant parts of the service.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看服务的一些相关部分。
- en: '`WorkoutBuilderService` needs the type definitions for `WorkoutPlan`, `ExercisePlan`,
    and `WorkoutService`, so we import these into the component:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService`需要`WorkoutPlan`、`ExercisePlan`和`WorkoutService`的类型定义，因此我们将这些导入到组件中：'
- en: '[PRE27]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`WorkoutBuilderService` has a dependency on `WorkoutService` to provide persistence
    and querying capabilities. We resolve this dependency by injecting `WorkoutService`
    into the constructor for `WorkoutBuilderService`**:**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService`依赖于`WorkoutService`以提供持久性和查询功能。我们通过将`WorkoutService`注入到`WorkoutBuilderService`的构造函数中解决这个依赖关系**：'
- en: '[PRE28]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`WorkoutBuilderService` also needs to track the workout being built. We use
    the `buildingWorkout` property for this. The tracking starts when we call the
    `startBuilding` method on the service:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService`还需要跟踪正在构建的锻炼。我们使用`buildingWorkout`属性来完成这项工作。跟踪从我们在服务上调用`startBuilding`方法时开始：'
- en: '[PRE29]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The basic idea behind this tracking function is to set up a `WorkoutPlan` object
    (`buildingWorkout`) that will be made available to components to manipulate the
    workout details. The `startBuilding` method takes the workout name as a parameter.
    If the name is not provided, it implies we are creating a new workout, and hence
    a new `WorkoutPlan` object is created and assigned; if not, we load the workout
    details by calling `WorkoutService.getWorkout(name)`. In any case, the `buildingWorkout`
    object has the workout being worked on.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 此跟踪功能背后的基本思想是设置一个`WorkoutPlan`对象（`buildingWorkout`），该对象将被提供给组件以操作锻炼细节。`startBuilding`方法接受锻炼名称作为参数。如果没有提供名称，则表示我们正在创建一个新的锻炼，因此创建一个新的`WorkoutPlan`对象并分配给它；如果没有，我们通过调用`WorkoutService.getWorkout(name)`来加载锻炼细节。在任何情况下，`buildingWorkout`对象都包含正在进行的锻炼。
- en: The `newWorkout` object signifies whether the workout is new or an existing
    one. It is used to differentiate between save and update situations when the `save`
    method on this service is called.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`newWorkout`对象表示锻炼是新的还是现有的。它用于在调用此服务上的`save`方法时区分保存和更新情况。'
- en: The rest of the methods, `removeExercise`, `addExercise`, and `moveExerciseTo`, are
    self-explanatory and affect the exercise list that is part of the workout (`buildingWorkout`).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的方法，`removeExercise`、`addExercise` 和 `moveExerciseTo`，都是一目了然的，并且会影响锻炼计划中的一部分锻炼列表（`buildingWorkout`）。
- en: '`WorkoutBuilderService` is calling a new method, `getWorkout`, on `WorkoutService`,
    which we have not added yet. Go ahead and copy the `getWorkout` implementation
    from the `workout-service.ts` file in the `services` folder under `trainer/src`
    in `checkpoint 4.5`. We will not dwell on the new service code as the implementation
    is quite simple.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService` 在 `WorkoutService` 上调用一个新的方法 `getWorkout`，我们还没有添加。请从
    `trainer/src/services` 文件夹下的 `workout-service.ts` 文件中复制 `getWorkout` 的实现。由于实现相当简单，我们不会过多关注新的服务代码。'
- en: Let's get back to left nav and implement the remaining functionality.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到左侧导航并实现剩余的功能。
- en: Adding exercises using ExerciseNav
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用锻炼导航添加锻炼
- en: 'To add exercises to the workout we are building, we just need to import `WorkoutBuilderService`
    and `ExercisePlan`, inject `WorkoutBuilderService` into the `LeftNavExercisesComponent`,
    and call its `addExercise` method, passing the selected exercise as a parameter:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要将锻炼添加到我们正在构建的锻炼计划中，我们只需导入 `WorkoutBuilderService` 和 `ExercisePlan`，将 `WorkoutBuilderService`
    注入到 `LeftNavExercisesComponent` 中，并调用其 `addExercise` 方法，传递所选的锻炼作为参数：
- en: '[PRE30]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Internally, `WorkoutBuilderService.addExercise` updates the `buildingWorkout`
    model data with the new exercise.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`WorkoutBuilderService.addExercise` 通过新的锻炼更新 `buildingWorkout` 模型数据。
- en: The preceding implementation is a classic case of sharing data between independent
    components. The shared service exposes the data in a controlled manner to any
    component that requests it. While sharing data, it is always a good practice to
    expose the state/data using methods instead of directly exposing the data object.
    We can see that in our component and service implementations too. `LeftNavExercisesComponent`
    does not update the workout data directly; in fact, it does not have direct access
    to the workout being built. Instead, it relies upon the service method, `addExercise`,
    to change the current workout's exercise list.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现是独立组件之间共享数据的一个典型例子。共享服务以受控的方式向请求它的任何组件公开数据。在共享数据时，始终是一个好习惯使用方法而不是直接公开数据对象来公开状态/数据。我们可以在我们的组件和服务实现中看到这一点。`LeftNavExercisesComponent`
    并不是直接更新锻炼数据；实际上，它没有直接访问正在构建的锻炼。相反，它依赖于服务方法 `addExercise` 来更改当前锻炼的锻炼列表。
- en: Since the service is shared, there are pitfalls to be aware of. As services
    are injectable through the system, we cannot stop any component from taking dependency
    on any service and calling its functions in an inconsistent manner, leading to
    undesired results or bugs. For example, `WorkoutBuilderService` needs to be initialized
    by calling `startBuilding` before `addExercise` is called. What happens if a component
    calls `addExercise` before the initialization takes place?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务是共享的，需要注意一些陷阱。由于服务可以通过系统注入，我们无法阻止任何组件依赖任何服务并以不一致的方式调用其函数，从而导致不期望的结果或错误。例如，在调用
    `addExercise` 之前，`WorkoutBuilderService` 需要通过调用 `startBuilding` 来初始化。如果在初始化之前组件调用了
    `addExercise` 会发生什么？
- en: Implementing the Workout component
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 Workout 组件
- en: The `WorkoutComponent` is responsible for managing a workout. This includes
    creating, editing, and viewing the workout. Due to the introduction of `WorkoutBuilderService`,
    the overall complexity of this component will be reduced. Other than the primary
    responsibility of integrating with, exposing, and interacting with its template
    view, we will delegate most of the other work to `WorkoutBuilderService`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutComponent` 负责管理锻炼。这包括创建、编辑和查看锻炼。由于引入了 `WorkoutBuilderService`，该组件的整体复杂性将降低。除了与模板视图集成、暴露和交互的主要责任外，我们将大部分其他工作委托给
    `WorkoutBuilderService`。'
- en: The `WorkoutComponent` is associated with two `routes/views`, namely `/builder/workout/new`
    and `/builder/workout/:id`. These routes handle both creating and editing workout
    scenarios. The first job of the component is to load or create the workout that
    it needs to manipulate.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutComponent` 与两个 `routes/views` 相关联，即 `/builder/workout/new` 和 `/builder/workout/:id`。这些路由处理创建和编辑锻炼计划的情况。组件的第一项任务是加载或创建它需要操作的锻炼计划。'
- en: Route parameters
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由参数
- en: But before we get to building out the `WorkoutComponent`and its associated view,
    we need to touch briefly on the navigation that brings a user to the screen for
    that component. This component handles both creating and editing workout scenarios.
    The first job of the component is to load or create the workout that it needs
    to manipulate. We plan to use Angular's routing framework to pass the necessary
    data to the component, so that it will know whether it is editing an existing
    workout or creating a new one, and in the case of an existing workout, which component
    it should be editing.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建 `WorkoutComponent` 及其相关视图之前，我们需要简要介绍将用户带到该组件屏幕的导航。此组件处理创建和编辑锻炼场景。组件的第一个任务是加载或创建它需要操作的锻炼。我们计划使用
    Angular 的路由框架将必要的数据传递给组件，以便它知道它是在编辑现有的锻炼还是创建一个新的锻炼，在现有锻炼的情况下，它应该编辑哪个组件。
- en: How is this done? The `WorkoutComponent` is associated with two routes, namely
    `/builder/workout/new` and `/builder/workout/:id`. The difference in these two
    routes lies in what is at the end of these routes; in one case, it is `/new`,
    and in the other,` /:id`. These are called **route parameters.** The `:id` in
    the second route is a token for a route parameter. The router will convert the
    token to the ID for the workout component. As we saw earlier, this means that
    the URL that will be passed to the component in the case of *7 Minute Workout*
    will be `/builder/workout/7MinuteWorkout`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何完成的？`WorkoutComponent` 与两个路由相关联，即 `/builder/workout/new` 和 `/builder/workout/:id`。这两个路由之间的区别在于这些路由的末尾是什么；在一种情况下，它是
    `/new`，在另一种情况下，是 `/:id`。这些被称为 **路由参数**。第二个路由中的 `:id` 是一个路由参数的占位符。路由器将占位符转换为锻炼组件的
    ID。正如我们之前所看到的，这意味着在 *7 分钟锻炼* 的情况下，将传递给组件的 URL 将是 `/builder/workout/7MinuteWorkout`。
- en: 'How do we know that this workout name is the right parameter for the ID? As
    you recall, when we set up the event for handling a click on the Workout tiles
    on the Workouts screen that takes us to the Workout screen, we designated the
    workout name as the parameter for the ID, like so:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道这个锻炼名称是正确的 ID 参数？如您所回忆的，当我们设置处理锻炼屏幕上锻炼瓷砖点击事件的程序时，该事件会将我们带到锻炼屏幕，我们指定锻炼名称作为
    ID 的参数，如下所示：
- en: '[PRE31]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we are constructing the route using the programmatic interface for the
    router (we covered routing in detail in the previous chapter, so we won't go over
    that again here). The `router.navigate` method accepts an array. This is called
    the **link parameters array**. The first item in the array is the path of the
    route, and the second is a route parameter that specifies the ID of the workout.
    In this case, we set the `id` parameter to the workout name. From our discussion
    of routing in the previous chapter, we know that we can also construct the same
    type of URL as part of a router link or simply enter it in the browser to get
    to the Workouts screen and edit a particular workout.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用路由器的程序化接口构建路由（我们已经在上一章详细介绍了路由，所以这里不再重复）。`router.navigate` 方法接受一个数组。这被称为
    **链接参数数组**。数组中的第一个元素是路由的路径，第二个是一个指定锻炼 ID 的路由参数。在这种情况下，我们将 `id` 参数设置为锻炼名称。根据我们在上一章对路由的讨论，我们知道我们也可以将相同类型的
    URL 作为路由链接的一部分构建，或者简单地将其输入浏览器以到达锻炼屏幕并编辑特定的锻炼。
- en: The other of the two routes ends with `/new`. Since this route does not have
    a `token` parameter, the router will simply pass the URL unmodified to the `WorkoutComponent`.
    The `WorkoutComponent` will then need to parse the incoming URL to identify that
    it should be creating a new component.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 两条路径中的另一条以 `/new` 结尾。由于此路径没有 `token` 参数，路由器将直接将未修改的 URL 传递给 `WorkoutComponent`。然后
    `WorkoutComponent` 需要解析传入的 URL 以识别它应该创建一个新的组件。
- en: Route guards
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由守卫
- en: But before the link takes the user to the `WorkoutComponent`, there is another
    step along the way that we need to consider. The possibility always exists that
    the ID that is passed in the URL for editing a workout could be incorrect or missing.
    In those cases, we do not want the component to load, but instead we want to have
    the user redirected to another page or back to where they came from.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 但在链接将用户带到 `WorkoutComponent` 之前，还有另一个步骤需要我们考虑。始终存在一种可能性，即用于编辑锻炼的 URL 中传递的 ID
    可能是错误的或缺失的。在这些情况下，我们不希望组件加载，而是希望将用户重定向到另一个页面或返回他们来的地方。
- en: Angular offers a way to accomplish this result with **route guards**. As the
    name implies, route guards **provide a way to prevent navigation to a route**.
    A route guard can be used to inject custom logic that can do things such as check
    authorization, load data, and make other verifications to determine whether the
    navigation to the component needs to be canceled or not. And all of this is done
    before the component loads so it is never seen if the routing is canceled.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供了一种使用 **路由守卫** 来实现此结果的方法。正如其名所示，路由守卫 **提供了一种防止导航到路由** 的方式。路由守卫可以用来注入自定义逻辑，可以执行诸如检查授权、加载数据和进行其他验证以确定是否需要取消导航到组件等操作。而且所有这些都是在组件加载之前完成的，所以如果路由被取消，它永远不会被看到。
- en: Angular offers several route guards, including `CanActivate`, `CanActivateChild`,
    `CanDeActivate`, `Resolve`, and `CanLoad`**.** At this point, we are interested
    in the `Resolve` route guard**. **The `Resolve` guard will allow us not only to
    check for the existence of a workout, but also to load the data associated with
    a workout before loading the `WorkoutComponent`. The advantage of doing the latter
    is that we avoid the necessity of checking to make sure the data is loaded in
    the `WorkoutComponent` and it eliminates adding conditional logic throughout its
    component template to make sure that the data is there when it is rendered.  This
    will be especially useful when in the next chapter when we start using `observables`
    where we must wait for the observable to complete before we are guaranteed of
    having the data that it will provide. The `Resolve` guard will handle waiting
    for the observable to complete, which means that the `WorkoutComponent` will be
    guaranteed to have the data that it needs before it loads.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供了多个路由守卫，包括 `CanActivate`、`CanActivateChild`、`CanDeActivate`、`Resolve`
    和 `CanLoad`**.** 在这一点上，我们感兴趣的是 `Resolve` 路由守卫**. **`Resolve` 守卫将允许我们不仅检查是否存在一个锻炼项目，而且在加载
    `WorkoutComponent` 之前加载与该锻炼项目相关的数据。这样做的好处是，我们避免了在 `WorkoutComponent` 中检查数据是否已加载的必要性，并且消除了在其组件模板中添加条件逻辑以确保数据在渲染时存在的需求。 
    这在下一章我们将开始使用 `observables` 时将特别有用，我们必须等待可观察对象完成，才能确保获得它将提供的数据。`Resolve` 守卫将处理等待可观察对象完成，这意味着
    `WorkoutComponent` 在加载之前将确保拥有所需的数据。
- en: Implementing the resolve route guard
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现resolve路由守卫
- en: The `Resolve` guard allows us to prefetch the data for a workout. In our case,
    what we want to do is use `Resolve` to check the validity of any ID that is passed
    for an existing workout. Specifically, we will run a check on that ID by making
    a call to the `WorkoutBuilderService` to retrieve the Workout Plan and see if
    it exists. If it exists, we will load the data associated with the Workout Plan
    so that it is available to the `WorkoutComponent`; if not we will redirect back
    to the Workouts screen.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resolve` 守卫允许我们预取一个锻炼项目的数据。在我们的情况下，我们想要做的是使用 `Resolve` 来检查传递给现有锻炼项目的任何 ID
    的有效性。具体来说，我们将通过调用 `WorkoutBuilderService` 来运行对该 ID 的检查，以检索锻炼计划并查看它是否存在。如果存在，我们将加载与锻炼计划相关的数据，以便它对
    `WorkoutComponent` 可用；如果不存在，我们将重定向回锻炼项目屏幕。'
- en: 'Copy `workout.resolver.ts` from the `workout-builder/workout` folder under
    `trainer/src/app/workout` in `checkpoint 4.5` and you will see the following code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `workout.resolver.ts` 从 `trainer/src/app/workout` 下的 `workout-builder/workout`
    文件夹复制到 `checkpoint 4.5`，你将看到以下代码：
- en: '[PRE32]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, the `WorkoutResolver` is an injectable class that implements
    the `Resolve` interface.  The code injects the `WorkoutBuilderService` and `Router`
    into the class and implements the interface with the `resolve` method. The `resolve`
    method accepts two parameters; `ActivatedRouteSnapshot` and `RouterStateSnapshot`.
    In this case, we are only interested in the first of these two parameters, `ActivatedRouteSnapshot`. 
    It contains a `paramMap` from which we extract the ID parameter for the route.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`WorkoutResolver` 是一个可注入的类，它实现了 `Resolve` 接口。  代码将 `WorkoutBuilderService`
    和 `Router` 注入到类中，并通过 `resolve` 方法实现接口。`resolve` 方法接受两个参数；`ActivatedRouteSnapshot`
    和 `RouterStateSnapshot`。在这种情况下，我们只对这两个参数中的第一个感兴趣，即 `ActivatedRouteSnapshot`。它包含一个
    `paramMap`，从中我们提取出路由的 ID 参数。
- en: The `resolve` method then calls the `startBuilding` method of `WorkoutBuildingService` using
    the parameter supplied in the route. If the workout exists, then `resolve` returns
    the data and the navigation proceeds; if not, it re-routes the user to the workouts
    page and returns false. If `new` is passed as an ID, `WorkoutBuilderService` will
    load a new workout and the `Resolve` guard will allow navigation to proceed to
    the `WorkoutComponent`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`resolve`方法使用路由中提供的参数调用`WorkoutBuildingService`的`startBuilding`方法。如果工作存在，则`resolve`返回数据并继续导航；如果不存在，它将用户重定向到工作页面并返回false。如果传递`new`作为ID，`WorkoutBuilderService`将加载一个新的工作，并且`Resolve`守卫将允许导航继续到`WorkoutComponent`。
- en: The `resolve` method can return a `Promise` , an `Observable,` or a synchronous
    value. If we return an `Observable`,  we will need to make sure that the `Observable`
    completes before proceeding with navigation. In this case, however, we are making
    a synchronous call to a local in-memory data store, so we are just returning a
    value.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolve`方法可以返回一个`Promise`、一个`Observable`或同步值。如果我们返回一个`Observable`，我们需要确保在导航之前`Observable`已经完成。然而，在这种情况下，我们正在对本地内存数据存储进行同步调用，所以我们只是返回一个值。'
- en: 'To complete the implementation of the `WorkoutResolver`, first make sure to
    import and add it to `WorkoutBuilderModule` as a provider:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成`WorkoutResolver`的实现，首先确保将其导入并作为提供者添加到`WorkoutBuilderModule`中：
- en: '[PRE33]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, add it to the route configuration for `WorkoutComponent` by updating `workout-builder-routing.module.ts`
    as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过更新`workout-builder-routing.module.ts`将其添加到`WorkoutComponent`的路由配置中，如下所示：
- en: '[PRE34]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, we add `WorkoutResolver` to the routing module''s imports.
    Then, we add `resolve { workout: WorkoutResolver }` to the end of the route configuration
    for `workout/new` and `workout/:id` . This instructs the router to use the `WorkoutResolver` resolve
    method and assign its return value to `workout` in the route''s data. This configuration
    means that `WorkoutResolver` will be called prior to the router navigating to `WorkoutComponent`
    and that the workout data will be available to the `WorkoutComponent` when it
    loads. We''ll see how to extract this data in the `WorkoutComponent` in the next
    section.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，我们将`WorkoutResolver`添加到路由模块的导入中。然后，我们将`resolve { workout: WorkoutResolver
    }`添加到`workout/new`和`workout/:id`路由配置的末尾。这指示路由器使用`WorkoutResolver`的解析方法，并将返回值分配给路由数据中的`workout`。这种配置意味着在路由器导航到`WorkoutComponent`之前，`WorkoutResolver`将被调用，并且当`WorkoutComponent`加载时，工作数据将可用。我们将在下一节中看到如何在`WorkoutComponent`中提取这些数据。'
- en: Implementing the Workout component continued...
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Workout组件继续...
- en: Now that we have established the routing that takes us to the `Workout` component,
    let's turn to completing its implementation. So, copy the `workout.component.ts`
    file from the `workout-builder/workout` folder under `trainer/src/app` in `checkpoint
    4.5`. (Also, copy `workout-builder.module.ts` from the `workout-builder` folder.
    We'll discuss the changes in this file a little later when we get to Angular forms.)
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了通往`Workout`组件的路由，让我们转向完成其实现。因此，从`trainer/src/app`下的`workout-builder/workout`文件夹中的`checkpoint
    4.5`复制`workout.component.ts`文件。（同时，从`workout-builder`文件夹复制`workout-builder.module.ts`。我们将在讨论Angular表单时稍后讨论该文件中的更改。）
- en: 'Open `workout.component.ts` and you''ll see that we have added a constructor
    that injects `ActivatedRoute` and `WorkoutBuilderService`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`workout.component.ts`，你会看到我们添加了一个构造函数，该构造函数注入了`ActivatedRoute`和`WorkoutBuilderService`：
- en: '[PRE35]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In addition, we have added the following `ngOnInit` method:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还添加了以下`ngOnInit`方法：
- en: '[PRE36]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The method subscribes to the `route` and extracts the `workout` from the `route.data`.
    There is no need to check the workout exists because we have already done that
    in the `WorkoutResolver`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法订阅了`route`并从`route.data`中提取了`workout`。没有必要检查工作是否存在，因为我们已经在`WorkoutResolver`中做了这个检查。
- en: We are subscribing to the `route.data` because as an `ActivatedRoute`, the `route`
    exposes its `data` as an  `Observable`, which can change during the lifetime of
    the component. This gives us the ability to reuse the same component instance
    with different parameters, even though the `OnInit` life cycle event for that
    component is called only once. We'll cover `Observables` in detail in the next
    chapter.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们订阅了`route.data`，因为作为一个`ActivatedRoute`，`route`将其`data`暴露为一个`Observable`，它可以在组件的生命周期内发生变化。这使我们能够使用相同的组件实例以不同的参数重用，尽管该组件的`OnInit`生命周期事件只被调用一次。我们将在下一章中详细介绍`Observables`。
- en: In addition to this code, we have also added a series of methods to the `Workout
    Component` for adding, removing,  and moving a workout. These methods all call
    corresponding methods on the `WorkoutBuilderService` and we will not review them
    in detail here. We've also added an array of `durations` for populating the duration
    drop-down list.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这段代码，我们还向`Workout组件`添加了一系列方法，用于添加、删除和移动锻炼。这些方法都调用了`WorkoutBuilderService`上的相应方法，我们在这里不会详细审查它们。我们还添加了一个`durations`数组，用于填充持续时间下拉列表。
- en: For now, this is enough for the **component** class implementation. Let's update
    the associated `Workout` template.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这已经足够用于**组件**类的实现了。让我们更新相关的`Workout`模板。
- en: Implementing the Workout template
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Workout模板
- en: Now, copy the `workout.component.html` files from the `workout-builder/workout`
    folder under `trainer/src/app` in `checkpoint 4.5`. Run the app, navigate to `/builder/workouts`,
    and double-click on the *7 Minute Workout* tile. This should load the *7 Minute
    Workout* details with a view similar to the one shown at the start of the *Building
    a workout* section.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从`trainer/src/app`下的`workout-builder/workout`文件夹中的`checkpoint 4.5`复制`workout.component.html`文件。运行应用程序，导航到`/builder/workouts`，然后双击*7分钟锻炼*磁贴。这应该会加载*7分钟锻炼*的详细信息，视图类似于*构建锻炼*部分开始时所示。
- en: 'In the event of any problem, you can refer to the `checkpoint4.5` code in the
    `GitHub repository: Branch: checkpoint4.5` (folder - `trainer`).'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何问题，您可以参考`GitHub仓库`中的`checkpoint4.5`代码：分支：`checkpoint4.5`（文件夹 - `trainer`）。
- en: We will be dedicating a lot of time to this view, so let's understand some specifics
    here.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个视图中投入大量时间，所以让我们了解一些具体细节。
- en: 'The exercise list div (`id="exercise-list"`) lists the exercises that are part
    of the workout in order. We display them as top-to-bottom tiles in the left part
    of the content area. Functionally, this template has:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 练习列表div（`id="exercise-list"`）按顺序列出构成锻炼的练习。我们在内容区域的左侧以自上而下的磁贴形式显示它们。从功能上讲，这个模板具有：
- en: The Delete button to delete the exercise
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除按钮用于删除练习
- en: Reorder buttons to move the exercise up and down the list, as well as to the
    top and bottom
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重排按钮用于将练习在列表中上下移动，以及移动到顶部和底部
- en: 'We use `ngFor` to iterate over the list of exercises and display them:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ngFor`遍历练习列表并显示它们：
- en: '[PRE37]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You will notice that we are using the `*` asterisk in front of `ngFor`,  which
    is shorthand for the `<template>` tag. We are also using `let` to set two local
    variables: `exerisePlan` to identify an item in the list of exercises and `i`
    to set up an index value that we will use to show a number for the exercises as
    they are displayed on the screen. We will also use the index value to manage reordering
    and deleting exercises from the list.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们在`ngFor`前面使用了`*`星号，它是`<template>`标签的简写。我们还使用`let`设置两个局部变量：`exerisePlan`用于识别练习列表中的一个条目，`i`用于设置一个索引值，我们将使用这个索引值来显示屏幕上显示的练习编号。我们还将使用索引值来管理列表中的重排和删除练习。
- en: The second div element for workout data (`id="workout-data"`) contains the HTML
    input element for details such as name, title, and rest duration, and a button
    to save workout changes.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个div元素用于锻炼数据（`id="workout-data"`），其中包含HTML输入元素，用于详细说明名称、标题和休息持续时间，以及一个保存锻炼更改的按钮。
- en: The complete list has been wrapped inside the HTML form element so that we can
    make use of the form-related capabilities that Angular provides. So, what are
    these capabilities?
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的列表被包裹在HTML表单元素中，这样我们就可以利用Angular提供的表单相关功能。那么，这些功能是什么呢？
- en: Angular forms
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular表单
- en: Forms are such an integral part of HTML development that any framework that
    targets client-side development just cannot ignore them. Angular provides a small
    but well-defined set of constructs that make standard form-based operations easier.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是HTML开发的一个基本组成部分，任何针对客户端开发的框架都无法忽视它们。Angular提供了一组小型但定义良好的结构，使得标准表单操作更加容易。
- en: 'If we think carefully, any form of interaction boils down to:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细思考，任何形式的交互都可以归结为：
- en: Allowing user inputs
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户输入
- en: Validating those inputs against business rules
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证这些输入是否符合业务规则
- en: Submitting the data to the backend server
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据提交到后端服务器
- en: Angular has something to offer for all the preceding use cases.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Angular为所有上述用例都提供了解决方案。
- en: For user input, it allows us to create two-way bindings between the form input
    elements and the underlying model, hence avoiding any boilerplate code that we
    may have to write for model input synchronization.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户输入，它允许我们在表单输入元素和底层模型之间创建双向绑定，从而避免编写任何可能需要的模型输入同步的样板代码。
- en: It also provides constructs to validate the input before it can be submitted.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了在提交之前验证输入的结构。
- en: Lastly, Angular provides HTTP services for client-server interaction and persisting
    data to the server. We'll cover those services in Chapter 5, *Supporting Server
    Data Persistence*.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Angular提供了客户端-服务器交互和将数据持久化到服务器的HTTP服务。我们将在第5章“支持服务器数据持久性”中介绍这些服务。
- en: Since the first two use cases are our main focus in this chapter, let's learn
    more about Angular user input and data validation support.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前两个用例是本章的主要关注点，让我们更多地了解Angular用户输入和数据验证支持。
- en: Template-driven and reactive forms
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板驱动和响应式表单
- en: 'Angular offers two types of forms: **template-driven** and **reactive**. We''ll
    be discussing both types of form in this chapter. Because the Angular team indicates
    that many of us will primarily use **template-driven forms**, that is what we
    will start with in this chapter.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了两种表单类型：**模板驱动**和**响应式**。在本章中，我们将讨论这两种表单类型。因为Angular团队指出，我们中的许多人将主要使用**模板驱动表单**，所以我们将从本章开始介绍这种类型。
- en: Template-driven forms
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板驱动表单
- en: As the name suggests, **template-driven forms** place the emphasis on developing
    a form within an HTML template and handling most of the logic for the form inputs,
    data validation, saving, and updating in-form directives placed within that template.
    The result is that very little form-related code is required in the component
    class that is associated with the form's template.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，**模板驱动表单**强调在HTML模板中开发表单，并在该模板内处理表单输入、数据验证、保存和更新的大部分逻辑。结果是，与表单模板关联的组件类中几乎不需要任何与表单相关的代码。
- en: '**Template-driven forms** make heavy use of the `ngModel` form directive. We
    will be discussing it in the next sections. It provides two-way data binding for
    form controls, which is a nice feature indeed. It allows us to write much less
    boilerplate code to implement a form. It also helps us to manage the state of
    the form (such as whether the form controls have changed and whether these changes
    have been saved). And, it also gives us the ability to easily construct messages
    that display if the validation requirements for a form control have not been met
    (for example, a required field not provided, email not in the right format, and
    so on).'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板驱动表单**大量使用`ngModel`表单指令。我们将在下一节中讨论它。它为表单控件提供双向数据绑定，这确实是一个很好的功能。它允许我们编写更少的样板代码来实现表单。它还帮助我们管理表单的状态（例如，表单控件是否已更改以及这些更改是否已保存）。此外，它还使我们能够轻松构建显示在表单控件验证要求未满足时的消息（例如，必填字段未提供，电子邮件格式不正确等）。'
- en: Getting started
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'In order to use Angular forms in our `Workout` component, we must first add
    some additional configuration. Open  `workout-buider.module.ts` from the `workout-builder`
    folder under `trainer/src/app` in `checkpoint 4.5`. You will see that it imports
    `FormsModule`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的`Workout`组件中使用Angular表单，我们必须首先添加一些额外的配置。打开`workout-buider.module.ts`文件，该文件位于`trainer/src/app`下的`workout-builder`文件夹中，在`checkpoint
    4.5`中。你会看到它导入了`FormsModule`：
- en: '[PRE38]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This brings in all that we will need to implement our form, including:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包括我们实现表单所需的所有内容，包括：
- en: '`NgForm`'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NgForm`'
- en: '`ngModel`'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngModel`'
- en: Let's start using these to build our form.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用这些来构建我们的表单。
- en: Using NgForm
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NgForm
- en: 'In our template (`workout.component.html`), we have added the following `form`
    tag:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模板（`workout.component.html`）中，我们添加了以下`form`标签：
- en: '[PRE39]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let's take a look at what we have here. One interesting thing is that we are
    still using a standard `<form>` tag and not a special Angular tag. We've also
    used `#` to define a local variable `f` to which we have assigned `ngForm`. Creating
    this local variable provides us with the convenience of being able to use it for
    form-related activity in other places within the form. For example, you can see
    that we are using it at the end of the opening `form` tag in a parameter, `f.form`,
    which is being passed to the `onSubmit` event bound to `(ngSubmit)`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这里有什么。一个有趣的事情是我们仍在使用标准的 `<form>` 标签，而不是特殊的 Angular 标签。我们还使用了 `#` 来定义一个局部变量
    `f`，并将其分配给 `ngForm`。创建这个局部变量为我们提供了便利，可以在表单的其他地方使用它来进行与表单相关的活动。例如，你可以看到我们在打开 `form`
    标签的末尾使用它，作为一个参数 `f.form`，它被传递到绑定到 `(ngSubmit)` 事件的 `onSubmit` 事件中。
- en: That last binding to `(ngSubmit)` should tell us that something different is
    going on here. Even though we did not explicitly add the `NgForm` directive, our
    `<form>` now has additional events such as `ngSubmit` to which we can bind actions.
    How did this happen? Well, this was not triggered by our assigning `ngForm` to
    a local variable. Instead, it happened *auto-magically* because we imported the
    forms module into `workout-builder.module.ts`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 最后绑定到 `(ngSubmit)` 应该告诉我们这里正在发生一些不同的事情。尽管我们没有明确添加 `NgForm` 指令，但我们的 `<form>`
    现在有了额外的 `ngSubmit` 等事件，我们可以绑定操作。这是怎么发生的呢？嗯，这并不是因为我们将 `ngForm` 分配给一个局部变量而触发的。相反，它是因为我们自动地将表单模块导入到
    `workout-builder.module.ts` 中。
- en: With that import in place, Angular scanned our template for a `<form>` tag and
    wrapped that `<form>` tag within an `NgForm` directive. The Angular documentation
    indicates that `<form>` elements in the component will be upgraded to use the
    Angular form system. This is important because it means that various capabilities
    of  `NgForm` are now available to use with the form. These include the `ngSubmit`
    event, which signals when a user has triggered a form submission and provides
    the ability to validate the entire form before submitting it.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好这个导入之后，Angular 检查了我们的模板中的 `<form>` 标签，并将其包裹在 `NgForm` 指令中。Angular 文档指出，组件中的
    `<form>` 元素将被升级以使用 Angular 表单系统。这很重要，因为它意味着 `NgForm` 的各种功能现在都可以与表单一起使用。这包括 `ngSubmit`
    事件，它表示用户已触发表单提交，并提供在提交之前验证整个表单的能力。
- en: ngModel
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ngModel
- en: One of the fundamental building blocks for template-driven forms is `ngModel`,
    and you will find it being used throughout our form. One of the primary roles
    of `ngModel` is to support two-way binding between user input and an underlying
    model. With such a setup, changes in the model are reflected in the view, and
    updates to the view too are reflected back on the model. Most of the other directives
    that we have covered so far only support one-way binding from models to views.
    `ngModel` goes both ways. But, be aware that it is only available within `NgForm`
    for use with elements that allow user input.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 模板驱动的表单的一个基本构建块是 `ngModel`，你会在我们的整个表单中找到它的使用。`ngModel` 的一个主要作用是支持用户输入和底层模型之间的双向绑定。在这种设置下，模型的变化会在视图中反映出来，视图的更新也会反映回模型。我们之前提到的其他大多数指令只支持从模型到视图的单向绑定。`ngModel`
    是双向的。但是，请注意，它仅在 `NgForm` 内部可用，用于允许用户输入的元素。
- en: 'As you know, we already have a model that we are using for the Workout page,
    `WorkoutPlan`. Here is the `WorkoutPlan` model from `model.ts`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，我们已经有了一个用于 Workout 页面的模型，`WorkoutPlan`。以下是来自 `model.ts` 的 `WorkoutPlan`
    模型：
- en: '[PRE40]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note the use of the `?` after `description`. This means that it is an optional
    property in our model and is not required to create a `WorkoutPlan`. In our form,
    this will mean that we will not require that a description be entered and everything
    will work fine without it.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 `description` 后面使用的 `?`。这意味着它是我们模型中的一个可选属性，并且不是创建 `WorkoutPlan` 所必需的。在我们的表单中，这意味着我们不需要输入描述，并且即使没有它，一切也会正常工作。
- en: 'Within the `WorkoutPlan` model, we also have a reference to an array made up
    of instances of another type of model: `ExercisePlan`. `ExercisePlan` in turn
    is made up of a number (`duration`) and another model (`Exercise`), which looks
    like this:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `WorkoutPlan` 模型中，我们还有一个指向由另一种类型模型的实例组成的数组的引用：`ExercisePlan`。`ExercisePlan`
    又由一个数字（`duration`）和另一个模型（`Exercise`）组成，看起来像这样：
- en: '[PRE41]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The use of these nested classes shows that we can create complex hierarchies
    of models that can all be data-bound within our form using `NgModel`. So throughout
    the form, whenever we need to update one of the values in a `WorkoutPlan` or an
    `ExercisePlan`, we can use `NgModel` to do that (the `WorkoutPlan` model will
    be represented by a local variable named `workout` in the following examples).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Using ngModel with input and textarea
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open `workout-component.html` and look for `ngModel.` It has been applied to
    form elements that allow user data input. These include input, textarea, and select.
    The workout name input setup looks like this:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding `[(ngModel)]` directive sets up a two-way binding between the
    input control and the `workout.name` model property. The brackets and parentheses
    should each look familiar. Previously, we used them separately from each other:
    the `[]` brackets for property binding and the `()` parentheses for event binding.
    In the latter case, we usually bound the event to a call to a method in the component
    associated with the template. You can see an example of this in the form with
    the button that a user clicks on to remove an exercise:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, the click event is explicitly bound to a method called `removeExercise`
    in our `Workout` component class. But for the `workout.name` input, we do not
    have an explicit binding to a method on the component. So what's going on here
    and how does the update happen without us calling a method on the component? The
    answer to that question is that the combination `[( )]` is shorthand for both
    binding a model property to the input element and wiring up an event that updates
    the model.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Put differently, if we reference a model element in our form, `ngModel` is smart
    enough to know that what we want to do is update that element (`workout.name`
    here) when a user enters or changes the data in the input field to which it is
    bound. Under the hood, Angular creates an update method similar to what we would
    otherwise have to write ourselves. Nice! This approach keeps us from having to
    write repetitive code to update our model.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Angular supports most of the HTML5 input types, including text, number, select,
    radio, and checkbox. This means binding between a model and any of these input
    types just works out of the box.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'The `textarea` element works the same as the input:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we bind `textarea` to `workout.description`. Under the hood, `ngModel`
    updates the workout description in our model with every change we type into the
    text area.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'To test out how this works, why don''t we verify this binding? Add a model
    interpolation expression at the end of any of the linked inputs, such as this
    one:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Open the Workout page, type something in the input, and see how the interpolation
    is updated instantaneously. The magic of two-way binding!
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
- en: Using ngModel with select
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at how `select` has been set up:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We are using `ngFor` here to bind to an array, `durations`, which is in the
    `Workout` component class. The array looks like this:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用 `ngFor` 来绑定到一个数组，`durations`，它位于 `Workout` 组件类中。数组看起来是这样的：
- en: '[PRE47]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `ngFor` component will loop over the array and populate the drop-down values
    with the corresponding values in the array with the title for each item being
    displayed using interpolation, `{{duration.title}}`. And `[(ngModel)]` then binds
    the drop-down selection to the `exercisePlan.duration` in the model.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor` 组件将遍历数组，并将数组中的对应值填充到下拉菜单中，每个项目的标题使用插值 `{{duration.title}}` 显示。然后 `[(ngModel)]`
    将下拉选择绑定到模型中的 `exercisePlan.duration`。'
- en: Notice here that we are binding to the nested model: `ExercisePlan`. And, we
    may have multiple exercises to which we will be applying this binding. With that
    being the case, we have to make use of another Angular form directive—`ngModelGroup`—to
    handle these bindings. `ngModelGroup` will allow us to create a nested group within
    our model that will contain the list of exercises included in the workout and
    then in turn loop over each exercise to bind its duration to the model.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里，我们正在绑定到嵌套的模型：`ExercisePlan`。并且，我们可能有多项练习需要应用此绑定。在这种情况下，我们必须使用另一个 Angular
    表单指令——`ngModelGroup`——来处理这些绑定。`ngModelGroup` 将允许我们在模型中创建一个嵌套组，该组将包含锻炼中包含的练习列表，然后依次遍历每个练习，将其持续时间绑定到模型上。
- en: 'To start with, we will add `ngModelGroup` to the div tag that we have created
    within the form to hold our list of exercises:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 `ngModelGroup` 添加到我们在表单中创建的 div 标签中，以保存我们的练习列表：
- en: '[PRE48]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'That takes care of creating the nested list of exercises. Now, we have to handle
    the individual exercises within that list, and we can do that by adding another
    `ngModelGroup` to the individual divs that contain each exercise:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就完成了创建嵌套的练习列表。现在，我们必须处理列表中的单个练习，我们可以通过为包含每个练习的单独 div 添加另一个 `ngModelGroup`
    来实现这一点：
- en: '[PRE49]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, we are using the index in our for loop to dynamically create an individual
    model group for each of our exercises. These model groups will be nested inside
    the first model group that we created. Temporarily, add the tag `<pre>{{ f.value
    | json }}</pre>` to the bottom of the form and you will be able to see the structure
    of this nested model:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用循环中的索引来动态为我们的每个练习创建一个单独的模型组。这些模型组将嵌套在我们最初创建的第一个模型组内部。暂时在表单底部添加标签 `<pre>{{
    f.value | json }}</pre>`，你将能够看到这个嵌套模型的结构：
- en: '[PRE50]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is powerful stuff that enables us to create complicated forms with nested
    models, all of which can use `ngModel` for databinding**.**
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种强大的功能，使我们能够创建具有嵌套模型的复杂表单，所有这些都可以使用 `ngModel` 进行数据绑定**。**
- en: You may have noticed a subtle difference in the two `ngModelGroup` directive
    tags we just introduced. The second of the two is wrapped in angle brackets, `[]`,
    while the first is not. This is because with the first tag we are just naming
    our model group, whereas with the second we are binding it dynamically to each
    exercise's div tag using the index of our for loop.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了我们刚刚引入的两个 `ngModelGroup` 指令标签之间的细微差别。第二个标签被括号 `<[]>` 包围，而第一个则不是。这是因为，在第一个标签中，我们只是命名我们的模型组，而在第二个标签中，我们使用循环的索引动态地将它绑定到每个练习的
    div 标签上。
- en: Like input, select too supports two-way binding. We saw how changing select
    updates a model, but the model-to-template binding may not be apparent. To verify
    that a model to a template binding works, open the *7 Minute Workout* app and
    verify the duration dropdowns. Each one has a value that is consistent with the
    model value (30 seconds).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 与输入类似，选择也支持双向绑定。我们看到了如何通过更改选择来更新模型，但模型到模板的绑定可能并不明显。为了验证模型到模板的绑定是否工作，请打开 *7 分钟健身*
    应用并验证持续时间下拉菜单。每个下拉菜单都有一个与模型值（30秒）一致的值。
- en: Angular does an awesome job of keeping the model and view in sync using `ngModel`.
    Change the model and see the view updated; change the view and watch as the model
    is updated instantaneously.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 使用 `ngModel` 做得非常好，能够保持模型和视图同步。更改模型，查看视图是否更新；更改视图，并观察模型是否立即更新。
- en: Now, let's add validation to our form.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们给我们的表单添加验证。
- en: 'The code for the next section is also available for everyone to download on
    GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: `GitHub Branch: checkpoint4.6` (folder—`trainer`). Or if you are not
    using Git, download the snapshot of Checkpoint 4.6 (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.6.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.6.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure and update the `styles.css` file, which we are not discussing here.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Angular validation
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the saying goes, *never trust user input*. Angular has support for validation,
    including the standard required, min, max, and pattern, as well as custom validators.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: ngModel
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ngModel` is the building block that we will use to implement validation. It
    does two things for us: it maintains the model state and provides a mechanism
    for identifying validation errors and displaying validation messages.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we need to assign `ngModel` to a local variable in all of our
    form controls that we will be validating. In each case, we need to use a unique
    name for this local variable. For example, for workout name we add `#name="ngModel"`
    within the `input` tag for that control along with the HTML 5 `required` attribute.
    The workout name `input` tag should now look like this:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Continue through the form, assigning `ngModel` to local variables for each of
    the inputs. Also, add the required attribute for all the required fields.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: The Angular model state
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever we use `NgForm`, every element within our form, including input, text
    area, and select, has some states defined on the associated model. `ngModel` tracks
    these states for us. The states tracked are:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '`pristine`: The value of this is `true` as long as the user does not interact
    with the input. Any update to the `input` field and `ng-pristine` is set to `false`.'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dirty`: This is the reverse of `ng-pristine`. This is `true` when the input
    data has been updated.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touched`: This is `true` if the control ever had focus.'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`untouched`: This is `true` if the control has never lost focus. This is just
    the reverse of `ng-touched`.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valid`: This is `true` if there are validations defined on the `input` element
    and none of them are failing.'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invalid`: This is `true` if any of the validations defined on the element
    are failing.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pristine``dirty` or `touched``untouched` are useful properties that can help
    us decide when error labels are shown.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Angular CSS classes
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the model state, Angular adds some CSS classes to an input element.
    These include the following:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '`ng-valid`: This is used if the model is valid'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-invalid`: This is used if the model is invalid'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-pristine`: This is used if the model is pristine'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-dirty`: This is used if the model is dirty'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-untouched`: This is used when the input is never visited'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-touched`: This is used when the input has focus'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To verify it, go back to the `workoutName` input tag and add a template reference
    variable named `spy` inside the `input` tag:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, below the tag, add the following label:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Reload the application and click on the New Workout link in the *Workout Builder*.
    Before touching anything on the screen, you will see the following displayed:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
- en: 'Add some content into the Name input box and tab away from it. The label changes
    to this:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
- en: What we are seeing here is Angular changing the CSS classes that apply to this
    control as the user interacts with it. You can also see these changes by inspecting
    the `input` element in the developer console.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'These CSS class transitions are tremendously useful if we want to apply visual
    clues to the element depending on its state. For example, look at this snippet:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This draws a red border around any input control that has invalid data.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: As you add more validations to the Workout page, you can observe (in the developer
    console) how these classes are added and removed as the user interacts with the
    `input` element.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of model states and how to use them, let's
    get back to our discussion of validations (before moving on, remove the variable
    name and label that you just added).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Workout validation
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The workout data needs to be validated for a number of conditions.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: After taking the step of adding the local variable references for `ngModel`
    and the required attribute to our `input` fields, we have been able to see how
    `ngModel` tracks changes in the state of these controls and how it toggles the
    CSS styles.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Displaying appropriate validation messages
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, the input needs to have a value; otherwise, the validation fails. But,
    how can we know if the validation has failed? `ngModel` comes to our rescue here.
    It can provide the validation state of the particular input. And that gives us
    what we need to display an appropriate validation message.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the input control for the Workout name. In order to get a
    validation message to display, we have to first modify the input tag to the following:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We have added a local variable called `#name` and assigned `ngModel` to it.
    This is called a template reference variable and we can use it with the following
    label to display a validation message for the input:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We are showing the validation message in the event that the name is not provided
    and the control has been touched. To check the first condition, we retrieve the
    `hasError` property of the control and see if the error type is `required`. We
    check to see if the name input has been `touched` because we do not want the message
    to display when the form first loads for a new workout.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that we are using a somewhat more verbose style to identify
    validation errors than is required in this situation. Instead of `name.control.hasError('required')`,
    we could have used `!name. valid` and it would have worked perfectly fine. However,
    using the more verbose approach allows us to identify validation errors with greater
    specificity, which will be essential when we start adding multiple validators
    to our form controls. We'll look at using multiple validators a little later in
    this chapter. For consistency, we'll stick with the more verbose approach.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the new Workout page (`/builder/workouts/new`) now. Enter a value in the
    name input box and then delete it. The error label appears as shown in the following
    screenshot:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
- en: Adding more validation
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular provides several out-of-the-box validators, including:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '`required`'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minLength`'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxLength`'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pattern`'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the complete list of out-of-the box validators, see the documentation for
    the `Validators` class at [https://angular.io/api/forms/Validators.](https://angular.io/api/forms/Validators)
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen how the `required` validator works. Now, let''s look at two of
    the other out-of-the-box validators: `minLength` and `maxLength`. In addition
    to making it required, we want the title of the workout to be between 5 and 20
    characters (we''ll look at the `pattern` validator a little later in this chapter).'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in addition to the `required` attribute we added previously to the title
    input box, we will add the `minLength` attribute and set it to `5`, and add the
    `maxLength` attribute and set it to `20`, like so:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, we add another label with a message that will display when this validation
    is not met:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Managing multiple validation messages
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll see that the conditions for displaying the message now test for the
    length not being zero. This prevents the message from displaying in the event
    that the control is touched but left empty. In that case, the title required message
    should display. This message only displays if nothing is entered in the field
    and we accomplish this by checking explicitly to see if the control''s `hasError`
    type is `required`:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Since we are attaching two validators to this input field, we can consolidate
    the check for the input being touched by wrapping both validators in a div tag
    that checks for that condition being met:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: What we just did shows how we can attach multiple validations to a single input
    control and also display the appropriate message in the event that one of the
    validation conditions is not met. However, it's pretty clear that this approach
    will not scale for more complicated scenarios. Some inputs contain a lot of validations
    and controlling when a validation message shows up can become complex. As the
    expressions for handling the various displays get more complicated, we may want
    to refactor and move them into a custom directive. Creating a custom directive
    will be covered in detail in Chapter 6, *Angular 2 Directives in Depth*.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Custom validation messages for an exercise
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A workout without any exercise is of no use. There should at least be one exercise
    in the workout and we should validate this restriction.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: The problem with exercise count validation is that it is not something that
    the user inputs directly and the framework validates. Nonetheless, we still want
    a mechanism to validate the exercise count in a manner similar to other validations
    on this form.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: 'What we will do is add a hidden input box to the form that contains the count
    of the exercises. We will then bind this to `ngModel` and add a pattern validator
    that will check to make sure that there is more than one exercise. We will set
    the value of the input box to the count of the exercises:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we will attach a validation message to it similar to what we just did
    with our other validators:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We are not using `ngModel` in its true sense here. There is no two-way binding
    involved. We are only interested in using it to do custom validation.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the new Workout page, add an exercise, and remove it; we should see this
    error:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  id: totrans-498
  prefs: []
  type: TYPE_IMG
- en: What we did here could have been easily done without involving any model validation
    infrastructure. But, by hooking our validation into that infrastructure, we do
    derive some benefits. We can now determine errors with a specific model and errors
    with the overall form in a consistent and familiar manner. Most importantly, if
    our validation fails here, the entire form will be invalidated.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: Implementing custom validation the way we just did is not what you would want
    to do very often. Instead, it will usually make more sense to implement this kind
    of complicated logic inside a custom directive. We'll cover creating custom directives
    in detail in Chapter 6, *Angular 2 Directives in Depth*.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: One nuisance with our newly implemented `Exercise Count` validation is that
    it shows when the screen for a new `Workout` first appears. With this message,
    we are not able to use `ng-touched` to hide the display. This is because the exercises
    are being added programmatically and the hidden input we are using to track their
    count never changes from untouched as exercises are added or removed.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this problem, we need an additional value to check when the state of
    the exercise list has been reduced to zero, except when the form is first loaded.
    The only way that situation can happen is if the user adds and then removes exercises
    from a workout to the point that there are no more exercises. So, we''ll add another
    property to our component that we can use to track whether the remove method has
    been called. We call that value `removeTouched` and set its initial value to `false`:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, in the remove method we will set that value to `true`:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we will add `removeTouched` to our validation message conditions, like
    so:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now, when we open a new workout screen, the validation message will not display.
    But if the user adds and then removes all the exercises, then it will display.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: To understand how model validation rolls up into form validation, we need to
    understand what form-level validation has to offer. However, even before that,
    we need to implement saving the workout and calling it from the workout form.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Saving the workout
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The workout that we are building needs to be persisted (in-memory only). The
    first thing that we need to do is extend `WorkoutService` and `WorkoutBuilderService`.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutService` needs two new methods, `addWorkout` and `updateWorkout`:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `addWorkout` method does a basic check on the workout name and then pushes
    the workout into the workout array. Since there is no backing store involved,
    if we refresh the page, the data is lost. We will fix this in the next chapter
    where we persist the data to a server.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: The `updateWorkout` method looks for a workout with the same name in the existing
    workouts array and if found, updates and replaces it.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: 'We only add one save method to `WorkoutBuilderService` as we are already tracking
    the context in which workout construction is going on:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `save` method calls either `addWorkout` or `updateWorkout` in the `Workout`
    service based on whether a new workout is being created or an existing one is
    being edited.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: From a service perspective, that should be enough. Time to integrate the ability
    to save workouts into the `Workout` component and learn more about the form directive!
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at `NgForm` in more detail, let''s add the save method to `Workout`
    to save the workout when the `Save` button is clicked on. Add this code to the
    `Workout` component:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We check the validation state of the form using its invalid property and then
    call the `WorkoutBuilderService.save` method if the form state is valid.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: More on NgForm
  id: totrans-523
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms in Angular have a different role to play as compared to traditional forms
    that post data to the server. If we go back and look again at the form tag, we
    will see that it is missing the standard action attribute. The standard form behavior
    of posting data to the server using full-page post-back does not make sense with
    an SPA framework such as Angular. In Angular, all server requests are made through
    asynchronous invocations originating from directives or services.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, Angular is also turning off the browser's inbuilt validation.
    As you have seen in this chapter, we are still using validation attributes such
    as `required` that look the same as native HTML validation attributes. However,
    as the Angular documentation explains, inside an Angular form "Angular uses directives
    to match these attributes with validator functions in the framework." See  [https://angular.io/guide/form-validation#template-driven-validation](https://angular.io/guide/form-validation#template-driven-validation).
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: 'The form here plays a different role. When the form encapsulates a set of input
    elements (such as input, textarea, and select) it provides an API for:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: Determining the state of the form, such as whether the form is dirty or pristine
    based on the input controls on it
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking validation errors at the form or control level
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you still want the standard form behavior, you can add an `ngNoForm` attribute
    to the `form` element, but this will definitely cause a full-page refresh. You
    can also turn on the browser's inbuilt validation by adding the `ngNativeValidate`
    attribute. We'll explore the specifics of the `NgForm` API a little later in this
    chapter when we look at saving the form and implementing validation.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: The state of the `FormControl` objects within the form is being monitored by
    `NgForm`. If any of them are invalid, then `NgForm` sets the entire form to invalid.
    In this case, we have been able to use `NgForm` to determine that one or more
    of the `FormControl` objects is invalid and therefore the state of the form as
    a whole is invalid too.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at one more issue before we finish this chapter.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the saving of forms and validation messages
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a new Workout page and directly click on the Save button. Nothing is saved
    as the form is invalid, but validations on individual form input do not show up
    at all. It now becomes difficult to know what elements have caused validation
    failure. The reason behind this behavior is pretty obvious. If we look at the
    error message binding for the name input element, it looks like this:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Remember that, earlier in the chapter, we explicitly disabled showing validation
    messages until the user has touched the input control. The same issue has come
    back to bite us and we need to fix it now.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not have a way to explicitly change the touched state of our controls
    to untouched. Instead, we will resort to a little trickery to get the job done.
    We''ll introduce a new property called `submitted`. Add it at the top of the `Workout`
    class definition and set its initial value to `false`, like so:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The variable will be set to `true` on the Save button click. Update the save
    implementation by adding the highlighted code:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'However, how does this help? Well, there is another part to this fix that requires
    us to change the error message for each of the controls we are validating. The
    expression now changes to:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: With this fix, the error message is shown when the control is touched or the
    form submit button is pressed (`submitted` is `true`). This expression fix now
    has to be applied to every validation message where a check appears.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now open the new Workout page and click on the Save button, we should
    see all validation messages on the input controls:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
- en: Reactive forms
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other type of form that Angular supports is called **reactive** forms. **Reactive
    forms** start with a model that is constructed in a component class. With this
    approach, we use the **form builder API** to create a form in code and associate
    it with a model.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: Given the minimal code we have to write to get template-driven forms working,
    why and when should we consider using reactive forms? There are several situations
    in which we might want to use them. These include cases where we want to take
    programmatic control of creating the form. This is especially beneficial, as we
    will see, when we are trying to create form controls dynamically based on data
    we are retrieving from the server.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: If our validation gets complicated, it is often easier to handle it in code.
    Using reactive forms, we can keep this complicated logic out of the HTML template,
    making the template syntax simpler.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: Another significant advantage of reactive forms is that they make unit-testing
    the form possible, which is not the case with **template-driven forms.** We can
    simply instantiate our form controls in our tests and then test them outside the
    markup on our page.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '**Reactive forms** use three new form directives that we haven''t discussed
    before: `FormGroup`, `FormControl`, and `FormArray`. These directives allow the
    form object that is constructed in code to be tied directly to the HTML markup
    in the template. The form controls that are created in the component class are
    then directly available in the form itself. Technically speaking, this means that
    we don''t need to use `ngModel` (which is integral to template-driven forms) with
    reactive forms (although it can be used). The overall approach is a cleaner and
    less cluttered template with more focus on the code that drives the form. Let''s
    get started with building a reactive form.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with reactive forms
  id: totrans-551
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll make use of reactive forms to build the form to add and edit Exercises.
    Among other things, this form will allow the user to add links to exercise videos
    on YouTube. And since they can add any number of video links, we will need to
    be able to add controls for these video links dynamically. This challenge will
    present a good test of how effective reactive forms can be in developing more
    complex forms. Here is how the form will look:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  id: totrans-553
  prefs: []
  type: TYPE_IMG
- en: 'To get started, open `workout-builder.module.ts` and add the following `import`:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`ReactiveFormsModule` contains what we will need to build reactive forms.'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, copy `exercise-builder-service.ts` from the `workout-builder/builder-services`
    folder under `trainer/src/app` in `checkpoint 4.6` and import it into `workout-builder.module.ts`:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, add it as an additional provider to the providers array in that same
    file:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You will notice here that we also have added `ExerciseResolver` as a provider.
    We won't be covering that here, but you should copy it from the `exercise` folder
    as well and also copy the updated `workout-builder-routing.module.ts`, which adds
    it as a route guard for the navigation to `ExerciseComponent`.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open `exercise.component.ts` and add the following import statement:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This brings in the following, which we will use to construct our form:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '`FormBuilder`'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormGroup`'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormControl`'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormArray`'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we inject `FormBuilder` (as well as `Router`, `ActivatedRoute`, and
    `ExerciseBuilderService`) into the constructor of our class:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: With these preliminary steps out of the way, we can now go ahead and start building
    out our form.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: Using the FormBuilder API
  id: totrans-572
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `FormBuilder` API is the foundation for reactive forms. You can think of
    it as a factory for turning out the forms we are constructing in our code. Go
    ahead and add the `ngOnInit` life cycle hook to your class, as follows:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: When `ngOnInit` fires, it will extract the data for an existing or new `exercise`
    from the route data that has been retrieved and returned by `ExerciseResolver`.
    This is the same pattern we followed with initializing the `Workout` component.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the `buildExerciseForm` method by adding the following
    code:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Let''s examine this code. To start with, we are using the injected instance
    of `FormBuilder` to construct the form and assign it to a local variable, `exerciseForm`.
    Using `formBuilder.group`, we add several form controls to our form. We add each
    of them by a simple key/value mapping:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The left side of the mapping is the name of the `FormControl`, and the right
    is an array containing as its first element the value of the control (in our case,
    the corresponding element on our exercise model) and the second a validator (in
    this case, the out-of-the-box required validator). Nice and neat! It's definitely
    easier to see and reason about our form controls by setting them up outside the
    template.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: 'We can not only build up `FormControls` in our form this way, but also add
    `FormControlGroups` and `FormControlArray`, which contain `FormControls` within
    them. This means we can create complex forms that contain nested input controls.
    In our case, as we have mentioned, we are going to need to accommodate the possibility
    of our users adding multiple videos to an exercise. We can do this by adding the
    following code:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'What we are doing here is assigning a `FormArray` to videos, which means we
    can assign multiple controls in this mapping. To construct this new `FormArray`,
    we add the following `addVideoArray` method to our class:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This method constructs a `FormControl` for each video; each is then added each
    to a `FormArray` that is assigned to the videos control in our form.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: Adding the form model to our HTML view
  id: totrans-586
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been working behind the scenes in our class to construct our
    form. The next step is to wire up our form to the view. To do this, we use the
    same controls that we used to build the form in our code: `formGroup`, `formControl`,
    and `formArray`.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `exercise.component.html` and add a `form` tag as follows:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Within the tag, we are first assigning the `exerciseForm` that we just built
    in code to `formGroup`. This establishes the connection between our coded model
    and the form in the view. We also wire up the `ngSubmit` event to an `onSubmit`
    method in our code (we'll discuss this method a little later).
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: Adding form controls to our form inputs
  id: totrans-591
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we start constructing the inputs for our form. We''ll start with the
    input for the name of our exercise:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We assign the name of our coded form control to `formControlName`. This establishes
    the link between the control in our code and the `input` field in the markup.
    Another item of interest here is that we do not use the `required` attribute.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: Adding validation
  id: totrans-595
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing that we do is add a validation message to the control that will
    display in the event of a validation error:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Notice that this markup is very similar to what we used in template-driven forms
    for validation, except that the syntax for identifying the control is somewhat
    more verbose Again, it checks the state of the `hasError` property of the control
    to make sure it is valid.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait a minute! How can we validate this input? Haven''t we removed the
    required attribute from our tag? This is where the control mappings that we added
    in our code come into play. If you look back at the code for the form model, you
    can see the following mapping for the `name` control:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The second element in the mapping array assigns the required validator to the
    name form control. This means that we don't have to add anything to our template;
    instead, the form control itself is attached to the template with a required validator.
    The ability to add a validator in our code enables us to conveniently add validators
    outside our template. This is especially useful when it comes to writing custom
    validators with complex logic behind them.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: Adding dynamic form controls
  id: totrans-602
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, the Exercise form that we are building requires that
    we allow the user to add one or more videos to the exercise. Since we don''t know
    how many videos the user may want to add, we will have to build the `input` fields
    for these videos dynamically as the user clicks on the Add Video button. Here''s
    how it will look:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  id: totrans-604
  prefs: []
  type: TYPE_IMG
- en: We have already seen the code in our component class that we use to do this.
    Now, let's take a look at how it is implemented in our template.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: 'We first use `ngFor` to loop through our list of videos. Then, we assign the
    index in our videos to a local variable, `i`. No surprises so far:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Inside the loop, we do three things. First, we dynamically add a video `input` field
    for each of the videos currently in our exercise:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, we add a button to allow the user to delete a video:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We bind a `deleteVideo` method in our component class to the button's `click`
    event and pass to it the index of the video being deleted.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add a validation message for each of the video `input` fields:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The validation message follows the same pattern for displaying the message that
    we have used elsewhere in this chapter. We drill into the `exerciseFormControls`
    group to find the particular control by its index. Again, the syntax is verbose
    but easy enough to understand.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: Saving the form
  id: totrans-616
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final step in building out our reactive form is to handle saving the form.
    When we constructed the form tag earlier, we bound the `ngSubmit` event to the
    following `onSubmit` method in our code:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This method sets `submitted` to `true`, which will trigger the display of any
    validation messages that might have been previously hidden because the form had
    not been touched. It also returns without saving in the event that there are any
    validation errors on the form. If there are none, then it calls the following
    `mapFormValues` method, which assigns the values from our form to the `exercise`
    that will be saved:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: It then calls the save method in `ExerciseBuilderService` and routes the user
    back to the exercise list screen (remember that any new exercise will not display
    in that list because we have not yet implemented data persistence in our application).
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: We hope this makes it clear; reactive forms offer many advantages when we are
    trying to build more complicated forms. They allow programming logic to be removed
    from the template. They permit validators to be added to the form programmatically.
    And, they support building forms dynamically at runtime.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: Custom validators
  id: totrans-623
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we'll take a look at one more thing before we conclude this chapter. As
    anyone who has worked on building web forms (either in Angular or any other web
    technology) knows, we are often called on to create validations that are unique
    to the application we are building. Angular provides us with the flexibility to
    enhance our reactive form validation by building custom validators.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: In building our exercise form, we need to be sure about what is entered, as
    a name contains only alphanumeric characters and no spaces. This is because when
    we get to storing the exercises in a remote data store, we are going to use the
    name of the exercise as its key. So, in addition to the standard required field
    validator, let's build another validator that checks to make sure that the name
    entered is in alphanumeric form only.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a custom control is quite straightforward. In its simplest form, an
    Angular custom validator is a function that takes a control as an input parameter,
    runs the validation check, and returns true or false. So, let''s start by adding
    a TypeScript file with the name `alphanumeric-validator.ts`. In that file, first
    import `FormControl` from `@angular/forms`, then add the following class to that
    file:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The code follows the pattern for creating a validator that we just mentioned.
    The only thing that may be a little surprising is that it returns true when the
    validation fails! As long as you are clear on this one quirk, you should have
    no problem writing your own custom validator.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: Integrating a custom validator into our forms
  id: totrans-629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So how do we plug our custom validator into our form? If we are using reactive
    forms, the answer is pretty simple. We add it just like a built-in validator when
    we build our form in code. Let''s do that. Open `exercise.component.ts` and first
    add an import for our custom validator:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Then, modify the form builder code to add the validator to the `name` control:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Since the name control already has a required validator, we add `AlphaNumericValidator`
    as a second validator using an array that contains both validators. The array
    can be used to add any number of validators to a control.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to incorporate the appropriate validation message for the
    control into our template. Open `workout.component.html` and add the following
    label just below the label that displays the message for the required validator:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The exercise screen will now display a validation message if a non-alphanumeric
    value is entered in the name input box:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  id: totrans-638
  prefs: []
  type: TYPE_IMG
- en: As we hope you can see, reactive forms give us the ability to add custom validators
    to our forms in a straightforward manner that allows us to maintain the validation
    logic in our code and easily integrate it into our templates.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that in this chapter, we have not covered how to use custom
    validators in template-driven forms. That is because implementing them requires
    the additional step of building a custom directive. We'll cover that in Chapter
    6, *Angular 2 Directives in Depth*.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: Configuration options for running validation
  id: totrans-641
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on from validation, there is one more topic to cover and that
    is configuration options for running the validations. So far, we have been using
    the default option, which runs validation checks on every input event. However,
    you have the choice of configuring them to run either on "blur"(that is when the
    user leaves an input control) or when the form is submitted. You can set this
    configuration at the form level or on a control-by-control basis.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we might decide that to avoid the complexity of handling missing
    exercises in the workout form, we will set that form to validate only upon submit.
    We can set this by adding the following highlighted assignment of `NgFormOptions`
    to the form tag:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This instructs Angular to run our validations only upon `submit`. Try it and
    you’ll see that no validations appear when you make entries into the form. Leave
    the form blank and press the Save button, and you will see the validation messages
    appear. Taking this approach, of course, means that there are no visual cues to
    the user regarding validation until they press the Save button.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: There are also a couple of other unintended side effects to using this approach
    in our form. The first is that the title no longer updates at the top of the screen
    as we type into the title input box. That value will only be updated when we press
    Save. Second, you will also see a validation message appear if you add one or
    more workouts and then remove all of them. This is because of the special conditions
    we set up for this control, which cause it to fire outside the normal validation
    flow.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: 'So, maybe we should take a different approach. Angular provides the option
    of implementing more fine-grained control of the validation flow by allowing us
    to make such configurations at the control level using `ngModelOptions`. For example,
    let’s remove the `ngFormOptions` assignment from the form tag and modify the title
    input control to add `ngModelOptions` as follows:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You’ll then notice that as you type the title into the input box, it does not
    update the title on the screen until you move off it (which triggers the `updateOn`
    event):'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  id: totrans-650
  prefs: []
  type: TYPE_IMG
- en: As you will remember, the default option caused the title to update with every
    keystroke. This is a contrived example but it illustrates how the differences
    in these configurations work.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: 'You probably don’t see the need to use the on blur setting here. But, incase
    where you may be doing validation by calling an external data store, this approach
    could be helpful in limiting the number of calls that are being made. And making
    such remote calls is exactly what we will be doing in [Chapter 6](part0277.html#885BQ0-7edc9b1e1ea341adae33006323903887), *Angular
    Directives in Depth*, when we implement a custom directive. The directive will
    be checking for duplicate names that already exist in our remote data store. So,
    let’s remove this configuration from the title input control and place it instead
    on the name input control, like so:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We also can set the validation timing options within a reactive form. From
    what we have already learned about reactive forms, you will not be surprised to
    learn that we will be applying these settings in our code rather than the template.
    For example, to set them for a form group you use the following syntax:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We can also apply them to individual form controls and that is what we will
    do in the case of our exercise form. Like the workout form, we will want to be
    able to validate the uniqueness of the name by making a remote call. So, we will
    want to limit the validation checking in a similar manner. We’ll do that by adding
    the following to the code that creates the name form control:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Note that we are putting the setting, along with the `validators` array, in
    the options object inside a pair of curly braces.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-659
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a *Personal Trainer* app. The process of converting a specific *7
    Minute Workout* app to a generic *Personal Trainer* app helped us learn a number
    of new concepts.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter by defining the new app requirements. Then, we designed
    the model as a shared service.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: We defined some new views and corresponding routes for the *Personal Trainer*
    app. We also used both child and asynchronous routing to separate out *Workout
    Builder* from the rest of the app.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: We then turned our focus to workout building. One of the primary technological
    focuses in this chapter was on Angular forms. The *Workout Builder* employed a
    number of form input elements and we implemented a number of common form scenarios
    using both template-driven and reactive forms. We also explored Angular validation
    in depth, and implemented a custom validator. We also covered configuring the
    timing options for running validation.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is all about client-server interaction. The workouts and exercises
    that we create need to be persisted. In the next chapter, we build a persistence
    layer, which will allow us to save workout and exercise data on the server.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: Before we conclude this chapter, here is a friendly reminder. If you have not
    completed the exercise building routine for *Personal Trainer*, go ahead and do
    it. You can always compare your implementation with what has been provided in
    the companion code base. There are also things you can add to the original implementation,
    such as file uploads for the exercise image, and once you are more familiar with
    client-server interaction, a remote check to determine whether the YouTube videos
    actually exist.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
