<html><head></head><body>
  <div id="_idContainer110" class="Basic-Text-Frame">
    <h1 class="chapterNumber">12</h1>
    <h1 id="_idParaDest-172" class="chapterTitle">State Management in React</h1>
    <p class="normal">In the previous chapters, we explored the concept of state in React and mastered the basics of working with it using the <code class="inlineCode">useState</code> hook. Now it’s time to delve deeper into the <strong class="keyWord">global state management</strong> of applications. In this chapter, we will focus on the global state: we’ll define what it is, its key advantages, and the strategies for its effective management.</p>
    <p class="normal">This chapter will cover the following topics:</p>
    <ul>
      <li class="bulletList">What is global state?</li>
      <li class="bulletList">React Context API and useReducer</li>
      <li class="bulletList">Redux</li>
      <li class="bulletList">Mobx</li>
    </ul>
    <h1 id="_idParaDest-173" class="heading-1">What is global state?</h1>
    <p class="normal">In developing React applications, one of the key aspects that requires special attention is <strong class="keyWord">state management</strong>. We<a id="_idIndexMarker420"/> are already familiar with the <code class="inlineCode">useState</code> hook, which allows us to create and manage state within a component. This type of state is often referred to <a id="_idIndexMarker421"/>as <strong class="keyWord">local</strong>, and it is very effective within a single component and very simple and easy to use. </p>
    <p class="normal">For a clearer illustration, consider an example with a small form component, where we have two <strong class="keyWord">input</strong> elements and have created two states for each <strong class="keyWord">input</strong>:</p>
    <figure class="mediaobject"><img src="../Images/B19636_12_01.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 12.1: Form component with local state</p>
    <p class="normal">In this example, everything<a id="_idIndexMarker422"/> is simple: the user enters something into the <code class="inlineCode">input</code>, which triggers an <code class="inlineCode">onChange</code> event, where we usually change our <code class="inlineCode">state</code>, causing a full re-render of the form, and then we see the result of the input on the screen.</p>
    <p class="normal">However, as the complexity and size of your application increase, there will inevitably be a need for a more scalable and flexible approach to state management. Let’s further consider our example and imagine that after entering information into the form, we need to make a request <a id="_idIndexMarker423"/>to the server for user authorization and obtain a <strong class="keyWord">session key</strong>. Then, with this key, we need to request user data: name, surname, and avatar.</p>
    <p class="normal">Here, we immediately encounter difficulties: where do we store the session key and user data? Perhaps we can retrieve the data right inside the form and then pass it up to the parent component, as it is more global and responsible. Alright, let’s illustrate this and take a look: </p>
    <figure class="mediaobject"><img src="../Images/B19636_12_02.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 12.2: Login page with form component</p>
    <p class="normal">So, now we <a id="_idIndexMarker424"/>have a login page, where we have local states for <strong class="keyWord">session</strong> and <strong class="keyWord">user</strong> objects. Using props, we can pass functions like <code class="inlineCode">onSessionChange</code> and <code class="inlineCode">onUserChange</code> to the form component, which ultimately allows us to transfer data from the form to the login page. Also, in the form, we now have<a id="_idIndexMarker425"/> the functions <code class="inlineCode">getSessionKey</code> and <code class="inlineCode">getUser</code>. These<a id="_idIndexMarker426"/> methods interact with the server, and upon successful response, they don’t store data locally but call the aforementioned <code class="inlineCode">onSessionChange</code> and <code class="inlineCode">onUserChange</code>.</p>
    <p class="normal">One might think that the data storage problem is solved, but likely after user authorization and obtaining their data, we need to redirect the user to some homepage of our application. We could repeat our trick of lifting the data higher once again, but before doing that, let’s think ahead and imagine that obtaining user data is probably not just the job of the authorization form, and such a function might be needed on other pages. </p>
    <p class="normal">Ultimately, we come to understand that in addition to the data itself, we also need to keep the logic for working with the data higher up in the component tree:</p>
    <figure class="mediaobject"><img src="../Images/B19636_12_03.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 12.3: App root component</p>
    <p class="normal">This image <a id="_idIndexMarker427"/>clearly demonstrates how the application becomes more complicated when we need to pass down all the necessary data and methods from the topmost component of the application to all its pages and components.</p>
    <p class="normal">In addition to the complexity of implementing and maintaining such an approach to organizing the application’s state, there is also a significant performance problem. For example, having a state in the root component created through <code class="inlineCode">useState</code>, every time we update it, the entire application will be re-rendered because the app root component will be redrawn.</p>
    <p class="normal">So, we have identified the main problems with organizing local state in the components of a large application:</p>
    <ul>
      <li class="bulletList">Overcomplicated component tree, where all important data must be passed down from top to bottom using props. This tightly couples the components, complicating the code and its maintenance.</li>
      <li class="bulletList">Performance issue, where the application may re-render unnecessarily when it’s not required.</li>
    </ul>
    <p class="normal">Looking at <a id="_idIndexMarker428"/>the last image, one can think of whether it is possible to break the connection of our components and extract all the data and logic somewhere outside of the components. This is where the concept of global state comes into play.</p>
    <p class="normal"><strong class="keyWord">Global state</strong> is a data management approach that allows state to be accessible and modifiable across different levels and components of your application. This solution overcomes the limitations of local state, facilitating data exchange between components and improving state manageability in large-scale projects.</p>
    <p class="normal">To clearly understand how global state would look in our example, take a look at the image below:</p>
    <figure class="mediaobject"><img src="../Images/B19636_12_04.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 12.4: App root component and global state</p>
    <p class="normal">In this example, we have a global state that is located outside of the components and the entire tree. Only the components that actually need any data from the state can directly access it and subscribe to its changes.</p>
    <p class="normal">By implementing global state, we can solve both problems at once:</p>
    <ul>
      <li class="bulletList">Simplifies the component tree and dependencies, thereby scaling and supporting the application.</li>
      <li class="bulletList">Increases application performance because now, only those components that were subscribed to data from the global state are re-rendered when the state changes.</li>
    </ul>
    <p class="normal">However, it’s <a id="_idIndexMarker429"/>important to understand that the local state remains a very powerful tool and should not be abandoned in favor of the global state. We only gain advantages when the state needs to be used across different levels of application components. Otherwise, if we start transferring all variables and states to the global state, we will only complicate the application without gaining any benefits.</p>
    <p class="normal">Now that we know that the global state is merely a way of organizing data, how do we manage the global state? A <strong class="keyWord">state manager</strong> is a<a id="_idIndexMarker430"/> tool that helps organize and manage state in an application, especially when it comes to complex interactions and extensive data. It <a id="_idIndexMarker431"/>provides a <strong class="keyWord">centralized repository</strong> for all your application’s state and manages its updates in an orderly and predictable manner. In practice, state managers are often represented as npm packages installed as project dependencies. However, it is also possible to manage the global state independently without any libraries using React’s API. We will explore one such approach later on. </p>
    <h1 id="_idParaDest-174" class="heading-1">React Context API and useReducer</h1>
    <p class="normal">To organize the global state on your own, you can use tools that already exist in the React ecosystem, namely the <strong class="keyWord">Context API</strong> and <code class="inlineCode">useReducer</code>. They represent a powerful duo for managing<a id="_idIndexMarker432"/> state, especially in situations where using third-party state managers seems excessive. These tools are ideal for creating and managing global states in more compact applications.</p>
    <p class="normal">The <strong class="keyWord">React Context API</strong> is <a id="_idIndexMarker433"/>designed to pass data through the component tree without the need to pass props at every level. This simplifies access to data in deeply nested components and <a id="_idIndexMarker434"/>reduces <strong class="keyWord">prop drilling</strong> (passing props through many levels), as illustrated in <em class="italic">Figure 12.4</em>. The React Context API is particularly useful for data such as theme settings, language preferences, or user information.</p>
    <p class="normal">Here’s an example of how to store theme settings using context:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">ThemeContext</span> = <span class="hljs-title">createContext</span>();
<span class="hljs-keyword">const</span> <span class="hljs-title">ThemeProvider</span> = (<span class="hljs-params">{ children }</span>) =&gt; {
  <span class="hljs-keyword">const</span> theme = <span class="hljs-string">'dark'</span>;
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">ThemeContext.Provider</span><span class="hljs-tag"> </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">{theme}</span><span class="hljs-tag">&gt;</span>
<span class="language-xml">      {children}</span>
<span class="language-xml">    </span><span class="hljs-tag">&lt;/</span><span class="hljs-name">ThemeContext.Provider</span><span class="hljs-tag">&gt;</span>
  );
};
<span class="hljs-keyword">const</span> <span class="hljs-title">useTheme</span> = () =&gt; <span class="hljs-title">useContext</span>(<span class="hljs-title">ThemeContext</span>);
<span class="hljs-keyword">export</span> { <span class="hljs-title">ThemeProvider</span>, useTheme };
</code></pre>
    <p class="normal">In this <a id="_idIndexMarker435"/>example, we created <code class="inlineCode">ThemeContext</code> using the <code class="inlineCode">createContext</code> function. Then, we made a <code class="inlineCode">ThemeProvider</code> component, which should wrap the root <a id="_idIndexMarker436"/>component of the application. This will later allow access at any level of nested components using the <code class="inlineCode">useTheme</code> hook, which was created with the <code class="inlineCode">useContext</code> hook:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">MyComponent</span> = () =&gt; {
  <span class="hljs-keyword">const</span> theme = <span class="hljs-title">useTheme</span>();
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
<span class="language-xml">      </span><span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span><span class="language-xml">Current theme: {theme}</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
<span class="language-xml">    </span><span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
};
</code></pre>
    <p class="normal">On any level of the component tree, we can access the current theme using the <code class="inlineCode">useTheme</code> hook. </p>
    <p class="normal">Next let’s take a look at the next one of the duo, the special hook that will help us to build the global state. <code class="inlineCode">useReducer</code> is a hook that allows you to manage complex states with reducers: functions that take the current state and an action, and then return a new state. <code class="inlineCode">useReducer</code> is ideal for managing states that require complex logic or multiple sub-states. Let’s consider a small example of a counter using <code class="inlineCode">useReducer</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-title">React</span>, { useReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">const</span> initialState = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };
<span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state, action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'increment'</span>:
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> };
    <span class="hljs-keyword">case</span> <span class="hljs-string">'decrement'</span>:
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span> };
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Error</span>();
  }
}
<span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>() {
  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title">useReducer</span>(reducer, initialState);
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;&gt;</span>
<span class="language-xml">      Count: {state.count}</span>
<span class="language-xml">      </span><span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{()</span><span class="hljs-tag"> =&gt;</span><span class="language-xml"> dispatch({ type: 'increment' })}&gt;+</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
<span class="language-xml">      </span><span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{()</span><span class="hljs-tag"> =&gt;</span><span class="language-xml"> dispatch({ type: 'decrement' })}&gt;-</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
<span class="language-xml">    </span><span class="hljs-tag">&lt;/&gt;</span>
  );
}
</code></pre>
    <p class="normal">In this <a id="_idIndexMarker437"/>example, a <a id="_idIndexMarker438"/>reducer is implemented that has two actions: <code class="inlineCode">increasing</code> and <code class="inlineCode">decreasing</code> the counter.</p>
    <p class="normal">The combination of the Context API and <code class="inlineCode">useReducer</code> provides a powerful mechanism for creating and managing the global state of an application. This approach is convenient for small applications, where ready-made and larger state management solutions might be redundant. However, it’s also worth noting that this solution doesn’t completely solve the performance issue, as any change in the theme in the <code class="inlineCode">useTheme</code> example or the counter in the counter example will cause the provider, and thus the entire component tree, to re-render. This can be avoided, but it requires additional logic and coding.</p>
    <p class="normal">Therefore, more complex applications require a more powerful tool. For this, there are several ready-made and popular solutions for working with state, each with its unique features and suitable for different use cases. </p>
    <h1 id="_idParaDest-175" class="heading-1">Redux</h1>
    <p class="normal">The first <a id="_idIndexMarker439"/>of such tools is, of course, <strong class="keyWord">Redux</strong>. It is one of the most popular tools for managing state in complex JavaScript applications, especially when used with React. Redux provides predictable state management by maintaining the application’s state in a single global object, simplifying the tracking of changes and data management.</p>
    <p class="normal">Redux is based on three core principles: a single source of truth (one global state), the state is read-only (immutable), and changes are made using pure functions (reducers). These principles ensure an orderly and controlled data flow.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">counterReducer</span>(<span class="hljs-params">state = { count: </span><span class="hljs-number">0</span><span class="hljs-params"> }, action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'INCREMENT'</span>:
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> };
    <span class="hljs-keyword">case</span> <span class="hljs-string">'DECREMENT'</span>:
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span> };
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
}
<span class="hljs-keyword">const</span> store = <span class="hljs-title">createStore</span>(counterReducer);
store.<span class="hljs-title">subscribe</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(store.<span class="hljs-title">getState</span>()));
store.<span class="hljs-title">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'INCREMENT'</span> });
store.<span class="hljs-title">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'DECREMENT'</span> });
</code></pre>
    <p class="normal">In this example, the state of the application has been implemented from the counter example. We have a <code class="inlineCode">counterReducer</code>, which is a regular function that takes the current state and the action to be performed on it. The reducer always returns a new state.</p>
    <p class="normal">Implementing asynchronous operations in the Redux world is a complex issue, as out of the box it offers nothing but middleware, which is used by third-party solutions. One such solution is <code class="inlineCode">redux-thunk</code>.</p>
    <p class="normal"><code class="inlineCode">redux-thunk</code> is a middleware that allows you to call action creator functions that return a function instead of an action object. This provides the ability to delay the dispatch of an action or dispatch multiple actions by making asynchronous requests.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchUserData</span>() {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(</span><span class="hljs-params">dispatch</span><span class="hljs-function">) =&gt;</span> {
    <span class="hljs-title">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'LOADING_USER_DATA'</span> });
    <span class="hljs-title">fetch</span>(<span class="hljs-string">'/api/user'</span>)
      .<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">response</span><span class="hljs-function">) =&gt;</span> response.<span class="hljs-title">json</span>())
      .<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">data</span><span class="hljs-function">) =&gt;</span> <span class="hljs-title">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'FETCH_USER_DATA_SUCCESS'</span>, <span class="hljs-attr">payload</span>: data }))
      .<span class="hljs-title">catch</span>(<span class="hljs-function">(</span><span class="hljs-params">error</span><span class="hljs-function">) =&gt;</span> <span class="hljs-title">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'FETCH_USER_DATA_ERROR'</span>, error }));
  };
}
<span class="hljs-keyword">const</span> store = <span class="hljs-title">createStore</span>(reducer, <span class="hljs-title">applyMiddleware</span>(thunk));
store.<span class="hljs-title">dispatch</span>(<span class="hljs-title">fetchUserData</span>());
</code></pre>
    <p class="normal">As you <a id="_idIndexMarker440"/>can see in the example, we create a function, <code class="inlineCode">fetchUserData</code>, that doesn’t immediately change the state. Instead, it returns another function with a <code class="inlineCode">dispatch</code> argument. This <code class="inlineCode">dispatch</code> can be used as many times as needed to change the state.</p>
    <p class="normal">There are also other more powerful but more complex solutions for asynchronous operations. We will not discuss these here.</p>
    <p class="normal">Redux is well suited for managing complex global state in applications. It offers powerful debugging tools, such as time travel. Redux also facilitates the testing of state and logic due to the clear separation between data and its processing.</p>
    <p class="normal">To integrate <a id="_idIndexMarker441"/>Redux with React, the <code class="inlineCode">React-Redux</code> library is used. It provides <code class="inlineCode">Provider</code> components, and the <code class="inlineCode">useSelector</code> and <code class="inlineCode">useDispatch</code> hooks, which allow easy connection of the Redux store to your React application.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>() {
  <span class="hljs-keyword">const</span> count = <span class="hljs-title">useSelector</span>(<span class="hljs-function">(</span><span class="hljs-params">state</span><span class="hljs-function">) =&gt;</span> state.<span class="hljs-property">count</span>);
  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title">useDispatch</span>();
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
<span class="language-xml">      </span><span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span><span class="language-xml">Count: {count}</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
<span class="language-xml">      </span><span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{()</span><span class="hljs-tag"> =&gt;</span><span class="language-xml"> dispatch({ type: 'INCREMENT' })}&gt;+</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
<span class="language-xml">      </span><span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{()</span><span class="hljs-tag"> =&gt;</span><span class="language-xml"> dispatch({ type: 'DECREMENT' })}&gt;-</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
<span class="language-xml">    </span><span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">In the<a id="_idIndexMarker442"/> example above, the <code class="inlineCode">Counter</code> component works with the Redux state by subscribing to changes through <code class="inlineCode">useSelector</code>. This subscription is more granular, and changing the counter does not lead to the re-rendering of the entire application, but only of the specific component that invokes this hook.</p>
    <p class="normal">However, it’s<a id="_idIndexMarker443"/> important to note the drawbacks of Redux. Although it is the most popular solution, it has significant issues that affect my personal choice against this solution:</p>
    <ul>
      <li class="bulletList">Redux is verbose. Implementing a large global state requires writing a lot of boilerplate code in the form of reducers, actions, selectors, etc.</li>
      <li class="bulletList">With the growth of the project, the complexity of maintaining and scaling the Redux state increases disproportionately.</li>
    </ul>
    <p class="normal">As the project and global state grow, application performance significantly decreases. This happens due to the need for a large number of computations, even if you simply change the state of one value from <code class="inlineCode">false</code> to <code class="inlineCode">true</code>.</p>
    <p class="normal">Implementation of asynchronous operations is not supported out of the box by Redux and requires additional solutions, further complicating the understanding and maintenance of the project.</p>
    <p class="normal">Dividing state and business logic into chunks for lazy loading requires a lot of effort. As a result, the application’s size and therefore its initial loading speed are affected.</p>
    <p class="normal">Despite these drawbacks, many companies and developers still use this solution, as it suits most business tasks, so I believe it is important to know this tool and be able to work with it.</p>
    <h1 id="_idParaDest-176" class="heading-1">MobX</h1>
    <p class="normal">The next <a id="_idIndexMarker444"/>popular solution for managing the global state is the <strong class="keyWord">MobX</strong> library. This library differs significantly from Redux, with a concept that is in some ways even the opposite.</p>
    <p class="normal">MobX is a state management library that provides reactive and flexible interaction with data. Its main idea is to make the application state as simple and transparent as possible, working through small objects and classes that can be created as many times as desired and nested within each other. </p>
    <p class="normal">Technically, the library allows for creating not just one global state but many small objects directly linked to some functionality of the application, which gives a significant advantage when working with large applications. To get the difference between one global state and MobX states, you can look at the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19636_12_05.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 12.5: MobX state</p>
    <p class="normal">In MobX, the <a id="_idIndexMarker445"/>state of the application is managed using <code class="inlineCode">observable </code>method, which automatically track changes and inform related computed values and reactions. This allows the application to automatically update in response to state changes, simplifying the data flow and increasing flexibility. </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span> {
  @observable accessor count = <span class="hljs-number">0</span>;
  @computed <span class="hljs-keyword">get</span> <span class="hljs-title">doubleCount</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-property">count</span> * <span class="hljs-number">2</span>;
  }
  @action <span class="hljs-title">increment</span>() {
    <span class="hljs-variable">this</span>.<span class="hljs-property">count</span> += <span class="hljs-number">1</span>;
  }
  @action <span class="hljs-title">decrement</span>() {
    <span class="hljs-variable">this</span>.<span class="hljs-property">count</span> -= <span class="hljs-number">1</span>;
  }
}
<span class="hljs-keyword">const</span> myStore = <span class="hljs-keyword">new</span> <span class="hljs-title">Store</span>();
</code></pre>
    <p class="normal">In the<a id="_idIndexMarker446"/> example, the same counter is implemented using MobX. In one class, both the actual data and computed data are present, along with actions to change the state.</p>
    <p class="normal">Speaking about asynchronous operations, MobX doesn’t have any issues with that, as you can work in a regular class and add a new method that returns a promise.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span> {
  @observable count = <span class="hljs-number">0</span>;
  @computed <span class="hljs-keyword">get</span> <span class="hljs-title">doubleCount</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-property">count</span> * <span class="hljs-number">2</span>;
  }
  @action <span class="hljs-title">increment</span>() {
    <span class="hljs-variable">this</span>.<span class="hljs-property">count</span> += <span class="hljs-number">1</span>;
  }
  @action <span class="hljs-title">decrement</span>() {
    <span class="hljs-variable">this</span>.<span class="hljs-property">count</span> -= <span class="hljs-number">1</span>;
  }
  @action <span class="hljs-keyword">async</span> <span class="hljs-title">fetchCountFromServer</span>() {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title">fetch</span>(<span class="hljs-string">'/count'</span>);
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title">json</span>();
    <span class="hljs-variable">this</span>.<span class="hljs-property">count</span> = data.<span class="hljs-property">count</span>;
  }
}
<span class="hljs-keyword">const</span> myStore = <span class="hljs-keyword">new</span> <span class="hljs-title">Store</span>();
</code></pre>
    <p class="normal">MobX is well suited for applications that require high performance and simplicity in managing complex data dependencies. It offers an elegant and intuitive way to handle complex state, allowing developers to focus on business logic rather than state management.</p>
    <p class="normal">One drawback of this library is the considerable freedom it provides in organizing state, which can lead to difficulties and scalability issues in inexperienced hands. For example, MobX allows direct manipulation of object data, which can trigger component updates, but this can also lead to unexpected state changes in large projects and debugging challenges. Similarly, this freedom often results in small, clean MobX classes becoming tightly coupled, making testing and project development more challenging.</p>
    <p class="normal">To integrate<a id="_idIndexMarker447"/> MobX with React, the <code class="inlineCode">mobx-react</code> library is used, which provides the <code class="inlineCode">observer</code> function. This allows React components to automatically react to changes in observed data.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-title">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { observer } <span class="hljs-keyword">from</span> <span class="hljs-string">'mobx-react'</span>;
<span class="hljs-keyword">import</span> myStore <span class="hljs-keyword">from</span> <span class="hljs-string">'./myStore'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title">Counter</span> = <span class="hljs-title">observer</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
<span class="language-xml">      </span><span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span><span class="language-xml">Count: {myStore.count}</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
<span class="language-xml">      </span><span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span><span class="language-xml">Double: {myStore.doubleCount}</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
<span class="language-xml">      </span><span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{()</span><span class="hljs-tag"> =&gt;</span><span class="language-xml"> myStore.increment()}&gt;-</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
<span class="language-xml">      </span><span class="hljs-tag">&lt;</span><span class="hljs-name">button</span><span class="hljs-tag"> </span><span class="hljs-attr">onClick</span><span class="hljs-tag">=</span><span class="hljs-string">{()</span><span class="hljs-tag"> =&gt;</span><span class="language-xml"> myStore.decrement()}&gt;+</span><span class="hljs-tag">&lt;/</span><span class="hljs-name">button</span><span class="hljs-tag">&gt;</span>
<span class="language-xml">    </span><span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
});
</code></pre>
    <p class="normal">In the example, the same counter is implemented using MobX. As you can see, we don’t use hooks to access the state or providers to store it in the application context. We simply import the variable from the file and use it. The <code class="inlineCode">myStore</code> created from the <code class="inlineCode">Store</code> class is the state itself. It’s easy to use the observed value of an object in a component because the component immediately subscribes to all changes of that value and will re-render every time it changes.</p>
    <p class="normal">Just from <a id="_idIndexMarker448"/>the examples, you can already see how simple and convenient MobX is for managing state. Since it’s just an object, there are no complexities in lazily loading it when needed and clearing the cache and memory of the application when the data is no longer needed. I consider it a powerful tool for state management and highly recommend trying it in a real project.</p>
    <h1 id="_idParaDest-177" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we’ve learned about global state and how to manage it. Using the example of limited local state, we’ve discussed why it’s important to have global state in cases where shared data is needed across different components at different levels of the application.</p>
    <p class="normal">We’ve explored an example using the React Context API and identified when to use it and when to prefer more powerful state management solutions. Next, we looked at two such solutions in the form of Redux and MobX.</p>
    <p class="normal">In the next chapter, we will discuss server-side rendering and the benefits it can bring to our applications.</p>
  </div>
</body></html>