<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Tables - Display Complex Collection Data</h1>
                </header>
            
            <article>
                
<p>In this chapter, you'll learn <span>about the following topics</span>:</p>
<ul>
<li>Stateful tables</li>
<li>Sortable columns</li>
<li>Filtering rows</li>
<li>Selecting rows</li>
<li>Row actions</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>If your<span> application needs to display tabular data, you can use the Material-UI </span><kbd>Table</kbd><span> component, along with all of its supporting components. Unlike grid components, which you might have seen or used in other React libraries, the Material-UI component is unopinionated. This means that you have to write your own code to control table data. On the plus side, the </span><kbd>Table</kbd><span> component stays out of your way and lets you implement things your own way.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stateful tables</h1>
                </header>
            
            <article>
                
<p>With <kbd>Table</kbd> components, it's rare that you'll have static markup that defines the row data of the table. Instead, component state will map to the rows that make up your table data. For example, you might have a component that fetches API data that you want displayed in a table.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have a component that fetches data from an API endpoint. When the data loads, you want to display the tabular data in a Material-UI <kbd>Table</kbd> component. Here's what the code looks like:</p>
<pre>import React, { useState, useEffect } from 'react';<br/><br/>import { makeStyles } from '@material-ui/styles';<br/>import Table from '@material-ui/core/Table';<br/>import TableBody from '@material-ui/core/TableBody';<br/>import TableCell from '@material-ui/core/TableCell';<br/>import TableHead from '@material-ui/core/TableHead';<br/>import TableRow from '@material-ui/core/TableRow';<br/>import Paper from '@material-ui/core/Paper';<br/><br/>const fetchData = () =&gt;<br/>  new Promise(resolve =&gt; {<br/>    const items = [<br/>      {<br/>        id: 1,<br/>        name: 'First Item',<br/>        created: new Date(),<br/>        high: 2935,<br/>        low: 1924,<br/>        average: 2429.5<br/>      },<br/>      {<br/>        id: 2,<br/>        name: 'Second Item',<br/>        created: new Date(),<br/>        high: 439,<br/>        low: 231,<br/>        average: 335<br/>      },<br/>      {<br/>        id: 3,<br/>        name: 'Third Item',<br/>        created: new Date(),<br/>        high: 8239,<br/>        low: 5629,<br/>        average: 6934<br/>      },<br/>      {<br/>        id: 4,<br/>        name: 'Fourth Item',<br/>        created: new Date(),<br/>        high: 3203,<br/>        low: 3127,<br/>        average: 3165<br/>      },<br/>      {<br/>        id: 5,<br/>        name: 'Fifth Item',<br/>        created: new Date(),<br/>        high: 981,<br/>        low: 879,<br/>        average: 930<br/>      }<br/>    ];<br/><br/>    setTimeout(() =&gt; resolve(items), 1000);<br/>  });<br/><br/>const usePaperStyles = makeStyles(theme =&gt; ({<br/>  root: { margin: theme.spacing(2) }<br/>}));<br/><br/>export default function StatefulTables() {<br/>  const classes = usePaperStyles();<br/><br/>  const [items, setItems] = useState([]);<br/><br/>  useEffect(() =&gt; {<br/>    fetchData().then(items =&gt; {<br/>      setItems(items);<br/>    });<br/>  }, []);<br/><br/>  return (<br/>    &lt;Paper className={classes.root}&gt;<br/>      &lt;Table&gt;<br/>        &lt;TableHead&gt;<br/>          &lt;TableRow&gt;<br/>            &lt;TableCell&gt;Name&lt;/TableCell&gt;<br/>            &lt;TableCell&gt;Created&lt;/TableCell&gt;<br/>            &lt;TableCell align="right"&gt;High&lt;/TableCell&gt;<br/>            &lt;TableCell align="right"&gt;Low&lt;/TableCell&gt;<br/>            &lt;TableCell align="right"&gt;Average&lt;/TableCell&gt;<br/>          &lt;/TableRow&gt;<br/>        &lt;/TableHead&gt;<br/>        &lt;TableBody&gt;<br/>          {items.map(item =&gt; {<br/>            return (<br/>              &lt;TableRow key={item.id}&gt;<br/>                &lt;TableCell component="th" scope="row"&gt;<br/>                  {item.name}<br/>                &lt;/TableCell&gt;<br/>                &lt;TableCell&gt;{item.created.toLocaleString()}&lt;/TableCell&gt;<br/>                &lt;TableCell align="right"&gt;{item.high}&lt;/TableCell&gt;<br/>                &lt;TableCell align="right"&gt;{item.low}&lt;/TableCell&gt;<br/>                &lt;TableCell align="right"&gt;{item.average}&lt;/TableCell&gt;<br/>              &lt;/TableRow&gt;<br/>            );<br/>          })}<br/>        &lt;/TableBody&gt;<br/>      &lt;/Table&gt;<br/>    &lt;/Paper&gt;<br/>  );<br/>}</pre>
<p>When you load the screen, you'll see a table populated with data after one second:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d2c62425-5743-4950-be34-ed1e5c408211.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's start by looking at the <kbd>fetchData()</kbd> function, which resolves the data that is eventually set as the component state:</p>
<pre>const fetchData = () =&gt;<br/>  new Promise(resolve =&gt; {<br/>    const items = [<br/>      {<br/>        id: 1,<br/>        name: 'First Item',<br/>        created: new Date(),<br/>        high: 2935,<br/>        low: 1924,<br/>        average: 2429.5<br/>      },<br/>      {<br/>        id: 2,<br/>        name: 'Second Item',<br/>        created: new Date(),<br/>        high: 439,<br/>        low: 231,<br/>        average: 335<br/>      },<br/>      ...<br/>    ];<br/><br/>    setTimeout(() =&gt; resolve(items), 1000);<br/>  });</pre>
<p>This function returns a <kbd>Promise</kbd> that resolves an array of objects after one second. The idea is to simulate a function that calls a real API using <kbd>fetch()</kbd>.</p>
<div class="packt_infobox">The objects shown in the array are truncated for brevity.</div>
<p>Next, let's look at the initial component state and what happens when your component is mounted:</p>
<pre>const [items, setItems] = useState([]);<br/><br/>useEffect(() =&gt; {<br/>  fetchData().then(items =&gt; {<br/>    setItems(items);<br/>  });<br/>}, []);</pre>
<p>The <kbd>items</kbd> <span>state represents</span> the table rows that are to be rendered within the <kbd>Table</kbd> component. When your component is mounted, the <kbd>fetchData()</kbd> call is made, and when the <kbd>Promise</kbd> resolves, the <kbd>items</kbd> state is set. Lastly, let's look at the markup that's responsible for rendering the table rows:</p>
<pre>&lt;Table&gt;<br/>  &lt;TableHead&gt;<br/>    &lt;TableRow&gt;<br/>      &lt;TableCell&gt;Name&lt;/TableCell&gt;<br/>      &lt;TableCell&gt;Created&lt;/TableCell&gt;<br/>      &lt;TableCell align="right"&gt;High&lt;/TableCell&gt;<br/>      &lt;TableCell align="right"&gt;Low&lt;/TableCell&gt;<br/>      &lt;TableCell align="right"&gt;Average&lt;/TableCell&gt;<br/>    &lt;/TableRow&gt;<br/>  &lt;/TableHead&gt;<br/>  &lt;TableBody&gt;<br/>    {items.map(item =&gt; {<br/>      return (<br/>        &lt;TableRow key={item.id}&gt;<br/>          &lt;TableCell component="th" scope="row"&gt;<br/>            {item.name}<br/>          &lt;/TableCell&gt;<br/>          &lt;TableCell&gt;{item.created.toLocaleString()}&lt;/TableCell&gt;<br/>          &lt;TableCell align="right"&gt;{item.high}&lt;/TableCell&gt;<br/>          &lt;TableCell align="right"&gt;{item.low}&lt;/TableCell&gt;<br/>          &lt;TableCell align="right"&gt;{item.average}&lt;/TableCell&gt;<br/>        &lt;/TableRow&gt;<br/>      );<br/>    })}<br/>  &lt;/TableBody&gt;<br/>&lt;/Table&gt;</pre>
<p><kbd>Table</kbd> components typically have two children—a <kbd>TableHead</kbd> and a <kbd>TableBody</kbd> component. Inside <kbd>TableHead</kbd>, you'll find a <kbd>TableRow</kbd> component with several <kbd>TableCell</kbd> components. These are the table column headings. Inside <kbd>TableBody</kbd>, you'll see that the <kbd>items</kbd> state is mapped to <kbd>TableRow</kbd> and <kbd>TableCell</kbd> components. When the <kbd>items</kbd> state changes, the rows are changed too. You can already see this in action, because the <kbd>items</kbd> state defaults to an empty array. After the API data resolves, the <kbd>items</kbd> state changes and the rows are visible on the screen.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>One suboptimal aspect of this example is the user's experience while they wait for table data to load. Showing the column headers upfront is fine, since you know what they are ahead of time and the user might too. What's needed is some sort of indicator that the actual row data <span>is, in fact,</span> loading.</p>
<p>One way to fix this issue is to add a circular progress indicator underneath the column headers. This should help the user understand that not only are they waiting for data to load, but that it's the table row data specifically, thanks to the position of the progress indicator.</p>
<p>First, let's introduce a new component for displaying a <kbd>CircularProgress</kbd> component along with some new styles:</p>
<pre>const usePaperStyles = makeStyles(theme =&gt; ({<br/>  root: { margin: theme.spacing(2), textAlign: 'center' }<br/>}));<br/><br/>const useProgressStyles = makeStyles(theme =&gt; ({<br/>  progress: { margin: theme.spacing(2) }<br/>}));<br/><br/>function MaybeLoading({ loading }) {<br/>  const classes = useProgressStyles();<br/>  return loading ? (<br/>    &lt;CircularProgress className={classes.progress} /&gt;<br/>  ) : null;<br/>}</pre>
<p>There's a new <kbd>progress</kbd> style that's applied to the <kbd>CircularProgress</kbd> component. This adds <kbd>margin</kbd> to the progress indicator. The <kbd>textAlign</kbd> property has been added to the <kbd>root</kbd> style so that the progress indicator is horizontally centered within the <kbd>Paper</kbd> component. The <kbd>MaybeLoading</kbd> component renders the <kbd>CircularProgress</kbd> component if the <kbd>loading</kbd> property is <kbd>true</kbd>.</p>
<p>This means that you now have to keep track of the <kbd>loading</kbd> state of the API call. Here's the new state, which defaults to <kbd>true</kbd>:</p>
<pre>const [loading, setLoading] = useState(true);</pre>
<p>When the API call returns, you can set the <kbd>loading</kbd> state to <kbd>false</kbd>:</p>
<pre>useEffect(() =&gt; {<br/>  fetchData().then(items =&gt; {<br/>    setItems(items);<br/>    setLoading(false);<br/>  });<br/>}, []);</pre>
<p>Lastly, you need to render the <kbd>MaybeLoading</kbd> component after the <kbd>Table</kbd> component:</p>
<pre>&lt;Paper className={classes.root}&gt;<br/>  &lt;Table&gt;<br/>    ...<br/>  &lt;/Table&gt;<br/>  &lt;MaybeLoading loading={loading} /&gt;<br/>&lt;/Paper&gt;</pre>
<p class="mce-root"/>
<p>Here's what your users will see while waiting for the table data to load:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d9ac9bca-e739-4648-a7f7-0d25e9151a05.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Table</kbd> API documentation: <a href="https://material-ui.com/api/table/">https://material-ui.com/api/table/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sortable columns</h1>
                </header>
            
            <article>
                
<p>Material-UI tables have tools that help you implement sortable columns. If you're rendering a <kbd>Table</kbd> component in your application, your users will likely expect to be able to sort the table data by column.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>When the users clicks on a column header, there should be a visual indication that table rows are now sorted by this column and the row order should change. When clicked on again, the column <span>should appear in reverse order</span>. Here's the code:</p>
<pre>import React, { useState } from 'react';<br/><br/>import { makeStyles } from '@material-ui/styles';<br/>import Table from '@material-ui/core/Table';<br/>import TableBody from '@material-ui/core/TableBody';<br/>import TableCell from '@material-ui/core/TableCell';<br/>import TableHead from '@material-ui/core/TableHead';<br/>import TableRow from '@material-ui/core/TableRow';<br/>import TableSortLabel from '@material-ui/core/TableSortLabel';<br/>import Paper from '@material-ui/core/Paper';<br/><br/>const comparator = (prop, desc = true) =&gt; (a, b) =&gt; {<br/>  const order = desc ? -1 : 1;<br/><br/>  if (a[prop] &lt; b[prop]) {<br/>    return -1 * order;<br/>  }<br/><br/>  if (a[prop] &gt; b[prop]) {<br/>    return 1 * order;<br/>  }<br/><br/>  return 0 * order;<br/>};<br/><br/>const useStyles = makeStyles(theme =&gt; ({<br/>  root: { margin: theme.spacing(2), textAlign: 'center' }<br/>}));<br/><br/>export default function SortableColumns() {<br/>  const classes = useStyles();<br/>  const [columns, setColumns] = useState([<br/>    { name: 'Name', active: false },<br/>    { name: 'Created', active: false },<br/>    { name: 'High', active: false, numeric: true },<br/>    { name: 'Low', active: false, numeric: true },<br/>    { name: 'Average', active: false, numeric: true }<br/>  ]);<br/>  const [rows, setRows] = useState([<br/>    {<br/>      id: 1,<br/>      name: 'First Item',<br/>      created: new Date(),<br/>      high: 2935,<br/>      low: 1924,<br/>      average: 2429.5<br/>    },<br/>    {<br/>      id: 2,<br/>      name: 'Second Item',<br/>      created: new Date(),<br/>      high: 439,<br/>      low: 231,<br/>      average: 335<br/>    },<br/>    {<br/>      id: 3,<br/>      name: 'Third Item',<br/>      created: new Date(),<br/>      high: 8239,<br/>      low: 5629,<br/>      average: 6934<br/>    },<br/>    {<br/>      id: 4,<br/>      name: 'Fourth Item',<br/>      created: new Date(),<br/>      high: 3203,<br/>      low: 3127,<br/>      average: 3165<br/>    },<br/>    {<br/>      id: 5,<br/>      name: 'Fifth Item',<br/>      created: new Date(),<br/>      high: 981,<br/>      low: 879,<br/>      average: 930<br/>    }<br/>  ]);<br/><br/>  const onSortClick = index =&gt; () =&gt; {<br/>    setColumns(<br/>      columns.map((column, i) =&gt; ({<br/>        ...column,<br/>        active: index === i,<br/>        order:<br/>          (index === i &amp;&amp;<br/>            (column.order === 'desc' ? 'asc' : 'desc')) ||<br/>          undefined<br/>      }))<br/>    );<br/><br/>    setRows(<br/>      rows<br/>        .slice()<br/>        .sort(<br/>          comparator(<br/>            columns[index].name.toLowerCase(),<br/>            columns[index].order === 'desc'<br/>          )<br/>        )<br/>    );<br/>  };<br/><br/>  return (<br/>    &lt;Paper className={classes.root}&gt;<br/>      &lt;Table&gt;<br/>        &lt;TableHead&gt;<br/>          &lt;TableRow&gt;<br/>            {columns.map((column, index) =&gt; (<br/>              &lt;TableCell<br/>                key={column.name}<br/>                align={column.numeric ? 'right' : 'inherit'}<br/>              &gt;<br/>                &lt;TableSortLabel<br/>                  active={column.active}<br/>                  direction={column.order}<br/>                  onClick={onSortClick(index)}<br/>                &gt;<br/>                  {column.name}<br/>                &lt;/TableSortLabel&gt;<br/>              &lt;/TableCell&gt;<br/>            ))}<br/>          &lt;/TableRow&gt;<br/>        &lt;/TableHead&gt;<br/>        &lt;TableBody&gt;<br/>          {rows.map(row =&gt; (<br/>            &lt;TableRow key={row.id}&gt;<br/>              &lt;TableCell component="th" scope="row"&gt;<br/>                {row.name}<br/>              &lt;/TableCell&gt;<br/>              &lt;TableCell&gt;{row.created.toLocaleString()}&lt;/TableCell&gt;<br/>              &lt;TableCell align="right"&gt;{row.high}&lt;/TableCell&gt;<br/>              &lt;TableCell align="right"&gt;{row.low}&lt;/TableCell&gt;<br/>              &lt;TableCell align="right"&gt;{row.average}&lt;/TableCell&gt;<br/>            &lt;/TableRow&gt;<br/>          ))}<br/>        &lt;/TableBody&gt;<br/>      &lt;/Table&gt;<br/>    &lt;/Paper&gt;<br/>  );<br/>}</pre>
<p>If you click on the <span class="packt_screen">Name</span> column header, here's what you'll see:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/23804a51-b62d-4a73-a07c-5e549d9a7703.png"/></p>
<p>The column changes to indicate the sort order. If you click on the name column again, the sort order will reverse:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f7bcc0a9-01fb-441b-acde-af3a58a60364.png"/></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's break down the code used to render this table, starting with the markup used to render the column headers:</p>
<pre>&lt;TableHead&gt;<br/>  &lt;TableRow&gt;<br/>    {columns.map((column, index) =&gt; (<br/>      &lt;TableCell<br/>        key={column.name}<br/>        align={column.numeric ? 'right' : 'inherit'}<br/>      &gt;<br/>        &lt;TableSortLabel<br/>          active={column.active}<br/>          direction={column.order}<br/>          onClick={onSortClick(index)}<br/>        &gt;<br/>          {column.name}<br/>        &lt;/TableSortLabel&gt;<br/>      &lt;/TableCell&gt;<br/>    ))}<br/>  &lt;/TableRow&gt;<br/>&lt;/TableHead&gt;</pre>
<p>Each column in the table is defined in the <kbd>columns</kbd> state. This array is mapped to <kbd>TableCell</kbd> components. Inside each <kbd>TableCell</kbd>, there's a <kbd>TableSortLabel</kbd> component. This component makes the column header text bold when it's the active column for sorting. It also adds the sort arrow to the right of the text. <kbd>TableSortLabel</kbd> takes <kbd>active</kbd>, <kbd>direction</kbd>, and <kbd>onClick</kbd> properties. The <kbd>active</kbd> property is based on the <kbd>active</kbd> state of the column, which changes when the column is clicked on. The <kbd>direction</kbd> property determines whether the rows are sorted in ascending or descending order for the given column. The <kbd>onClick</kbd> property takes an event handler that makes the necessary state changes when the column is clicked on. Here's the <kbd>onSortClick()</kbd> handler:</p>
<pre>const onSortClick = index =&gt; () =&gt; {<br/>  setColumns(<br/>    columns.map((column, i) =&gt; ({<br/>      ...column,<br/>      active: index === i,<br/>      order:<br/>        (index === i &amp;&amp;<br/>          (column.order === 'desc' ? 'asc' : 'desc')) ||<br/>        undefined<br/>    }))<br/>  );<br/><br/>  setRows(<br/>    rows<br/>      .slice()<br/>      .sort(<br/>        comparator(<br/>          columns[index].name.toLowerCase(),<br/>          columns[index].order === 'desc'<br/>        )<br/>      )<br/>  );<br/>};</pre>
<p>This function takes an <kbd>index</kbd> argument—the column index—and returns a new function for the column. The returned function has two purposes:</p>
<ol>
<li><span>To update the column</span> state so that the correct column is marked as active and that it has the correct sort direction</li>
<li><span>To update the row</span> state so that the table rows are in the correct order</li>
</ol>
<p>Once these state changes have been made, the <kbd>active</kbd> column and the table rows will reflect them. The last piece of code to look at is the <kbd>comparator()</kbd> function. This is another higher-order function that takes the name of a column, and returns a new function that can be passed to <kbd>Array.sort()</kbd> to sort an array of objects by the given column:</p>
<pre>const comparator = (prop, desc = true) =&gt; (a, b) =&gt; {<br/>  const order = desc ? -1 : 1;<br/><br/>  if (a[prop] &lt; b[prop]) {<br/>    return -1 * order;<br/>  }<br/><br/>  if (a[prop] &gt; b[prop]) {<br/>    return 1 * order;<br/>  }<br/><br/>  return 0 * order;<br/>};</pre>
<p>This function is generic enough that you can use it with any tables in your app. In this case, the column name and order are passed to <kbd>comparator()</kbd> from the component state. As the state of the component changes, so too does the sorting behavior in <kbd>comparator()</kbd>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>What if your data is already sorted by a particular column when it arrives from the API? If this is the case, you'll probably want to indicate which columns the rows are sorted by and in what direction, before the user starts interacting with the table.</p>
<p>To do so, you just need to change the default column state. For example, let's say that the <span class="packt_screen">Average</span> column is sorted in descending order by default. Here's what your initial <kbd>column</kbd> state would look like:</p>
<pre>const [columns, setColumns] = useState([<br/>  { name: 'Name', active: false },<br/>  { name: 'Created', active: false },<br/>  { name: 'High', active: false, numeric: true },<br/>  { name: 'Low', active: false, numeric: true },<br/>  { name: 'Average', active: true, numeric: true }<br/>]);</pre>
<p>The <span class="packt_screen">Average</span> column is now active by default. You didn't need to specify the order since the default is ascending. Here's what the table looks like when the screen first loads:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/be2b1f68-131e-4634-8711-ca17e96217cb.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Table</kbd> demos: <a href="https://material-ui.com/demos/tables/">https://material-ui.com/demos/tables/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Filtering rows</h1>
                </header>
            
            <article>
                
<p>Where there are tables, there's potential for too much information. This is why adding a search feature to your tables is a good idea. It allows the user to remove irrelevant rows from the table as they type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have a table with lots of rows in it, meaning that the user is going to have a tough time scrolling through the entire table. To make things easier for them, you decide to add a search feature to your table that filters rows by checking <span>whether</span> the search text exists within the name column. Here's the code:</p>
<pre>import React, { useState, useEffect, Fragment } from 'react';<br/><br/>import { makeStyles } from '@material-ui/styles';<br/>import { withStyles } from '@material-ui/core/styles';<br/>import Table from '@material-ui/core/Table';<br/>import TableBody from '@material-ui/core/TableBody';<br/>import TableCell from '@material-ui/core/TableCell';<br/>import TableHead from '@material-ui/core/TableHead';<br/>import TableRow from '@material-ui/core/TableRow';<br/>import Paper from '@material-ui/core/Paper';<br/>import CircularProgress from '@material-ui/core/CircularProgress';<br/>import Input from '@material-ui/core/Input';<br/>import InputLabel from '@material-ui/core/InputLabel';<br/>import InputAdornment from '@material-ui/core/InputAdornment';<br/>import FormControl from '@material-ui/core/FormControl';<br/>import TextField from '@material-ui/core/TextField';<br/><br/>import SearchIcon from '@material-ui/icons/Search';<br/><br/>const fetchData = () =&gt;<br/>  new Promise(resolve =&gt; {<br/>    const items = [<br/>      {<br/>        id: 1,<br/>        name: 'First Item',<br/>        created: new Date(),<br/>        high: 2935,<br/>        low: 1924,<br/>        average: 2429.5<br/>      },<br/>      {<br/>        id: 2,<br/>        name: 'Second Item',<br/>        created: new Date(),<br/>        high: 439,<br/>        low: 231,<br/>        average: 335<br/>      },<br/>      {<br/>        id: 3,<br/>        name: 'Third Item',<br/>        created: new Date(),<br/>        high: 8239,<br/>        low: 5629,<br/>        average: 6934<br/>      },<br/>      {<br/>        id: 4,<br/>        name: 'Fourth Item',<br/>        created: new Date(),<br/>        high: 3203,<br/>        low: 3127,<br/>        average: 3165<br/>      },<br/>      {<br/>        id: 5,<br/>        name: 'Fifth Item',<br/>        created: new Date(),<br/>        high: 981,<br/>        low: 879,<br/>        average: 930<br/>      }<br/>    ];<br/><br/>    setTimeout(() =&gt; resolve(items), 1000);<br/>  });<br/><br/>const styles = theme =&gt; ({<br/>  root: { margin: theme.spacing(2), textAlign: 'center' },<br/>  progress: { margin: theme.spacing(2) },<br/>  search: { marginLeft: theme.spacing(2) }<br/>});<br/>const useStyles = makeStyles(styles);<br/><br/>const MaybeLoading = withStyles(styles)(({ classes, loading }) =&gt;<br/>  loading ? &lt;CircularProgress className={classes.progress} /&gt; : null<br/>);<br/><br/>export default function FilteringRows() {<br/>  const classes = useStyles();<br/>  const [search, setSearch] = useState('');<br/>  const [items, setItems] = useState([]);<br/>  const [loading, setLoading] = useState(true);<br/><br/>  useEffect(() =&gt; {<br/>    fetchData().then(items =&gt; {<br/>      setItems(items);<br/>      setLoading(false);<br/>    });<br/>  }, []);<br/><br/>  const onSearchChange = e =&gt; {<br/>    setSearch(e.target.value);<br/>  };<br/><br/>  return (<br/>    &lt;Fragment&gt;<br/>      &lt;TextField<br/>        value={search}<br/>        onChange={onSearchChange}<br/>        className={classes.search}<br/>        id="input-search"<br/>        InputProps={{<br/>          startAdornment: (<br/>            &lt;InputAdornment position="start"&gt;<br/>              &lt;SearchIcon /&gt;<br/>            &lt;/InputAdornment&gt;<br/>          )<br/>        }}<br/>      /&gt;<br/>      &lt;Paper className={classes.root}&gt;<br/>        &lt;Table&gt;<br/>          &lt;TableHead&gt;<br/>            &lt;TableRow&gt;<br/>              &lt;TableCell&gt;Name&lt;/TableCell&gt;<br/>              &lt;TableCell&gt;Created&lt;/TableCell&gt;<br/>              &lt;TableCell align="right"&gt;High&lt;/TableCell&gt;<br/>              &lt;TableCell align="right"&gt;Low&lt;/TableCell&gt;<br/>              &lt;TableCell align="right"&gt;Average&lt;/TableCell&gt;<br/>            &lt;/TableRow&gt;<br/>          &lt;/TableHead&gt;<br/>          &lt;TableBody&gt;<br/>            {items<br/>              .filter(item =&gt; !search || item.name.includes(search))<br/>              .map(item =&gt; {<br/>                return (<br/>                  &lt;TableRow key={item.id}&gt;<br/>                    &lt;TableCell component="th" scope="row"&gt;<br/>                      {item.name}<br/>                    &lt;/TableCell&gt;<br/>                    &lt;TableCell&gt;<br/>                      {item.created.toLocaleString()}<br/>                    &lt;/TableCell&gt;<br/>                    &lt;TableCell align="right"&gt;{item.high}&lt;/TableCell&gt;<br/>                    &lt;TableCell align="right"&gt;{item.low}&lt;/TableCell&gt;<br/>                    &lt;TableCell align="right"&gt;<br/>                      {item.average}<br/>                    &lt;/TableCell&gt;<br/>                  &lt;/TableRow&gt;<br/>                );<br/>              })}<br/>          &lt;/TableBody&gt;<br/>        &lt;/Table&gt;<br/>        &lt;MaybeLoading loading={loading} /&gt;<br/>      &lt;/Paper&gt;<br/>    &lt;/Fragment&gt;<br/>  );<br/>}</pre>
<p>Here's what the table and search input fields look like when the screen first loads:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/12f6ec74-4c3e-4b8b-a651-3c6eb5fe6bb2.png"/></p>
<p>The search input is just above the table. Try typing in a filter string, such as <span class="packt_screen">Fourth</span>—you should see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e635e51a-3080-441d-8d60-77bdb4aafb14.png"/></p>
<p>If you delete the filter text from the search input, all rows in the table data will be rendered again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's start by looking at the state of the <kbd>FilteringRows</kbd> component:</p>
<pre>const [search, setSearch] = useState('');<br/>const [items, setItems] = useState([]);<br/>const [loading, setLoading] = useState(true);</pre>
<p>The search string is the actual filter that changes the rows that are rendered within the <kbd>Table</kbd> element. Next, let's look at the <kbd>TextField</kbd> component that renders the search input:</p>
<pre>&lt;TextField<br/>  value={search}<br/>  onChange={onSearchChange}<br/>  className={classes.search}<br/>  id="input-search"<br/>  InputProps={{<br/>    startAdornment: (<br/>      &lt;InputAdornment position="start"&gt;<br/>        &lt;SearchIcon /&gt;<br/>      &lt;/InputAdornment&gt;<br/>    )<br/>  }}<br/>/&gt;</pre>
<p>The <kbd>onSearchChange()</kbd> function is responsible for maintaining the search state as the user types. You should render the search input component close to the table that it filters. In this example, the position of the search input feels like it belongs to the table.</p>
<p>Lastly, let's look at how the table rows are filtered and rendered:</p>
<pre>&lt;TableBody&gt;<br/>  {items<br/>    .filter(item =&gt; !search || item.name.includes(search))<br/>    .map(item =&gt; {<br/>      return (<br/>        &lt;TableRow key={item.id}&gt;<br/>          &lt;TableCell component="th" scope="row"&gt;<br/>            {item.name}<br/>          &lt;/TableCell&gt;<br/>          &lt;TableCell&gt;<br/>            {item.created.toLocaleString()}<br/>          &lt;/TableCell&gt;<br/>          &lt;TableCell align="right"&gt;{item.high}&lt;/TableCell&gt;<br/>          &lt;TableCell align="right"&gt;{item.low}&lt;/TableCell&gt;<br/>          &lt;TableCell align="right"&gt;<br/>            {item.average}<br/>          &lt;/TableCell&gt;<br/>        &lt;/TableRow&gt;<br/>      );<br/>    })}<br/>&lt;/TableBody&gt;</pre>
<p>Instead of calling <kbd>map()</kbd> directly on the item's state, <kbd>filter()</kbd> is used to produce an array of items that match the search criteria. As the <kbd>search</kbd> state changes, the <kbd>filter()</kbd> call is repeated. The condition that checks <span>whether</span> the item matches what the user has typed checks to see <span>whether</span> the <kbd>name</kbd> property of the item contains the search string. But first, you have to make sure that the user is actually filtering. For example, if the search string is empty, every item should be returned. How the item is searched is specific to your application—you could search every item property if you wanted to.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Table</kbd> demos: <a href="https://material-ui.com/demos/tables/">https://material-ui.com/demos/tables/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selecting rows</h1>
                </header>
            
            <article>
                
<p>Users often need to interact with specific rows in a table. For example, they might select a row and then perform an action that uses data from the selected row. Or, the user selects multiple rows, which produces new data related to their selection. With Material-UI tables, you can mark rows as selected using a single <kbd>TableRow</kbd> property.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>In this example, let's assume that the user needs to be able to select multiple rows in your table. As rows are selected, another section on the screen is updated with data that reflects the selected rows. Let's start by looking at the <kbd>Card</kbd> component, which displays data from the selected table rows:</p>
<pre>&lt;Card className={classes.card}&gt;<br/>  &lt;CardHeader title={`(${selections()}) rows selected`} /&gt;<br/>  &lt;CardContent&gt;<br/>    &lt;Grid container direction="column"&gt;<br/>      &lt;Grid item&gt;<br/>        &lt;Grid container justify="space-between"&gt;<br/>          &lt;Grid item&gt;<br/>            &lt;Typography&gt;Low&lt;/Typography&gt;<br/>          &lt;/Grid&gt;<br/>          &lt;Grid item&gt;<br/>            &lt;Typography&gt;{selectedLow()}&lt;/Typography&gt;<br/>          &lt;/Grid&gt;<br/>        &lt;/Grid&gt;<br/>      &lt;/Grid&gt;<br/>      &lt;Grid item&gt;<br/>        &lt;Grid container justify="space-between"&gt;<br/>          &lt;Grid item&gt;<br/>            &lt;Typography&gt;High&lt;/Typography&gt;<br/>          &lt;/Grid&gt;<br/>          &lt;Grid item&gt;<br/>            &lt;Typography&gt;{selectedHigh()}&lt;/Typography&gt;<br/>          &lt;/Grid&gt;<br/>        &lt;/Grid&gt;<br/>      &lt;/Grid&gt;<br/>      &lt;Grid item&gt;<br/>        &lt;Grid container justify="space-between"&gt;<br/>          &lt;Grid item&gt;<br/>            &lt;Typography&gt;Average&lt;/Typography&gt;<br/>          &lt;/Grid&gt;<br/>          &lt;Grid item&gt;<br/>            &lt;Typography&gt;{selectedAverage()}&lt;/Typography&gt;<br/>          &lt;/Grid&gt;<br/>        &lt;/Grid&gt;<br/>      &lt;/Grid&gt;<br/>    &lt;/Grid&gt;<br/>  &lt;/CardContent&gt;<br/>&lt;/Card&gt;</pre>
<p><span> Let's take a look at the rest of the components now:</span></p>
<pre>import React, { useState, Fragment } from 'react';<br/><br/>import { makeStyles } from '@material-ui/styles';<br/>import Typography from '@material-ui/core/Typography';<br/>import Grid from '@material-ui/core/Grid';<br/>import Table from '@material-ui/core/Table';<br/>import TableBody from '@material-ui/core/TableBody';<br/>import TableCell from '@material-ui/core/TableCell';<br/>import TableHead from '@material-ui/core/TableHead';<br/>import TableRow from '@material-ui/core/TableRow';<br/>import Paper from '@material-ui/core/Paper';<br/>import Card from '@material-ui/core/Card';<br/>import CardContent from '@material-ui/core/CardContent';<br/>import CardHeader from '@material-ui/core/CardHeader';<br/><br/>const useStyles = makeStyles(theme =&gt; ({<br/>  root: { margin: theme.spacing.unit * 2, textAlign: 'center' },<br/>  card: { margin: theme.spacing.unit * 2, maxWidth: 300 }<br/>}));<br/><br/>export default function SelectingRows() {<br/>  const classes = useStyles();<br/>  const [columns, setColumns] = useState([<br/>    { name: 'Name', active: false },<br/>    { name: 'Created', active: false },<br/>    { name: 'High', active: false, numeric: true },<br/>    { name: 'Low', active: false, numeric: true },<br/>    { name: 'Average', active: true, numeric: true }<br/>  ]);<br/>  const [rows, setRows] = useState([<br/>    {<br/>      id: 1,<br/>      name: 'First Item',<br/>      created: new Date(),<br/>      high: 2935,<br/>      low: 1924,<br/>      average: 2429.5<br/>    },<br/>    {<br/>      id: 2,<br/>      name: 'Second Item',<br/>      created: new Date(),<br/>      high: 439,<br/>      low: 231,<br/>      average: 335<br/>    },<br/>    {<br/>      id: 3,<br/>      name: 'Third Item',<br/>      created: new Date(),<br/>      high: 8239,<br/>      low: 5629,<br/>      average: 6934<br/>    },<br/>    {<br/>      id: 4,<br/>      name: 'Fourth Item',<br/>      created: new Date(),<br/>      high: 3203,<br/>      low: 3127,<br/>      average: 3165<br/>    },<br/>    {<br/>      id: 5,<br/>      name: 'Fifth Item',<br/>      created: new Date(),<br/>      high: 981,<br/>      low: 879,<br/>      average: 930<br/>    }<br/>  ]);<br/><br/>  const onRowClick = id =&gt; () =&gt; {<br/>    const newRows = [...rows];<br/>    const index = rows.findIndex(row =&gt; row.id === id);<br/>    const row = rows[index];<br/><br/>    newRows[index] = { ...row, selected: !row.selected };<br/>    setRows(newRows);<br/>  };<br/><br/>  const selections = () =&gt; rows.filter(row =&gt; row.selected).length;<br/><br/>  const selectedLow = () =&gt;<br/>    rows<br/>      .filter(row =&gt; row.selected)<br/>      .reduce((total, row) =&gt; total + row.low, 0);<br/><br/>  const selectedHigh = () =&gt;<br/>    rows<br/>      .filter(row =&gt; row.selected)<br/>      .reduce((total, row) =&gt; total + row.high, 0);<br/><br/>  const selectedAverage = () =&gt; (selectedLow() + selectedHigh()) / 2;<br/><br/>  return (<br/>    &lt;Fragment&gt;<br/>      &lt;Card className={classes.card}&gt;<br/>        ...<br/>      &lt;/Card&gt;<br/>      &lt;Paper className={classes.root}&gt;<br/>        &lt;Table&gt;<br/>          &lt;TableHead&gt;<br/>            &lt;TableRow&gt;<br/>              {columns.map(column =&gt; (<br/>                &lt;TableCell<br/>                  key={column.name}<br/>                  align={column.numeric ? 'right' : 'inherit'}<br/>                &gt;<br/>                  {column.name}<br/>                &lt;/TableCell&gt;<br/>              ))}<br/>            &lt;/TableRow&gt;<br/>          &lt;/TableHead&gt;<br/>          &lt;TableBody&gt;<br/>            {rows.map(row =&gt; (<br/>              &lt;TableRow<br/>                key={row.id}<br/>                onClick={onRowClick(row.id)}<br/>                selected={row.selected}<br/>              &gt;<br/>                &lt;TableCell component="th" scope="row"&gt;<br/>                  {row.name}<br/>                &lt;/TableCell&gt;<br/>                &lt;TableCell&gt;{row.created.toLocaleString()}&lt;/TableCell&gt;<br/>                &lt;TableCell align="right"&gt;{row.high}&lt;/TableCell&gt;<br/>                &lt;TableCell align="right"&gt;{row.low}&lt;/TableCell&gt;<br/>                &lt;TableCell align="right"&gt;{row.average}&lt;/TableCell&gt;<br/>              &lt;/TableRow&gt;<br/>            ))}<br/>          &lt;/TableBody&gt;<br/>        &lt;/Table&gt;<br/>      &lt;/Paper&gt;<br/>    &lt;/Fragment&gt;<br/>  );<br/>}</pre>
<p class="mce-root"/>
<p>Here's what the screen looks like when it first loads:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ba4e04ff-17c3-4a51-9181-5e6890c3b8a3.png"/></p>
<p>Now, you can try making some row selections. Here's what you'll see if you select the second and fourth rows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/aa0fef0d-d84c-41b6-b2c3-0794937e2d56.png"/></p>
<p>When you click on a table row, it changes visually so that the user can see that it is selected. Also note that the <kbd>Card</kbd> component contents change to reflect the selected rows. It also tells you how many rows are selected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>Card</kbd> component relies on a few helper functions:</p>
<ul>
<li><kbd>selectedLow</kbd></li>
<li><kbd>selectedHigh</kbd></li>
<li><kbd>selectedAverage</kbd></li>
</ul>
<p>The return values of these functions change when the table row selection changes. Let's take a closer look at how these values are computed:</p>
<pre>const selectedLow = () =&gt;<br/>  rows<br/>    .filter(row =&gt; row.selected)<br/>    .reduce((total, row) =&gt; total + row.low, 0);<br/><br/>const selectedHigh = () =&gt;<br/>  rows<br/>    .filter(row =&gt; row.selected)<br/>    .reduce((total, row) =&gt; total + row.high, 0);<br/><br/>const selectedAverage = () =&gt; (selectedLow() + selectedHigh()) / 2;</pre>
<p>The <kbd>selectedLow()</kbd> and <kbd>selectedHigh()</kbd> functions work the same way—they just operate on the <kbd>low</kbd> and <kbd>high</kbd> fields respectively. The <kbd>filter()</kbd> call is used to make sure that you're only working with selected rows. The <kbd>reduce()</kbd> call adds the values of the given field for the selected rows and returns the result as the property value. The <kbd>selectedAverage()</kbd> function uses the <kbd>selectedLow()</kbd> and <kbd>selectedHigh()</kbd> functions to compute a new average for the row selections.</p>
<p>Next, let's look at the handler that's called when a row is selected:</p>
<pre>const onRowClick = id =&gt; () =&gt; {<br/>  const newRows = [...rows];<br/>  const index = rows.findIndex(row =&gt; row.id === id);<br/>  const row = rows[index];<br/><br/>  newRows[index] = { ...row, selected: !row.selected };<br/>  setRows(newRows);<br/>};</pre>
<p>The <kbd>onRowClick()</kbd> function finds the selected row in the <kbd>rows</kbd> state based on the <kbd>id</kbd> argument. Then, it toggles the selected state of the row. As a result, the computed properties that you just looked at are updated, and so is the appearance of the row itself:</p>
<pre>&lt;TableRow<br/>  key={row.id}<br/>  onClick={onRowClick(row.id)}<br/>  selected={row.selected}<br/>&gt;</pre>
<p>The <kbd>TableRow</kbd> component has a <kbd>selected</kbd> property, which changes the style of the row to mark it as selected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Table</kbd> demos: <a href="https://material-ui.com/demos/tables/">https://material-ui.com/demos/tables/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Row actions</h1>
                </header>
            
            <article>
                
<p>Table rows often represent an object that you can perform actions on. For example, you might have a table of servers where each row represents a server that can be turned on or off. Instead of making your users click a link that takes them away from the table to perform an action, you can include common actions directly in each table row.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have a table with rows that have servers that can be turned on or off, depending on their current state. You want to include both of these actions as part of each table row, so that the user can more easily control their servers without spending lots of time navigating. <span>The buttons also need</span> to change their color and disabled state based on the state of the row.</p>
<p>Here's the code to do this:</p>
<pre>import React, { useState } from 'react';<br/><br/>import { makeStyles } from '@material-ui/styles';<br/>import Table from '@material-ui/core/Table';<br/>import TableBody from '@material-ui/core/TableBody';<br/>import TableCell from '@material-ui/core/TableCell';<br/>import TableHead from '@material-ui/core/TableHead';<br/>import TableRow from '@material-ui/core/TableRow';<br/>import Paper from '@material-ui/core/Paper';<br/>import IconButton from '@material-ui/core/IconButton';<br/><br/>import PlayArrowIcon from '@material-ui/icons/PlayArrow';<br/>import StopIcon from '@material-ui/icons/Stop';<br/><br/>const useStyles = makeStyles(theme =&gt; ({<br/>  root: { margin: theme.spacing(2), textAlign: 'center' },<br/>  button: {}<br/>}));<br/><br/>const StartButton = ({ row, onClick }) =&gt; (<br/>  &lt;IconButton<br/>    onClick={onClick}<br/>    color={row.status === 'off' ? 'primary' : 'default'}<br/>    disabled={row.status === 'running'}<br/>  &gt;<br/>    &lt;PlayArrowIcon fontSize="small" /&gt;<br/>  &lt;/IconButton&gt;<br/>);<br/><br/>const StopButton = ({ row, onClick }) =&gt; (<br/>  &lt;IconButton<br/>    onClick={onClick}<br/>    color={row.status === 'running' ? 'primary' : 'default'}<br/>    disabled={row.status === 'off'}<br/>  &gt;<br/>    &lt;StopIcon fontSize="small" /&gt;<br/>  &lt;/IconButton&gt;<br/>);<br/><br/>export default function RowActions() {<br/>  const classes = useStyles();<br/>  const [rows, setRows] = useState([<br/>    {<br/>      id: 1,<br/>      name: 'First Item',<br/>      status: 'running'<br/>    },<br/>    {<br/>      id: 2,<br/>      name: 'Second Item',<br/>      status: 'off'<br/>    },<br/>    {<br/>      id: 3,<br/>      name: 'Third Item',<br/>      status: 'off'<br/>    },<br/>    {<br/>      id: 4,<br/>      name: 'Fourth Item',<br/>      status: 'running'<br/>    },<br/>    {<br/>      id: 5,<br/>      name: 'Fifth Item',<br/>      status: 'off'<br/>    }<br/>  ]);<br/><br/>  const toggleStatus = id =&gt; () =&gt; {<br/>    const newRows = [...rows];<br/>    const index = rows.findIndex(row =&gt; row.id === id);<br/>    const row = rows[index];<br/><br/>    newRows[index] = {<br/>      ...row,<br/>      status: row.status === 'running' ? 'off' : 'running'<br/>    };<br/>    setRows(newRows);<br/>  };<br/><br/>  return (<br/>    &lt;Paper className={classes.root}&gt;<br/>      &lt;Table&gt;<br/>        &lt;TableHead&gt;<br/>          &lt;TableRow&gt;<br/>            &lt;TableCell&gt;Name&lt;/TableCell&gt;<br/>            &lt;TableCell&gt;Status&lt;/TableCell&gt;<br/>            &lt;TableCell&gt;Actions&lt;/TableCell&gt;<br/>          &lt;/TableRow&gt;<br/>        &lt;/TableHead&gt;<br/>        &lt;TableBody&gt;<br/>          {rows.map(row =&gt; {<br/>            return (<br/>              &lt;TableRow key={row.id}&gt;<br/>                &lt;TableCell component="th" scope="row"&gt;<br/>                  {row.name}<br/>                &lt;/TableCell&gt;<br/>                &lt;TableCell&gt;{row.status}&lt;/TableCell&gt;<br/>                &lt;TableCell&gt;<br/>                  &lt;StartButton<br/>                    row={row}<br/>                    onClick={toggleStatus(row.id)}<br/>                  /&gt;<br/>                  &lt;StopButton<br/>                    row={row}<br/>                    onClick={toggleStatus(row.id)}<br/>                  /&gt;<br/>                &lt;/TableCell&gt;<br/>              &lt;/TableRow&gt;<br/>            );<br/>          })}<br/>        &lt;/TableBody&gt;<br/>      &lt;/Table&gt;<br/>    &lt;/Paper&gt;<br/>  );<br/>}</pre>
<p>Here's what the screen looks like when it first loads:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/35feccdc-ed17-4395-8cba-c7d2f7277c2c.png" style="width:34.50em;height:21.17em;"/></p>
<p>Depending on the status of the row data, the action buttons will show differently. For example, in the first row, the start button is disabled because <kbd>status</kbd> is <kbd>running</kbd>. The second row has a disabled stop button because the <kbd>status</kbd> is <kbd>off</kbd>. Let's try clicking on the stop button in the first row and the start button in the second row. Here's how the UI changes once this is done:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2fa663ae-417c-4c41-8444-818dc9e94b9f.png" style="width:35.25em;height:21.42em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's start by looking at the two components that are used as the row actions:</p>
<pre>const StartButton = ({ row, onClick }) =&gt; (<br/>  &lt;IconButton<br/>    onClick={onClick}<br/>    color={row.status === 'off' ? 'primary' : 'default'}<br/>    disabled={row.status === 'running'}<br/>  &gt;<br/>    &lt;PlayArrowIcon fontSize="small" /&gt;<br/>  &lt;/IconButton&gt;<br/>);<br/><br/>const StopButton = ({ row, onClick }) =&gt; (<br/>  &lt;IconButton<br/>    onClick={onClick}<br/>    color={row.status === 'running' ? 'primary' : 'default'}<br/>    disabled={row.status === 'off'}<br/>  &gt;<br/>    &lt;StopIcon fontSize="small" /&gt;<br/>  &lt;/IconButton&gt;<br/>);</pre>
<p>The <kbd>StartButton</kbd> and <kbd>StopButton</kbd> components are very similar. Both of these components are rendered in every row of the table. There's the <kbd>onClick</kbd> property, a function that changes the state of the row data when clicked. The <kbd>color</kbd> of the icon changes based on the <kbd>status</kbd> of the row. Likewise, the <kbd>disabled</kbd> property changes based on the <kbd>status</kbd> of the row.</p>
<p>Next, let's look at the <kbd>toggleStatus()</kbd> handler, which changes the status state of the row when an action button is clicked:</p>
<pre>const toggleStatus = id =&gt; () =&gt; {<br/>  const newRows = [...rows];<br/>  const index = rows.findIndex(row =&gt; row.id === id);<br/>  const row = rows[index];<br/><br/>  newRows[index] = {<br/>    ...row,<br/>    status: row.status === 'running' ? 'off' : 'running'<br/>  };<br/>  setRows(newRows);<br/>};</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>StartButton</kbd> and <kbd>StopButton</kbd> components both use the same handler function—it toggles the <kbd>status</kbd> value between <kbd>running</kbd> and <kbd>off</kbd>. Finally, let's look at the <kbd>TableCell</kbd> component where these <kbd>row</kbd> actions are rendered:</p>
<pre>&lt;TableCell&gt;<br/>  &lt;StartButton<br/>    row={row}<br/>    onClick={toggleStatus(row.id)}<br/>  /&gt;<br/>  &lt;StopButton<br/>    row={row}<br/>    onClick={toggleStatus(row.id)}<br/>  /&gt;<br/>&lt;/TableCell&gt;</pre>
<p>The row data is passed as the <kbd>row</kbd> property. The <kbd>toggleStatus()</kbd> function takes a <kbd>row id</kbd> argument and returns a new handler function that acts on this row.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Table</kbd> demos: <a href="https://material-ui.com/demos/tables/">https://material-ui.com/demos/tables/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>