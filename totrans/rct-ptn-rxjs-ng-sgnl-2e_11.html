<html><head></head><body>
<div id="_idContainer077">
<h1 class="chapter-number" id="_idParaDest-164"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-165"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.2.1">Performing Bulk Operations</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.3.1">Bulk operations</span></strong><span class="koboSpan" id="kobo.4.1"> are tasks </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.5.1">performed on a large scale, such as uploading many files at once, deleting or inserting many items in one shot, or applying a transformation or computation to multiple elements of a </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">list simultaneously.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">These operations are designed to handle multiple updates in a single operation, often resulting in improved efficiency and performance compared to when each item is processed separately. </span><span class="koboSpan" id="kobo.7.2">Tracking the progress of bulk operations is crucial to provide feedback to users, monitor the health of the operation, and identify </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">potential issues.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we will start by explaining the bulk operation requirement and the type of bulk operation that we will consider. </span><span class="koboSpan" id="kobo.9.2">After that, we will walk you through the different steps to implement the reactive pattern for implementing bulk operations. </span><span class="koboSpan" id="kobo.9.3">Finally, we will learn the reactive pattern for tracking the bulk </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">operation’s progress.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Defining the bulk </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">operation requirements</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Learning the reactive pattern for </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">bulk operations</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Learning the reactive pattern for tracking the bulk </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">operation’s progress</span></span></li>
</ul>
<h1 id="_idParaDest-166"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">This chapter assumes that you have a basic understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">of RxJS.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">The source code of this chapter is available </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">at </span></span><a href="https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap11"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap11</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.25.1">.</span></span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.26.1">Defining the bulk operation requirements</span></h1>
<p><span class="koboSpan" id="kobo.27.1">In </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.28.1">web applications, a bulk operation is represented by one action or event; however, in the background, there are two </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">possible behaviors:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.30.1">Running one network request for all </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">the tasks</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Running parallel network requests for </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">every task</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.34.1">In this chapter, we will be using the second behavior. </span><span class="koboSpan" id="kobo.34.2">We want to allow the user to upload the recipe images at once, track the progress of the upload operation, and display a progress bar to the user. </span><span class="koboSpan" id="kobo.34.3">We can see what this will look </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">like here:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.36.1"><img alt="Figure 11.1 – Uploading the recipe’s images" src="image/B21180_11_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.37.1">Figure 11.1 – Uploading the recipe’s images</span></p>
<p><span class="koboSpan" id="kobo.38.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">RecipeCreation</span></strong><span class="koboSpan" id="kobo.40.1"> interface, we will be changing the layout of the </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">ImageUrl</span></strong><span class="koboSpan" id="kobo.42.1"> field to the </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">File Upload</span></strong><span class="koboSpan" id="kobo.44.1"> layout available in our library of components, PrimeNG, as shown in the screenshot. </span><span class="koboSpan" id="kobo.44.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.45.1">File Upload</span></strong><span class="koboSpan" id="kobo.46.1"> layout allows the user to choose multiple files, clear the selection, and upload </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">the files.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">The upload will be done on the server, and we have a specific service for the upload that takes both the file to be uploaded and the identifier of the associated recipe as input. </span><span class="koboSpan" id="kobo.48.2">Since the backend upload API supports only one file at a time, we will be running </span><em class="italic"><span class="koboSpan" id="kobo.49.1">N</span></em><span class="koboSpan" id="kobo.50.1"> network requests in parallel to upload </span><em class="italic"><span class="koboSpan" id="kobo.51.1">N</span></em><span class="koboSpan" id="kobo.52.1"> files (i.e., if we upload two files, two requests will be sent). </span><span class="koboSpan" id="kobo.52.2">This is the bulk change use case that we will consider in </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">In the UI, we will</span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.55.1"> have one event that will trigger multiple requests at the same time. </span><span class="koboSpan" id="kobo.55.2">The following diagram provides a graphical representation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">bulk operation:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<span class="koboSpan" id="kobo.57.1"><img alt="Figure 11.2 – A bulk operation visualization" src="image/B21180_11_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.58.1">Figure 11.2 – A bulk operation visualization</span></p>
<p><span class="koboSpan" id="kobo.59.1">So, to sum up, we </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.60.1">want to do </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.62.1">Allow the user to upload many files after clicking only once on the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.63.1">Upload</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.64.1"> button</span></span></li>
<li><span class="koboSpan" id="kobo.65.1">Display the progress of this </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">bulk operation</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.67.1">Now that we have defined the requirement, let’s see how we can implement it in a </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">reactive way.</span></span></p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.69.1">Learning the reactive pattern for bulk operations</span></h1>
<p><span class="koboSpan" id="kobo.70.1">As usual, we have to consider</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.71.1"> our tasks as streams. </span><span class="koboSpan" id="kobo.71.2">As the task </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.72.1">that we are going to perform is uploading the recipe image in the backend, let’s imagine a stream called </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">uploadRecipeImage$</span></strong><span class="koboSpan" id="kobo.74.1"> that will take the file and the recipe identifier as input and perform an HTTP request. </span><span class="koboSpan" id="kobo.74.2">If we have </span><em class="italic"><span class="koboSpan" id="kobo.75.1">N</span></em><span class="koboSpan" id="kobo.76.1"> files to be uploaded, then we will create </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.77.1">N</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.78.1"> streams.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">We want to subscribe to all those streams together, but we are not interested in the values emitted from each stream</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.80.1"> through the process. </span><span class="koboSpan" id="kobo.80.2">Instead, we only care about the final result (the last emission) – whether the file is uploaded successfully, or </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.81.1">something wrong happens and the </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">upload fails.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">Is there an RxJS operator that gathers a list of Observables together to get a cumulative result? </span><span class="koboSpan" id="kobo.83.2">Thankfully, yes: we have the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">forkJoin</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.85.1"> operator.</span></span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.86.1">The forkJoin operator</span></h2>
<p><span class="koboSpan" id="kobo.87.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">forkJoin</span></strong><span class="koboSpan" id="kobo.89.1"> operator</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.90.1"> falls under the category of combination operators. </span><span class="koboSpan" id="kobo.90.2">If we look at the official documentation, we find </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">this definition:</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.92.1">“Accepts an Array of ObservableInput or a dictionary Object of ObservableInput and returns an Observable that emits either an array of values in the exact same order as the passed array, or a dictionary of values in the same shape as the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.93.1">passed dictionary.”</span></em></span></p>
<p><span class="koboSpan" id="kobo.94.1">In other words, </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">forkJoin</span></strong><span class="koboSpan" id="kobo.96.1"> takes a list of Observables as input, waits for the Observables to complete, and then combines the last values they emitted in one array and returns it. </span><span class="koboSpan" id="kobo.96.2">The order of the values in the resulting array is the same as the order of the </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">input Observables.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">Let’s consider the following marble diagram to better </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">understand this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<span class="koboSpan" id="kobo.100.1"><img alt="Figure 11.3 – A forkJoin marble diagram" src="image/B21180_11_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.101.1">Figure 11.3 – A forkJoin marble diagram</span></p>
<p><span class="koboSpan" id="kobo.102.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">forkJoin</span></strong><span class="koboSpan" id="kobo.104.1"> has three</span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.105.1"> input Observables (represented by the three timelines before the </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">operator box).</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">The first Observable emitted the </span><strong class="bold"><span class="koboSpan" id="kobo.108.1">a</span></strong><span class="koboSpan" id="kobo.109.1"> value, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">forkJoin</span></strong><span class="koboSpan" id="kobo.111.1"> does not emit anything (look at the last timeline after the operator box, which represented the returned result </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">forkJoin</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">Then, the third Observable emitted </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">1</span></strong><span class="koboSpan" id="kobo.117.1">, and, again, nothing was emitted by </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">forkJoin</span></strong><span class="koboSpan" id="kobo.119.1">. </span><span class="koboSpan" id="kobo.119.2">Why? </span><span class="koboSpan" id="kobo.119.3">Because, as we said in the definition, </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">forkJoin</span></strong><span class="koboSpan" id="kobo.121.1"> will emit only once when all the Observables </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">are complete.</span></span></p>
<p><span class="koboSpan" id="kobo.123.1">So, as illustrated in the marble diagram, </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">forkJoin</span></strong><span class="koboSpan" id="kobo.125.1"> emitted only once when the last Observable (the second one) completed. </span><span class="koboSpan" id="kobo.125.2">Let’s break </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">this down:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.127.1">The third Observable (represented by the third timeline) completed first, and the last value emitted </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">was </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.129.1">4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.131.1">Then, the first Observable (represented by the first timeline) completed, and the last value emitted was </span><strong class="bold"><span class="koboSpan" id="kobo.132.1">e</span></strong><span class="koboSpan" id="kobo.133.1">. </span><span class="koboSpan" id="kobo.133.2">At that time, </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">forkJoin</span></strong><span class="koboSpan" id="kobo.135.1"> did not emit any value because there was still an </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">Observable running.</span></span></li>
<li><span class="koboSpan" id="kobo.137.1">Finally, the last Observable (represented by the second timeline) completed, and the last value emitted was </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">j</span></strong><span class="koboSpan" id="kobo.139.1">. </span><span class="koboSpan" id="kobo.139.2">Therefore, </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">forkJoin</span></strong><span class="koboSpan" id="kobo.141.1"> returns an array containing the results of each stream in the order of the input Observables (</span><strong class="bold"><span class="koboSpan" id="kobo.142.1">e</span></strong><span class="koboSpan" id="kobo.143.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.144.1">j</span></strong><span class="koboSpan" id="kobo.145.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.147.1">4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">).</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.149.1">The order of completion is not considered; otherwise, we would have had </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">[4,e,j]</span></strong><span class="koboSpan" id="kobo.151.1">. </span><span class="koboSpan" id="kobo.151.2">Even though the third Observable was completed before the first and second one, </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">forkJoin</span></strong><span class="koboSpan" id="kobo.153.1"> respected the order of the input Observables and returned the </span><strong class="bold"><span class="koboSpan" id="kobo.154.1">e</span></strong><span class="koboSpan" id="kobo.155.1"> value before the </span><strong class="bold"><span class="koboSpan" id="kobo.156.1">4</span></strong><span class="koboSpan" id="kobo.157.1"> and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.158.1">j</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.159.1"> values.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">So, keep in </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.161.1">mind that </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">forkJoin</span></strong><span class="koboSpan" id="kobo.163.1"> emits once when all the input Observables are complete and preserves the order of the </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">input Observables.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">This fits our requirements well! </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">forkJoin</span></strong><span class="koboSpan" id="kobo.167.1"> is best used when you have a list of Observables and only care about the final emitted value of each. </span><span class="koboSpan" id="kobo.167.2">That’s what we want to do. </span><span class="koboSpan" id="kobo.167.3">In our case, we will issue multiple upload requests, and we only want to take action when a response is received from all the </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">input streams.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">Let’s now see the bulk operation reactive pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">in action.</span></span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.171.1">The bulk operation reactive pattern</span></h2>
<p><span class="koboSpan" id="kobo.172.1">To utilize the pattern in our recipe app, first, we need to</span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.173.1"> create a new service called </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">UploadRecipesPreviewService</span></strong><span class="koboSpan" id="kobo.175.1"> under </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">src/app/core/services</span></strong><span class="koboSpan" id="kobo.177.1">, which is responsible for uploading the files. </span><span class="koboSpan" id="kobo.177.2">Here is the </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">service’s code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.179.1">
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { UploadStatus } from '../model/upload.status.model';
import { environment } from 'src/environments/environment';
const BASE_PATH = environment.basePath
@Injectable({
  providedIn: 'root'
})
export class UploadRecipesPreviewService {
  constructor(private http: HttpClient) { }
  upload(recipeId: number|undefined|null, fileToUpload:
  File): Observable&lt;UploadStatus&gt; {
    const formData = new FormData()
    formData.append('fileToUpload', fileToUpload as File)
    return this.http.post&lt; UploadStatus &gt;(
      `${BASE_PATH}/recipes/upload/${recipeId}`,
      formData
    )
  }
}</span></pre> <p><span class="koboSpan" id="kobo.180.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">upload</span></strong><span class="koboSpan" id="kobo.182.1"> method</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.183.1"> issues the HTTP upload request and returns the upload status (whether having succeeded or failed). </span><span class="koboSpan" id="kobo.183.2">This method takes two parameters </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">as input:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">recipeId</span></strong><span class="koboSpan" id="kobo.186.1">: The identifier of </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">the recipe</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">fileToUpload</span></strong><span class="koboSpan" id="kobo.189.1">: The file to </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">be uploaded</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.191.1">Then we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">FormData</span></strong><span class="koboSpan" id="kobo.193.1"> to send the file to the server. </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">FormData</span></strong><span class="koboSpan" id="kobo.195.1"> is an object in JavaScript that allows you to easily build a set of key-value pairs representing form fields and their </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">values respectively.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">Now we need to implement the behavior of the </span><strong class="bold"><span class="koboSpan" id="kobo.198.1">Upload</span></strong><span class="koboSpan" id="kobo.199.1"> button. </span><span class="koboSpan" id="kobo.199.2">For this purpose, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">RecipeCreationComponent</span></strong><span class="koboSpan" id="kobo.201.1"> template, we need to specify the method that will be called when clicking on the </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">Upload</span></strong><span class="koboSpan" id="kobo.203.1"> button – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">onUpload</span></strong><span class="koboSpan" id="kobo.205.1"> method in our case – and put it as a value to the callback – </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">uploadHandler</span></strong><span class="koboSpan" id="kobo.207.1"> – provided by the component library we are using to get triggered when the user uploads the files. </span><span class="koboSpan" id="kobo.207.2">Here’s the HTML </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">template snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.209.1">
    &lt;div class="form-row"&gt;
        &lt;div class="col-12"&gt;
            &lt;label for="ImageUrl"&gt;ImageUrl&lt;/label&gt;
            &lt;p-fileUpload name="imageUrl" [multiple]=true
                [customUpload]="true" (uploadHandler)=
                    "onUpload($event.files)"&gt;
            &lt;/p-fileUpload&gt;
        &lt;/div&gt;
    &lt;/div&gt;</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.210.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.211.1">Some of the code in the template has been removed here for brevity. </span><span class="koboSpan" id="kobo.211.2">You can find the full template code in the book’s GitHub repository, the link for which can be found in the </span><em class="italic"><span class="koboSpan" id="kobo.212.1">Technical </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.213.1">requirements</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.214.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">Next, we </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.216.1">need to implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">onUpload</span></strong><span class="koboSpan" id="kobo.218.1"> method and define our reactive streams in </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">RecipeCreationComponent</span></strong><span class="koboSpan" id="kobo.220.1">. </span><span class="koboSpan" id="kobo.220.2">So, we will define </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.222.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.224.1"> that will always emit the last value of the uploaded files, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">uploadedFilesSubject$</span></strong><span class="koboSpan" id="kobo.226.1">, and initialize it with an </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">empty array:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.228.1">
uploadedFilesSubject$ = new BehaviorSubject&lt;File[]&gt;([]);</span></pre></li> <li><span class="koboSpan" id="kobo.229.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">onUpload (files: File[])</span></strong><span class="koboSpan" id="kobo.231.1"> method, which is called when clicking on the </span><strong class="bold"><span class="koboSpan" id="kobo.232.1">Upload</span></strong><span class="koboSpan" id="kobo.233.1"> button. </span><span class="koboSpan" id="kobo.233.2">Here, we will update the emissions of </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">uploadedFilesSubject$</span></strong><span class="koboSpan" id="kobo.235.1"> with the last array of uploaded files </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.237.1">
  onUpload(files: File[]) {
    this.uploadedFilesSubject$.next(files);
  }</span></pre></li> <li><span class="koboSpan" id="kobo.238.1">A stream called </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">uploadRecipeImages$</span></strong><span class="koboSpan" id="kobo.240.1"> that is responsible for doing the bulk upload </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.242.1">
  uploadRecipeImages$ =
  this.uploadedFilesSubject$.pipe(
      switchMap(uploadedFiles=&gt;forkJoin(
      uploadedFiles.map((file: File) =&gt;
        this.uploadService.upload(
        this.recipeForm.value.id, file))))
  )</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.243.1">Let’s break down </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.244.1">what’s going on in the code here, piece </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">by piece.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.246.1">Every time we click on the </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">Upload</span></strong><span class="koboSpan" id="kobo.248.1"> button, </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">uploadedFilesSubject$</span></strong><span class="koboSpan" id="kobo.250.1"> will emit the files to be uploaded. </span><span class="koboSpan" id="kobo.250.2">We need to listen to </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">uploadedFilesSubject$</span></strong><span class="koboSpan" id="kobo.252.1"> emissions, and then use </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">switchMap</span></strong><span class="koboSpan" id="kobo.254.1"> (which we learned about in </span><a href="B21180_06.xhtml#_idTextAnchor097"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.255.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.256.1">, </span><em class="italic"><span class="koboSpan" id="kobo.257.1">Transforming Streams</span></em><span class="koboSpan" id="kobo.258.1">) to transform every value emitted by </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">uploadedFilesSubject$</span></strong><span class="koboSpan" id="kobo.260.1"> to the Observable that will be built </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">forkJoin</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.264.1">To </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">forkJoin</span></strong><span class="koboSpan" id="kobo.266.1">, we pass an array of the Observables responsible for uploading each file. </span><span class="koboSpan" id="kobo.266.2">We built the array of Observables by mapping every file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">uploadedFiles</span></strong><span class="koboSpan" id="kobo.268.1"> array to the stream, resulting from calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">upload</span></strong><span class="koboSpan" id="kobo.270.1"> method available in </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">UploadRecipesPreviewService</span></strong><span class="koboSpan" id="kobo.272.1"> that takes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">id</span></strong><span class="koboSpan" id="kobo.274.1"> property of the recipe (which we retrieved from </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">recipeForm</span></strong><span class="koboSpan" id="kobo.276.1">) and the file </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">as input.</span></span></p></li> </ul>
<p><span class="koboSpan" id="kobo.278.1">Now that we’ve established our upload logic and defined the upload stream, it’s time to subscribe to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">uploadRecipeImages$</span></strong><span class="koboSpan" id="kobo.280.1"> stream. </span><span class="koboSpan" id="kobo.280.2">We need to inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">UploadRecipesPreviewService</span></strong><span class="koboSpan" id="kobo.282.1"> into the constructor and subscribe to </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">uploadRecipeImages$</span></strong><span class="koboSpan" id="kobo.284.1"> in the template, </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.286.1">
&lt;ng-container *ngIf="uploadRecipeImages$ | async"&gt;&lt;/ng-
  container&gt;</span></pre> <p><span class="koboSpan" id="kobo.287.1">Now, let’s suppose one of the inner streams errors out. </span><span class="koboSpan" id="kobo.287.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">forkJoin</span></strong><span class="koboSpan" id="kobo.289.1"> operator will no longer emit any values for us. </span><span class="koboSpan" id="kobo.289.2">This is another important thing to be aware of when using this operator. </span><span class="koboSpan" id="kobo.289.3">You will lose the value of any other stream that would have already been completed if you do not catch the error correctly on the inner Observable. </span><span class="koboSpan" id="kobo.289.4">Therefore, catching the error in this case </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">is crucial!</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">This is how we </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">handle it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.293.1">
  uploadRecipeImages$ = this.uploadedFilesSubject$.pipe(
    switchMap(uploadedFiles=&gt;forkJoin(uploadedFiles.map((
      file: File) =&gt;
      this.uploadService.upload(this.recipeForm.value.id,
        file).pipe(
          catchError(errors =&gt; of(errors)),
      ))))</span></pre> <p><span class="koboSpan" id="kobo.294.1">Here, we called </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">catchError</span></strong><span class="koboSpan" id="kobo.296.1"> on the inner stream returned by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">upload</span></strong><span class="koboSpan" id="kobo.298.1"> method. </span><span class="koboSpan" id="kobo.298.2">Then, we wrapped the error inside another Observable and returned it. </span><span class="koboSpan" id="kobo.298.3">This way, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">forkJoin</span></strong><span class="koboSpan" id="kobo.300.1"> stream will stay alive and </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">emit values.</span></span></p>
<p><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.302.1">It makes a lot of sense to catch the errors in order to display something significant to the user – for example, in our case, if one of the uploads fails because the maximum image file size was reached or the extension of the image is not allowed, then the system should display such an exception to the user to help them fix </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">the file.</span></span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.304.1">Benefits of the forkJoin operator</span></h2>
<p><span class="koboSpan" id="kobo.305.1">To sum up, </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">forkJoin</span></strong><span class="koboSpan" id="kobo.307.1"> has the</span><a id="_idIndexMarker498"/> <span class="No-Break"><span class="koboSpan" id="kobo.308.1">following benefits:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.309.1">It is very useful when you are interested in combining results and getting a value </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">only once</span></span></li>
<li><span class="koboSpan" id="kobo.311.1">It only emits </span><em class="italic"><span class="koboSpan" id="kobo.312.1">once</span></em><span class="koboSpan" id="kobo.313.1">, when all the </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">Observables complete</span></span></li>
<li><span class="koboSpan" id="kobo.315.1">It preserves the order of the input Observables in </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">the emission</span></span></li>
<li><span class="koboSpan" id="kobo.317.1">It will complete when one of the </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.318.1">streams errors out, so make sure you handle </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">the error</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.320.1">Now, at this point, our code works nicely. </span><span class="koboSpan" id="kobo.320.2">But what if we need to know some information during the process, such as how many files were already uploaded? </span><span class="koboSpan" id="kobo.320.3">What is the progress of the operation? </span><span class="koboSpan" id="kobo.320.4">How much time do we still need </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">to wait?</span></span></p>
<p><span class="koboSpan" id="kobo.322.1">With the current </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">forkJoin</span></strong><span class="koboSpan" id="kobo.324.1"> implementation, it is not possible, but let’s see how we can do it in the </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">next section.</span></span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.326.1">Learning the reactive pattern for tracking the bulk operation’s progress</span></h1>
<p><span class="koboSpan" id="kobo.327.1">Tracking</span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.328.1"> the progress of bulk operations is very important, as it provides feedback to the user and can identify potential issues. </span><span class="koboSpan" id="kobo.328.2">When it comes to approaches for tracking progress, there are different strategies and techniques depending on the nature of the bulk operation and the technology stack you’re using. </span><span class="koboSpan" id="kobo.328.3">For example, you can use an increment counter to show when each operation is processed, use a percentage to track the progress of the operations, or even log the progress to a file </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">or database.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">In the case of our recipe app, in order to track the</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.331.1"> progress of the bulk upload, we will use the percentage of completion strategy. </span><span class="koboSpan" id="kobo.331.2">To implement this strategy, we will use a very useful operator </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">finalize</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.335.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">finalize</span></strong><span class="koboSpan" id="kobo.337.1"> operator allows you to call a function when the Observable completes or errors out. </span><span class="koboSpan" id="kobo.337.2">The idea is to call this operator and execute a function that will calculate the progress. </span><span class="koboSpan" id="kobo.337.3">This way, every time an Observable completes, the progress will </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">get updated.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">This is what the code will </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">look like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.341.1">
  counter: number = 0;
  uploadProgress: number=0;
uploadRecipeImages$ = this.uploadedFilesSubject$.pipe(
  switchMap(uploadedFiles =&gt;
  forkJoin(uploadedFiles.map((file: File) =&gt;
    this.uploadService.upload(this.recipeForm.value.id,
      file).pipe(
        catchError(errors =&gt; of(errors)),
        finalize(() =&gt; this.calculateProgressPercentage(
          ++this.counter, uploadedFiles.length))
      ))))
  )
  private calculateProgressPercentage(completedRequests:
  number, totalRequests: number) {
    this.uploadProgress =
      Math.round((completedRequests / totalRequests) *
        100);
  }
onUpload(files: File[]) {
  this.uploadProgress=0;
  this.counter=0;
  this.uploadedFilesSubject$.next(files);
}</span></pre> <p><span class="koboSpan" id="kobo.342.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">finalize</span></strong><span class="koboSpan" id="kobo.344.1"> operator calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">calculateProgressPercentage</span></strong><span class="koboSpan" id="kobo.346.1"> private function that takes the </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">following parameters:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.348.1">The number of completed requests</span></em><span class="koboSpan" id="kobo.349.1">: We just declare a </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">counter</span></strong><span class="koboSpan" id="kobo.351.1"> property that we will increment every time the </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">Observable completes</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.353.1">The total number of requests</span></em><span class="koboSpan" id="kobo.354.1">: This number is retrieved from the array </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">uploadedFiles</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.357.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">calculateProgressPercentage</span></strong><span class="koboSpan" id="kobo.359.1"> function, we perform a simple computation to</span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.360.1"> identify the completion percentage and store the result in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">uploadProgress</span></strong><span class="koboSpan" id="kobo.362.1"> property. </span><span class="koboSpan" id="kobo.362.2">When the user clicks on </span><strong class="bold"><span class="koboSpan" id="kobo.363.1">Upload</span></strong><span class="koboSpan" id="kobo.364.1">, both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">uploadProgress</span></strong><span class="koboSpan" id="kobo.366.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">counter</span></strong><span class="koboSpan" id="kobo.368.1"> properties should be reset </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">Then, you can map the value of this property to any </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">ProgressBar</span></strong><span class="koboSpan" id="kobo.374.1"> component in the UI. </span><span class="koboSpan" id="kobo.374.2">In our case, we used the PrimeNG </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">p-progressBar</span></strong><span class="koboSpan" id="kobo.376.1"> component </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.378.1">
    &lt;div class="row"&gt;
        &lt;div class="col-12"&gt;
            &lt;label for="ImageUrl"&gt;ImageUrl&lt;/label&gt;
            &lt;!-- &lt;input type="text" name="imageUrl"
            formControlName="imageUrl"&gt; --&gt;
            &lt;p-fileUpload name="imageUrl" [multiple]=true
                [customUpload]="true"
                (uploadHandler)="onUpload($event.files)"
                accept="image/*"&gt;&lt;/p-fileUpload&gt;
            @if(uploadProgress&gt;0) {
            &lt;p-progressBar [value]=uploadProgress&gt;
                &lt;/p-progressBar&gt;
            }
        &lt;/div&gt;
    &lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.379.1">Here, we only display </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">p-progressBar</span></strong><span class="koboSpan" id="kobo.381.1"> when the upload is in progress (</span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">uploadProgress&gt;0</span></strong><span class="koboSpan" id="kobo.383.1">) and we pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">uploadProgress</span></strong><span class="koboSpan" id="kobo.385.1"> value as input to the progress component. </span><span class="koboSpan" id="kobo.385.2">This</span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.386.1"> way, you will be able to display the progress to </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">Here is the result in </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">our app:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<span class="koboSpan" id="kobo.390.1"><img alt="Figure 11.4 – The file upload progress bar" src="image/B21180_11_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.391.1">Figure 11.4 – The file upload progress bar</span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.392.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.393.1">In this chapter, we explained the concept of bulk operation and learned how to implement a real-world example of a bulk task in a reactive way. </span><span class="koboSpan" id="kobo.393.2">We learned the behavior and a use case of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">forkJoin</span></strong><span class="koboSpan" id="kobo.395.1"> operator and went through the different steps to implement a bulk upload. </span><span class="koboSpan" id="kobo.395.2">Finally, we went through a reactive technique to implement the tracking progress functionality using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">finalize</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.397.1"> operator.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">In the next chapter, we will explore the pattern of real-time updates and the different techniques available in RxJS to implement them at the </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">lowest cost.</span></span></p>
</div>
</body></html>