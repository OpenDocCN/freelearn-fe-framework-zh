- en: Redux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux
- en: Maintaining and controlling state in an app is something that quickly becomes
    complicated as soon as our app is larger than a Todo app, especially if we have
    multiple views, models, and dependencies between them. The situation is complicated
    by multiple types of states, such as cached data, server responses, and data that
    only lives locally when you work with the app. Changing the state is made more
    complicated because multiple actors, synchronous, and asynchronous code can change
    the state. The end result with a growing app is, sooner or later, a non-deterministic
    system. The problem with such a system is that you lose predictability, which
    in turn means you may have bugs that are hard to produce, and it makes the app
    and its data hard to reason with. We crave order and predictability, but we get
    neither.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个应用中维护和控制状态，当我们的应用比Todo应用更大时，这会迅速变得复杂，尤其是如果我们有多个视图、模型以及它们之间的依赖关系。多种状态类型，如缓存数据、服务器响应以及当你与该应用一起工作时仅在本地存在的数据，使得情况更加复杂。由于多个参与者、同步和异步代码可以更改状态，更改状态变得更加复杂。随着应用的不断增长，最终结果是一个非确定性的系统。这样的系统的问题是，你失去了可预测性，这反过来意味着你可能会有难以复现的bug，并且使得应用及其数据难以推理。我们渴望秩序和可预测性，但我们两者都没有。
- en: To try to address the problem, we covered the Flux pattern in a previous chapter.
    All is well and good, right? We don't need another pattern. Or do we? Well, Flux
    has problems. One of the problems is that your data is divided up into several
    stores. Why is that a problem, you wonder? Imagine you have an action that triggers
    in multiple stores. It's easy to forget to handle an action in all stores. So,
    that issue is more of a management problem. Another problem with multiple stores
    is that it's hard to get a good overview of what your state consists of. Updates
    are another problem we have with Flux. Sometimes you have a lot of updates; updating
    the state and the order matters. In Flux, this is handled with a construct called
    `waitFor`. The idea is that you should be able to specify what should happen in
    which order. That's all well and good, but imagine that this is spread out over
    many modules; it becomes hard to keep track of and is thereby error prone.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试解决这个问题，我们在前一章中介绍了Flux模式。一切都很顺利，对吧？我们不需要另一个模式。或者我们需要吗？好吧，Flux有问题。其中一个问题是你的数据被分割成几个存储。你可能会想，那有什么问题呢？想象一下你有一个在多个存储中触发的动作。很容易忘记在所有存储中处理一个动作。所以，这个问题更多的是一个管理问题。多个存储的另一个问题是，很难获得一个关于你的状态构成的良好概览。更新是我们与Flux的另一个问题。有时你有很多更新；更新状态和顺序很重要。在Flux中，这是通过一个称为`waitFor`的结构来处理的。想法是，你应该能够指定在什么顺序下发生什么。这听起来很好，但想象一下，这被分散在许多模块中；这变得难以跟踪，因此容易出错。
- en: Mutation and asynchronous behavior are two concepts that are hard to deal with.
    Mutation means we change the data. Asynchronous means something takes time to
    complete; when it does it may mutate a state. Imagine mixing synchronous and asynchronous
    operations that all update state. We realize it's not easy to keep track of the
    code because of this, and mixing that in with state mutation makes it all the
    more complicated.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 变更和异步行为是两个难以处理的概念。变更意味着我们更改数据。异步意味着某事需要时间来完成；当它完成时，可能会更改状态。想象一下混合同步和异步操作，所有这些操作都在更新状态。我们意识到由于这一点，跟踪代码变得不容易，而且与状态变更混合在一起使得整个情况更加复杂。
- en: This leads us to what Redux can do for us, which is to make our mutations predictable,
    but it also gives us one store, one single source of truth.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这引导我们思考Redux能为我们做什么，那就是使我们的变更可预测，但它也给我们一个存储，一个单一的真实来源。
- en: 'In this chapter, you will learn:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: The core concepts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心概念
- en: How data flows
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据如何流动
- en: How to put your skills into practice by building your own mini implementation
    of Redux
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过构建自己的Redux迷你实现来将你的技能付诸实践
- en: How to deal with AJAX in the context of Redux
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Redux的上下文中如何处理AJAX
- en: Some sound best practices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些最佳实践
- en: Principles
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原则
- en: 'Redux rests on three principles:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Redux建立在三个原则之上：
- en: 'Single source of truth: We have one place where all our data lives.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一真实来源：我们有一个地方存放所有数据。
- en: 'State is read-only: No mutation; there is only one way to change state and
    that is through an action.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态是只读的：无变更；改变状态只有一种方式，那就是通过一个动作。
- en: 'Changes are made with pure functions: A new state is produced by taking the
    old state, applying the change, and producing the new state; the old state is
    never changed.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更通过纯函数进行：通过应用变更并产生新状态来生成新状态；旧状态永远不会被更改。
- en: Let's explore these bullet points one by one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一点探索这些要点。
- en: Single source of truth
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一事实来源
- en: 'The data lives in a single store in Redux and not a multiple store like in
    Flux. The data is represented by one object tree. This brings about a lot of benefits,
    such as:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数据生活在Redux的单个存储中，而不是像Flux那样的多个存储。数据由一个对象树表示。这带来了很多好处，例如：
- en: It is easier to see what your application knows at any given point, so it is
    easy to serialize or deserialize it.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何给定时刻更容易看到你的应用程序知道什么，因此它很容易进行序列化或反序列化。
- en: It is easier to work with in development, and easier to debug and inspect.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发中更容易处理，更容易调试和检查。
- en: It easier to do things such as undo/redo if all applied actions produce a new
    state.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有应用的动作都产生一个新的状态，那么执行撤销/重做等操作会更简单。
- en: 'An example of a single store can look like the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单存储的例子可能如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, this is just an object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这只是一个对象。
- en: Read-only states
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只读状态
- en: 'We want to ensure we only have one way to alter state, and that is through
    mediators called actions. An action should describe the intent of the action as
    well as the data that should be applied to the current state. An action is dispatched
    by us using a `store.dispatch(action)`. The action itself should look like the
    following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望确保只有一种方式可以改变状态，那就是通过称为动作的中介。一个动作应该描述动作的意图以及应该应用于当前状态的数据。我们通过`store.dispatch(action)`来分发动作。动作本身应该看起来像以下这样：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At this point, let''s try to implement what a store might actually look like
    and what it initially contains:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，让我们尝试实现一个存储可能的样子以及它最初包含的内容：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can see that it is an object that consists of two properties, `jedis`, which
    is an array, and `selectedJedi`, which is an object holding an object that we
    select. At this point, we want to dispatch an action, which means we will take
    our old state, as shown in the preceding code, and produce a new state. The action
    we described earlier should change the `jedis` array and replace the empty array
    with the incoming array. Remember, though, we don''t mutate the existing store
    object; we simply take it, apply our change, and produce a new object. Let''s
    dispatch our action and see the end result:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它是一个由两个属性组成的对象，`jedis`是一个数组，`selectedJedi`是一个包含我们选择的对象的对象。在这个时候，我们想要分发一个动作，这意味着我们将使用前面代码中显示的旧状态，并产生一个新的状态。我们之前描述的动作应该改变`jedis`数组，并用传入的数组替换空数组。但是，请记住，我们并没有修改现有的存储对象；我们只是取它，应用我们的更改，并产生一个新的对象。让我们分发我们的动作并查看最终结果：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code is pseudo code as it doesn't actually produce the intended
    result, yet. We will learn to implement a store in later chapters. OK, so now
    our state has changed and our incoming array has replaced the empty array we used
    to have. We again repeat that we have not mutated the existing state, but instead
    produced a new state given the old state and our action. Let's look at the next
    section on *pure functions* and further explain what we mean.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是伪代码，因为它实际上还没有产生预期的结果。我们将在后面的章节中学习如何实现存储。好的，现在我们的状态已经改变，传入的数组已经替换了我们之前使用的空数组。我们再次强调，我们没有修改现有的状态，而是根据旧状态和我们的动作产生了新的状态。让我们看看下一个关于*纯函数*的部分，并进一步解释我们的意思。
- en: Changing states with pure functions
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纯函数改变状态
- en: 'In the previous section, we introduced the concept of the action and how that
    was the mediator through which we were allowed to change our state. We didn''t
    change the state, though, in the normal sense of the word, but rather took the
    old state, applied the action, and produced a new state. To accomplish this, we
    need to use a pure function. In the context of Redux those are called reducers.
    Let''s write ourselves a `reducer`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个部分，我们介绍了动作的概念以及它是我们允许改变状态的媒介。然而，我们并没有在正常意义上改变状态，而是取了旧状态，应用了动作，并产生了新状态。为了完成这个任务，我们需要使用一个纯函数。在Redux的上下文中，这些被称为reducers。让我们自己写一个`reducer`：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We highlight the pure aspect of the preceding `reducer`. It takes our `selectedJedi`
    from the `action.payload`, it copies it using the `Object.assign()`, assigns it,
    and returns the new state.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强调前面`reducer`的纯特性。它从`action.payload`中获取我们的`selectedJedi`，使用`Object.assign()`进行复制，分配它，并返回新状态。
- en: 'What we have written is a `reducer` that switches, depending on the action
    we try to perform, and carries out the change. Let''s put this pure function into
    use:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所写的是一个`reducer`，它根据我们尝试执行的动作进行切换，并执行更改。让我们将这个纯函数投入使用：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Core concepts
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心概念
- en: In React, we are dealing with three core concepts, which we have already introduced
    the state, the action, and the reducer. Now, let's dive in deeper and really get
    a sense of how they fit together and how they work.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，我们正在处理三个核心概念，我们已经介绍了状态、动作和reducer。现在，让我们深入了解，真正理解它们是如何结合在一起以及它们是如何工作的。
- en: Immutability patterns
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变模式
- en: 'The whole point of the state is to take an existing state, apply an action
    to it, and produce a new state. It can be written like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 状态的全部意义在于接受一个现有的状态，对其应用一个动作，并产生一个新的状态。它可以写成这样：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Imagine, if you were performing basic calculations, then you would start writing
    it like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在进行基本的计算，那么你将开始这样写：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The Redux way of doing things, though, is to change the preceding to:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Redux的方式是将前面的操作改为：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We don't mutate anything but rather produce a new state for everything we do.
    Let's look at different constructs and what it means in practice to not mutate.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有做任何修改，而是为我们所做的每一件事都产生一个新的状态。让我们看看不同的构造，以及在实际中不修改意味着什么。
- en: Changing a list
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改列表
- en: 'There are two operations we can perform on a list:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在列表上执行两种操作：
- en: Add item(s) to a list
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向列表中添加项目
- en: Remove item(s) from a list
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表中移除项目
- en: 'Let''s take the first bullet point and make this change in the old way and
    then make the Redux way:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿第一个要点，以旧的方式做出这个改变，然后以Redux的方式做出这个改变：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code takes the old list and its items and creates a new list containing
    the old list plus our new member.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码取旧列表及其项目，创建一个新的列表，包含旧列表加上我们的新成员。
- en: 'For our next bullet, to remove an item, we do this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个要点，要移除一个项目，我们这样做：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we produce a list not containing our item.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们产生了一个不包含我们的项目的列表。
- en: Changing an object
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改对象
- en: 'Changing an object is about changing properties on it as well as adding properties
    to it. First off, let''s look at how to change existing values:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 修改对象涉及到在它上面更改属性以及向它添加属性。首先，让我们看看如何更改现有值：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That covers the existing case. What about adding a new property? We can do
    that like so:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这就涵盖了现有情况。那么，添加新属性怎么办？我们可以这样做：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using reducers
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用reducer
- en: 'In the previous section, we covered how to change state in the old way and
    how to do it in the new Redux-like way. The reducers are nothing more than pure
    functions; pure in the sense that they don''t mutate but produce a new state.
    A reducer needs an action to work though. Let''s deepen our knowledge on Reducers
    and Actions. Let''s create an action meant to add things to a list and a reducer
    that goes with it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了如何以旧的方式更改状态以及如何以新的Redux方式执行。reducer不过是纯函数；纯的意思是它们不改变，而是产生一个新的状态。但是，reducer需要一个动作来工作。让我们深化我们对reducer和动作的了解。让我们创建一个动作，用于向列表添加项目，以及与之对应的reducer：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'OK, so know we know how to deal with lists; what about objects? We again need
    to define an action and a reducer:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们知道如何处理列表了；那么对象呢？我们再次需要定义一个动作和一个reducer：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What we see here is how one object completely replaces the content of another
    object by invoking `SELECT_JEDI`. We also see how we use `Object.assign()` to
    ensure we only copy over the values from the incoming object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是如何通过调用`SELECT_JEDI`使一个对象完全替换另一个对象的内容。我们还看到我们如何使用`Object.assign()`来确保我们只复制传入对象中的值。
- en: Merging all reducers together
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并所有reducer
- en: 'OK, so we now have a reducer for handling our list of `jedis` as well as a
    reducer dedicated to handling selections of a specific `jedis`. We mentioned before
    that, in Redux, we have a single store where all our data lives. Now it''s time
    to create that single store. This can be easily accomplished by creating the following
    function `store()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经有了一个处理`jedis`列表的reducer，以及一个专门处理特定`jedis`选择的reducer。我们之前提到，在Redux中，我们有一个单一的存储，所有我们的数据都存储在那里。现在是我们创建这个单一存储的时候了。这可以通过创建以下函数`store()`轻松实现：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From what we can see here, our `store()` function does nothing more than return
    an object. The returned object is our current state. What we choose to call the
    properties of the state object is what we want to refer to when displaying the
    content of the store. If we want to change the state of our store, we need to
    invoke the `store()` function anew and provide it with an action that represents
    the intent of our change.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们在这里看到的情况来看，我们的`store()`函数所做的不过是返回一个对象。返回的对象是我们的当前状态。我们选择如何称呼状态对象的属性，就是我们想要在显示存储内容时引用的内容。如果我们想要改变存储的状态，我们需要重新调用`store()`函数，并给它提供一个表示我们改变意图的动作。
- en: Data flow
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据流
- en: 'OK, so we know about actions, reducers, and manipulating the state in a pure
    way. What about putting all this in practice in a real application? How would
    we do that? Let''s try to model the data flow of our application. Imagine that
    we have a view that handles adding an item to a list and a view that handles showing
    the list. Then, our data flow could look like the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们知道了动作、reducer 和以纯方式操作状态。那么，如何在实际应用中将所有这些结合起来呢？我们该如何做呢？让我们尝试模拟我们应用程序的数据流。想象一下，我们有一个视图处理向列表添加项目，还有一个视图处理显示列表。然后，我们的数据流可能看起来像以下这样：
- en: '![](img/a7ea7fcf-2e7a-4661-b129-b18afa23b745.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7ea7fcf-2e7a-4661-b129-b18afa23b745.png)'
- en: 'In the case of the create item view, we enter the data we need to create an
    item and then we dispatch an action, create-item, which ends up adding the item
    to the store. In our other data flow, we simply have a list view that selects
    the items from the store, which leads to the list view being populated. We realize
    that in a real application there may be the following steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建项目视图的情况下，我们输入创建项目所需的数据，然后我们派发一个动作，即 create-item，这最终会将项目添加到存储中。在我们的其他数据流中，我们只有一个列表视图，它从存储中选择项目，这导致列表视图被填充。我们意识到在实际应用中可能有以下步骤：
- en: User interaction
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户交互
- en: Creation of an action that represents our intent
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建表示我们意图的动作
- en: Dispatching an action, which leads to our state changing its state
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 派发一个动作，这导致我们的状态改变其状态
- en: The preceding steps are true for our create item view. For our list view, we
    simply want to read from a store and display the data. Let's try to make this
    more tangible and turn at least the Redux part into actual code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤适用于我们的创建项目视图。对于我们的列表视图，我们只想从存储中读取并显示数据。让我们尝试使这一点更具体，并将至少 Redux 部分转换为实际代码。
- en: Creating the action
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动作
- en: 'We will start by creating an action creator, a helper function that helps us
    create actions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个动作创建器，一个辅助函数，帮助我们创建动作：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Creating a controller class – create-view.js
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建控制器类 – create-view.js
- en: 'Now imagine that we are inside the code of the view that handles creating items;
    it may look something like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们处于处理创建项目的视图代码中；它可能看起来像这样：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'OK, so, in our `create-view.js` file we create a `CreateItemView` class that
    has a method `saveItem()` method on it. The `saveItem()` method is the first responder
    to a button click on a button with the ID `saveButton`. When the button is clicked,
    our `saveItem()` method is invoked, which ends up calling our dispatch function
    with the `createItem()` action method, which in turn is using the input elements
    value as input, like so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以，在我们的 `create-view.js` 文件中，我们创建了一个 `CreateItemView` 类，它上面有一个 `saveItem()`
    方法。`saveItem()` 方法是响应 ID 为 `saveButton` 的按钮点击事件的第一响应者。当按钮被点击时，我们的 `saveItem()`
    方法被调用，这最终会调用我们的 `dispatch` 函数，使用 `createItem()` 动作方法，该方法反过来使用输入元素值作为输入，如下所示：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating a store implementation
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建存储实现
- en: 'We have yet to create the `dispatch()` method, so we will do that next:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有创建 `dispatch()` 方法，所以我们将接下来做这件事：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What we can see from the preceding code is that we have a `dispatch()` function,
    which is one of the things we export from this file. Let''s try to fill in the
    implementation:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中我们可以看到，我们有一个 `dispatch()` 函数，这是我们从这个文件导出的东西之一。让我们尝试填写实现：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's explain what we did there from the top. We first define a reducer 1) called
    `itemsReducer`, which can produce a new state given a new item. Thereafter, we
    create a state variable, which is our state 2). This is followed by the `store()`
    function 3), which is a function to set up which property goes together with which
    reducer. Thereafter, we define a function called `getState()` 4), which returns
    our current state. Lastly, we have our `dispatch()` function 5), which just invokes
    the `store()` function with the action we provide it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下我们从顶部做了什么。我们首先定义了一个名为 `itemsReducer` 的 reducer 1)，它可以根据新项目生成新状态。之后，我们创建了一个状态变量，即我们的状态
    2）。这之后是 `store()` 函数 3)，这是一个设置哪个属性与哪个 reducer 配对的函数。之后，我们定义了一个名为 `getState()`
    的函数 4)，它返回我们的当前状态。最后，我们有我们的 `dispatch()` 函数 5)，它只是调用 `store()` 函数并传递给它我们提供的动作。
- en: Testing out our store
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的存储
- en: 'Now it is time to put our code to use; first, we will create a `redux-demo.js`
    file to test out our Redux implementation, then we will polish it a bit, and lastly
    we will use it in the view we created earlier:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用我们的代码了；首先，我们将创建一个 `redux-demo.js` 文件来测试我们的 Redux 实现，然后我们将对其进行一些润色，最后我们将将其用于我们之前创建的视图中：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Cleaning up the implementation
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理实现
- en: 'OK, so our Redux implementation seems to be working. It''s time to clean it
    up a bit. We need to move the reducer out into its own file, like so:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们的 Redux 实现看起来似乎正在工作。现在是时候对其进行一些清理了。我们需要将 reducer 移动到它自己的文件中，如下所示：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It''s also a good idea to add a `select()` function to the store as we sometimes
    don''t want to move a full state back, only part of it. Our list view will benefit
    from the use of the `select()` function. Let''s add that next:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 也是一个好主意，向存储中添加一个 `select()` 函数，因为我们有时不想移动整个状态，而只想移动其中的一部分。我们的列表视图将受益于 `select()`
    函数的使用。让我们添加这个函数：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Creating our second controller class – list-view.js
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建第二个控制器类 – `list-view.js`
- en: 'Let''s now shift our focus to our `list-view.js` file that we are yet to create:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在将注意力转移到我们尚未创建的 `list-view.js` 文件上：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: OK, so we utilize the `select()` method and get a slice of state from our state
    from the `redux.js` file we created. Thereafter, we render the response. As long
    as these views are on different pages, we will always get the latest version of
    `items` arrays from our state. However, if these views are visible at the same
    time, then we have a problem.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们利用 `select()` 方法从我们创建的 `redux.js` 文件中的状态中获取状态的一部分。然后我们渲染响应。只要这些视图在不同的页面上，我们总是会从我们的状态中获得
    `items` 数组的最新版本。然而，如果这些视图同时可见，那么我们就有一个问题。
- en: Adding subscription capability to our store
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的存储添加订阅功能
- en: 'Somehow, the list view needs to listen to changes in the store so that it can
    rerender when a change happens. A way to do that is, of course, to set up some
    kind of listener that triggers an event when a change happens. If we, as a view,
    subscribe to such changes, then we can act accordingly and rerender our view.
    There are different ways of accomplishing this: we can either just implement an
    Observable pattern or use a library, such as `EventEmitter`. Let''s update our
    `redux.js` file to make it so:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 某种程度上，列表视图需要监听存储中的变化，以便在发生变化时重新渲染。实现这一点的办法当然是设置某种类型的监听器，当发生变化时触发事件。如果我们作为视图订阅这些变化，那么我们可以相应地采取行动并重新渲染我们的视图。有几种不同的方法可以实现这一点：我们可以实现一个可观察的模式，或者使用一个库，例如
    `EventEmitter`。让我们更新我们的 `redux.js` 文件来实现这一点：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Creating a program
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个程序
- en: 'So far, we have created a bunch of files, namely, the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一系列文件，具体如下：
- en: '`redux.js`: Our store implementation.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redux.js`：我们的存储实现。'
- en: '`create-view.js`: A controller that listens to inputs and button presses. The
    controller will read the input on a button press and dispatch the input''s value
    so it is saved in the store.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create-view.js`：一个控制器，它监听输入和按钮点击。控制器将在按钮点击时读取输入，并派发输入的值以便将其保存在存储中。'
- en: '`list-view.js`: Our second controller, responsible for showing the content
    of the store.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list-view.js`：我们的第二个控制器，负责显示存储的内容。'
- en: '`todo-app.js`: The starter file that creates our entire application (we have
    yet to create this).'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`todo-app.js`：创建我们整个应用的启动文件（我们尚未创建此文件）。'
- en: '`index.html`: The UI for our application (we are yet to create this).'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`：我们应用的 UI（我们尚未创建此文件）。'
- en: Setting up our environment
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的环境。
- en: 'Maybe you have noticed that we are using import statements used for ES6 modules?
    There are many ways to make that work, but we choose a modern option, namely,
    utilizing webpack. We will need to do the following to set up webpack successfully:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你已经注意到我们正在使用用于 ES6 模块的导入语句？有许多方法可以使它工作，但我们选择了一个现代选项，即利用 webpack。为了成功设置 webpack，我们需要做以下事情：
- en: Install the npm libraries `webpack` and `webpack-cli`
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 npm 库 `webpack` 和 `webpack-cli`
- en: Create a `webpack.config.js` file and specify the entry point of your application
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `webpack.config.js` 文件并指定应用的入口点。
- en: Add an entry to the `package.json` file so that we can build and run our app
    with a simple `npm start`
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `package.json` 文件中添加一个条目，以便我们可以通过简单的 `npm start` 来构建和运行我们的应用。
- en: Add a HTTP server so that we can show the app
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个 HTTP 服务器，以便我们可以展示应用。
- en: 'We can install the needed libraries by typing:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过输入以下命令来安装所需的库：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Thereafter, we need to create our `config` file, `webpack.config.js`, like
    so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，我们需要创建我们的 `config` 文件，`webpack.config.js`，如下所示：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding code, we are stating that the entry point should be `todo-app.js`
    and also that the output file should be called `bundle.js`. We also ensure our
    bundle will be rebuilt by setting `watch` to `true`. Let''s add the needed entry
    to `package.json` by adding the following to the `script` tag:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明入口点应该是 `todo-app.js`，并且输出文件应该命名为 `bundle.js`。我们还通过将 `watch` 设置为
    `true` 来确保我们的包将被重新构建。让我们通过在 `script` 标签中添加以下内容来将所需的入口添加到 `package.json` 文件中：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we are defining a start command that invokes webpack with the flag `-d`,
    which means it will generate source maps, making for a nice debug experience.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个启动命令，它使用webpack的`-d`标志调用webpack，这意味着它将生成源映射，从而提供良好的调试体验。
- en: For our last setup step, we need a HTTP server so that we can display our app.
    Webpack itself has one called, `webpack-dev-server`, or we could use `http-server`,
    which is an NPM package. This is a pretty simple application so either will do
    fine.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最后一步设置，我们需要一个HTTP服务器来显示我们的应用程序。Webpack本身有一个叫做`webpack-dev-server`的，或者我们可以使用`http-server`，这是一个NPM包。这是一个相当简单的应用程序，所以两者都可以。
- en: Creating the missing files and running our program
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建缺失的文件并运行我们的程序
- en: 'Our application needs a UI so let''s create that:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要一个UI，让我们创建它：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So, here we have an input element and a button that we can press to save a new
    item. This is followed by a list, where our content will be rendered.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里我们有一个输入元素和一个按钮，我们可以按下它来保存一个新项目。接下来是一个列表，我们的内容将会在这里渲染。
- en: 'Let''s create the `todo-app.js` next. It should look like the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`todo-app.js`。它应该看起来像以下这样：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we are requiring in the two controllers so we can collect input as well
    as displaying store content. Let''s try out our application by typing `npm start`
    in the Terminal window. This will create the `bundle.js` file in a dist folder.
    To display the app, we need to fire up another terminal window and place ourselves
    in the `dist` folder. Your dist folder should consist of the following files:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在引入两个控制器，这样我们就可以收集输入以及显示存储内容。让我们通过在终端窗口中输入`npm start`来尝试我们的应用程序。这将在dist文件夹中创建`bundle.js`文件。为了显示应用程序，我们需要打开另一个终端窗口并定位到`dist`文件夹。你的dist文件夹应该包含以下文件：
- en: '`index.html`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`'
- en: '`bundle.js`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bundle.js`'
- en: 'Now we are ready to launch the app by typing `http-server -p 5000`. You will
    be able to find your app at `http:localhost:5000` in your browser:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好通过输入`http-server -p 5000`来启动应用程序。你可以在浏览器中的`http://localhost:5000`找到你的应用程序：
- en: '![](img/b4fc348d-1562-40ad-af1f-1438a75d88f7.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b4fc348d-1562-40ad-af1f-1438a75d88f7.png)'
- en: 'We see our expected application with an input element and a button, and we
    see our console to the right showing us that both our controllers were loaded.
    Additionally, we see the content of the items property of our store object, which
    points to an empty array. This is expected as we haven''t added any items to it
    yet. Let''s add an item to our store by adding a value to our input element and
    pressing the Save button:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们期望的应用程序，有一个输入元素和一个按钮，我们还看到右侧的控制台显示我们的两个控制器都已加载。此外，我们还看到存储对象items属性的内容，它指向一个空数组。这是预期的，因为我们还没有向其中添加任何项目。让我们通过向我们的输入元素添加一个值并按下保存按钮来向我们的存储添加一个项目：
- en: '![](img/a880068f-935e-4247-b91b-bece6c20b24a.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a880068f-935e-4247-b91b-bece6c20b24a.png)'
- en: 'On the right, we can see that our store now contains an item but our UI is
    not updated. The reason for that is that we don''t actually subscribe to changes.
    We can change that by adding the following piece of code to our list-view.js controller
    file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，我们可以看到我们的存储现在包含了一个项目，但我们的UI没有更新。原因是我们没有实际订阅这些变化。我们可以通过向我们的list-view.js控制器文件中添加以下代码片段来改变这一点：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now our app renders as it should and should look something like this, providing
    that you added a few items:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序应该按预期渲染，并且看起来应该像这样，前提是你添加了一些项目：
- en: '![](img/5dd99207-9a3c-473f-989b-5a3b6886eb2f.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5dd99207-9a3c-473f-989b-5a3b6886eb2f.png)'
- en: Dealing with asynchronous calls
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异步调用
- en: Dispatching actions is always done synchronously. Data is fetched through AJAX
    asynchronously, so how do we get asynchronous to play well with Redux?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 分发动作始终是同步完成的。数据通过AJAX异步获取，那么我们如何让异步与Redux良好地协同工作呢？
- en: 'You should define your Redux states in the following way when setting up an
    asynchronous call:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置异步调用时，你应该以下述方式定义你的Redux状态：
- en: 'Loading: Here, we have the chance to show a spinner, not render part of the
    UI, or convey to the user in some other way that the UI is waiting for something'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载：在这里，我们有显示旋转器、不渲染UI的一部分，或者以其他方式向用户传达UI正在等待某物的机会
- en: 'Data successfully fetched: You should set a state for the fetched data'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据成功获取：你应该为获取的数据设置一个状态
- en: 'Error happened: You should record the error somehow so that you are able to
    tell the user that an error occurred'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生错误：你应该以某种方式记录错误，这样你就能告诉用户发生了错误
- en: 'You, by convention, use the word fetch to indicate that you are fetching data.
    Let''s look at an example of what that might look like. First off, let''s start
    by defining the steps we need to take:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 根据惯例，您使用单词 fetch 来表示您正在获取数据。让我们看看这可能会是什么样子。首先，让我们定义我们需要采取的步骤：
- en: Create a reducer. This should have the ability to set different states depending
    on whether we are waiting for the response, got the response, or an error happened.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 reducer。这个 reducer 应该能够根据我们是在等待响应、已收到响应还是发生了错误来设置不同的状态。
- en: Create actions. We need a file of actions that supports our states mentioned
    earlier; creating this is more about convenience.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建动作。我们需要一个文件的动作来支持我们之前提到的状态；创建这个文件更多的是关于便利性。
- en: Update our `redux.js` file to use our new reducer.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新我们的 `redux.js` 文件以使用我们新的 reducer。
- en: Test our creation out.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试我们的创建。
- en: 'Let''s say we are fetching a book from an API. We should have a reducer that
    looks like the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在从 API 获取一本书。我们应该有一个看起来像以下的 reducer：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we have covered the reducer bit, let''s move on to the creation of
    actions. It will look like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了 reducer 部分，让我们继续创建动作。它看起来如下：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we need to turn to our `store` file and update it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要转向我们的 `store` 文件并更新它：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Creating a demo with Redux and asynchronous
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redux 和异步创建一个演示
- en: 'Now the time has come to test everything out. What we are interested in here
    is ensuring that our store state behaves the way we want it to. We want the store
    to reflect the fact that we are loading the data, receiving the data, and if there
    is an error, that should be reflected as well. Let''s start out by mimicking an
    AJAX call:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试一切了。我们在这里感兴趣的是确保我们的存储状态按预期工作。我们希望存储反映我们正在加载数据、接收数据，以及如果发生错误，这也应该得到反映。让我们先模拟一个
    AJAX 调用：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As our next order of business, let''s set up some logging for the state and
    dispatch our first action, `fetchBookLoading`, which indicates that an AJAX request
    is underway. This is where, ideally, we would want to reflect this state in the
    UI and show a spinner or similar:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们接下来的业务，让我们为状态设置一些日志记录，并分发我们的第一个动作 `fetchBookLoading`，这表示一个 AJAX 请求正在进行中。理想情况下，我们希望在这个状态下反映
    UI 并显示一个旋转器或类似的东西：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The last step is about a call to our `fetchBook()` method and setting the store
    state appropriately:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是调用我们的 `fetchBook()` 方法并适当地设置存储状态：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We have so far described our demo in pieces from top to bottom. The full code
    should read like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经从上到下分步骤描述了我们的演示。完整的代码应该像这样：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, there is really not much to dealing with asynchronous, you just
    need to dispatch the suitable state once the asynchronous action has run its course.
    There are libraries for dealing with asynchronous though. If you are a React user
    it might be worth looking into Sagas and if Angular is your flavor, then NgRx
    and effects is your go-to. The reason for separate libraries existing for this
    is to say that asynchronous interactions, especially AJAX ones, are considered
    side-effects and as such they are outside the *normal* flow. Ultimately, it's
    up to you if you feel you need such a library.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，处理异步操作实际上并没有太多复杂的地方，你只需要在异步操作完成其流程后，分配合适的状态即可。尽管如此，处理异步操作还是有相应的库。如果您是 React
    用户，那么研究 Sagas 可能是值得的；如果您喜欢 Angular，那么 NgRx 和 effects 就是您的首选。存在这些独立库的原因在于，异步交互，尤其是
    AJAX 交互，被视为副作用，因此它们位于 *正常* 流程之外。最终，是否需要这样的库取决于您的个人判断。
- en: Best practices
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: So far, we have gone through a lot. We have covered principles, core concepts,
    and even got to build our own Redux implementation. We should be mighty proud
    of ourselves at this point. There is something we have yet to cover, though, and
    that is how we use Redux in an optimal way. There are some key rules we can follow.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经走得很远了。我们已经涵盖了原则、核心概念，甚至自己构建了 Redux 实现。在这个时候，我们应该非常自豪。尽管如此，我们还有一些内容尚未涉及，那就是如何以最佳方式使用
    Redux。有一些关键规则我们可以遵循。
- en: 'Organize your file system optimally. You should not have a few files when building
    an app but rather many, and usually organized by feature. This leads to the following
    file setup for a feature:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 优化文件系统。在构建应用程序时，您不应该只有几个文件，而应该有很多，通常按功能组织。这导致了一个功能以下面的文件设置：
- en: '**Reducer**: We should have one file, per reducer, for this'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reducer**：我们应该为每个 reducer 有一个文件'
- en: '**Actions**: We should have a file describing all the actions we could possibly
    dispatch'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Actions**：我们应该有一个文件来描述我们可能需要分发的所有动作'
- en: '**View/component file**: This has nothing to do with Redux but, regardless
    of the framework we go with, we usually have a file describing the component we
    are trying to build'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图/组件文件**：这与Redux无关，但无论我们选择哪个框架，我们通常都有一个文件来描述我们试图构建的组件'
- en: 'There is another aspect that is worth doing as well, and that is optimizing
    the setup process of our store. The store normally needs to be initialized with
    a number of reducers. We could write some code that looks like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个值得做的事情，那就是优化我们store的设置过程。store通常需要用多个reducer进行初始化。我们可以编写一些类似这样的代码：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There is nothing wrong with the setup here, but it you have many features,
    and a reducer in each, you will end up with a lot of imports, and your call to
    `combineReducers()` will be longer and longer. An approach that will solve that
    is having each reducer register itself with the `rootReducer`. This way, we can
    switch the following call:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的设置没有问题，但是如果你有很多功能，每个功能都有一个reducer，最终你会有很多导入，你的 `combineReducers()` 调用会越来越长。解决这个问题的方法是在每个reducer中注册它自己到
    `rootReducer`。这样，我们可以切换以下调用：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It will be switched with this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被替换为以下内容：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This forces us to create a new `root-reducer.js` file, which will look like
    the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这迫使我们创建一个新的 `root-reducer.js` 文件，其结构如下：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We have highlighted the important part here, the `registerReducer()` method,
    which a reducer can now use to register itself with the `rootReducer`. At this
    point, it''s worth going back to our reducer and updating it to use the `registerReducer()`
    method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里突出了重要部分，即 `registerReducer()` 方法，reducer现在可以使用它来注册自己到 `rootReducer`。在这个时候，回到我们的reducer并更新它以使用
    `registerReducer()` 方法是值得的：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has been a wild ride, going from describing principles to core
    concepts, to being able to understand and even build our own Redux. Time was spent
    looking at how to deal with AJAX calls and suitable state patterns for that. We
    learned that there was really nothing much to it. We finished off the chapter
    by looking at best practices as well. At this point, we are in a considerably
    better position to be able to understand and appreciate NgRx because we know its
    underlying patterns and reasons for existing. We can say farewell to this chapter
    knowing that we will take on NgRx in the last chapter of the book. The aim is
    to cover the principles and concepts that govern it, how to use it in practice,
    and also to cover some necessary tooling that will ensure we become really successful.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容丰富多彩，从描述原则到核心概念，再到能够理解和甚至构建自己的Redux。我们花费时间研究如何处理AJAX调用和适合该状态的模式。我们了解到这实际上并没有什么复杂。我们通过查看最佳实践来结束本章。到目前为止，我们能够更好地理解和欣赏NgRx，因为我们知道了其底层模式和存在的理由。我们可以知道，在书的最后一章我们将学习NgRx。目标是涵盖其原则和概念，如何在实践中使用它，以及涵盖一些必要的工具，以确保我们真正成功。
