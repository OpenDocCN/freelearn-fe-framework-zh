- en: Chapter 1. Get Going with Angular
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章。开始使用 Angular
- en: 'On September 18, 2014, Google pushed the first public commit to the repository
    that now contains the new versions of Angular. A few weeks later, at **ng-europe**,
    Igor and Tobias, from the core team, gave a short overview of what the new version
    of the framework was expected to be. The vision at that time was far from final;
    however, one thing was certain: the new version of the framework would be entirely
    different from AngularJS.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 2014 年 9 月 18 日，谷歌将第一个公开提交推送到包含新版本 Angular 的存储库。几周后，在 **ng-europe** 上，核心团队中的
    Igor 和 Tobias 给出了一个关于新版本框架预期内容的简要概述。当时的愿景远未最终确定；然而，有一点是确定的：新版本的框架将完全不同于 AngularJS。
- en: 'This announcement brought a lot of questions and controversies. The reasons
    behind the drastic changes were quite clear: AngularJS was no longer able to take
    full advantage of the evolved Web and the requirements of large-scale JavaScript
    applications needed to be completely satisfied. A new framework would let Angular
    developers capitalize on developments in web technology in simpler, more performant,
    and productive ways. Yet, people were concerned. One of the biggest nightmares
    with backward incompatibility for developers is the migration of their current
    codebases to the new version of the third-party software they use. In Angular''s
    case, after that first announcement, migration looked daunting, even impossible.
    Later, at **ng-conf** 2015 and **ng-vegas** 2015, different migration strategies
    were introduced. The Angular community came together and shared additional ideas,
    anticipating the benefits of the new version of the framework, while preserving
    the things learned from AngularJS.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这一公告引发了许多问题和争议。这些重大变化背后的原因非常明显：AngularJS 已无法充分利用演进的 Web，以及大规模 JavaScript 应用程序的需求需要得到完全满足。一个新的框架将让
    Angular 开发者以更简单、更高效、更富有成效的方式利用 Web 技术的发展。然而，人们对此表示担忧。对于开发者来说，向后不兼容的最大噩梦之一是将他们当前的代码库迁移到他们使用的第三方软件的新版本。在
    Angular 的情况下，在那次第一次公告之后，迁移看起来令人畏惧，甚至不可能。后来，在 2015 年的 **ng-conf** 和 **ng-vegas**
    上，介绍了不同的迁移策略。Angular 社区团结起来，分享了额外的想法，预计新版本的框架将带来好处，同时保留从 AngularJS 中学到的经验。
- en: 'This book is a part of that project. Making the upgrade to the new versions
    of Angular is now smooth and is worth it. The main drivers behind the drastic
    changes in Angular 2 and its lack of backward compatibility are the evolution
    of the Web and the lessons learned from the usage of AngularJS in the wild. *Getting
    Started with Angular* will help you learn the new framework by making you understand
    how we got here and why Angular''s new features make intuitive sense for the modern
    Web in building high-performance, scalable, single-page applications. Some of
    the topics that we will discuss in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是该项目的一部分。现在将 Angular 升级到新版本变得平滑且值得。Angular 2 和其缺乏向后兼容性的巨大变化背后的主要推动力是 Web 的发展以及从
    AngularJS 的实际使用中吸取的教训。《Angular 入门》将帮助你通过了解我们是如何到达这里的以及为什么 Angular 的新特性对现代 Web
    来说在构建高性能、可扩展的单页应用程序方面具有直观的意义来学习新框架。本章我们将讨论的一些主题包括：
- en: How to use TypeScript and how it extends JavaScript.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 TypeScript 以及它如何扩展 JavaScript。
- en: Building the user interface of Angular applications with a component-based architecture.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于组件架构构建 Angular 应用程序的用户界面。
- en: Using Angular's dependency injection mechanism and delegating the business logic
    to services.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular 的依赖注入机制并将业务逻辑委托给服务。
- en: We are going to explore in-depth Angular's router and forms module.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将深入探讨 Angular 的路由和表单模块。
- en: We'll take a look at the Ahead-of-Time compilation for building lightning fast
    applications.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将探讨即时编译（Ahead-of-Time compilation）以构建闪电般快速的应用程序。
- en: Angular adopted semantic versioning, so before going any further let's have an
    overview of what this actually means.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 采用了语义版本控制，因此在继续之前，让我们先概述一下这实际上意味着什么。
- en: Angular and semver
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 和 semver
- en: AngularJS was rewritten from scratch and replaced with its successor, Angular
    2\. A lot of us were bothered by this big step, which didn't allow us to have
    a smooth transition between these two versions of the framework. Right after Angular
    2 was stable, Google announced that they wanted to follow the so called semantic
    versioning (also known as semver).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 从头开始重写，并替换为其继任者 Angular 2。我们中的许多人对此重大步骤感到烦恼，因为它不允许我们在这两个框架版本之间实现平滑过渡。在
    Angular 2 稳定后，谷歌宣布他们希望遵循所谓的语义版本控制（也称为 semver）。
- en: Semver defines the version of given software project as the triple **X.Y.Z**,
    where Z is called **patch version**, Y is called **minor version**, and X is called
    **major version**. A change in the patch version means that there are no intended
    breaking changes between two versions of the same project, but only bug fixes.
    The minor version of a project will be incremented when new functionality is introduced,
    and there are no breaking changes. Finally, the major version will be increased when
    incompatible changes are introduced in the API.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Semver定义了给定软件项目的版本为**X.Y.Z**的三元组，其中Z被称为**修补版本**，Y被称为**次要版本**，X被称为**主版本**。修补版本的变化意味着同一项目的两个版本之间没有预期的破坏性变化，只有错误修复。当引入新功能且没有破坏性变化时，项目的次要版本将增加。最后，当API中引入不兼容的变化时，主版本将增加。
- en: This means that between versions 2.3.1 and 2.10.4, there are no introduced breaking
    changes but only a few added features and bug fixes. However, if we have version
    2.10.4 and we want to change any of the already existing public APIs in a backward-incompatible
    manner (for instance, change the order of the parameters that a method accepts),
    we need to increment the major version, and reset the patch and minor versions,
    so we will get version 3.0.0.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在2.3.1和2.10.4版本之间，没有引入破坏性变化，只有一些新增功能和错误修复。然而，如果我们有2.10.4版本，并且想要以向后不兼容的方式更改任何现有的公共API（例如，更改方法接受的参数顺序），我们需要增加主版本号，并将修补版本和次要版本重置，这样我们将得到版本3.0.0。
- en: The Angular team also follows a strict schedule. According to it, *a new patch
    version needs to be introduced every week; there should be three monthly minor
    releases after each major release*, and finally, *one major release every six
    months*. This means that by the end of 2018, we will have at least Angular 6\.
    However, this doesn't mean that every six months we'll have to go through the
    same migration path like we did between AngularJS and Angular 2\. *Not every major
    release will introduce breaking changes that are going to impact our projects.*
    For instance, support for a newer version of TypeScript or change of the last
    optional argument of a method will be considered as a breaking change. We can
    think of these breaking changes in a way similar to what happened between AngularJS
    1.2 and AngularJS 1.3.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Angular团队也遵循严格的计划。根据该计划，*每个星期需要引入一个新的修补版本；在每次主要版本发布后，应有三次每月的次要版本发布*，最后，*每六个月发布一次主要版本*。这意味着到2018年底，我们将至少拥有Angular
    6。然而，这并不意味着每六个月我们都必须经历像AngularJS和Angular 2之间的相同迁移路径。*并非每个主要版本都会引入影响我们项目的破坏性变化*。例如，对TypeScript新版本的支持或方法最后一个可选参数的改变将被视为破坏性变化。我们可以将这些破坏性变化视为类似于AngularJS
    1.2和AngularJS 1.3之间发生的情况。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since the content that you're going to read in this book will be mostly relevant
    across different Angular versions, *we'll refer to Angular 2 as either Angular
    2 or only Angular*. If we explicitly mention Angular 2, this doesn't mean that
    the given paragraph will not be valid for Angular 4 or Angular 5; it most likely
    will. In case you're interested to know what the changes are between different
    versions of the framework, you can take a look at the changelog at [https://github.com/angular/angular/blob/master/CHANGELOG.md](https://github.com/angular/angular/blob/master/CHANGELOG.md).
    If we're discussing AngularJS (that is, version 1.x of the framework), we will
    be more explicit by mentioning a version number, or using AngularJS instead of
    Angular.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书中您将要阅读的内容将主要适用于不同的Angular版本，*我们将Angular 2称为Angular 2或仅称Angular*。如果我们明确提到Angular
    2，这并不意味着给定的段落对于Angular 4或Angular 5将不适用；它很可能适用。如果您对框架不同版本之间的变化感兴趣，可以查看变更日志[https://github.com/angular/angular/blob/master/CHANGELOG.md](https://github.com/angular/angular/blob/master/CHANGELOG.md)。如果我们讨论的是AngularJS（即框架的1.x版本），我们将通过提及版本号或使用AngularJS代替Angular来更加明确。
- en: Now that we've introduced Angular's semantic versioning and conventions for
    referring to the different versions of the framework, we can officially start
    our journey!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了Angular的语义版本和引用框架不同版本的约定，我们可以正式开始我们的旅程了！
- en: The evolution of the Web - time for a new framework
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络的演变 - 是时候引入新的框架了
- en: In the past couple of years, the Web has evolved in big steps. During the implementation
    of ECMAScript 5, the ECMAScript 6 standard started its development (now known
    as **ECMAScript 2015** or **ES2015**). ES2015 introduced many changes in JavaScript,
    such as adding built-in language support for modules, block scope variable definition,
    and a lot of syntactical sugar, such as classes and destructuring.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年里，Web经历了巨大的发展。在实施ECMAScript 5的过程中，ECMAScript 6标准开始了其开发（现在被称为**ECMAScript
    2015**或**ES2015**）。ES2015在JavaScript中引入了许多变化，例如添加内置语言支持模块、块作用域变量定义以及许多语法糖，如类和结构赋值。
- en: Meanwhile, **Web Components** were invented. Web Components allow us to define
    custom HTML elements and attach behavior to them. Since it is hard to extend the
    existing set of HTML elements with new ones (such as dialogs, charts, grids, and
    more), mostly because of the time required for consolidation and standardization
    of their APIs, a better solution is to allow developers to extend the existing
    elements in the way they want. Web Components provide us with a number of benefits,
    including better encapsulation, better semantics of the markup we produce, better
    modularity, and easier communication between developers and designers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，**Web Components**被发明了。Web Components允许我们定义自定义的HTML元素并将行为附加到它们上。由于很难通过添加新的元素（如对话框、图表、网格等）来扩展现有的HTML元素集，这主要是因为它们API的整合和标准化所需的时间，因此一个更好的解决方案是允许开发者以他们想要的方式扩展现有的元素。Web
    Components为我们提供了许多好处，包括更好的封装、我们产生的标记的更好语义、更好的模块化，以及开发者和设计师之间更易沟通。
- en: We know that JavaScript is a single-threaded language. Initially, it was developed
    for simple client-side scripting, but over time, its role has shifted quite a
    bit. Now, with HTML5, we have different APIs that allow audio and video processing,
    communication with external services through a two-directional communication channel,
    transferring and processing big chunks of raw data, and more. All these heavy
    computations in the main thread may create a poor user experience. They may introduce
    freezing of the user interface when time-consuming computations are being performed.
    This led to the development of **Web Workers**, which allow the execution of the
    scripts in the background that communicate with the main thread through message
    passing. This way, multithreaded programming was brought to the browser.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道JavaScript是一种单线程语言。最初，它是为了简单的客户端脚本开发而开发的，但随时间推移，它的角色发生了很大变化。现在，有了HTML5，我们有不同的API允许音频和视频处理、通过双向通信通道与外部服务进行通信、传输和处理大量原始数据等。所有这些在主线程中的重计算可能会创建一个糟糕的用户体验。它们可能会在执行耗时计算时导致用户界面冻结。这导致了**Web
    Workers**的发展，它允许在后台执行脚本并通过消息传递与主线程通信。这样，多线程编程被带到了浏览器中。
- en: 'Some of these APIs were introduced after the development of AngularJS had begun;
    that''s why the framework wasn''t built with most of them in mind. Taking advantage
    of the APIs gives developers many benefits, such as the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一些这些API是在AngularJS开发开始之后引入的；这就是为什么框架在构建时没有考虑到它们中的大多数。利用这些API为开发者带来了许多好处，例如以下这些：
- en: Significant performance improvements.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显著的性能改进。
- en: Development of software with better quality characteristics.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发具有更好质量特性的软件。
- en: Now, let's briefly discuss how each of these technologies has been made part
    of the new Angular core and why.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要讨论这些技术是如何成为新Angular核心的一部分以及为什么。
- en: The evolution of ECMAScript
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECMAScript的演变
- en: Nowadays, browser vendors are releasing new features in short iterations, and
    users receive updates quite often. This helps developers take advantage of bleeding-edge
    Web technologies. ES2015 is already standardized. The implementation of the latest
    version of the language has already started in the major browsers. Learning the
    new syntax and taking advantage of it will not only increase our productivity
    as developers but will also prepare us for the near future when all browsers will
    have full support for it. This makes it essential to start using the latest syntax
    now.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，浏览器厂商正在以短周期迭代的方式发布新功能，用户经常收到更新。这有助于开发者利用前沿的Web技术。ES2015已经标准化。该语言最新版本的实现已经在主要浏览器中开始。学习新语法并利用它不仅会增加我们的开发效率，而且还会为我们为即将到来的所有浏览器都将完全支持它的近未来做好准备。这使得现在开始使用最新语法变得至关重要。
- en: Some projects' requirements may enforce us to support older browsers, which
    do not support any ES2015 features. In this case, we can directly write ECMAScript
    5, which has different syntax but equivalent semantics to ES2015\. On the other
    hand, a better approach will be to take advantage of the process of **transpilation**.
    Using a transpiler in our build process allows us to take advantage of the new
    syntax by writing ES2015 and translating it to a target language that is supported
    by the browsers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目的需求可能迫使我们支持不支持任何ES2015特性的旧浏览器。在这种情况下，我们可以直接编写ECMAScript 5，它具有不同的语法但与ES2015具有等效的语义。另一方面，更好的方法将是利用**转译**过程。在我们的构建过程中使用转译器允许我们通过编写ES2015并将其转换为浏览器支持的目标语言来利用新语法。
- en: Angular has been around since 2009\. Back then, the frontend of most websites
    was powered by ECMAScript 3, the last main release of ECMAScript before ECMAScript
    5\. This automatically meant that the language used for the framework's implementation
    was ECMAScript 3\. Taking advantage of the new version of the language requires
    porting of the entirety of AngularJS to ES2015.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Angular自2009年以来一直存在。当时，大多数网站的前端由ECMAScript 3提供支持，这是ECMAScript 5之前的最后一个主要版本。这自动意味着框架实现所使用的语言是ECMAScript
    3。利用语言的新版本需要将AngularJS的全部内容移植到ES2015。
- en: From the beginning, Angular 2 took into account the current state of the Web
    by bringing the latest syntax in the framework. Although new Angular is written
    with a superset of ES2016 (TypeScript, which we're going to take a look at in
    [Chapter 3](ch03.html "Chapter 3. TypeScript Crash Course"), *TypeScript Crash
    Course*), it allows developers to use a language of their own preference. We can
    use ES2015, or if we prefer not to have any intermediate preprocessing of our
    code and simplify the build process, we can even use ECMAScript 5\. Note that
    if we use JavaScript for our Angular applications we cannot use **Ahead-of-Time**
    (**AoT**) compilation. You can find more about AoT compilation in [Chapter 8](ch08.html
    "Chapter 8. Tooling and Development Experience"), *Tooling and Development Experience*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，Angular 2就考虑了Web的当前状态，通过引入框架中的最新语法。虽然新的Angular是用ES2016的超集（TypeScript）编写的（我们将在[第3章](ch03.html
    "第3章。TypeScript快速入门"，*TypeScript快速入门*）中探讨），但它允许开发者使用他们自己的语言。我们可以使用ES2015，或者如果我们更喜欢不进行任何中间预处理我们的代码并简化构建过程，我们甚至可以使用ECMAScript
    5。请注意，如果我们为Angular应用程序使用JavaScript，我们不能使用**即时编译**（**AoT**）。您可以在[第8章](ch08.html
    "第8章。工具和开发体验"，*工具和开发体验*）中找到有关AoT编译的更多信息。
- en: Web Components
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web Components
- en: The first public draft of Web Components was published on May 22, 2012, about
    three years after the release of AngularJS. As mentioned, the Web Components standard
    allows us to create custom elements and attach behavior to them. It sounds familiar;
    we've already used a similar concept in the development of the user interface
    in AngularJS applications. Web Components sound like an alternative to Angular
    directives; however, they have a more intuitive API and built-in browser support.
    They introduced a few other benefits, such as better encapsulation, which is very
    important, for example, in handling CSS-style collisions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Web Components的第一个公开草案于2012年5月22日发布，比AngularJS发布晚了大约三年。正如所提到的，Web Components标准允许我们创建自定义元素并将行为附加到它们上。这听起来很熟悉；我们已经在AngularJS应用程序的用户界面开发中使用了类似的概念。Web
    Components听起来像是Angular指令的替代品；然而，它们具有更直观的API和内置的浏览器支持。它们引入了一些其他好处，例如更好的封装，这在处理CSS样式冲突时非常重要。
- en: A possible strategy for adding Web Components support in AngularJS is to change
    the directives implementation and introduce primitives of the new standard in
    the DOM compiler. As Angular developers, we know how powerful and complex the
    directives API is. It includes a lot of properties, such as `postLink`, `preLink`,
    `compile`, `restrict`, `scope`, `controller`, and much more, and of course, our
    favorite `transclude`. Approved as standard, Web Components will be implemented
    on a much lower level in the browsers, which introduces plenty of benefits, such
    as better performance and native API.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS中添加Web Components支持的可能策略是更改指令实现，并在DOM编译器中引入新标准的原语。作为Angular开发者，我们知道指令API是多么强大和复杂。它包括许多属性，例如`postLink`、`preLink`、`compile`、`restrict`、`scope`、`controller`等等，当然，还有我们最喜欢的`transclude`。作为标准被批准后，Web
    Components将在浏览器中以更低级别实现，这带来了许多好处，如更好的性能和原生API。
- en: During the implementation of Web Components, a lot of web specialists met with
    the same problems the Angular team did when developing the directives API, and
    came up with similar ideas. Good design decisions behind Web Components include
    the **content** element, which deals with the infamous transclusion problem in
    AngularJS. Since both the directives API and Web Components solve similar problems
    in different ways, keeping the directives API on top of Web Components would have
    been redundant and added unnecessary complexity. That's why the Angular core team
    decided to start from the beginning by building a framework compatible with Web
    Components and taking full advantage of the new standard. Web Components involve
    new features; some of them were not yet implemented by all browsers. In case our
    application is run in a browser which does not support any of these features natively,
    Angular emulates them. An example for this is the content element polyfilled with
    the `ng-content` directive.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 Web 组件时，许多网络专家遇到了 Angular 团队在开发指令 API 时遇到的问题，并提出了类似的想法。Web 组件背后的良好设计决策包括**内容**元素，它解决了
    AngularJS 中的臭名昭著的转包含问题。由于指令 API 和 Web 组件以不同的方式解决了类似的问题，因此在 Web 组件之上保留指令 API 将是多余的，并增加了不必要的复杂性。这就是为什么
    Angular 核心团队决定从头开始构建一个与 Web 组件兼容的框架，并充分利用这个新标准。Web 组件涉及新的功能；其中一些功能尚未被所有浏览器实现。如果我们的应用程序在一个不支持这些功能的浏览器中运行，Angular
    将模拟它们。一个例子是使用 `ng-content` 指令填充的内容元素。
- en: Web Workers
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web Workers
- en: JavaScript is known for its event loop. Usually, JavaScript programs are executed
    in a single thread and different events are scheduled by being pushed in a queue
    and processed sequentially, in the order of their arrival. However, this computational
    strategy is not effective when one of the scheduled events requires a lot of computational
    time. In such cases, the event's handling will block the main thread, and all
    other events will not be handled until the time-consuming computation is complete
    and the execution passed to the next one in the queue. A simple example of this
    is a mouse click that triggers an event, in which callback we do some audio processing
    using the HTML5 audio API. If the processed audio track is big and the algorithm
    running over it is heavy, this will affect the user's experience by freezing the
    UI until the execution is complete.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 以其事件循环而闻名。通常，JavaScript 程序是在单个线程中执行的，不同的事件通过被推入队列并按到达顺序依次处理来安排。然而，当预定的事件之一需要大量的计算时间时，这种计算策略并不有效。在这种情况下，事件的处理将阻塞主线程，并且所有其他事件将不会处理，直到耗时的计算完成并将执行传递到队列中的下一个事件。一个简单的例子是鼠标点击触发的事件，在其中我们使用
    HTML5 音频 API 进行一些音频处理。如果处理的音频轨道很大，并且运行其上的算法很重，这将通过冻结用户界面直到执行完成来影响用户体验。
- en: The Web Workers API was introduced in order to prevent such pitfalls. It allows
    execution of heavy computations inside the context of a different thread, which
    leaves the main thread of execution free, capable of handling user input and rendering
    the user interface.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers API 的引入是为了防止这样的陷阱。它允许在另一个线程的上下文中执行重计算，这使主执行线程保持空闲，能够处理用户输入和渲染用户界面。
- en: 'How can we take advantage of this in Angular? In order to answer this question,
    let''s think about how things work in AngularJS. What if we have an enterprise
    application, which processes a huge amount of data that needs to be rendered on
    the screen using data binding? For each binding, the framework will create a new
    watcher. Once the digest loop is run, it will loop over all the watchers, execute
    the expressions associated with them, and compare the returned results with the
    results gained from the previous iteration. We have a few slowdowns here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在 Angular 中利用这一点？为了回答这个问题，让我们思考一下 AngularJS 中事物是如何工作的。如果我们有一个企业应用程序，它处理大量需要通过数据绑定在屏幕上渲染的数据，会怎样？对于每个绑定，框架都会创建一个新的观察者。一旦运行了消化循环，它将遍历所有观察者，执行与它们相关的表达式，并将返回的结果与上一次迭代中获得的结果进行比较。在这里我们有几个减速点：
- en: The iteration over a large number of watchers.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对大量观察者的迭代。
- en: The evaluation of the expression in a given context.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给定上下文中评估表达式。
- en: The copy of the returned result.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回结果的副本。
- en: The comparison between the current result of the expression's evaluation and
    the previous one.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式评估的当前结果与之前的一个比较。
- en: All these steps could be quite slow, depending on the size of the input. If
    the digest loop involves heavy computations, why not move it to a Web Worker?
    Why not run the digest loop inside Web Worker, get the changed bindings, and then
    apply them to the DOM?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤可能会相当慢，这取决于输入的大小。如果消化循环涉及到大量的计算，为什么不将其移动到Web Worker中呢？为什么不将消化循环运行在Web
    Worker内部，获取已更改的绑定，然后将它们应用到DOM上呢？
- en: There were experiments by the community which aimed for this result. However,
    their integration into the framework wasn't trivial. One of the main reasons behind
    the lack of satisfying results was the coupling of the framework with the DOM.
    Often, inside the watchers' callbacks, AngularJS directly manipulates the DOM,
    which makes it impossible to move the watchers inside a Web Worker since the Web
    Workers are executed in an isolated context, without access to the DOM. In AngularJS,
    we may have implicit or explicit dependencies between the different watchers,
    which require multiple iterations of the digest loop in order to get stable results.
    Combining the last two points, it is quite hard to achieve practical results in
    calculating the changes in threads other than the main thread of execution.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 社区进行了一些实验，旨在实现这一结果。然而，它们与框架的集成并不简单。导致满意结果缺乏的一个主要原因是框架与DOM的耦合。通常，在观察者的回调函数内部，AngularJS直接操作DOM，这使得无法将观察者移动到Web
    Worker中，因为Web Workers是在一个隔离的上下文中执行的，没有访问DOM的权限。在AngularJS中，我们可能在不同观察者之间存在隐式或显式的依赖关系，这需要多次迭代消化循环才能得到稳定的结果。结合最后两点，在其他执行线程（而非主线程）中计算变化是非常困难的。
- en: Fixing this in AngularJS introduces a great deal of complexity into the internal
    implementation. The framework simply was not built with this in mind. Since Web
    Workers were introduced before the Angular 2 design process started, the core
    team took them into consideration from the beginning.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS中修复这个问题会在内部实现中引入大量的复杂性。这个框架显然没有考虑到这一点。由于Web Workers是在Angular 2设计过程开始之前引入的，因此核心团队从一开始就考虑了它们。
- en: Lessons learned from AngularJS in the wild
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从野外的AngularJS中学到的经验
- en: Although the previous section listed a lot of arguments for the required re-implementation
    of the framework responding to the latest trends, it's important to remember that
    we're not starting completely from scratch. We're taking what we've learned from
    AngularJS with us. In the period since 2009, the Web is not the only thing that
    evolved. We also started building more and more complex applications. Today, single-page
    applications are not something exotic, but more like a strict requirement for
    all web applications solving business problems, which are aiming for high performance
    and a good user experience.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上一节列出了很多关于响应最新趋势所需重新实现框架的论点，但重要的是要记住，我们并不是完全从头开始的。我们带着从AngularJS中学到的经验继续前进。自2009年以来，不仅仅是Web在进化。我们还开始构建越来越多地复杂的应用程序。如今，单页应用程序不再是某种异类，而是所有解决业务问题的网络应用程序的严格要求，它们追求高性能和良好的用户体验。
- en: AngularJS helped us to efficiently build large-scale, single-page applications.
    However, by applying it in various use cases, we've also discovered some of its
    pitfalls. Learning from the community's experience, Angular's core team worked
    on new ideas aiming to answer the new requirements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS帮助我们高效地构建大规模的单页应用程序。然而，通过在各种用例中应用它，我们也发现了它的一些陷阱。从社区的经验中学习，Angular的核心团队致力于新的想法，旨在回答新的需求。
- en: Controllers
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: AngularJS follows the **Model View Controller** (**MVC**) micro-architectural
    pattern. Some may argue that it looks more like **Model View ViewModel** (**MVVM**)
    because of the view model attached as properties to the scope or the current context
    in case of "controller as syntax". It could be approached differently again, if
    we use the **Model View Presenter pattern** (**MVP**). Because of all the different
    variations of how we can structure the logic in our applications, the core team
    called AngularJS a **Model View Whatever** (**MVW**) framework.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS遵循**模型-视图-控制器**（**MVC**）微架构模式。有些人可能会认为它更像**模型-视图-视图模型**（**MVVM**），因为视图模型作为属性附加到作用域或“控制器作为语法”中的当前上下文中。如果我们使用**模型-视图-表示者**（**MVP**）模式，它可能又有不同的处理方式。由于我们可以在应用程序中用不同的方式来结构逻辑，核心团队将AngularJS称为**模型-视图-任何**（**MVW**）框架。
- en: The view in any AngularJS application is supposed to be a composition of directives.
    The directives collaborate together in order to deliver fully functional user
    interfaces. Services are responsible for encapsulating the business logic of the
    applications. That's the place where we should put the communication with RESTful
    services through HTTP, real-time communication with WebSockets, and even WebRTC.
    Services are the building blocks where we should implement the domain models and
    business rules of our applications. There's one more component, which is mostly
    responsible for handling user input and delegating the execution to the services-the
    controller.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何 AngularJS 应用程序中，视图应该是由指令组成的。指令协同工作以提供功能齐全的用户界面。服务负责封装应用程序的业务逻辑。这就是我们在那里放置通过
    HTTP 与 RESTful 服务通信、通过 WebSocket 进行实时通信以及甚至 WebRTC 的地方。服务是我们应该实现应用程序领域模型和业务规则的建筑模块。还有一个组件，它主要负责处理用户输入并将执行委托给服务——控制器。
- en: Although the services and directives have well-defined roles, we can often see
    the anti-pattern of the **Massive View Controller**, which is common in iOS applications.
    Occasionally, developers are tempted to access or even manipulate the DOM directly
    from their controllers. Initially, this happens while you want to achieve something
    simple, such as changing the size of an element, or quick and dirty changing elements'
    styles. Another noticeable anti-pattern is the duplication of the business logic
    across controllers. Often, developers tend to copy and paste logic, which should
    be encapsulated inside services.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管服务和指令有明确的角色，但我们经常看到反模式**大量视图控制器**，这在 iOS 应用程序中很常见。偶尔，开发者会诱惑直接从他们的控制器访问或甚至操作
    DOM。最初，这发生在你想要实现一些简单的事情时，比如改变元素的大小，或者快速而粗糙地改变元素的样式。另一个值得注意的反模式是在控制器之间重复业务逻辑。通常，开发者倾向于复制和粘贴应该封装在服务内部的逻辑。
- en: The best practices for building AngularJS applications state that the controllers
    should not manipulate the DOM at all; instead, all DOM access and manipulations
    should be isolated in directives. If we have some repetitive logic between controllers,
    most likely we want to encapsulate it into a service and inject this service with
    the dependency injection mechanism of Angular in all the controllers that need
    that functionality.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 AngularJS 应用程序的最佳实践表明，控制器不应操纵 DOM；相反，所有 DOM 访问和操作都应隔离在指令中。如果我们有一些在控制器之间的重复逻辑，我们很可能想要将其封装到一个服务中，并使用
    Angular 的依赖注入机制将此服务注入到所有需要该功能的所有控制器中。
- en: This is where we're coming from in AngularJS. All this said, it seems that the
    functionality of controllers could be moved into the directive's controllers.
    Since directives support the dependency injection API, after receiving the user's
    input, we can directly delegate the execution to a specific service, already injected.
    This is the main reason why Angular now uses a different approach, by removing
    the ability to put controllers everywhere by using the `ng-controller` directive.
    We'll take a look at how AngularJS controllers' responsibilities could be taken
    from the new components and directives in [Chapter 4](ch04.html "Chapter 4. Getting
    Started with Angular Components and Directives"), *Getting Started with Angular
    Components and Directives*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在 AngularJS 中的出发点。所有这些话，似乎控制器的功能可以被移动到指令的控制器中。由于指令支持依赖注入 API，在接收到用户输入后，我们可以直接将执行委托给已经注入的特定服务。这就是为什么
    Angular 现在采用不同方法的主要原因，通过移除使用 `ng-controller` 指令将控制器放在任何地方的能力。我们将在第 4 章[“开始使用 Angular
    组件和指令”](ch04.html "第 4 章。开始使用 Angular 组件和指令")中查看 AngularJS 控制器的责任如何被新的组件和指令所取代。
- en: Scope
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围
- en: 'Data binding in AngularJS is achieved using the `scope` object. We can attach
    properties to it and explicitly declare in the template that we want to bind to
    these properties (one- or two-way). Although the idea of the scope seems clear,
    it has two more responsibilities, including event dispatching and the change detection-related
    behavior. Angular beginners have a hard time understanding what scope really is
    and how it should be used. AngularJS 1.2 introduced something called **controller
    as syntax**. It allows us to add properties to the current context inside the
    given controller (`this`), instead of explicitly injecting the `scope` object
    and later adding properties to it. This simplified syntax can be demonstrated
    through the following snippet:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS中，数据绑定是通过`scope`对象实现的。我们可以将其属性附加到它上，并在模板中显式声明我们想要绑定到这些属性（单向或双向）。尽管作用域的概念似乎很清晰，但它还有两个额外的职责，包括事件分发和与变更检测相关的行为。Angular初学者很难理解作用域到底是什么以及应该如何使用它。AngularJS
    1.2引入了所谓的**控制器作为语法**。它允许我们在给定控制器内部添加属性到当前上下文（`this`），而不是显式注入`scope`对象并稍后添加属性。这种简化的语法可以通过以下代码片段进行演示：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The latest Angular took this even further by removing the `scope` object. All
    the expressions are evaluated in the context of the given UI component. Removing
    the entire scope API introduces higher simplicity; we don't need to explicitly
    inject it anymore, instead we add properties to the UI components to which we
    can later bind. This API feels much simpler and more natural.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最新版本的Angular通过移除`scope`对象将这一概念进一步发扬光大。所有表达式都在给定的UI组件的上下文中进行评估。移除整个作用域API引入了更高的简洁性；我们不再需要显式地注入它，而是将属性添加到UI组件中，我们可以稍后将其绑定。这个API感觉更加简单和自然。
- en: We will take a more detailed look at the components and the change detection
    mechanism of Angular in [Chapter 4](ch04.html "Chapter 4. Getting Started with
    Angular Components and Directives"), *Getting Started with Angular Components
    and Directives*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](ch04.html "第4章。开始使用Angular组件和指令")*开始使用Angular组件和指令*中更详细地探讨Angular的组件和变更检测机制。
- en: Dependency injection
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Maybe the first framework on the market that included **inversion of control**
    (**IoC**) through **dependency injection** (**DI**) in the JavaScript world was
    AngularJS. DI provides a number of benefits, such as easier testability, better
    code organization and modularization, and simplicity. Although the DI in the first
    version of the framework does an amazing job, Angular 2 took this even further.
    Since the latest Angular is on top of the latest Web standards, it uses the ECMAScript
    2016 decorators' syntax for annotating the code for using DI. Decorators are quite
    similar to the decorators in Python or annotations in Java. They allow us to *decorate*
    the behavior of a given object, or add metadata to it, using reflection. Since
    decorators are not yet standardized and supported by major browsers, their usage
    requires an intermediate transpilation step; however, if you don't want to take
    it, you can directly write a little bit more verbose code with ECMAScript 5 syntax
    and achieve the same semantics.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是市场上第一个在JavaScript世界中通过**依赖注入**（**DI**）实现**控制反转**（**IoC**）的框架是AngularJS。DI提供了一系列好处，例如更易于测试、更好的代码组织和模块化，以及简洁性。尽管该框架第一版本的DI功能强大，但Angular
    2将这一概念进一步发扬光大。由于最新的Angular基于最新的Web标准，它使用ECMAScript 2016装饰器语法来注释使用DI的代码。装饰器与Python中的装饰器或Java中的注解非常相似。它们允许我们使用反射来**装饰**给定对象的行为，或为其添加元数据。由于装饰器尚未标准化且不被主流浏览器支持，其使用需要中间转译步骤；然而，如果您不想这样做，您可以直接使用ECMAScript
    5语法编写更多冗长的代码，并达到相同的语义。
- en: The new DI is much more flexible and feature-rich. It also fixes some of the
    pitfalls of AngularJS, such as the different APIs; in the first version of the
    framework, some objects are injected by position (such as the scope, element,
    attributes, and controller in the directives' link function) and others, by name
    (using parameters names in controllers, directives, services, and filters).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 新的DI更加灵活且功能丰富。它还修复了AngularJS的一些缺陷，例如不同的API；在框架的第一版本中，一些对象通过位置（例如指令的链接函数中的作用域、元素、属性和控制器）注入，而其他对象则通过名称（使用控制器、指令、服务和过滤器中的参数名称）注入。
- en: We will take a further look at the Angular's dependency injection API in [Chapter
    5](ch05.html "Chapter 5. Dependency Injection in Angular"), *Dependency Injection
    in Angular*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第5章](ch05.html "第5章。Angular中的依赖注入")*Angular中的依赖注入*中进一步探讨Angular的依赖注入API。
- en: Server-side rendering
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: The bigger the requirements of the Web are, the more complex web applications
    become. Building a real-life, single-page application requires writing a huge
    amount of JavaScript, and including all the required external libraries may increase
    the size of the scripts on our page to a few megabytes. The initialization of
    the application may take up to several seconds or even tens of seconds on mobile
    until all the resources get fetched from the server, the JavaScript is parsed
    and executed, the page gets rendered, and all the styles are applied. On low-end
    mobile devices that use a mobile Internet connection, this process may make the
    users give up on visiting our application. Although there are a few practices
    that speed up this process, in complex applications, there's no silver bullet.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 网络需求越大，Web应用就越复杂。构建一个真实的单页应用需要编写大量的JavaScript，并且包含所有必需的外部库可能会使页面上的脚本大小增加到几兆字节。在移动设备上，直到从服务器获取所有资源、解析并执行JavaScript、渲染页面以及应用所有样式，应用的初始化可能需要几秒钟甚至几十秒钟。在低端移动设备上，使用移动网络连接时，这个过程可能会让用户放弃访问我们的应用。尽管有一些做法可以加快这个过程，但在复杂的应用中，并没有一劳永逸的解决方案。
- en: In the process of trying to improve the user experience, developers discovered
    something called **server-side rendering**. It allows us to render the requested
    view of a single-page application on the server and directly provide the HTML
    for the page to the user. Later, once all the resources are processed, the event
    listeners and bindings can be added by the script files. This sounds like a good
    way to boost the performance of our application. One of the pioneers in this was
    React, which allowed prerendering of the user interface on the server side using
    Node.js DOM implementations. Unfortunately, the architecture of AngularJS does
    not allow this. The showstopper is the strong coupling between the framework and
    the browser APIs, the same issue we had in running the change detection in Web
    Workers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试提升用户体验的过程中，开发者发现了一种称为**服务器端渲染**的技术。它允许我们在服务器上渲染单页应用的请求视图，并直接将页面的HTML提供给用户。一旦所有资源都处理完毕，脚本文件可以添加事件监听器和绑定。这听起来像是提升我们应用性能的好方法。在这方面，React是一个先驱，它允许使用Node.js
    DOM实现来在服务器端预渲染用户界面。不幸的是，AngularJS的架构不允许这样做。主要障碍是框架与浏览器API之间的强耦合，这正是我们在Web Workers中运行变更检测时遇到的问题。
- en: Another typical use case for the server-side rendering is for building **Search
    Engine Optimization** (**SEO**)-friendly applications. There were a couple of
    hacks used in the past for making the AngularJS applications indexable by the
    search engines. One such practice, for instance, is the traversal of the application
    with a headless browser, which executes the scripts on each page and caches the
    rendered output into HTML files, making it accessible by the search engines.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染的另一个典型用例是构建**搜索引擎优化**（**SEO**）友好型应用。过去，为了使AngularJS应用可由搜索引擎索引，人们使用了一些技巧。例如，一种做法是使用无头浏览器遍历应用，在每个页面上执行脚本并将渲染输出缓存到HTML文件中，使其可被搜索引擎访问。
- en: Although this workaround for building SEO-friendly applications works, server-side
    rendering solves both of the above-mentioned issues, improving the user experience
    and allowing us to build SEO-friendly applications much more easily and far more
    elegantly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管构建SEO友好型应用的这种解决方案是可行的，但服务器端渲染解决了上述两个问题，提升了用户体验，并使我们能够更加轻松且优雅地构建SEO友好型应用。
- en: The decoupling of Angular with the DOM allows us to run our Angular applications
    outside the context of the browser. We will take a further look at it in [Chapter
    8](ch08.html "Chapter 8. Tooling and Development Experience"), *Tooling and Development
    Experience*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将Angular与DOM解耦使我们能够在浏览器之外运行Angular应用。我们将在[第8章](ch08.html "第8章。工具和开发体验")*工具和开发体验*中进一步探讨这一点。
- en: Applications that scale
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展的应用
- en: 'MVW has been the default choice for building single-page applications since
    Backbone.js appeared. It allows separation of concerns by isolating the business
    logic from the view, allowing us to build well-designed applications. Taking advantage
    of the observer pattern, MVW allows listening for model changes in the view and
    updating it when changes are detected. However, there are some explicit and implicit
    dependencies between these event handlers, which make the data flow in our applications
    not obvious and hard to reason about. In AngularJS, we are allowed to have dependencies
    between the different watchers, which requires the digest loop to iterate over
    all of them a couple of times until the expressions'' results get stable. The
    new Angular makes the data flow one-directional; this has a number of benefits:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Backbone.js出现以来，MVW（Model-View-Whatever）一直是构建单页应用程序的默认选择。它通过将业务逻辑与视图隔离开来，使我们能够构建设计良好的应用程序。利用观察者模式，MVW允许在视图中监听模型变化，并在检测到变化时更新它。然而，这些事件处理器之间存在一些显式和隐式的依赖关系，这使得我们应用程序中的数据流不明显，难以推理。在AngularJS中，我们允许不同观察者之间存在依赖关系，这要求消化循环迭代所有这些观察者几次，直到表达式的结果稳定。新的Angular使数据流单向；这带来了许多好处：
- en: More explicit data flow.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更明确的数据流。
- en: No dependencies between bindings, so no **time to live** (**TTL**) of the digest.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定之间没有依赖关系，因此没有**生存时间**（**TTL**）。
- en: 'Better performance of the framework:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架性能更好：
- en: The digest loop is run only once.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消化循环只运行一次。
- en: We can create apps, which are friendly to immutable or observable models, that
    allow us to make further optimizations.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建对不可变或可观察模型友好的应用程序，这使我们能够进行进一步的优化。
- en: The change in the data flow introduces one more fundamental change in AngularJS
    architecture.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流的变化在AngularJS架构中引入了另一个根本性的变化。
- en: We may take another perspective on this problem when we need to maintain a large
    codebase written in JavaScript. Although JavaScript's duck typing makes the language
    quite flexible, it also makes its analysis and support by IDEs and text editors
    harder. Refactoring of large projects gets very hard and error-prone because in
    most cases, the static analysis and type inference are impossible. The lack of
    compiler makes typos all too easy, which are hard to notice until we run our test
    suite or run the application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要维护一个用JavaScript编写的庞大代码库时，我们可能会对这个问题的看法有所不同。尽管JavaScript的鸭子类型使语言非常灵活，但它也使得IDE和文本编辑器对其分析和支持变得更加困难。大型项目的重构变得非常困难且容易出错，因为在大多数情况下，静态分析和类型推断是不可能的。缺少编译器使得打字错误变得过于容易，直到我们运行测试套件或运行应用程序，我们才难以注意到这些错误。
- en: 'The Angular core team decided to use TypeScript because of the better tooling
    possible with it and the compile-time type checking, which help us to be more
    productive and less error-prone. As the following diagram shows, TypeScript is
    a superset of ECMAScript; it introduces explicit type annotations and a compiler:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TypeScript提供了更好的工具和编译时类型检查，Angular核心团队决定使用TypeScript，这有助于我们提高生产效率并减少错误。正如以下图表所示，TypeScript是ECMAScript的超集；它引入了显式的类型注解和编译器：
- en: '![Applications that scale](img/5081_01_01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![可扩展的应用程序](img/5081_01_01.jpg)'
- en: Figure 1
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: The TypeScript language is compiled to plain JavaScript, supported by today's
    browsers. Since version 1.6, TypeScript implements the ECMAScript 2016 decorators,
    which makes it the perfect choice for Angular.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript语言编译成普通JavaScript，被今天的浏览器支持。自1.6版本以来，TypeScript实现了ECMAScript 2016装饰器，使其成为Angular的完美选择。
- en: The usage of TypeScript allows much better IDE and text editors' support with
    static code analysis and type checking. All this increases our productivity dramatically
    by reducing the mistakes we make and simplifying the refactoring process. Another
    important benefit of TypeScript is the performance improvement we implicitly get
    by the static typing, which allows runtime optimizations by the JavaScript virtual
    machine.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的使用允许IDE和文本编辑器提供更好的支持，包括静态代码分析和类型检查。所有这些通过减少我们犯的错误并简化重构过程，极大地提高了我们的生产效率。TypeScript的另一个重要好处是通过静态类型隐式获得的性能提升，这使得JavaScript虚拟机可以进行运行时优化。
- en: We'll be talking about TypeScript in detail in [Chapter 3](ch03.html "Chapter 3. TypeScript
    Crash Course"), *TypeScript Crash Course*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](ch03.html "第3章。TypeScript快速入门")*TypeScript快速入门*中详细讨论TypeScript。
- en: Templates
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: Templates are one of the key features in AngularJS. They are simple HTML and
    do not require any intermediate translation, unlike most template engines, such
    as mustache. Templates in Angular combine simplicity with power by allowing us
    to extend HTML by creating an internal **domain-specific language** (**DSL**)
    inside it, with custom elements and attributes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是AngularJS的关键特性之一。它们是简单的HTML，不需要任何中间转换，与大多数模板引擎（如mustache）不同。Angular的模板通过允许我们在其中创建一个内部**领域特定语言**（**DSL**），结合了自定义元素和属性，将简单性与强大功能相结合。
- en: This is one of the main purposes of Web Components as well. We already mentioned
    how and why Angular takes advantage of this new technology. Although AngularJS
    templates are great, they can still get better! The new Angular templates took
    the best parts of the ones in the previous release of the framework and enhanced
    them by fixing some of their confusing parts.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是Web Components的主要目的之一。我们已经提到了Angular如何以及为什么利用这项新技术。尽管AngularJS模板很棒，但它们仍然可以变得更好！新的Angular模板吸收了框架先前版本中模板的精华，并通过修复其中一些令人困惑的部分来增强它们。
- en: 'For example, let''s say we have a directive and we want to allow the user to
    pass a property to it using an attribute. In AngularJS, we can approach this in
    the following three different ways:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个指令，并希望允许用户通过属性传递给它。在AngularJS中，我们可以用以下三种不同的方式来处理这个问题：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the `user` directive, we pass the `name` property using three different approaches.
    We can either pass a literal (in this case, the string `"literal"`), a string,
    which will be evaluated as an expression (in our case `"expression"`), or an expression
    inside, `{{ }}`. Which syntax should be used completely depends on the directive's
    implementation, which makes its API tangled and hard to remember.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`user`指令中，我们通过三种不同的方法传递`name`属性。我们可以传递一个字面量（在这种情况下，字符串`"literal"`），一个字符串，它将被评估为一个表达式（在我们的案例中是`"expression"`），或者一个在`{{
    }}`内的表达式。应该使用哪种语法完全取决于指令的实现，这使得它的API错综复杂，难以记忆。
- en: It is a frustrating task to deal with a large amount of components with different
    design decisions on a daily basis. By introducing a common convention, we can
    handle such problems. However, in order to have good results and consistent APIs,
    the entire community needs to agree with it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每天处理大量具有不同设计决策的组件是一项令人沮丧的任务。通过引入一个共同约定，我们可以处理这些问题。然而，为了获得良好的结果和一致的API，整个社区都需要达成一致。
- en: The new Angular deals with this problem by providing special syntax for attributes,
    whose values need to be evaluated in the context of the current component, and
    a different syntax for passing literals.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Angular通过提供特殊语法来处理这个问题，这些属性的值需要在当前组件的上下文中进行评估，并且为传递字面量提供了不同的语法。
- en: 'Another thing we''re used to, based on our AngularJS experience, is the microsyntax
    in template directives, such as `ng-if` and `ng-for`. For instance, if we want
    to iterate over a list of users and display their names in AngularJS, we can use:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的AngularJS经验，我们还习惯于模板指令中的微语法，例如`ng-if`和`ng-for`。例如，如果我们想在AngularJS中遍历用户列表并显示他们的名字，我们可以使用：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Although this syntax looks intuitive to us, it allows limited tooling support.
    However, Angular 2 approached this differently by bringing a little bit more explicit
    syntax with richer semantics:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种语法对我们来说看起来直观，但它只提供了有限的工具支持。然而，Angular 2通过引入更多明确的语法和更丰富的语义来解决这个问题：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding snippet explicitly defines the property, which has to be created
    in the context of the current iteration (`user`), and the one we iterate over
    (`users`).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段明确定义了属性，这些属性必须在当前迭代（`user`）的上下文中创建，以及我们迭代的（`users`）。
- en: 'Since this syntax is too verbose for typing, developers can use the following
    syntax, which later gets translated to the more verbose one:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种语法在键入时过于冗长，开发者可以使用以下语法，它最终会被转换成更冗长的形式：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The improvements in the new templates will also allow better tooling for advanced
    support by text editors and IDEs. We will discuss Angular's templates in [Chapter
    4](ch04.html "Chapter 4. Getting Started with Angular Components and Directives"),
    *Getting Started with Angular Components and Directives*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 新模板的改进也将允许更好的工具支持高级功能，例如文本编辑器和IDE。我们将在[第4章](ch04.html "第4章。开始使用Angular组件和指令")*开始使用Angular组件和指令*中讨论Angular的模板。
- en: Change detection
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变更检测
- en: In the *Web Workers* section, we already mentioned the opportunity to run the
    digest loop in the context of a different thread, instantiated as Web Worker.
    However, the implementation of the digest loop in AngularJS is not quite as memory-efficient
    and prevents the JavaScript virtual machine from doing further code optimizations,
    which allows for significant performance improvements. One such optimization is
    the inline caching ( [http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html](http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html)
    ).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Web Workers* 部分，我们已经提到了在作为 Web Worker 实例化的不同线程上下文中运行消化循环的机会。然而，AngularJS
    中消化循环的实现并不那么内存高效，并阻止 JavaScript 虚拟机进行进一步的代码优化，这允许实现显著的性能提升。其中一种优化是内联缓存（[http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html](http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html)）。
- en: The Angular team did a lot of research in order to discover different ways the
    performance and efficiency of the change detection could be improved. This led
    to the development of a brand new change detection mechanism.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 团队进行了大量研究，以发现提高变更检测性能和效率的不同方法。这导致了全新的变更检测机制的诞生。
- en: 'As a result, Angular performs change detection in code that the framework directly
    generates from the components'' templates. The code is generated by the **Angular
    compiler**. There are two built-in code generation (also known as compilation)
    strategies:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Angular 在框架直接从组件模板生成的代码中执行变更检测。代码由 **Angular 编译器**生成。有两种内置的代码生成（也称为编译）策略：
- en: '**Just-in-Time (JiT) compilation**: At runtime, Angular generates code that
    performs change detection on the entire application. The generated code is optimized
    for the JavaScript virtual machine, which provides a great performance boost.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即时编译 (JiT)**：在运行时，Angular 生成代码以在整个应用程序上执行变更检测。生成的代码针对 JavaScript 虚拟机进行了优化，从而提供了显著的性能提升。'
- en: '**Ahead-of-Time (AoT) compilation**: Similar to JiT, with the difference that
    the code is being generated as part of the application''s build process. It can
    be used for speeding the rendering up by not performing the compilation in the
    browser and also in environments that disallow `eval()`, such as **CSP** (**Content-Security-Policy**)
    and Chrome extensions. We will discuss it further in the next sections of the
    book.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提前编译 (AoT)**：与即时编译 (JiT) 类似，但不同之处在于代码作为应用程序构建过程的一部分被生成。它可以用于通过不在浏览器中执行编译来加速渲染，也可以用于不允许
    `eval()` 的环境，例如 **内容安全策略 (CSP)** 和 Chrome 扩展。我们将在本书的下一节中进一步讨论。'
- en: We will take a look at the new change detection mechanisms and how we can configure
    them in [Chapter 4](ch04.html "Chapter 4. Getting Started with Angular Components
    and Directives"), *Getting Started with Angular Components and Directives*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 4 章 [“开始使用 Angular 组件和指令”](ch04.html "第 4 章。开始使用 Angular 组件和指令") 中查看新的变更检测机制以及如何配置它们。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we considered the main reasons behind the decisions taken by
    the Angular core team and the lack of backward compatibility between the last
    two major versions of the framework. We saw that these decisions were fueled by
    two things-the evolution of the Web and the evolution of the frontend development,
    with the lessons learned from the development of AngularJS applications.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们考虑了 Angular 核心团队做出决策的主要原因以及框架最后两个主要版本之间缺乏向后兼容性的原因。我们看到，这些决策是由两件事推动的——Web
    的演变和前端开发的演变，以及从 AngularJS 应用程序开发中学到的经验教训。
- en: In the first section, we learned why we need to use the latest version of the
    JavaScript language, why to take advantage of Web Components and Web Workers,
    and why it's not worth it to integrate all these powerful tools in version 1.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们学习了为什么需要使用 JavaScript 语言的最新版本，为什么应该利用 Web 组件和 Web Workers，以及为什么在版本 1
    中集成所有这些强大的工具并不值得。
- en: We observed the current direction of frontend development and the lessons learned
    in the last few years. We described why the controller and scope were removed
    from Angular 2, and why AngularJS's architecture was changed in order to allow
    server-side rendering for SEO-friendly, high-performance, single-page applications.
    Another fundamental topic we took a look at was building large-scale applications,
    and how that motivated single-way data flow in the framework and the choice of
    the statically typed language, TypeScript.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察了前端开发的当前方向和过去几年中吸取的教训。我们描述了为什么控制器和作用域被从 Angular 2 中移除，以及为什么为了允许 SEO 友好、高性能的单页应用程序进行服务器端渲染，AngularJS
    的架构发生了变化。我们审视的另一个基本主题是构建大规模应用程序，以及它是如何激励框架中的单向数据流和选择静态类型语言 TypeScript 的。
- en: In the next chapter, we will take a look at the main building blocks of an Angular
    application, how they can be used and how they relate to each other. The new Angular
    reuses some of the naming of the concepts introduced by AngularJS, but generally
    changes the building blocks of our single-page applications completely. We will
    take a peek at the new concepts and compare them with the ones in the previous
    version of the framework. We'll make a quick introduction to modules, directives,
    components, routers, pipes, and services, and describe how they could be combined
    for building classy, single-page applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Angular 应用程序的主要构建块，它们的使用方法以及它们之间的关系。新的 Angular 重用了 AngularJS 中引入的一些概念名称，但通常完全改变了我们的单页应用程序的构建块。我们将简要了解新概念，并将它们与框架的前一个版本中的概念进行比较。我们将快速介绍模块、指令、组件、路由器、管道和服务，并描述如何将它们组合起来构建优雅的单页应用程序。
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for this book from your account at [http://www.packtpub.com](http://www.packtpub.com)
    . If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载本书的示例代码文件。如果您在其他地方购买了这本书，您可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册，以便将文件直接通过电子邮件发送给您。
