<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer033">
<h1 class="chapter-number" id="_idParaDest-172"><a id="_idTextAnchor183"/>10</h1>
<h1 id="_idParaDest-173"><a id="_idTextAnchor184"/>Filtering and Searching Data</h1>
<p>In this chapter, we’ll continue applying the techniques we’ve already learned to another, more complex use case.</p>
<p>As we work through the chapter, we’ll learn how to adjust a component’s design using tests to show us where the design is lacking. Test-driven development really helps highlight design issues when the tests get knarly. Luckily, the tests we’ve already written give us the confidence to change course and completely reinvent our design. With each change, we simply run <strong class="source-inline">npm test</strong> and have our new implementation verified in a matter of seconds.</p>
<p>In the current workflow, users start by adding a new customer and then immediately book an appointment for that customer. Now, we’ll expand on that by allowing them to choose an existing customer before adding an appointment.</p>
<p>We want users to be able to quickly search through customers. There could be hundreds, maybe thousands, of customers registered with this salon. So, we’ll build a <strong class="source-inline">CustomerSearch</strong> search component that will allow our users to search for customers by name and to page through the returned results.</p>
<p>In this chapter, you’ll learn about the following topics:</p>
<ul>
<li>Displaying tabular data fetched from an endpoint</li>
<li>Paging through a large dataset</li>
<li>Filtering data</li>
<li>Performing actions with render props</li>
</ul>
<p>The following screenshot shows how the new component will look:</p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<img alt="Figure 10.1 – The new CustomerSearch component " height="1305" src="image/Figure_10.01_B18423.jpg" width="1466"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – The new CustomerSearch component</p>
<p>By the end of the chapter, you’ll have built a relatively complex component using all the techniques you’ve learned so far.</p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor185"/>Technical requirements</h1>
<p>The code files for this chapter can be found here: </p>
<p><a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter10">https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter10</a></p>
<h1 id="_idParaDest-175">D<a id="_idTextAnchor186"/>isplaying tabular data fetched from an endpoint</h1>
<p>In this section, we’ll <a id="_idIndexMarker965"/>get the basic form of the table in place, with an initial set of data retrieved from the server when the component is mounted.</p>
<p>The server <strong class="bold">application programming interface (API)</strong> supports <strong class="source-inline">GET</strong> requests to <strong class="source-inline">/customers</strong>. There is a <strong class="source-inline">searchTerm</strong> parameter that takes the string the user is searching for. There is also an <strong class="source-inline">after</strong> parameter that is used to retrieve the next page of results. The response is an array of customers, as shown here:</p>
<pre class="source-code">
[{ id: 123, firstName: "Ashley"}, ... ]</pre>
<p>Sending a request to <strong class="source-inline">/customers</strong> with no parameters will return the first 10 of our customers, in alphabetical order by first name.</p>
<p>This gives us a good place to start. When the component mounts, we’ll perform this basic search and display the results in a table.</p>
<p class="callout-heading">Skipping the starting point</p>
<p class="callout">If you’re following along using the GitHub repository, be aware that this chapter starts with a barebones <strong class="source-inline">CustomerSearch</strong> component already implemented, and it has already been hooked up to the <strong class="source-inline">App</strong> component. The component is displayed by clicking on the <strong class="bold">Search appointments</strong> button in the top menu.</p>
<p>Let’s start with our first test for the new <strong class="source-inline">CustomerSearch</strong> component. Follow these steps:</p>
<ol>
<li>Open <strong class="source-inline">test/CustomerSearch.test.js</strong> and add the first test. It checks that a table has been rendered with the four headings that we want to see. The code is illustrated in the following snippet:<p class="source-code">it("renders a table with four headings", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;CustomerSearch /&gt;);</p><p class="source-code">  const headings = elements("table th");</p><p class="source-code">  expect(textOf(headings)).toEqual([</p><p class="source-code">    "First name",</p><p class="source-code">    "Last name",</p><p class="source-code">    "Phone number",</p><p class="source-code">    "Actions",</p><p class="source-code">  ]);</p><p class="source-code">});</p></li>
<li>That test should be <a id="_idIndexMarker966"/>simple to pass with the following definition for <strong class="source-inline">CustomerSearch</strong> in <strong class="source-inline">src/CustomerSearch.js</strong>:<p class="source-code">export const CustomerSearch = () =&gt; (</p><p class="source-code">  &lt;table&gt;</p><p class="source-code">    &lt;thead&gt;</p><p class="source-code">      &lt;tr&gt;</p><p class="source-code">        &lt;th&gt;First name&lt;/th&gt;</p><p class="source-code">        &lt;th&gt;Last name&lt;/th&gt;</p><p class="source-code">        &lt;th&gt;Phone number&lt;/th&gt;</p><p class="source-code">        &lt;th&gt;Actions&lt;/th&gt;</p><p class="source-code">      &lt;/tr&gt;</p><p class="source-code">    &lt;/thead&gt;</p><p class="source-code">  &lt;/table&gt;</p><p class="source-code"> );</p></li>
<li>In order to display data, the component will need to make a <strong class="source-inline">GET</strong> request. Write out this next test, which specifies that behavior:<p class="source-code">it("fetches all customer data when component mounts", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;CustomerSearch /&gt;);</p><p class="source-code">  expect(global.fetch).toBeCalledWith("/customers", {</p><p class="source-code">    method: "GET",</p><p class="source-code">    credentials: "same-origin",</p><p class="source-code">    headers: { "Content-Type": "application/json" },</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>To make that pass, add a <strong class="source-inline">useEffect</strong> hook to the component that performs the search. We need to use the same <strong class="source-inline">useEffect</strong> ceremony that we’ve seen before, using an inline function to ensure we don’t return a value and passing an empty array to the dependency list, which ensures the effect only runs when the component <a id="_idIndexMarker967"/>is first mounted. The code is illustrated in the following screenshot:<p class="source-code">export const CustomerSearch = () =&gt; {</p><p class="source-code">  useEffect(() =&gt; {</p><p class="source-code">    const fetchData = async () =&gt;</p><p class="source-code">      await global.fetch("/customers", {</p><p class="source-code">        method: "GET",</p><p class="source-code">        credentials: "same-origin",</p><p class="source-code">        headers: {</p><p class="source-code">          "Content-Type": "application/json"</p><p class="source-code">        },</p><p class="source-code">      });</p><p class="source-code">    fetchData();</p><p class="source-code">  }, []);</p><p class="source-code">  return (</p><p class="source-code">    ...</p><p class="source-code">  )</p><p class="source-code">};</p></li>
<li>Now, it’s time to code what happens depending on the data returned. We’ll start by figuring out the display of a single row of data. Add a definition of <strong class="source-inline">oneCustomer</strong> at the top of the file, above the <strong class="source-inline">describe</strong> block, as follows:<p class="source-code">const oneCustomer = [</p><p class="source-code">  {</p><p class="source-code">    id: 1,</p><p class="source-code">    firstName: "A",</p><p class="source-code">    lastName: "B",</p><p class="source-code">    phoneNumber: "1"</p><p class="source-code">  },</p><p class="source-code">];</p></li>
<li>Make use of<a id="_idIndexMarker968"/> that definition in the next test, shown in the following code snippet, which verifies that the component displays all the customer data for a single customer row:<p class="source-code">it("renders all customer data in a table row", async () =&gt; {</p><p class="source-code">  global.fetch.mockResolvedValue(</p><p class="source-code">    fetchResponseOk(oneCustomer)</p><p class="source-code">  );</p><p class="source-code">  await renderAndWait(&lt;CustomerSearch /&gt;);</p><p class="source-code">  const columns = elements("table &gt; tbody &gt; tr &gt; td");</p><p class="source-code">  expect(columns[0]).toContainText("A");</p><p class="source-code">  expect(columns[1]).toContainText("B");</p><p class="source-code">  expect(columns[2]).toContainText("1");</p><p class="source-code">});</p></li>
<li>To make this pass, we’ll need to use component state to pass data back from the <strong class="source-inline">useEffect</strong> hook into the next render cycle. Create a new state variable, <strong class="source-inline">customers</strong>, which has an initial value of the empty array (<strong class="source-inline">[]</strong>), as follows:<p class="source-code">const [customers, setCustomers] = useState([]);</p></li>
<li>Save the results of the search into <strong class="source-inline">customers</strong> by modifying the definition of <strong class="source-inline">useEffect</strong>, as <a id="_idIndexMarker969"/>shown here:<p class="source-code">const fetchData = <strong class="bold">async</strong> () =&gt; <strong class="bold">{</strong></p><p class="source-code"><strong class="bold">  const result = </strong>await global.fetch(...);</p><p class="source-code"><strong class="bold">  setCustomers(await result.json());</strong></p><p class="source-code"><strong class="bold">};</strong></p></li>
<li>We’re ready to display the data. We’ll do that with a new <strong class="source-inline">CustomerRow</strong> component that is responsible for displaying a single row of customer information. Add its implementation above the definition of <strong class="source-inline">CustomerSearch</strong>. Notice here how the final column is blank; it will hold action buttons that perform various operations on the specific customer record. We’ll use a separate test later to fill out that functionality:<p class="source-code">const CustomerRow = ({ customer }) =&gt; (</p><p class="source-code">  &lt;tr&gt;</p><p class="source-code">    &lt;td&gt;{customer.firstName}&lt;/td&gt;</p><p class="source-code">    &lt;td&gt;{customer.lastName}&lt;/td&gt;</p><p class="source-code">    &lt;td&gt;{customer.phoneNumber}&lt;/td&gt;</p><p class="source-code">    &lt;td /&gt;</p><p class="source-code">  &lt;/tr&gt;</p><p class="source-code">);</p></li>
<li>All that’s left is to make use of this new component in <strong class="source-inline">CustomerSearch</strong>. Add the following <strong class="source-inline">tbody</strong> element, which renders <strong class="source-inline">CustomerRow</strong> for the first customer, if it exists. After adding this code, your test should now be passing:<p class="source-code">return (</p><p class="source-code">  &lt;table&gt;</p><p class="source-code">    &lt;thead&gt;</p><p class="source-code">      ...</p><p class="source-code">    &lt;/thead&gt;</p><p class="source-code"><strong class="bold">    &lt;tbody&gt;</strong></p><p class="source-code"><strong class="bold">      {customers[0] ? (</strong></p><p class="source-code"><strong class="bold">        &lt;CustomerRow customer={customers[0]} /&gt;</strong></p><p class="source-code"><strong class="bold">      ) : null}</strong></p><p class="source-code"><strong class="bold">    &lt;/tbody&gt;</strong></p><p class="source-code">  &lt;/table&gt;</p><p class="source-code">);</p></li>
<li>For the final<a id="_idIndexMarker970"/> test in this section, let’s add a test to show that this works for multiple customers. For that, we need a new result set: <strong class="source-inline">twoCustomers</strong>. This can be placed at the top of the file, after <strong class="source-inline">oneCustomer</strong>, as shown in the following code snippet:<p class="source-code">const twoCustomers = [</p><p class="source-code">  {</p><p class="source-code">    id: 1,</p><p class="source-code">    firstName: "A",</p><p class="source-code">    lastName: "B",</p><p class="source-code">    phoneNumber: "1"</p><p class="source-code">  },</p><p class="source-code">  {</p><p class="source-code">    id: 2,</p><p class="source-code">    firstName: "C",</p><p class="source-code">    lastName: "D",</p><p class="source-code">    phoneNumber: "2"</p><p class="source-code">  }</p><p class="source-code">];</p></li>
<li>Then, add a<a id="_idIndexMarker971"/> test that makes use of this and checks that two rows are rendered, as follows:<p class="source-code">it("renders multiple customer rows", async () =&gt; {</p><p class="source-code">  global.fetch.mockResolvedValue(</p><p class="source-code">    fetchResponseOk(twoCustomers)</p><p class="source-code">  );</p><p class="source-code">  await renderAndWait(&lt;CustomerSearch /&gt;);</p><p class="source-code">  const rows = elements("table tbody tr");</p><p class="source-code">  expect(rows[1].childNodes[0]).toContainText("C");</p><p class="source-code">});</p></li>
<li>Making this pass is a one-liner; change the JSX to map over each customer, instead of pulling out just the first customer:<p class="source-code">&lt;tbody&gt;</p><p class="source-code">  <strong class="bold">{customers.map(customer =&gt; (</strong></p><p class="source-code"><strong class="bold">     &lt;CustomerRow</strong></p><p class="source-code"><strong class="bold">       customer={customer}</strong></p><p class="source-code"><strong class="bold">       key={customer.id}</strong></p><p class="source-code"><strong class="bold">     /&gt;</strong></p><p class="source-code"><strong class="bold">    )</strong></p><p class="source-code"><strong class="bold">  )}</strong></p><p class="source-code">&lt;/tbody&gt;</p></li>
</ol>
<p>This gives us <a id="_idIndexMarker972"/>a great base to build on for the remaining functionality we’ll build in this chapter.</p>
<p>In the next section, we’ll introduce the ability to move between multiple pages of search re<a id="_idTextAnchor187"/>sults.</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor188"/>Paging through a large dataset</h1>
<p>By default, our endpoint returns 10 records. To get the next 10 records, we can page through the result set <a id="_idIndexMarker973"/>by using<a id="_idIndexMarker974"/> the <strong class="source-inline">after</strong> parameter, which represents the last customer identifier seen. The server will skip through results until it finds that ID and returns results from the next customer onward.</p>
<p>We’ll add <strong class="bold">Next</strong> and <strong class="bold">Previous</strong> buttons that will help us move between search results. Clicking <strong class="bold">Next</strong> will take the ID of the last customer record currently shown on the page and send it as the <strong class="source-inline">after</strong> parameter to the next search request.</p>
<p>To support <strong class="bold">Previous</strong>, we’ll need to maintain a stack of <strong class="source-inline">after</strong> IDs that we can pop each time the user clicks <strong class="bold">P<a id="_idTextAnchor189"/>revious</strong>.</p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor190"/>Adding a button to move to the next page</h2>
<p>Let’s start <a id="_idIndexMarker975"/>with the <strong class="bold">Next</strong> button, which the user can click to bring them to the next page of results. Since we’re going to be dealing with multiple buttons on the screens, we’ll build a new <strong class="source-inline">buttonWithLabel</strong> helper <a id="_idIndexMarker976"/>that will match a button with that label. Follow these steps:</p>
<ol>
<li value="1">In <strong class="source-inline">test/reactTestExtensions.js</strong>, add the following new helper function at the bottom of the file:<p class="source-code">export const buttonWithLabel = (label) =&gt;</p><p class="source-code">  elements("button").find(</p><p class="source-code">    ({ textContent }) =&gt; textContent === label</p><p class="source-code"> );</p></li>
<li>Back in <strong class="source-inline">test/CustomerSearch.test.js</strong>, update the import statement to include this new helper function, like so:<p class="source-code">import {</p><p class="source-code">  ...,</p><p class="source-code">  buttonWithLabel,</p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Write the <a id="_idIndexMarker977"/>following test, which will let us get a <strong class="bold">Next</strong> button onto the page:<p class="source-code">it("has a next button", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;CustomerSearch /&gt;);</p><p class="source-code">  expect(buttonWithLabel("Next")).not.toBeNull();</p><p class="source-code">});</p></li>
<li>Create a <strong class="source-inline">SearchButtons</strong> component that renders the <strong class="bold">Next</strong> button in a <strong class="source-inline">menu</strong> element, just as we did in <strong class="source-inline">App</strong>. We’ll be expanding this menu bar with more buttons in subsequent tests. The code is illustrated here:<p class="source-code">const SearchButtons = () =&gt; (</p><p class="source-code">  &lt;menu&gt;</p><p class="source-code">    &lt;li&gt;</p><p class="source-code">      &lt;button&gt;Next&lt;/button&gt;</p><p class="source-code">    &lt;/li&gt;</p><p class="source-code">  &lt;/menu&gt;</p><p class="source-code">);</p></li>
<li>Now, render that in <strong class="source-inline">CustomerSearch</strong>, above the table, as follows:<p class="source-code">return (</p><p class="source-code"><strong class="bold">  &lt;&gt;</strong></p><p class="source-code"><strong class="bold">    &lt;SearchButtons /&gt;</strong></p><p class="source-code">    &lt;table&gt;</p><p class="source-code">      ...</p><p class="source-code">    &lt;/table&gt;</p><p class="source-code"><strong class="bold">  &lt;/&gt;</strong></p><p class="source-code">);</p></li>
<li>When the button is clicked, we want to take the last customer ID already displayed<a id="_idIndexMarker978"/> and send that back to the server. To make that choice obvious in our tests, we’ll use a new return value named <strong class="source-inline">tenCustomers</strong>, which mimics the default number of records coming back from the server API. Place this definition of <strong class="source-inline">tenCustomers</strong> at the top of the file, next to your other customer definitions, like so:<p class="source-code">const tenCustomers =</p><p class="source-code">  Array.from("0123456789", id =&gt; ({ id })</p><p class="source-code">);</p></li>
</ol>
<p class="callout-heading">Making good use of Array.from</p>
<p class="callout">This definition <a id="_idIndexMarker979"/>uses a “clever” version of the <strong class="source-inline">Array.from</strong> function that takes each character of the string and creates an object using that character as input. We end up with 10 objects, each with an <strong class="source-inline">id</strong> property ranging from <strong class="source-inline">0</strong> to <strong class="source-inline">9</strong>.</p>
<ol>
<li value="7">The next test checks that when the <strong class="bold">Next</strong> button is clicked, the component makes a new <strong class="source-inline">GET</strong> request with the last seen customer ID. Given our previous definition of <strong class="source-inline">tenCustomers</strong>, that is the customer with ID <strong class="source-inline">9</strong>. Notice in the following code snippet how <strong class="source-inline">toHaveBeenLastCalledWith</strong> is needed since this will be the second call to <strong class="source-inline">global.fetch</strong>:<p class="source-code">it("requests next page of data when next button is clicked", async () =&gt; {</p><p class="source-code">  global.fetch.mockResolvedValue(</p><p class="source-code">    fetchResponseOk(tenCustomers)</p><p class="source-code">  );</p><p class="source-code">  await renderAndWait(&lt;CustomerSearch /&gt;);</p><p class="source-code">  await clickAndWait(buttonWithLabel("Next"));</p><p class="source-code">  expect(global.fetch).toHaveBeenLastCalledWith(</p><p class="source-code">    "/customers?after=9",</p><p class="source-code">    expect.anything()</p><p class="source-code">  );</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Avoiding unnecessary fields to highlight important implications</p>
<p class="callout">The <strong class="source-inline">tenCustomers</strong> value is only a partial definition for each customer: only the <strong class="source-inline">id</strong> property is included. That’s not lazy: it’s intentional. Because the logic of taking the last ID is non-obvious, it’s important to highlight the <strong class="source-inline">id</strong> property as the key feature of this flow. We won’t worry about the other fields because our previous tests check their correct usage.</p>
<ol>
<li value="8">To make this <a id="_idIndexMarker980"/>pass, define a handler for the <strong class="bold">Next</strong> button that performs the <strong class="source-inline">fetch</strong> request. It calculates the <strong class="source-inline">after</strong> request parameter by taking the last customer in the <strong class="source-inline">customers</strong> state variable, as illustrated in the following code snippet:<p class="source-code">const handleNext = useCallback(() =&gt; {</p><p class="source-code">  const after = customers[customers.length - 1].id;</p><p class="source-code">  const url = `/customers?after=${after}`;</p><p class="source-code">  global.fetch(url, {</p><p class="source-code">    method: "GET",</p><p class="source-code">    credentials: "same-origin",</p><p class="source-code">    headers: { "Content-Type": "application/json" }</p><p class="source-code">  });</p><p class="source-code">}, [customers]);</p></li>
<li>Give <strong class="source-inline">SearchButtons</strong> a <strong class="source-inline">handleNext</strong> prop and set that as the <strong class="source-inline">onClick</strong> handler<a id="_idIndexMarker981"/> on the button, like so:<p class="source-code">const SearchButtons = <strong class="bold">({ handleNext }</strong>) =&gt; (</p><p class="source-code">  &lt;menu&gt;</p><p class="source-code">    &lt;li&gt;</p><p class="source-code">      &lt;button<strong class="bold"> onClick={handleNext}&gt;</strong>Next&lt;/button&gt;</p><p class="source-code">    &lt;/li&gt;</p><p class="source-code">  &lt;/menu&gt;</p><p class="source-code">);</p></li>
<li>Hook the handler up to <strong class="source-inline">SearchButtons</strong>, as follows. After this change, your test should be passing:<p class="source-code">&lt;SearchButtons<strong class="bold"> handleNext={handleNext}</strong> /&gt;</p></li>
<li>Continue by adding the following test. It sets up two <strong class="source-inline">fetch</strong> responses using a sequence of <strong class="source-inline">mockResolvedValueOnce</strong> followed by <strong class="source-inline">mockResolvedValue</strong>. The second response only contains one record. The test asserts that this record is displayed after pressing the <strong class="bold">Next</strong> button:<p class="source-code">it("displays next page of data when next button is clicked", async () =&gt; {</p><p class="source-code">  const nextCustomer = [{ id: "next", firstName: "Next" }];</p><p class="source-code">  global.fetch</p><p class="source-code">    .mockResolvedValueOnce(</p><p class="source-code">      fetchResponseOk(tenCustomers)</p><p class="source-code">    )</p><p class="source-code">    .mockResolvedValue(fetchResponseOk(nextCustomer));</p><p class="source-code">  await renderAndWait(&lt;CustomerSearch /&gt;);</p><p class="source-code">  await clickAndWait(buttonWithLabel("Next"));</p><p class="source-code">  expect(elements("tbody tr")).toHaveLength(1);</p><p class="source-code">  expect(elements("td")[0]).toContainText("Next");</p><p class="source-code">});</p></li>
<li>To make this pass, modify <strong class="source-inline">handleNext</strong> to save its response into the <strong class="source-inline">customers</strong> state variable, as follows:<p class="source-code">const handleNext = useCallback(<strong class="bold">async</strong> () =&gt; {</p><p class="source-code">  ...</p><p class="source-code"><strong class="bold">  const result = </strong>await global.fetch(...);</p><p class="source-code"><strong class="bold">  setCustomers(await result.json());</strong></p><p class="source-code">}, [customers]);</p></li>
</ol>
<p>That’s it<a id="_idIndexMarker982"/> for our <strong class="bold">Next</strong> button. Before we move on to the <strong class="bold">Previous</strong> button, we need to correct a design issue.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor191"/>Adjusting the design </h2>
<p>Look here<a id="_idIndexMarker983"/> at the similarities between the <strong class="source-inline">handleNext</strong> and <strong class="source-inline">fetchData</strong> functions. They are almost identical; the only place they differ is in the first parameter to the <strong class="source-inline">fetch</strong> call. The <strong class="source-inline">handleNext</strong> function has an <strong class="source-inline">after</strong> parameter; <strong class="source-inline">fetchData</strong> has no parameters:</p>
<pre class="source-code">
const handleNext = useCallback(<strong class="bold">async</strong> () =&gt; {
<strong class="bold">  const after = customers[customers.length - 1].id;</strong>
<strong class="bold">  const url = `/customers?after=${after}`;</strong>
<strong class="bold">  const result = </strong>await global.fetch(<strong class="bold">url</strong>, ...);
<strong class="bold">  setCustomers(await result.json());</strong>
}, [customers]);
const fetchData = <strong class="bold">async</strong> () =&gt; <strong class="bold">{</strong>
<strong class="bold">  const result = </strong>await global.fetch(`/customers`, ...);
<strong class="bold">  setCustomers(await result.json());</strong>
<strong class="bold">};</strong></pre>
<p>We will be adding a <strong class="bold">Previous</strong> button, which would result in further duplication if we carried on with this same design. But there’s an alternative. We can take advantage of the <strong class="source-inline">useEffect</strong> hook’s ability to rerun when the state changes.</p>
<p>We will introduce a new state variable, <strong class="source-inline">queryString</strong>, which <strong class="source-inline">handleNext</strong> will update and <strong class="source-inline">useEffect</strong> will listen for.</p>
<p>Let’s do that now. Proceed as follows:</p>
<ol>
<li value="1">Add that new variable now at the top of the <strong class="source-inline">CustomerSearch</strong> component, as shown in the following code snippet. Its initial value is the empty string, which is important:<p class="source-code">const [queryString, setQueryString] = useState("");</p></li>
<li>Replace <strong class="source-inline">handleNext</strong> with the following function:<p class="source-code">const handleNext = useCallback(() =&gt; {</p><p class="source-code">  const after = customers[customers.length - 1].id;</p><p class="source-code"><strong class="bold">  const newQueryString = `?after=${after}`;</strong></p><p class="source-code"><strong class="bold">  setQueryString(newQueryString);</strong></p><p class="source-code">}, [customers]);</p></li>
<li>Update <strong class="source-inline">useEffect</strong> with <a id="_idIndexMarker984"/>the following definition, appending <strong class="source-inline">queryString</strong> to the <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>). Your tests should still be passing at this <a id="_idIndexMarker985"/>point:<p class="source-code">useEffect(() =&gt; {</p><p class="source-code">  const fetchData = async () =&gt; {</p><p class="source-code">    const result = await global.fetch(</p><p class="source-code">      `/customers<strong class="bold">${queryString}`</strong>,</p><p class="source-code">      ...</p><p class="source-code">    );</p><p class="source-code">    setCustomers(await result.json());</p><p class="source-code">  };</p><p class="source-code">  fetchData();</p><p class="source-code">}, [<strong class="bold">queryString</strong>]);</p></li>
</ol>
<p>That’s it for the <strong class="bold">Next</strong> button: you’ve seen how to write elegant tests for a complex piece of API <a id="_idIndexMarker986"/>orchestration logic, and we’ve refactored our production code<a id="_idTextAnchor192"/> to be elegant, too.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor193"/>Adding a button to move to the previous page</h2>
<p>Let’s <a id="_idIndexMarker987"/>move on to the <strong class="bold">Previous</strong> button:</p>
<ol>
<li value="1">Write out the following test:<p class="source-code">it("has a previous button", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;CustomerSearch /&gt;);</p><p class="source-code">  expect(buttonWithLabel("Previous")).not.toBeNull();</p><p class="source-code">});</p></li>
<li>Make that pass by modifying <strong class="source-inline">SearchButtons</strong> to include the following button, just before the <strong class="bold">Next</strong> button:<p class="source-code">&lt;menu&gt;</p><p class="source-code">  &lt;li&gt;</p><p class="source-code">    &lt;button&gt;Previous&lt;/button&gt;</p><p class="source-code">  &lt;/li&gt;</p><p class="source-code">  ...</p><p class="source-code">&lt;/menu&gt;</p></li>
<li>The next test mounts the component, clicks <strong class="bold">Next</strong>, and then clicks <strong class="bold">Previous</strong>. It expects<a id="_idIndexMarker988"/> another call to the endpoint to have been made, but this time identical to the initial page—in other words, with no query string. The code is illustrated here:<p class="source-code">it("moves back to first page when previous button is clicked", async () =&gt; {</p><p class="source-code">  global.fetch.mockResolvedValue(</p><p class="source-code">    fetchResponseOk(tenCustomers)</p><p class="source-code">  );</p><p class="source-code">  await renderAndWait(&lt;CustomerSearch /&gt;);</p><p class="source-code">  await clickAndWait(buttonWithLabel("Next"));</p><p class="source-code">  await clickAndWait(buttonWithLabel("Previous"));</p><p class="source-code">  expect(global.fetch).toHaveBeenLastCalledWith(</p><p class="source-code">    "/customers",</p><p class="source-code">    expect.anything()</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>To make this pass, start by defining a <strong class="source-inline">handlePrevious</strong> function, as follows:<p class="source-code">const handlePrevious = useCallback(</p><p class="source-code">  () =&gt; setQueryString(""),</p><p class="source-code">  []</p><p class="source-code">);</p></li>
<li>Modify <strong class="source-inline">SearchButtons</strong> to take a new <strong class="source-inline">handlePrevious</strong> prop, and set that<a id="_idIndexMarker989"/> as the <strong class="source-inline">onClick</strong> handler on the new button, like so:<p class="source-code">const SearchButtons = (</p><p class="source-code">  { handleNext<strong class="bold">, handlePrevious</strong> }</p><p class="source-code">) =&gt; (</p><p class="source-code">  &lt;menu&gt;</p><p class="source-code">    &lt;li&gt;</p><p class="source-code">      &lt;button</p><p class="source-code"><strong class="bold">        onClick={handlePrevious}</strong></p><p class="source-code">      &gt;</p><p class="source-code">        Previous</p><p class="source-code">      &lt;/button&gt;</p><p class="source-code">    &lt;/li&gt;</p><p class="source-code">    ...</p><p class="source-code">  &lt;/menu&gt;</p><p class="source-code">);</p></li>
<li>Hook up the handler to <strong class="source-inline">SearchButtons</strong>, like so. After this, your test should be passing:<p class="source-code">&lt;SearchButtons</p><p class="source-code">  handleNext={handleNext}</p><p class="source-code"><strong class="bold">  handlePrevious={handlePrevious}</strong></p><p class="source-code">/&gt;</p></li>
<li>The next test is one that’ll require us to do some thinking. It simulates clicking <strong class="bold">Next</strong> twice, then clicking <strong class="bold">Previous</strong> once. For the second <strong class="bold">Next</strong> click, we need another set of customers. Add <strong class="source-inline">anotherTenCustomers</strong> just after the definition <a id="_idIndexMarker990"/>of <strong class="source-inline">tenCustomers</strong>, as follows:<p class="source-code">const anotherTenCustomers =</p><p class="source-code">  Array.from("ABCDEFGHIJ", id =&gt; ({ id }));</p></li>
<li>Now, add the next test, which checks that the <strong class="bold">Previous</strong> button still works after navigating to two more pages:<p class="source-code">it("moves back one page when clicking previous after multiple clicks of the next button", async () =&gt; {</p><p class="source-code">  global.fetch</p><p class="source-code">    .mockResolvedValueOnce(</p><p class="source-code">      fetchResponseOk(tenCustomers)</p><p class="source-code">    )</p><p class="source-code">    .mockResolvedValue(</p><p class="source-code">      fetchResponseOk(anotherTenCustomers)</p><p class="source-code">    );</p><p class="source-code">  await renderAndWait(&lt;CustomerSearch /&gt;);</p><p class="source-code">  await clickAndWait(buttonWithLabel("Next"));</p><p class="source-code">  await clickAndWait(buttonWithLabel("Next"));</p><p class="source-code">  await clickAndWait(buttonWithLabel("Previous"));</p><p class="source-code">  expect(global.fetch).toHaveBeenLastCalledWith(</p><p class="source-code">    "/customers?after=9",</p><p class="source-code">    expect.anything()</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>We’ll make this pass by maintaining a record <a id="_idIndexMarker991"/>of the query strings that were passed to the endpoint. For this specific test, we only need to know what<a id="_idIndexMarker992"/> the <em class="italic">previous</em> query string was. Add a new state variable to record that, as follows:<p class="source-code">const [</p><p class="source-code">  previousQueryString, setPreviousQueryString</p><p class="source-code">] = useState("");</p></li>
</ol>
<p class="callout-heading">Forcing design issues</p>
<p class="callout">You may recognize this as an overly complicated design. Let’s just go with it for now: we will simplify this again with another test.</p>
<ol>
<li value="10">Change <strong class="source-inline">handleNext</strong> to save the previous query string, making sure that this happens before the call to <strong class="source-inline">setQueryString</strong>. Include <strong class="source-inline">queryString</strong> in the array passed to the second parameter of <strong class="source-inline">useCallback</strong> so that this callback is regenerated each time the value of <strong class="source-inline">queryString</strong> changes. The code is illustrated in the following snippet:<p class="source-code">const handleNext = useCallback(queryString =&gt; {</p><p class="source-code">  ...</p><p class="source-code">  <strong class="bold">setPreviousQueryString(queryString);</strong></p><p class="source-code">  setQueryString(newQueryString);</p><p class="source-code">}, [customers, <strong class="bold">queryString</strong>]);</p></li>
<li>Now, <strong class="source-inline">handlePrevious</strong> can use this value as the query string to pass to <strong class="source-inline">fetchData</strong>, as illustrated here. Your test should be passing at this point:<p class="source-code">const handlePrevious = useCallback(async () =&gt;</p><p class="source-code">  setQueryString(<strong class="bold">previousQueryString</strong>)</p><p class="source-code">, [<strong class="bold">previousQueryString</strong>]);</p></li>
</ol>
<p>That’s it for a basic <strong class="bold">Previous</strong> button implementation. However, what happens when we want to <a id="_idIndexMarker993"/>go back two or more pages? Our current design only has a “depth” of two additional pages. What if we want to support any number of pages?</p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor194"/>Forcing design changes using tests</h2>
<p>We can use <a id="_idIndexMarker994"/>a test to force the design issue. The process of TDD helps us to ensure that we always take time to think about the simplest solution that solves all tests. So, if we add one more test that highlights the limits of the current design, that test becomes a trigger for us to stop, think, and reimplement.</p>
<p>In this case, we can use a stack of previous query strings to remember the history of pages. We’ll replace our two state<a id="_idIndexMarker995"/> variables, <strong class="source-inline">queryString</strong> and <strong class="source-inline">previousQueryString</strong>, with a single state variable, <strong class="source-inline">queryStrings</strong>, which is a stack of all previous query strings.</p>
<p>Let’s get started with the test. Follow these steps:</p>
<ol>
<li value="1">Add this test, which asserts that the <strong class="bold">Previous</strong> button works for multiple presses: <p class="source-code">it("moves back multiple pages", async () =&gt; {</p><p class="source-code">  global.fetch</p><p class="source-code">    .mockResolvedValue(fetchResponseOk(tenCustomers));</p><p class="source-code">  await renderAndWait(&lt;CustomerSearch /&gt;);</p><p class="source-code">  await clickAndWait(buttonWithLabel("Next"));</p><p class="source-code">  await clickAndWait(buttonWithLabel("Next"));</p><p class="source-code">  await clickAndWait(buttonWithLabel("Previous"));</p><p class="source-code">  await clickAndWait(buttonWithLabel("Previous"));</p><p class="source-code">  expect(global.fetch).toHaveBeenLastCalledWith(</p><p class="source-code">    "/customers",</p><p class="source-code">    expect.anything()</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>For this to pass, start by adding a new <strong class="source-inline">queryStrings</strong> state variable, deleting <strong class="source-inline">queryString</strong> and <strong class="source-inline">previousQueryStrings</strong>, as follows:<p class="source-code">const [queryStrings, setQueryStrings] = useState([]);</p></li>
<li>Change <strong class="source-inline">fetchData</strong> as follows. If there are entries in the <strong class="source-inline">queryStrings</strong> array, it sets <strong class="source-inline">queryString</strong> to the last entry, and that value is then passed to the <strong class="source-inline">fetch</strong> call. If <a id="_idIndexMarker996"/>there’s nothing in the array, then <strong class="source-inline">queryString</strong> will be an empty string:<p class="source-code">useEffect(() =&gt; {</p><p class="source-code">  const fetchData = async () =&gt; {</p><p class="source-code"><strong class="bold">    const queryString =</strong></p><p class="source-code"><strong class="bold">      queryStrings[queryStrings.length - 1] || "";</strong></p><p class="source-code">    const result = await global.fetch(</p><p class="source-code">      `/customers${queryString}`,</p><p class="source-code">      ...</p><p class="source-code">    );</p><p class="source-code">    setCustomers(await result.json());</p><p class="source-code">  };</p><p class="source-code">  fetchData();</p><p class="source-code">}, [<strong class="bold">queryStrings</strong>]);</p></li>
<li>Change <strong class="source-inline">handleNext</strong> as follows. It now <em class="italic">appends</em> the current query string to the<a id="_idIndexMarker997"/> previous query strings:<p class="source-code">const handleNext = useCallback(() =&gt; {</p><p class="source-code">  const after = customers[customers.length - 1].id;</p><p class="source-code">  const newQueryString = `?after=${after}`;</p><p class="source-code"><strong class="bold">  setQueryStrings([...queryStrings, newQueryString]);</strong></p><p class="source-code">}, [customers, <strong class="bold">queryStrings</strong>]);</p></li>
<li>Change <strong class="source-inline">handlePrevious</strong> as follows. The last value is <em class="italic">popped off</em> the query string stack:<p class="source-code">const handlePrevious = useCallback(() =&gt; {</p><p class="source-code">  <strong class="bold">setQueryStrings(queryStrings.slice(0, -1));</strong></p><p class="source-code">} [<strong class="bold">queryStrings</strong>]);</p></li>
</ol>
<p>You now have a relatively complete implementation for the <strong class="bold">Next</strong> and <strong class="bold">Previous</strong> buttons. You’ve also seen how tests can help you alter your design as you encounter issues<a id="_idIndexMarker998"/> with it.</p>
<p>Next, we’ll continue building out our integration with the <strong class="source-inline">searchTerm</strong> parameter of<a id="_idTextAnchor195"/> the <strong class="source-inline">/customers</strong> HTTP endpoint.  </p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor196"/>Filtering data</h1>
<p>In this section, we’ll <a id="_idIndexMarker999"/>add a textbox that the user can use to filter names. Each character that the user types into the search field will cause a new <strong class="source-inline">fetch</strong> request to be made to the server. That request will contain the new search term as provided by the search box.</p>
<p>The <strong class="source-inline">/customers</strong> endpoint supports a parameter named <strong class="source-inline">searchTerm</strong> that filters search results using those terms, as shown in the following code snippet:</p>
<pre class="source-code">
GET /customers?searchTerm=Dan
[
  {
    firstName: "Daniel",
    ...
  }
  ...
]</pre>
<p>Let’s start by adding a text field into which the user can input a search term, as follows: </p>
<ol>
<li value="1">Add the following test to the <strong class="source-inline">CustomerSearch</strong> test suite, just below the last test. It simply checks for a new field:<p class="source-code">it("renders a text field for a search term", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;CustomerSearch /&gt;);</p><p class="source-code">  expect(element("input")).not.toBeNull();</p><p class="source-code">});</p></li>
<li>In <strong class="source-inline">CustomerSearch</strong>, update your JSX to add that input element at the top of the component, as follows:<p class="source-code">return (</p><p class="source-code">  &lt;&gt;</p><p class="source-code"><strong class="bold">    &lt;input /&gt;</strong></p><p class="source-code">    ...</p><p class="source-code">  &lt;/&gt;</p><p class="source-code">);</p></li>
<li>Next, we want to check that the <strong class="source-inline">placeholder</strong> attribute for that field is set. We can do this by running the following code:<p class="source-code">it("sets the placeholder text on the search term field", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;CustomerSearch /&gt;);</p><p class="source-code">  expect(</p><p class="source-code">    element("input").getAttribute("placeholder")</p><p class="source-code">  ).toEqual("Enter filter text");</p><p class="source-code">});</p></li>
<li>To make that <a id="_idIndexMarker1000"/>pass, add the placeholder to the input element in your JSX, like so:<p class="source-code">&lt;input <strong class="bold">placeholder="Enter filter text"</strong> /&gt;</p></li>
<li>We want to hook this up to the DOM change event: we’ll make an <strong class="source-inline">async</strong> fetch request every time the value changes. For that, we’ll need a new helper. In <strong class="source-inline">test/reactTestExtensions.js</strong>, add the following definition for <strong class="source-inline">changeAndWait</strong>, just <a id="_idIndexMarker1001"/>below the definition of <strong class="source-inline">change</strong>. This allows us to run effects when the DOM change event occurs:<p class="source-code">export const changeAndWait = async (target, value) =&gt;</p><p class="source-code">  act(async () =&gt; change(target, value));</p></li>
<li>Import the new helper at the top of <strong class="source-inline">test/CustomerSearch.test.js</strong>, like so:<p class="source-code">import {</p><p class="source-code">  ...,</p><p class="source-code"><strong class="bold">  changeAndWait,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Each time a new character is entered into the search box, we should perform a new search with <a id="_idIndexMarker1002"/>whatever text is entered in the textbox. Add the following test:<p class="source-code">it("performs search when search term is changed", async () =&gt; {</p><p class="source-code">  await renderAndWait(&lt;CustomerSearch /&gt;);</p><p class="source-code">  await changeAndWait(element("input"), "name");</p><p class="source-code">  expect(global.fetch).toHaveBeenLastCalledWith(</p><p class="source-code">    "/customers?searchTerm=name",</p><p class="source-code">    expect.anything()</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>Define a new <strong class="source-inline">searchTerm</strong> variable, as follows:<p class="source-code">const [searchTerm, setSearchTerm] = useState("");</p></li>
<li>Add a new handler, <strong class="source-inline">handleSearchTextChanged</strong>, as follows. It stores the search term in the state because we’ll need to pull it back when moving between pages:<p class="source-code">const handleSearchTextChanged = (</p><p class="source-code">  { target: { value } }</p><p class="source-code">) =&gt; setSearchTerm(value);</p></li>
<li>Hook it up to the input element, like so:<p class="source-code">&lt;input</p><p class="source-code"><strong class="bold">  value={searchTerm}</strong></p><p class="source-code"><strong class="bold">  onChange={handleSearchTextChanged}</strong></p><p class="source-code">  placeholder="Enter filter text"</p><p class="source-code">/&gt;</p></li>
<li>Now, we can use the <strong class="source-inline">searchTerm</strong> variable in <strong class="source-inline">fetchData</strong> to fetch the updated set<a id="_idIndexMarker1003"/> of customers from the server, as follows:<p class="source-code">const fetchData = async () =&gt; {</p><p class="source-code"><strong class="bold">  let queryString = "";</strong></p><p class="source-code">  <strong class="bold">if (searchTerm !== "") {</strong></p><p class="source-code"><strong class="bold">    queryString = `?searchTerm=${searchTerm}`;</strong></p><p class="source-code"><strong class="bold">  } else</strong> if (queryStrings.length &gt; 0) {</p><p class="source-code">    queryString =</p><p class="source-code">     queryStrings[queryStrings.length - 1];</p><p class="source-code">  }</p><p class="source-code">  ...</p><p class="source-code">};</p></li>
<li>Finally, we need to modify <strong class="source-inline">useEffect</strong> by adding <strong class="source-inline">searchTerm</strong> to the dependency list, as follows. After this, the test should be passing:<p class="source-code">useEffect(() =&gt; {</p><p class="source-code"> ...</p><p class="source-code">}, [queryStrings<strong class="bold">, searchTerm</strong>]);</p></li>
<li>We need to ensure that hitting the <strong class="bold">Next</strong> button will maintain our search term. Right now, it won’t. We can use the following test to fix that:<p class="source-code">it("includes search term when moving to next page", async () =&gt; {</p><p class="source-code">  global.fetch.mockResolvedValue(</p><p class="source-code">    fetchResponseOk(tenCustomers)</p><p class="source-code">  );</p><p class="source-code">  await renderAndWait(&lt;CustomerSearch /&gt;);</p><p class="source-code">  await changeAndWait(element("input"), "name");</p><p class="source-code">  await clickAndWait(buttonWithLabel("Next"));</p><p class="source-code">  expect(global.fetch).toHaveBeenLastCalledWith(</p><p class="source-code">    "/customers?after=9&amp;searchTerm=name",</p><p class="source-code">    expect.anything()</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>To make this<a id="_idIndexMarker1004"/> pass, let’s force the behavior into <strong class="source-inline">fetchData</strong> with an addition to the <strong class="source-inline">if</strong> statement, as follows:<p class="source-code">const fetchData = async () =&gt; {</p><p class="source-code">  let queryString;</p><p class="source-code">  <strong class="bold">if (queryStrings.length &gt; 0 &amp;&amp; searchTerm !== "") {</strong></p><p class="source-code"><strong class="bold">    queryString =</strong></p><p class="source-code"><strong class="bold">      queryStrings[queryStrings.length - 1]</strong></p><p class="source-code"><strong class="bold">      + `&amp;searchTerm=${searchTerm}`;</strong></p><p class="source-code"><strong class="bold">  } else</strong> if (searchTerm !== '') {</p><p class="source-code">    queryString = `?searchTerm=${searchTerm}`;</p><p class="source-code">  } else if (queryStrings.length &gt; 0) {</p><p class="source-code">    queryString =</p><p class="source-code">      queryStrings[queryStrings.length - 1];</p><p class="source-code">  }</p><p class="source-code">  ...</p><p class="source-code">};</p></li>
</ol>
<p>We’ve made this test<a id="_idIndexMarker1005"/> pass... but this is a mess! Any <strong class="source-inline">if</strong> statement with so many moving parts (variables, operators, conditions, and so on) is a signal that the design is<a id="_idTextAnchor197"/>n’t as good as it can be. Let’s fix it.</p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor198"/>Refactoring to simplify the component design</h2>
<p>The issue is <a id="_idIndexMarker1006"/>the <strong class="source-inline">queryString</strong> data structure and its historical counterpart, the <strong class="source-inline">queryStrings</strong> state variable. The construction is complex.</p>
<p>How about we just store the <em class="italic">original data</em> instead—the ID of the customer in the last table row? Then, we can construct the <strong class="source-inline">queryString</strong> data structure immediately before fetching, since in reality, <strong class="source-inline">queryString</strong> is an input to the <strong class="source-inline">fetch</strong> request only. Keeping the raw data seems like it will be simpler.</p>
<p>Let’s plan out our refactor. At each of the following stages, our tests should still be passing, giving us confidence that we’re still on the right path:</p>
<ol>
<li value="1">First, move the query string building logic from <strong class="source-inline">handleNext</strong> into <strong class="source-inline">fetchData</strong>, changing the values that are stored in <strong class="source-inline">queryStrings</strong> from query strings to <a id="_idIndexMarker1007"/>customer IDs in the process.</li>
<li>Then, change the names of those variables, using your editor’s search and replace facility.</li>
<li>Finally, simplify the logic in <strong class="source-inline">fetchData</strong>.</li>
</ol>
<p>Doesn’t sound so hard, does it? Let’s begin, as follows:</p>
<ol>
<li value="1">At the top of the component, replace the <strong class="source-inline">queryStrings</strong> variable with this new one:<p class="source-code">const [lastRowIds, setLastRowIds] = useState([]);</p></li>
<li>Use your editor’s search and replace facility to change all occurrences of <strong class="source-inline">queryStrings</strong> to <strong class="source-inline">lastRowIds</strong>.</li>
<li>Likewise, change the call to <strong class="source-inline">setQueryStrings</strong> to a call to <strong class="source-inline">setLastRowIds</strong>. Your tests should still be passing at this point.</li>
<li>Delete the following line from <strong class="source-inline">handleNext</strong>:<p class="source-code">const newQueryString = `?after=${after}`;</p></li>
<li>On the line below that, change the call to <strong class="source-inline">fetchData</strong> to pass in <strong class="source-inline">after</strong> instead of the now deleted <strong class="source-inline">newQueryString</strong>, as follows:<p class="source-code">const handleNext = useCallback(() =&gt; {</p><p class="source-code">  const after = customers[customers.length - 1].id;</p><p class="source-code">  setLastRowIds([...lastRowIds, <strong class="bold">after</strong>]);</p><p class="source-code">}, [customers, lastRowIds]);</p></li>
<li>In the same <a id="_idIndexMarker1008"/>function, rename <strong class="source-inline">after</strong> <strong class="source-inline">currentLastRowId</strong>. Your tests should still be passing at this point.</li>
<li>It’s time to simplify the logic within <strong class="source-inline">fetchData</strong>. Create a <strong class="source-inline">searchParams</strong> function that will generate the search parameters for us, given values for <strong class="source-inline">after</strong> and <strong class="source-inline">searchTerm</strong>. This can be defined outside of your component. The code is illustrated here:<p class="source-code">const searchParams = (after, searchTerm) =&gt; {</p><p class="source-code">  let pairs = [];</p><p class="source-code">  if (after) {</p><p class="source-code">    pairs.push(`after=${after}`);</p><p class="source-code">  }</p><p class="source-code">  if (searchTerm) {</p><p class="source-code">    pairs.push(`searchTerm=${searchTerm}`);</p><p class="source-code">  }</p><p class="source-code">  if (pairs.length &gt; 0) {</p><p class="source-code">    return `?${pairs.join("&amp;")}`;</p><p class="source-code">  }</p><p class="source-code">  return "";</p><p class="source-code">};</p></li>
<li>Finally, update <strong class="source-inline">fetchData</strong> to use this new function in place of the existing query string logic, as shown here. At this point, your tests should be passing, with a vastly simpler and easier-to-understand implementation:<p class="source-code">const fetchData = async () =&gt; {</p><p class="source-code"><strong class="bold">  const after = lastRowIds[lastRowIds.length - 1];</strong></p><p class="source-code"><strong class="bold">  const queryString = searchParams(after, searchTerm);</strong></p><p class="source-code">  const response = await global.fetch(...);</p><p class="source-code">};</p></li>
</ol>
<p>You’ve now built a <a id="_idIndexMarker1009"/>functional search component. You introduced a new helper, <strong class="source-inline">changeAndWait</strong>, and<a id="_idIndexMarker1010"/> extracted out a <strong class="source-inline">searchParams</strong> function that could be reused in other places.</p>
<p>Next, we’ll add a fina<a id="_idTextAnchor199"/>l mechanism to the <strong class="source-inline">CustomerSearch</strong> component.</p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor200"/>Performing actions with render props</h1>
<p>Each row<a id="_idIndexMarker1011"/> of the table will hold a <strong class="bold">Create appointment</strong> action button. When the user has found the customer that they are searching for, they can press this button to navigate to the <strong class="source-inline">AppointmentForm</strong> component, creating an appointment for that customer.</p>
<p>We’ll display these actions by<a id="_idIndexMarker1012"/> using a <strong class="bold">render prop</strong> that is passed to <strong class="source-inline">CustomerSearch</strong>. The parent component—in our case, <strong class="source-inline">App</strong>—uses this to insert its own rendering logic into the child component. <strong class="source-inline">App</strong> will pass a function that displays a button that causes a view transition in <strong class="source-inline">App</strong> itself.</p>
<p>Render props are useful if the child component should be unaware of the context it’s operating in, such as the workflow that <strong class="source-inline">App</strong> provides.</p>
<p class="callout-heading">Unnecessarily complex code alert!</p>
<p class="callout">The implementation you’re about to see could be considered more complex than it needs to be. There are other approaches to solving this problem: you could simply have <strong class="source-inline">CustomerSearch</strong> render <strong class="source-inline">AppointmentFormLoader</strong> directly, or you could allow <strong class="source-inline">CustomerSearch</strong> to render the button and then invoke a callback such as <strong class="source-inline">onSelect(customer)</strong>.</p>
<p class="callout">Render props are probably more useful to library authors than to any application authors since library components can’t account for the context they run within.</p>
<p class="callout">The testing techniques we need for render props are much more complex than anything we’ve seen so far, which you can take as another sign that there are “better” solutions.</p>
<p>To begin with, we’ll<a id="_idIndexMarker1013"/> add the <strong class="source-inline">renderCustomerActions</strong> prop to <strong class="source-inline">CustomerSearch</strong> and render it in a new table cell. Follow these steps:</p>
<ol>
<li value="1">In <strong class="source-inline">test/CustomerSearch.test.js</strong>, write the following test:<p class="source-code">it("displays provided action buttons for each customer", async () =&gt; {</p><p class="source-code">  const actionSpy = jest.fn(() =&gt; "actions");</p><p class="source-code">  global.fetch.mockResolvedValue(</p><p class="source-code">   fetchResponseOk(oneCustomer)</p><p class="source-code">  );</p><p class="source-code">  await renderAndWait(</p><p class="source-code">    &lt;CustomerSearch</p><p class="source-code">      renderCustomerActions={actionSpy}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  const rows = elements("table tbody td");</p><p class="source-code">  expect(rows[rows.length - 1])</p><p class="source-code">    .toContainText("actions");</p><p class="source-code">});</p></li>
<li>Set a default <strong class="source-inline">renderCustomerActions</strong> prop so that our existing tests won’t start failing when we begin using the new prop, as follows. This goes at the bottom of <strong class="source-inline">src/CustomerSearch.js</strong>:<p class="source-code">CustomerSearch.defaultProps = {</p><p class="source-code">  renderCustomerActions: () =&gt; {}</p><p class="source-code">};</p></li>
<li>Destructure that <a id="_idIndexMarker1014"/>prop in the top line of the <strong class="source-inline">CustomerSearch</strong> component, like so:<p class="source-code">export const CustomerSearch = (</p><p class="source-code"><strong class="bold">  { renderCustomerActions }</strong></p><p class="source-code">) =&gt; {</p><p class="source-code">  ...</p><p class="source-code">};</p></li>
<li>Pass it through to <strong class="source-inline">CustomerRow</strong>, like so:<p class="source-code">&lt;CustomerRow</p><p class="source-code">  customer={customer}</p><p class="source-code">  key={customer.id}</p><p class="source-code"><strong class="bold">  renderCustomerActions={renderCustomerActions}</strong></p><p class="source-code">/&gt;</p></li>
<li>In <strong class="source-inline">CustomerRow</strong>, update the fourth <strong class="source-inline">td</strong> cell to call this new prop, as follows:<p class="source-code">const CustomerRow = (</p><p class="source-code">  { customer<strong class="bold">, renderCustomerActions </strong>}</p><p class="source-code">) =&gt; (</p><p class="source-code">  &lt;tr&gt;</p><p class="source-code">    &lt;td&gt;{customer.firstName}&lt;/td&gt;</p><p class="source-code">    &lt;td&gt;{customer.lastName}&lt;/td&gt;</p><p class="source-code">    &lt;td&gt;{customer.phoneNumber}&lt;/td&gt;</p><p class="source-code"><strong class="bold">    &lt;td&gt;{renderCustomerActions()}&lt;/td&gt;</strong></p><p class="source-code">  &lt;/tr&gt;</p><p class="source-code">);</p></li>
<li>For the next test, we<a id="_idIndexMarker1015"/> want to check that this render prop receives the specific customer record that applies to that row. Here’s how we can do this:<p class="source-code">it("passes customer to the renderCustomerActions prop", async () =&gt; {</p><p class="source-code">  const actionSpy = jest.fn(() =&gt; "actions");</p><p class="source-code">  global.fetch.mockResolvedValue(</p><p class="source-code">    fetchResponseOk(oneCustomer)</p><p class="source-code">  );</p><p class="source-code">  await renderAndWait(</p><p class="source-code">    &lt;CustomerSearch</p><p class="source-code">      renderCustomerActions={actionSpy}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  expect(actionSpy).toBeCalledWith(oneCustomer[0]);</p><p class="source-code">});</p></li>
<li>To make this pass, all you have to do is update the JSX call that you just wrote to include the customer as a parameter, as fo<a id="_idTextAnchor201"/>llows:<p class="source-code">&lt;td&gt;{renderCustomerActions(<strong class="bold">customer</strong>)}&lt;/td&gt;</p></li>
</ol>
<p>That’s all there is<a id="_idIndexMarker1016"/> to invoking the render prop inside the <strong class="source-inline">CustomerSearch</strong> component. Where it gets difficult is test-driving the implementation of the render prop itself, in the <strong class="source-inline">App</strong> component.</p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor202"/>Testing render props in additional render contexts</h2>
<p>Recall that<a id="_idIndexMarker1017"/> the <strong class="source-inline">App</strong> component has a <strong class="source-inline">view</strong> state variable that determines which component the user is currently viewing on the screen. If they are searching for customers, then <strong class="source-inline">view</strong> will be set to <strong class="source-inline">searchCustomers</strong>.</p>
<p>Pressing the <strong class="bold">Create appointment</strong> button on the <strong class="source-inline">CustomerSearch</strong> component should have the effect of setting <strong class="source-inline">view</strong> to <strong class="source-inline">addAppointment</strong>, causing the user’s screen to hide the <strong class="source-inline">CustomerSearch</strong> component and show the <strong class="source-inline">AppointmentForm</strong> component.</p>
<p>We also need to set the <strong class="source-inline">App</strong> component’s <strong class="source-inline">customer</strong> state variable to the customer that the user just selected in the <strong class="source-inline">CustomerSearch</strong> component.</p>
<p>All of this will be done in the render prop that <strong class="source-inline">App</strong> passes to <strong class="source-inline">customer</strong>.</p>
<p>The big question is: how do we test-drive the implementation of this render prop?</p>
<p>There are a few different ways we could do it:</p>
<ul>
<li>You could render an actual <strong class="source-inline">CustomerSearch</strong> component within your <strong class="source-inline">App</strong> components, navigate to a customer, and click the <strong class="bold">Create appointment</strong> button. While this is simple, it also introduces a dependency in your test suite, increasing its surface area. And since your current <strong class="source-inline">App</strong> tests have a module-level mock for <strong class="source-inline">CustomerSearch</strong>, you’d need to create a new test suite for those tests, which increases maintenance overhead.</li>
<li>You could modify the <strong class="source-inline">CustomerSearch</strong> mock to have some mechanism to trigger a render prop. This involves making the mock definition more complex than the standard form. That is an immediate red flag for me, for the reasons stated in <a href="B18423_07.xhtml#_idTextAnchor125"><em class="italic">Chapter 7</em></a>, <em class="italic">Testing useEffect and Mocking Components</em>. This solution moves to the back of the pile.</li>
<li>You could pull out the render prop from your <strong class="source-inline">CustomerSearch</strong> component, render it, then find the <strong class="bold">Create appointment</strong> button and click it. This is the approach we’ll continue with.</li>
</ul>
<p>If we use our <strong class="source-inline">render</strong> and <strong class="source-inline">renderAndWait</strong> functions to render this additional prop, it will replace the rendered <strong class="source-inline">App</strong> component. We would then click the button and we’d observe nothing happening because <strong class="source-inline">App</strong> has gone.</p>
<p>What we need is a <a id="_idIndexMarker1018"/>second React root that can be used to just render that <em class="italic">additional</em> piece of the DOM. Our test can simply pretend that <em class="italic">it</em> is the <strong class="source-inline">CustomerSearch</strong> component.</p>
<p>To do this, we need a new render component that <a id="_idIndexMarker1019"/>we’ll call <strong class="source-inline">renderAdditional</strong>. Let’s add that now and then write our test, as follows:</p>
<ol>
<li value="1">In <strong class="source-inline">test/reactTestExtensions.js</strong>, add the following function definition, just below the definition of <strong class="source-inline">renderAndWait</strong>:<p class="source-code">export const renderAdditional = (component) =&gt; {</p><p class="source-code">  const container = document.createElement("div");</p><p class="source-code">  act(() =&gt;</p><p class="source-code">    ReactDOM.createRoot(container).render(component)</p><p class="source-code">  );</p><p class="source-code">  return container;</p><p class="source-code">};</p></li>
<li>In <strong class="source-inline">test/App.test.js</strong>, update the <strong class="source-inline">import</strong> statement to pull in this new extension, like so:<p class="source-code">import {</p><p class="source-code">  ...,</p><p class="source-code"><strong class="bold">  renderAdditional,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Locate the <strong class="source-inline">search customers</strong> nested <strong class="source-inline">describe</strong> block and add a <strong class="source-inline">searchFor</strong> helper function that calls the render prop for the supplied customer, as follows:<p class="source-code">const searchFor = (customer) =&gt;</p><p class="source-code">  propsOf(CustomerSearch)</p><p class="source-code">    .renderCustomerActions(customer);</p></li>
<li>Now, add the test. This<a id="_idIndexMarker1020"/> renders the prop and checks that a button has been rendered, as illustrated in the following code snippet:<p class="source-code">it("passes a button to the CustomerSearch named Create appointment", async () =&gt; {</p><p class="source-code">  render(&lt;App /&gt;);</p><p class="source-code">  navigateToSearchCustomers();</p><p class="source-code">  const buttonContainer = </p><p class="source-code">    renderAdditional(searchFor());</p><p class="source-code">  expect(</p><p class="source-code">    buttonContainer.firstChild</p><p class="source-code">  ).toBeElementWithTag("button");</p><p class="source-code">  expect(</p><p class="source-code">    buttonContainer.firstChild</p><p class="source-code">  ).toContainText("Create appointment");</p><p class="source-code">});</p></li>
<li>In <strong class="source-inline">src/App.js</strong>, add the following function just above the returned JSX:<p class="source-code">const searchActions = () =&gt; (</p><p class="source-code">  &lt;button&gt;Create appointment&lt;/button&gt;</p><p class="source-code">);</p></li>
<li>Set the prop on <strong class="source-inline">CustomerSearch</strong>, as follows. Your test should pass after this change:<p class="source-code">case "searchCustomers":</p><p class="source-code">  return (</p><p class="source-code">    &lt;CustomerSearch </p><p class="source-code"><strong class="bold">      renderCustomerActions={searchActions}</strong></p><p class="source-code">    /&gt;</p><p class="source-code">  );</p></li>
<li>Back in <strong class="source-inline">test/CustomerSearch.test.js</strong>, add the next test, as follows. This uses the<a id="_idIndexMarker1021"/> same helper function, but this time clicks the button and verifies that <strong class="source-inline">AppointmentFormLoader</strong> was shown with the correct customer ID:<p class="source-code">it("clicking appointment button shows the appointment form for that customer", async () =&gt; {</p><p class="source-code">  const customer = { id: 123 };</p><p class="source-code">  render(&lt;App /&gt;);</p><p class="source-code">  navigateToSearchCustomers();</p><p class="source-code">  const buttonContainer = renderAdditional(</p><p class="source-code">    searchFor(customer)</p><p class="source-code">  );</p><p class="source-code">  click(buttonContainer.firstChild);</p><p class="source-code">  expect(</p><p class="source-code">   element("#AppointmentFormLoader")</p><p class="source-code">  ).not.toBeNull();</p><p class="source-code">  expect(</p><p class="source-code">    propsOf(AppointmentFormLoader).original</p><p class="source-code">  ).toMatchObject({ customer: 123 });</p><p class="source-code">});</p></li>
<li>To make that pass, update <strong class="source-inline">searchActions</strong> in <strong class="source-inline">src/App.js</strong> to use the customer parameter that will be passed to it by <strong class="source-inline">CustomerSearch</strong>, as follows:<p class="source-code">const searchActions = (<strong class="bold">customer</strong>) =&gt; (</p><p class="source-code">  &lt;button</p><p class="source-code"><strong class="bold">    onClick={</strong></p><p class="source-code"><strong class="bold">      () =&gt; transitionToAddAppointment(customer)</strong></p><p class="source-code"><strong class="bold">    }&gt;</strong></p><p class="source-code">    Create appointment</p><p class="source-code">&lt;/button&gt;</p><p class="source-code">);</p></li>
</ol>
<p>That’s all there <a id="_idIndexMarker1022"/>is to it: you’ve<a id="_idIndexMarker1023"/> now used <strong class="source-inline">renderAdditional</strong> to trigger your render props and check that it works as expected.</p>
<p>This technique can be very handy when working with third-party libraries that expect you to pass render props.</p>
<p>That completes this feature; go ahead<a id="_idTextAnchor203"/> and manually test if you’d like to see it all in action.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor204"/>Summary</h1>
<p>This chapter has explored building out a component with some complex user interactions between the user interface and an API. You’ve created a new table component and integrated it into the existing application workflow.</p>
<p>You have seen how to make large changes to your component’s implementation, using your tests as a safety mechanism. </p>
<p>You have also seen how to test render props using an additional render root—a technique that I hope you don’t have to use too often!</p>
<p>In the next chapter, we’ll use tests to integrate React Router into our application. We’ll continue with the <strong class="source-inline">CustomerSearch</strong> component by adding the ability to use the browser location bar to specify search criteria. That will set<a id="_idTextAnchor205"/> us up nicely for introducing Redux and GraphQL later on.</p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor206"/>Exercises</h1>
<ol>
<li value="1">Disable the <strong class="bold">Previous</strong> button if the user is on the first page and disable the <strong class="bold">Next</strong> button if the current listing has fewer than 10 records on display.</li>
<li>Extract the <strong class="source-inline">searchParams</strong> function into a separate module that handles any number of parameters and uses the <strong class="source-inline">encodeURIComponent</strong> JavaScript function to ensure the values are encoded correctly.</li>
<li>The <strong class="source-inline">/customers</strong> endpoint supports a <strong class="source-inline">limit</strong> parameter that allows you to specify the maximum number of records that are returned. Provide a mechanism for the user to change the limit on each page.</li>
</ol>
</div>
<div>
<div id="_idContainer034">
</div>
</div>
</div></body></html>