<html><head></head><body>
<div id="_idContainer110" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-229"><a id="_idTextAnchor232" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-230" class="calibre5"><a id="_idTextAnchor233" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Interfacing with GraphQL on the Frontend Using Apollo Client</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">After successfully implementing a GraphQL backend using Apollo Server in the previous chapter, we are now going to interface with our new GraphQL API on the frontend using Apollo Client. </span><span class="kobospan" id="kobo.3.2">Apollo Client is a library that makes it easier and more convenient to interact with GraphQL APIs. </span><span class="kobospan" id="kobo.3.3">We’ll start by replacing the fetching of the post list with GraphQL queries, then resolve the author usernames without needing extra queries, showing the power of GraphQL. </span><span class="kobospan" id="kobo.3.4">Next, we’ll add variables to the query to allow setting filters and sorting options. </span><span class="kobospan" id="kobo.3.5">Finally, we’ll learn how to use mutations on </span><span><span class="kobospan" id="kobo.4.1">the frontend.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">In this chapter, we are going to cover the following </span><span><span class="kobospan" id="kobo.6.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.7.1">Setting up Apollo Client and making our </span><span><span class="kobospan" id="kobo.8.1">first query</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.9.1">Using variables in </span><span><span class="kobospan" id="kobo.10.1">GraphQL queries</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.11.1">Using mutations on </span><span><span class="kobospan" id="kobo.12.1">the frontend</span></span></li>
</ul>
<h1 id="_idParaDest-231" class="calibre5"><a id="_idTextAnchor234" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.13.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.14.1">Before we start, please install all requirements from </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.15.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.16.1">, </span><em class="italic"><span class="kobospan" id="kobo.17.1">Preparing For Full-Stack Development</span></em><span class="kobospan" id="kobo.18.1">, and </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.19.1">Chapter 2</span></em></span></a><span class="kobospan" id="kobo.20.1">, </span><em class="italic"><span class="kobospan" id="kobo.21.1">Getting to Know Node.js </span></em><span><em class="italic"><span class="kobospan" id="kobo.22.1">and MongoDB</span></em></span><span><span class="kobospan" id="kobo.23.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">The versions listed in those chapters are the ones used in the book. </span><span class="kobospan" id="kobo.24.2">While installing a newer version should not be an issue, please note that certain steps might work differently on a newer version. </span><span class="kobospan" id="kobo.24.3">If there is an issue with the code and steps provided in this book, please try using the versions mentioned in </span><em class="italic"><span class="kobospan" id="kobo.25.1">Chapters 1 </span></em><span><span class="kobospan" id="kobo.26.1">and</span></span><span><em class="italic"><span class="kobospan" id="kobo.27.1"> 2.</span></em></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.28.1">You can find the code for this chapter on </span><span><span class="kobospan" id="kobo.29.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch12" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.30.1">https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch12</span></span></a><span><span class="kobospan" id="kobo.31.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.32.1">The CiA video for this chapter can be found </span><span><span class="kobospan" id="kobo.33.1">at: </span></span><a href="https://youtu.be/Gl_5i9DR_xA" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.34.1">https://youtu.be/Gl_5i9DR_xA</span></span></a><span><span class="kobospan" id="kobo.35.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.36.1">If you cloned the full repository for the book, Husky may not find the </span><strong class="source-inline"><span class="kobospan" id="kobo.37.1">.git</span></strong><span class="kobospan" id="kobo.38.1"> directory when running </span><strong class="source-inline"><span class="kobospan" id="kobo.39.1">npm install</span></strong><span class="kobospan" id="kobo.40.1">. </span><span class="kobospan" id="kobo.40.2">In that case, just run </span><strong class="source-inline"><span class="kobospan" id="kobo.41.1">git</span></strong> <strong class="source-inline"><span class="kobospan" id="kobo.42.1">init</span></strong><span class="kobospan" id="kobo.43.1"> in the root of the corresponding </span><span><span class="kobospan" id="kobo.44.1">chapter folder.</span></span></p>
<h1 id="_idParaDest-232" class="calibre5"><a id="_idTextAnchor235" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.45.1">Setting up Apollo Client and making our first query</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.46.1">Before we can get started making GraphQL queries on the frontend, we first need to set up Apollo Client. </span><strong class="bold"><span class="kobospan" id="kobo.47.1">Apollo Client</span></strong><span class="kobospan" id="kobo.48.1"> is the</span><a id="_idIndexMarker724" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.49.1"> frontend counterpart to Apollo Server, which we have already been using on the backend. </span><span class="kobospan" id="kobo.49.2">While it is not required to use Apollo Client (we could also simply make a </span><strong class="source-inline"><span class="kobospan" id="kobo.50.1">POST</span></strong><span class="kobospan" id="kobo.51.1"> request to the </span><strong class="source-inline"><span class="kobospan" id="kobo.52.1">/graphql</span></strong><span class="kobospan" id="kobo.53.1"> endpoint), Apollo Client makes interacting with GraphQL much easier and more convenient. </span><span class="kobospan" id="kobo.53.2">It also includes additional features, such as caching, out of </span><span><span class="kobospan" id="kobo.54.1">the box.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.55.1">Follow these steps to </span><a id="_idIndexMarker725" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.56.1">set up </span><span><span class="kobospan" id="kobo.57.1">Apollo Client:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.58.1">Copy the existing </span><strong class="source-inline1"><span class="kobospan" id="kobo.59.1">ch11</span></strong><span class="kobospan" id="kobo.60.1"> folder to a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.61.1">ch12</span></strong><span class="kobospan" id="kobo.62.1"> folder, </span><span><span class="kobospan" id="kobo.63.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.64.1">$ cp -R ch11 ch12</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.65.1">Open the </span><strong class="source-inline1"><span class="kobospan" id="kobo.66.1">ch12</span></strong><span class="kobospan" id="kobo.67.1"> folder in </span><span><span class="kobospan" id="kobo.68.1">VS Code.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.69.1">Install the </span><strong class="source-inline1"><span class="kobospan" id="kobo.70.1">@apollo/client</span></strong><span class="kobospan" id="kobo.71.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.72.1">graphql</span></strong></span><span><span class="kobospan" id="kobo.73.1"> dependencies:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.74.1">$ npm install @apollo/client@3.9.5 graphql@16.8.1</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.75.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.76.1">.env</span></strong><span class="kobospan" id="kobo.77.1"> and add a new environment variable, pointing to the endpoint for our </span><span><span class="kobospan" id="kobo.78.1">GraphQL server:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.79.1">
VITE_GRAPHQL_URL="http://localhost:3001/graphql"</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.80.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.81.1">src/App.jsx</span></strong><span class="kobospan" id="kobo.82.1"> and import </span><strong class="source-inline1"><span class="kobospan" id="kobo.83.1">ApolloClient</span></strong><span class="kobospan" id="kobo.84.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.85.1">InMemoryCache</span></strong><span class="kobospan" id="kobo.86.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.87.1">ApolloProvider</span></strong><span class="kobospan" id="kobo.88.1"> from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.89.1">@</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.90.1">apollo/client</span></strong></span><span><span class="kobospan" id="kobo.91.1"> package:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.92.1">
import { ApolloProvider } from '@apollo/client/react/index.js'
import { ApolloClient, InMemoryCache } from '@apollo/client/core/index.js'</span></pre><p class="calibre3"><span class="kobospan" id="kobo.93.1">At the time of writing, there is an issue with ESM imports in Apollo Client, so we need to import directly from the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.94.1">index.js</span></strong></span><span><span class="kobospan" id="kobo.95.1"> files.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.96.1">Create a new instance of Apollo Client, pointing to the GraphQL endpoint and </span><span><span class="kobospan" id="kobo.97.1">using </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.98.1">InMemoryCache</span></strong></span><span><span class="kobospan" id="kobo.99.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.100.1">
const apolloClient = new ApolloClient({
  uri: import.meta.env.VITE_GRAPHQL_URL,
  cache: new InMemoryCache(),
})</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.101.1">Adjust the </span><strong class="source-inline1"><span class="kobospan" id="kobo.102.1">App</span></strong><span class="kobospan" id="kobo.103.1"> component</span><a id="_idIndexMarker726" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.104.1"> to add </span><strong class="source-inline1"><span class="kobospan" id="kobo.105.1">ApolloProvider</span></strong><span class="kobospan" id="kobo.106.1">, providing the Apollo Client context to our </span><span><span class="kobospan" id="kobo.107.1">whole app:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.108.1">
export function App({ children }) {
  return (
    &lt;HelmetProvider&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.109.1">      &lt;ApolloProvider client={apolloClient}&gt;</span></strong><span class="kobospan1" id="kobo.110.1">
        &lt;QueryClientProvider client={queryClient}&gt;
          &lt;AuthContextProvider&gt;{children}&lt;/AuthContextProvider&gt;
        &lt;/QueryClientProvider&gt;
</span><strong class="bold1"><span class="kobospan1" id="kobo.111.1">      &lt;/ApolloProvider&gt;</span></strong><span class="kobospan1" id="kobo.112.1">
    &lt;/HelmetProvider&gt;
  )
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.113.1">We are also going to create a GraphQL config file now so that the VS Code GraphQL extension can autocomplete and validate queries for us. </span><span class="kobospan" id="kobo.113.2">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.114.1">graphql.config.json</span></strong><span class="kobospan" id="kobo.115.1"> file in the root of the project, with the </span><span><span class="kobospan" id="kobo.116.1">following contents:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.117.1">
{
  "schema": "http://localhost:3001/graphql",
  "documents": "src/api/graphql/**/*.{js,jsx}"
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.118.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.119.1">schema</span></strong><span class="kobospan" id="kobo.120.1"> defines the URL to the GraphQL endpoint, and </span><strong class="source-inline"><span class="kobospan" id="kobo.121.1">documents</span></strong><span class="kobospan" id="kobo.122.1"> defines where to find files that contain GraphQL queries. </span><span class="kobospan" id="kobo.122.2">We are going to put the GraphQL queries in the </span><strong class="source-inline"><span class="kobospan" id="kobo.123.1">src/api/graphql/</span></strong> <span><span class="kobospan" id="kobo.124.1">folder later.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.125.1">Make sure Docker and the database container are running, then start the backend, </span><span><span class="kobospan" id="kobo.126.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.127.1">$ cd backend/</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.128.1">$ npm run dev</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.129.1">Keep the backend running throughout this chapter, so that the GraphQL extension can access the </span><span><span class="kobospan" id="kobo.130.1">GraphQL endpoint.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.131.1">Restart the VS Code </span><a id="_idIndexMarker727" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.132.1">GraphQL extension. </span><span class="kobospan" id="kobo.132.2">You can do so by accessing the VS Code command palette (</span><em class="italic"><span class="kobospan" id="kobo.133.1">Ctrl</span></em><span class="kobospan" id="kobo.134.1"> + </span><em class="italic"><span class="kobospan" id="kobo.135.1">Shift</span></em><span class="kobospan" id="kobo.136.1"> + </span><em class="italic"><span class="kobospan" id="kobo.137.1">P</span></em><span class="kobospan" id="kobo.138.1"> on Windows/Linux and </span><em class="italic"><span class="kobospan" id="kobo.139.1">Cmd</span></em><span class="kobospan" id="kobo.140.1"> + </span><em class="italic"><span class="kobospan" id="kobo.141.1">Shift</span></em><span class="kobospan" id="kobo.142.1"> + </span><em class="italic"><span class="kobospan" id="kobo.143.1">P</span></em><span class="kobospan" id="kobo.144.1"> on macOS) and typing in </span><strong class="source-inline1"><span class="kobospan" id="kobo.145.1">GraphQL: </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.146.1">Manual Restart</span></strong></span><span><span class="kobospan" id="kobo.147.1">.</span></span></li>
</ol>
<h2 id="_idParaDest-233" class="calibre7"><a id="_idTextAnchor236" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.148.1">Querying posts from the frontend using GraphQL</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.149.1">Now that</span><a id="_idIndexMarker728" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.150.1"> Apollo Client is set up and ready to be used, let’s define our first GraphQL query: a simple query to fetch </span><span><span class="kobospan" id="kobo.151.1">all posts.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.152.1">Follow these steps to define the query and use it in </span><span><span class="kobospan" id="kobo.153.1">our app:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.154.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.155.1">src/api/graphql/</span></strong><span class="kobospan" id="kobo.156.1"> folder, where we will put our </span><span><span class="kobospan" id="kobo.157.1">GraphQL queries.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.158.1">Inside this folder, create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.159.1">src/api/graphql/posts.js</span></strong></span><span><span class="kobospan" id="kobo.160.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.161.1">In the </span><strong class="source-inline1"><span class="kobospan" id="kobo.162.1">src/api/graphql/posts.js</span></strong><span class="kobospan" id="kobo.163.1"> file, import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.164.1">gql</span></strong><span class="kobospan" id="kobo.165.1"> function </span><span><span class="kobospan" id="kobo.166.1">from </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.167.1">@apollo/client</span></strong></span><span><span class="kobospan" id="kobo.168.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.169.1">
import { gql } from '@apollo/client/core/index.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.170.1">Define </span><a id="_idIndexMarker729" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.171.1">a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.172.1">GET_POSTS</span></strong><span class="kobospan" id="kobo.173.1"> query, which retrieves all the relevant properties for a post (except the author, which will </span><span><span class="kobospan" id="kobo.174.1">come later):</span></span><pre class="source-code"><span class="kobospan1" id="kobo.175.1">
export const GET_POSTS = gql`
  query getPosts {
    posts {
      id
      title
      contents
      tags
      updatedAt
      createdAt
    }
  }
`</span></pre><p class="calibre3"><span class="kobospan" id="kobo.176.1">You should see that the GraphQL extension is offering us autocomplete options for the types we defined in our backend! </span><span class="kobospan" id="kobo.176.2">If we enter the wrong field name, it will also warn us that this field does not exist on </span><span><span class="kobospan" id="kobo.177.1">the type.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.178.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.179.1">src/pages/Blog.jsx</span></strong><span class="kobospan" id="kobo.180.1"> and import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.181.1">useQuery</span></strong><span class="kobospan" id="kobo.182.1"> hook </span><span><span class="kobospan" id="kobo.183.1">from </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.184.1">@apollo/client</span></strong></span><span><span class="kobospan" id="kobo.185.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.186.1">
import { useQuery as useGraphQLQuery } from '@apollo/client/react/index.js'</span></pre><p class="calibre3"><span class="kobospan" id="kobo.187.1">We renamed the </span><strong class="source-inline"><span class="kobospan" id="kobo.188.1">useQuery</span></strong><span class="kobospan" id="kobo.189.1"> hook from Apollo Client to </span><strong class="source-inline"><span class="kobospan" id="kobo.190.1">useGraphQLQuery</span></strong><span class="kobospan" id="kobo.191.1"> to avoid confusion with the </span><strong class="source-inline"><span class="kobospan" id="kobo.192.1">useQuery</span></strong><span class="kobospan" id="kobo.193.1"> hook from TanStack </span><span><span class="kobospan" id="kobo.194.1">React Query.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.195.1">Import the previously defined </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.196.1">GET_POSTS</span></strong></span><span><span class="kobospan" id="kobo.197.1"> query:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.198.1">
import { GET_POSTS } from '../api/graphql/posts.js'</span></pre></li> <li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.199.1">Remove</span></em><span class="kobospan" id="kobo.200.1"> the imports to </span><strong class="source-inline1"><span class="kobospan" id="kobo.201.1">useQuery</span></strong> <span><span class="kobospan" id="kobo.202.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.203.1">getPosts</span></strong></span><span><span class="kobospan" id="kobo.204.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.205.1">
import { useQuery } from '@tanstack/react-query'
import { getPosts } from '../api/posts.js'</span></pre></li> <li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.206.1">Remove</span></em><span class="kobospan" id="kobo.207.1"> the </span><a id="_idIndexMarker730" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.208.1">existing </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.209.1">useQuery</span></strong></span><span><span class="kobospan" id="kobo.210.1"> hook:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.211.1">
  const postsQuery = useQuery({
    queryKey: ['posts', { author, sortBy, sortOrder }],
    queryFn: () =&gt; getPosts({ author, sortBy, sortOrder }),
  })
  const posts = postsQuery.data ?? </span><span class="kobospan1" id="kobo.211.2">[]</span></pre></li> <li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.212.1">Replace</span></em><span class="kobospan" id="kobo.213.1"> it with the </span><span><span class="kobospan" id="kobo.214.1">following hook:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.215.1">
  const postsQuery = useGraphQLQuery(GET_POSTS)
  const posts = postsQuery.data?.posts ?? </span><span class="kobospan1" id="kobo.215.2">[]</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.216.1">Make sure you are in the root of the project, then run the frontend </span><span><span class="kobospan" id="kobo.217.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.218.1">$ npm run dev</span></strong></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.219.1">Now, open the frontend on </span><strong class="source-inline"><span class="kobospan" id="kobo.220.1">http://localhost:5173/</span></strong><span class="kobospan" id="kobo.221.1"> and you will see that the post titles are properly shown. </span><span class="kobospan" id="kobo.221.2">However, the links to posts do not work and there is an error in the console. </span><span class="kobospan" id="kobo.221.3">There is a slight difference in the results from GraphQL and the REST API: the REST API returns the ID of posts as an </span><strong class="source-inline"><span class="kobospan" id="kobo.222.1">_id</span></strong><span class="kobospan" id="kobo.223.1"> property, while GraphQL returns them as an </span><span><strong class="source-inline"><span class="kobospan" id="kobo.224.1">id</span></strong></span><span><span class="kobospan" id="kobo.225.1"> property.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.226.1">Let’s adjust our code to accommodate this </span><span><span class="kobospan" id="kobo.227.1">change now:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.228.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.229.1">src/components/Post.jsx</span></strong><span class="kobospan" id="kobo.230.1"> and change the </span><strong class="source-inline1"><span class="kobospan" id="kobo.231.1">_id</span></strong><span class="kobospan" id="kobo.232.1"> prop </span><span><span class="kobospan" id="kobo.233.1">to </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.234.1">id</span></strong></span><span><span class="kobospan" id="kobo.235.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.236.1">
export function Post({
  title,
  contents,
  author,
</span><strong class="bold1"><span class="kobospan1" id="kobo.237.1">  id,</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.238.1">Also, update the variable name where it </span><span><span class="kobospan" id="kobo.239.1">is used:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.240.1">
        &lt;Link to={`/posts/</span><strong class="bold1"><span class="kobospan1" id="kobo.241.1">${id}</span></strong><span class="kobospan1" id="kobo.242.1">/${slug(title)}`}&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.243.1">Make sure to update </span><strong class="source-inline1"><span class="kobospan" id="kobo.244.1">propTypes</span></strong> <span><span class="kobospan" id="kobo.245.1">as well:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.246.1">
Post.propTypes = {
  title: PropTypes.string.isRequired,
  contents: PropTypes.string,
  author: PropTypes.string,
  </span><strong class="bold1"><span class="kobospan1" id="kobo.247.1">id</span></strong><span class="kobospan1" id="kobo.248.1">: PropTypes.string.isRequired,</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.249.1">Now that the</span><a id="_idIndexMarker731" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.250.1"> prop is changed, edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.251.1">src/pages/ViewPost.jsx</span></strong><span class="kobospan" id="kobo.252.1"> and pass in the new prop, </span><span><span class="kobospan" id="kobo.253.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.254.1">
      {post ? </span><span class="kobospan1" id="kobo.254.2">(
        &lt;Post {...post} </span><strong class="bold1"><span class="kobospan1" id="kobo.255.1">id={postId}</span></strong><span class="kobospan1" id="kobo.256.1"> fullPost /&gt;
      ) : (
        `Post with id ${postId} not found.`
      )}</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.257.1">After saving all files, the frontend should refresh and properly render the list of all posts with working links. </span><span class="kobospan" id="kobo.257.2">Now all that’s left to do to restore the original functionality is to show the </span><span><span class="kobospan" id="kobo.258.1">author usernames.</span></span></p>
<h2 id="_idParaDest-234" class="calibre7"><a id="_idTextAnchor237" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.259.1">Resolving author usernames in a single query</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.260.1">Instead of </span><a id="_idIndexMarker732" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.261.1">resolving each author username separately, we can now get them all at once in a single query, thanks to the power of GraphQL! </span><span class="kobospan" id="kobo.261.2">Let’s make use of this power to refactor our code a bit to make it simpler and improve </span><span><span class="kobospan" id="kobo.262.1">the performance:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.263.1">Start by editing</span><a id="_idIndexMarker733" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.264.1"> the GraphQL query in </span><strong class="source-inline1"><span class="kobospan" id="kobo.265.1">src/api/graphql/posts.js</span></strong><span class="kobospan" id="kobo.266.1">, adding the </span><strong class="source-inline1"><span class="kobospan" id="kobo.267.1">author.</span></strong><strong class="source-inline1"><span class="kobospan" id="kobo.268.1">username</span></strong><span class="kobospan" id="kobo.269.1"> field, </span><span><span class="kobospan" id="kobo.270.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.271.1">
export const GET_POSTS = gql`
  query getPosts {
    posts {
</span><strong class="bold1"><span class="kobospan1" id="kobo.272.1">      author {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.273.1">        username</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.274.1">      }</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.275.1">Then, edit the </span><strong class="source-inline1"><span class="kobospan" id="kobo.276.1">src/components/User.jsx</span></strong><span class="kobospan" id="kobo.277.1"> component. </span><em class="italic"><span class="kobospan" id="kobo.278.1">Replace</span></em><span class="kobospan" id="kobo.279.1"> the whole component with the following, </span><span><span class="kobospan" id="kobo.280.1">simpler component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.281.1">
import PropTypes from 'prop-types'
export function User({ username }) {
  return &lt;b&gt;{username}&lt;/b&gt;
}
User.propTypes = {
  username: PropTypes.string.isRequired,
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.282.1">It is not necessary to fetch the user info here anymore, as we can directly display the username from the </span><span><span class="kobospan" id="kobo.283.1">GraphQL response.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.284.1">Next, edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.285.1">src/components/Post.jsx</span></strong><span class="kobospan" id="kobo.286.1"> and pass the whole </span><strong class="source-inline1"><span class="kobospan" id="kobo.287.1">author</span></strong><span class="kobospan" id="kobo.288.1"> object to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.289.1">User</span></strong><span class="kobospan" id="kobo.290.1"> component, </span><span><span class="kobospan" id="kobo.291.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.292.1">
          Written by &lt;User </span><strong class="bold1"><span class="kobospan1" id="kobo.293.1">{...author}</span></strong><span class="kobospan1" id="kobo.294.1"> /&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.295.1">We also need to adjust </span><strong class="source-inline1"><span class="kobospan" id="kobo.296.1">propTypes</span></strong><span class="kobospan" id="kobo.297.1"> now to accept a full </span><strong class="source-inline1"><span class="kobospan" id="kobo.298.1">author</span></strong><span class="kobospan" id="kobo.299.1"> object for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.300.1">Post</span></strong><span class="kobospan" id="kobo.301.1"> component, instead of a </span><span><span class="kobospan" id="kobo.302.1">user ID:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.303.1">
  author: </span><strong class="bold1"><span class="kobospan1" id="kobo.304.1">PropTypes.shape(User.propTypes)</span></strong><span class="kobospan1" id="kobo.305.1">,</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.306.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.307.1">src/pages/ViewPost.jsx</span></strong><span class="kobospan" id="kobo.308.1"> and pass the whole </span><strong class="source-inline1"><span class="kobospan" id="kobo.309.1">author</span></strong><span class="kobospan" id="kobo.310.1"> object to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.311.1">Post</span></strong></span><span><span class="kobospan" id="kobo.312.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.313.1">
        &lt;Post {...post} id={postId} </span><strong class="bold1"><span class="kobospan1" id="kobo.314.1">author={userInfo}</span></strong><span class="kobospan1" id="kobo.315.1"> fullPost /&gt;</span></pre><p class="calibre3"><span class="kobospan" id="kobo.316.1">Thankfully, we</span><a id="_idIndexMarker734" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.317.1"> are already resolving the username for the meta tags on this page, so we do not need to make an additional query </span><span><span class="kobospan" id="kobo.318.1">here either.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.319.1">However, in </span><strong class="source-inline1"><span class="kobospan" id="kobo.320.1">Header</span></strong><span class="kobospan" id="kobo.321.1">, we do need to make an additional query to resolve the username when a user is </span><span><span class="kobospan" id="kobo.322.1">logged in.</span></span><p class="calibre3"><span class="kobospan" id="kobo.323.1">Edit </span><strong class="source-inline"><span class="kobospan" id="kobo.324.1">src/components/Header.jsx</span></strong><span class="kobospan" id="kobo.325.1"> and import the </span><strong class="source-inline"><span class="kobospan" id="kobo.326.1">useQuery</span></strong><span class="kobospan" id="kobo.327.1"> hook and the </span><strong class="source-inline"><span class="kobospan" id="kobo.328.1">getUserInfo</span></strong> <span><span class="kobospan" id="kobo.329.1">API function:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.330.1">
import { useQuery } from '@tanstack/react-query'
import { getUserInfo } from '../api/users.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.331.1">Then, adjust the component to get the user ID from the token (the </span><strong class="source-inline1"><span class="kobospan" id="kobo.332.1">sub</span></strong><span class="kobospan" id="kobo.333.1"> field of the JWT) and make a query for the </span><span><span class="kobospan" id="kobo.334.1">user info:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.335.1">
export function Header() {
  const [token, setToken] = useAuth()
</span><strong class="bold1"><span class="kobospan1" id="kobo.336.1">  const { sub } = token ? </span><span class="kobospan1" id="kobo.336.2">jwtDecode(token) : {}</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.337.1">  const userInfoQuery = useQuery({</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.338.1">    queryKey: ['users', sub],</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.339.1">    queryFn: () =&gt; getUserInfo(sub),</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.340.1">    enabled: Boolean(sub),</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.341.1">  })</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.342.1">  const userInfo = userInfoQuery.data</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.343.1">Lastly, we check</span><a id="_idIndexMarker735" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.344.1"> whether we were able to resolve the query for user info (instead of just checking for </span><strong class="source-inline1"><span class="kobospan" id="kobo.345.1">token</span></strong><span class="kobospan" id="kobo.346.1">). </span><span class="kobospan" id="kobo.346.2">If so, we pass the user info to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.347.1">User</span></strong></span><span><span class="kobospan" id="kobo.348.1"> component:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.349.1">
  if (token</span><strong class="bold1"><span class="kobospan1" id="kobo.350.1"> &amp;&amp; userInfo</span></strong><span class="kobospan1" id="kobo.351.1">) {
    return (
      &lt;nav&gt;
        Logged in as &lt;User </span><strong class="bold1"><span class="kobospan1" id="kobo.352.1">{...userInfo}</span></strong><span class="kobospan1" id="kobo.353.1"> /&gt;</span></pre><p class="calibre3"><span class="kobospan" id="kobo.354.1">We also removed the token decoding here, like we already </span><span><span class="kobospan" id="kobo.355.1">did earlier.</span></span></p></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.356.1">Now we are using GraphQL to fetch the list of posts and resolve the author usernames in one single request! </span><span class="kobospan" id="kobo.356.2">However, the filters and sorting do not work anymore, as we are not passing this information to the GraphQL </span><span><span class="kobospan" id="kobo.357.1">query yet.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.358.1">In the next section, we are going to introduce variables for filtering and sorting our </span><span><span class="kobospan" id="kobo.359.1">GraphQL queries.</span></span></p>
<h1 id="_idParaDest-235" class="calibre5"><a id="_idTextAnchor238" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.360.1">Using variables in GraphQL queries</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.361.1">To add support</span><a id="_idIndexMarker736" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.362.1"> for filters and sorting, we need to add variables</span><a id="_idIndexMarker737" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.363.1"> to our GraphQL query. </span><span class="kobospan" id="kobo.363.2">We can then fill in these variables when executing </span><span><span class="kobospan" id="kobo.364.1">the query.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.365.1">Follow these steps to add variables to </span><span><span class="kobospan" id="kobo.366.1">the query:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.367.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.368.1">src/api/graphql/posts.js</span></strong><span class="kobospan" id="kobo.369.1"> and adjust the query to accept an </span><strong class="source-inline1"><span class="kobospan" id="kobo.370.1">$</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.371.1">options</span></strong></span><span><span class="kobospan" id="kobo.372.1"> variable:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.373.1">
export const GET_POSTS = gql`
  query getPosts</span><strong class="bold1"><span class="kobospan1" id="kobo.374.1">($options: PostsOptions)</span></strong><span class="kobospan1" id="kobo.375.1"> {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.376.1">Then, pass the </span><strong class="source-inline1"><span class="kobospan" id="kobo.377.1">$options</span></strong><span class="kobospan" id="kobo.378.1"> variable to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.379.1">posts</span></strong><span class="kobospan" id="kobo.380.1"> resolver, for which we already implemented an </span><strong class="source-inline1"><span class="kobospan" id="kobo.381.1">options</span></strong><span class="kobospan" id="kobo.382.1"> argument in the </span><span><span class="kobospan" id="kobo.383.1">previous chapter:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.384.1">
    posts</span><strong class="bold1"><span class="kobospan1" id="kobo.385.1">(options: $options)</span></strong><span class="kobospan1" id="kobo.386.1"> {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.387.1">Now, we just need to pass the options when executing the query. </span><span class="kobospan" id="kobo.387.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.388.1">src/pages/Blog.jsx</span></strong><span class="kobospan" id="kobo.389.1"> and pass the variable, </span><span><span class="kobospan" id="kobo.390.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.391.1">
  const postsQuery = useGraphQLQuery(GET_POSTS</span><strong class="bold1"><span class="kobospan1" id="kobo.392.1">, {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.393.1">    variables: { options: { sortBy, sortOrder } },</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.394.1">  }</span></strong><span class="kobospan1" id="kobo.395.1">)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.396.1">Go to the</span><a id="_idIndexMarker738" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.397.1"> blog frontend and change the sort order</span><a id="_idIndexMarker739" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.398.1"> to ascending to see the variable </span><span><span class="kobospan" id="kobo.399.1">in action!</span></span></li>
</ol>
<h2 id="_idParaDest-236" class="calibre7"><a id="_idTextAnchor239" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.400.1">Using fragments to reuse parts of queries</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.401.1">Now that sorting is </span><a id="_idIndexMarker740" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.402.1">working, we just need to add filtering by author. </span><span class="kobospan" id="kobo.402.2">To do this, we need to add a second query for </span><strong class="source-inline"><span class="kobospan" id="kobo.403.1">postsByAuthor</span></strong><span class="kobospan" id="kobo.404.1">. </span><span class="kobospan" id="kobo.404.2">As you can imagine, this query should return the same fields as the </span><strong class="source-inline"><span class="kobospan" id="kobo.405.1">posts</span></strong><span class="kobospan" id="kobo.406.1"> query. </span><span class="kobospan" id="kobo.406.2">We can make use of a fragment to reuse the fields for both queries, </span><span><span class="kobospan" id="kobo.407.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.408.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.409.1">src/api/graphql/posts.js</span></strong><span class="kobospan" id="kobo.410.1"> and define a new fragment in GraphQL that contains all the fields that we need from </span><span><span class="kobospan" id="kobo.411.1">a post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.412.1">
export const POST_FIELDS = gql`
  fragment PostFields on Post {
    id
    title
    contents
    tags
    updatedAt
    createdAt
    author {
      username
    }
  }
`</span></pre><p class="calibre3"><span class="kobospan" id="kobo.413.1">The fragment is defined by giving it a name (</span><strong class="source-inline"><span class="kobospan" id="kobo.414.1">PostFields</span></strong><span class="kobospan" id="kobo.415.1">) and specifying which type it can be used on (</span><strong class="source-inline"><span class="kobospan" id="kobo.416.1">on Post</span></strong><span class="kobospan" id="kobo.417.1">). </span><span class="kobospan" id="kobo.417.2">Then, all fields from the specified type can be queried in </span><span><span class="kobospan" id="kobo.418.1">the fragment.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.419.1">To use the</span><a id="_idIndexMarker741" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.420.1"> fragment, we first have to include its definition in the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.421.1">GET_POSTS</span></strong></span><span><span class="kobospan" id="kobo.422.1"> query:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.423.1">
export const GET_POSTS = gql`
</span><strong class="bold1"><span class="kobospan1" id="kobo.424.1">  ${POST_FIELDS}</span></strong><span class="kobospan1" id="kobo.425.1">
  query getPosts($options: PostsOptions) {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.426.1">Now, instead of listing all fields manually, we can use </span><span><span class="kobospan" id="kobo.427.1">the fragment:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.428.1">
    posts(options: $options) {
</span><strong class="bold1"><span class="kobospan1" id="kobo.429.1">      ...PostFields</span></strong><span class="kobospan1" id="kobo.430.1">
    }
  }
`</span></pre><p class="calibre3"><span class="kobospan" id="kobo.431.1">The syntax for using a fragment is like object destructuring in JavaScript, where all properties defined in an object are spread into </span><span><span class="kobospan" id="kobo.432.1">another object.</span></span></p></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.433.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.434.1">Sometimes the VS Code GraphQL extension needs to be restarted to be able to detect fragments properly. </span><span class="kobospan" id="kobo.434.2">You can do so by accessing the VS Code command palette (</span><em class="italic"><span class="kobospan" id="kobo.435.1">Ctrl</span></em><span class="kobospan" id="kobo.436.1"> + </span><em class="italic"><span class="kobospan" id="kobo.437.1">Shift</span></em><span class="kobospan" id="kobo.438.1"> + </span><em class="italic"><span class="kobospan" id="kobo.439.1">P</span></em><span class="kobospan" id="kobo.440.1"> on Windows/Linux and </span><em class="italic"><span class="kobospan" id="kobo.441.1">Cmd</span></em><span class="kobospan" id="kobo.442.1"> + </span><em class="italic"><span class="kobospan" id="kobo.443.1">Shift</span></em><span class="kobospan" id="kobo.444.1"> + </span><em class="italic"><span class="kobospan" id="kobo.445.1">P</span></em><span class="kobospan" id="kobo.446.1"> on macOS) and typing in </span><strong class="source-inline1"><span class="kobospan" id="kobo.447.1">GraphQL: </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.448.1">Manual Restart</span></strong></span><span><span class="kobospan" id="kobo.449.1">.</span></span></p>
<ol class="calibre15">
<li value="4" class="calibre11"><span class="kobospan" id="kobo.450.1">Next, we </span><a id="_idIndexMarker742" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.451.1">define a second query, where we query posts by author, and get all necessary fields with </span><span><span class="kobospan" id="kobo.452.1">the fragment:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.453.1">
export const GET_POSTS_BY_AUTHOR = gql`
  ${POST_FIELDS}
  query getPostsByAuthor($author: String!, $options: PostsOptions) {
    postsByAuthor(username: $author, options: $options) {
      ...PostFields
    }
  }
`</span></pre><p class="calibre3"><span class="kobospan" id="kobo.454.1">We defined the </span><strong class="source-inline"><span class="kobospan" id="kobo.455.1">$author</span></strong><span class="kobospan" id="kobo.456.1"> variable as required for this query (by using an exclamation mark after the type). </span><span class="kobospan" id="kobo.456.2">We need to do this because the </span><strong class="source-inline"><span class="kobospan" id="kobo.457.1">postsByAuthor</span></strong><span class="kobospan" id="kobo.458.1"> field also requires the first argument (</span><strong class="source-inline"><span class="kobospan" id="kobo.459.1">username</span></strong><span class="kobospan" id="kobo.460.1">) to </span><span><span class="kobospan" id="kobo.461.1">be set.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.462.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.463.1">src/pages/Blog.jsx</span></strong><span class="kobospan" id="kobo.464.1"> and import the newly </span><span><span class="kobospan" id="kobo.465.1">defined query:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.466.1">
import { GET_POSTS</span><strong class="bold1"><span class="kobospan1" id="kobo.467.1">, GET_POSTS_BY_AUTHOR</span></strong><span class="kobospan1" id="kobo.468.1"> } from '../api/graphql/posts.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.469.1">Then, adjust the hook to use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.470.1">GET_POSTS_BY_AUTHOR</span></strong><span class="kobospan" id="kobo.471.1"> query if </span><strong class="source-inline1"><span class="kobospan" id="kobo.472.1">author</span></strong> <span><span class="kobospan" id="kobo.473.1">is defined:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.474.1">
  const postsQuery = useGraphQLQuery(</span><strong class="bold1"><span class="kobospan1" id="kobo.475.1">author ? </span><span class="kobospan1" id="kobo.475.2">GET_POSTS_BY_AUTHOR : GET_POSTS</span></strong><span class="kobospan1" id="kobo.476.1">, {</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.477.1">Pass the </span><strong class="source-inline1"><span class="kobospan" id="kobo.478.1">author</span></strong><span class="kobospan" id="kobo.479.1"> variable to </span><span><span class="kobospan" id="kobo.480.1">the query:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.481.1">
    variables: { </span><strong class="bold1"><span class="kobospan1" id="kobo.482.1">author,</span></strong><span class="kobospan1" id="kobo.483.1"> options: { sortBy, sortOrder } },
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.484.1">Lastly, we need to adjust how we select the results because the </span><strong class="source-inline1"><span class="kobospan" id="kobo.485.1">postsByAuthor</span></strong><span class="kobospan" id="kobo.486.1"> field from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.487.1">GET_POSTS_BY_AUTHOR</span></strong><span class="kobospan" id="kobo.488.1"> query will return the results in </span><strong class="source-inline1"><span class="kobospan" id="kobo.489.1">data.postsByAuthor</span></strong><span class="kobospan" id="kobo.490.1">, while the </span><strong class="source-inline1"><span class="kobospan" id="kobo.491.1">GET_POSTS</span></strong><span class="kobospan" id="kobo.492.1"> query uses the </span><strong class="source-inline1"><span class="kobospan" id="kobo.493.1">posts</span></strong><span class="kobospan" id="kobo.494.1"> field, which returns results in </span><strong class="source-inline1"><span class="kobospan" id="kobo.495.1">data.posts</span></strong><span class="kobospan" id="kobo.496.1">. </span><span class="kobospan" id="kobo.496.2">As there is no case where both fields are returned at once, we can simply do </span><span><span class="kobospan" id="kobo.497.1">the following:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.498.1">
  const posts = </span><strong class="bold1"><span class="kobospan1" id="kobo.499.1">postsQuery.data?.postsByAuthor ??</span></strong><span class="kobospan1" id="kobo.500.1"> postsQuery.data?.posts ?? </span><span class="kobospan1" id="kobo.500.2">[]</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.501.1">Go to the</span><a id="_idIndexMarker743" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.502.1"> frontend and try filtering by author. </span><span class="kobospan" id="kobo.502.2">The filter works </span><span><span class="kobospan" id="kobo.503.1">again now!</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.504.1">As we can see, fragments are very useful for reusing the same fields for multiple queries! </span><span class="kobospan" id="kobo.504.2">Now that our post list is fully refactored to use GraphQL, let’s move on to using mutations on the frontend, allowing us to migrate the signup, login, and create post functionalities </span><span><span class="kobospan" id="kobo.505.1">to GraphQL.</span></span></p>
<h1 id="_idParaDest-237" class="calibre5"><a id="_idTextAnchor240" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.506.1">Using mutations on the frontend</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.507.1">As we learned in the </span><a id="_idIndexMarker744" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.508.1">previous chapter, mutations in GraphQL are used to change the state of the backend (similar to </span><strong class="source-inline"><span class="kobospan" id="kobo.509.1">POST</span></strong><span class="kobospan" id="kobo.510.1"> requests in REST). </span><span class="kobospan" id="kobo.510.2">We are now going to implement mutations for signing up and logging in to </span><span><span class="kobospan" id="kobo.511.1">our app.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.512.1">Follow </span><span><span class="kobospan" id="kobo.513.1">these steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.514.1">Create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.515.1">src/api/graphql/users.js</span></strong><span class="kobospan" id="kobo.516.1"> file and </span><span><span class="kobospan" id="kobo.517.1">import </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.518.1">gql</span></strong></span><span><span class="kobospan" id="kobo.519.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.520.1">
import { gql } from '@apollo/client/core/index.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.521.1">Then, define a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.522.1">SIGNUP_USER</span></strong><span class="kobospan" id="kobo.523.1"> mutation, which takes a username and a password and calls the </span><strong class="source-inline1"><span class="kobospan" id="kobo.524.1">signupUser</span></strong> <span><span class="kobospan" id="kobo.525.1">mutation field:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.526.1">
export const SIGNUP_USER = gql`
  mutation signupUser($username: String!, $password: String!) {
    signupUser(username: $username, password: $password) {
      username
    }
  }
`</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.527.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.528.1">src/pages/Signup.jsx</span></strong><span class="kobospan" id="kobo.529.1"> and </span><em class="italic"><span class="kobospan" id="kobo.530.1">replace</span></em><span class="kobospan" id="kobo.531.1"> the current </span><strong class="source-inline1"><span class="kobospan" id="kobo.532.1">useMutation</span></strong><span class="kobospan" id="kobo.533.1"> hook from</span><a id="_idIndexMarker745" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.534.1"> TanStack React Query with the one from Apollo Client. </span><span class="kobospan" id="kobo.534.2">As we did before for </span><strong class="source-inline1"><span class="kobospan" id="kobo.535.1">useQuery</span></strong><span class="kobospan" id="kobo.536.1">, we are also going to rename this hook to </span><strong class="source-inline1"><span class="kobospan" id="kobo.537.1">useGraphQLMutation</span></strong><span class="kobospan" id="kobo.538.1"> to </span><span><span class="kobospan" id="kobo.539.1">avoid confusion:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.540.1">
import { useMutation as useGraphQLMutation } from '@apollo/client/react/index.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.541.1">Additionally, </span><em class="italic"><span class="kobospan" id="kobo.542.1">replace</span></em><span class="kobospan" id="kobo.543.1"> the import of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.544.1">signup</span></strong><span class="kobospan" id="kobo.545.1"> function with an import of the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.546.1">SIGNUP_USER</span></strong></span><span><span class="kobospan" id="kobo.547.1"> mutation:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.548.1">
import { SIGNUP_USER } from '../api/graphql/users.js'</span></pre></li> <li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.549.1">Replace</span></em><span class="kobospan" id="kobo.550.1"> the existing mutation hook with </span><span><span class="kobospan" id="kobo.551.1">the following:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.552.1">  const [signupUser, { loading }] = useGraphQLMutation(SIGNUP_USER, {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.553.1">    variables: { username, password },</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.554.1">    onCompleted:</span></strong><span class="kobospan1" id="kobo.555.1"> () =&gt; navigate('/login'),
    onError: () =&gt; alert('failed to sign up!'),
  })</span></pre><p class="calibre3"><span class="kobospan" id="kobo.556.1">As can be seen, the Apollo Client mutation hook has a slightly different API than the TanStack React Query mutation hook. </span><span class="kobospan" id="kobo.556.2">It returns an array with a function to call the mutation, and an object with the loading state, error state, and data. </span><span class="kobospan" id="kobo.556.3">Similar to the </span><strong class="source-inline"><span class="kobospan" id="kobo.557.1">useGraphQLQuery</span></strong><span class="kobospan" id="kobo.558.1"> hook, it also accepts the mutation as the first argument and an object with variables as the second argument. </span><span class="kobospan" id="kobo.558.2">Moreover, the </span><strong class="source-inline"><span class="kobospan" id="kobo.559.1">onSuccess</span></strong><span class="kobospan" id="kobo.560.1"> function is called </span><strong class="source-inline"><span class="kobospan" id="kobo.561.1">onCompleted</span></strong><span class="kobospan" id="kobo.562.1"> in </span><span><span class="kobospan" id="kobo.563.1">Apollo Client.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.564.1">Change the </span><strong class="source-inline1"><span class="kobospan" id="kobo.565.1">handleSubmit</span></strong><span class="kobospan" id="kobo.566.1"> function </span><span><span class="kobospan" id="kobo.567.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.568.1">
  const handleSubmit = (e) =&gt; {
    e.preventDefault()
    </span><strong class="bold1"><span class="kobospan1" id="kobo.569.1">signupUser()</span></strong><span class="kobospan1" id="kobo.570.1">
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.571.1">Lastly, change the</span><a id="_idIndexMarker746" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.572.1"> submit button </span><span><span class="kobospan" id="kobo.573.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.574.1">
      &lt;input
        type='submit'
        value={</span><strong class="bold1"><span class="kobospan1" id="kobo.575.1">loading</span></strong><span class="kobospan1" id="kobo.576.1"> ? </span><span class="kobospan1" id="kobo.576.2">'Signing up...' </span><span class="kobospan1" id="kobo.576.3">: 'Sign Up'}
        disabled={!username || !password || </span><strong class="bold1"><span class="kobospan1" id="kobo.577.1">loading</span></strong><span class="kobospan1" id="kobo.578.1">}
      /&gt;</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.579.1">Now the signup functionality is successfully migrated to GraphQL. </span><span class="kobospan" id="kobo.579.2">Next, let’s migrate the </span><span><span class="kobospan" id="kobo.580.1">login functionality.</span></span></p>
<h2 id="_idParaDest-238" class="calibre7"><a id="_idTextAnchor241" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.581.1">Migrating login to GraphQL</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.582.1">Refactoring the login</span><a id="_idIndexMarker747" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.583.1"> functionality to GraphQL is very similar to the signup functionality, so let’s quickly go through </span><span><span class="kobospan" id="kobo.584.1">the steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.585.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.586.1">src/api/graphql/users.js</span></strong><span class="kobospan" id="kobo.587.1"> and define a mutation for </span><span><span class="kobospan" id="kobo.588.1">logging in:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.589.1">
export const LOGIN_USER = gql`
  mutation loginUser($username: String!, $password: String!) {
    loginUser(username: $username, password: $password)
  }
`</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.590.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.591.1">src/pages/Login.jsx</span></strong><span class="kobospan" id="kobo.592.1"> and </span><em class="italic"><span class="kobospan" id="kobo.593.1">replace</span></em><span class="kobospan" id="kobo.594.1"> the imports to TanStack React Query and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.595.1">login</span></strong><span class="kobospan" id="kobo.596.1"> function with </span><span><span class="kobospan" id="kobo.597.1">the following:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.598.1">
import { useMutation as useGraphQLMutation } from '@apollo/client/react/index.js'
import { LOGIN_USER } from '../api/graphql/users.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.599.1">Update the hook </span><span><span class="kobospan" id="kobo.600.1">as well:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.601.1">
  </span><strong class="bold1"><span class="kobospan1" id="kobo.602.1">const [loginUser, { loading }] = useGraphQLMutation(LOGIN_USER, {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.603.1">    variables: { username, password },</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.604.1">    onCompleted</span></strong><span class="kobospan1" id="kobo.605.1">: (data) =&gt; {
      setToken(data.</span><strong class="bold1"><span class="kobospan1" id="kobo.606.1">loginUser</span></strong><span class="kobospan1" id="kobo.607.1">)
      navigate('/')
    },
    onError: () =&gt; alert('failed to login!'),
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.608.1">Update </span><a id="_idIndexMarker748" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.609.1">the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.610.1">handleSubmit</span></strong></span><span><span class="kobospan" id="kobo.611.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.612.1">
  const handleSubmit = (e) =&gt; {
    e.preventDefault()
    </span><strong class="bold1"><span class="kobospan1" id="kobo.613.1">loginUser()</span></strong><span class="kobospan1" id="kobo.614.1">
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.615.1">Finally, update the </span><span><span class="kobospan" id="kobo.616.1">submit button:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.617.1">
      &lt;input
        type='submit'
        value={</span><strong class="bold1"><span class="kobospan1" id="kobo.618.1">loading</span></strong><span class="kobospan1" id="kobo.619.1"> ? </span><span class="kobospan1" id="kobo.619.2">'Logging in...' </span><span class="kobospan1" id="kobo.619.3">: 'Log In'}
        disabled={!username || !password || </span><strong class="bold1"><span class="kobospan1" id="kobo.620.1">loading</span></strong><span class="kobospan1" id="kobo.621.1">}
      /&gt;</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.622.1">Now that signup and login are using GraphQL mutations, let’s move on to migrating the create post functionality </span><span><span class="kobospan" id="kobo.623.1">to GraphQL.</span></span></p>
<h2 id="_idParaDest-239" class="calibre7"><a id="_idTextAnchor242" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.624.1">Migrating create post to GraphQL</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.625.1">The create post functionality is a</span><a id="_idIndexMarker749" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.626.1"> bit trickier to implement, as it requires us to be logged in (which means that we need to send the JWT header), and invalidate the post list queries, so that the list gets updated after creating a </span><span><span class="kobospan" id="kobo.627.1">new post.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.628.1">Now let’s get started on implementing this with </span><span><span class="kobospan" id="kobo.629.1">Apollo Client:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.630.1">First, let’s define the mutation. </span><span class="kobospan" id="kobo.630.2">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.631.1">src/api/graphql/posts.js</span></strong><span class="kobospan" id="kobo.632.1"> and add the </span><span><span class="kobospan" id="kobo.633.1">following code:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.634.1">
export const CREATE_POST = gql`
  mutation createPost($title: String!, $contents: String, $tags: [String!]) {
    createPost(title: $title, contents: $contents, tags: $tags) {
      id
      title
    }
  }
`</span></pre><p class="calibre3"><span class="kobospan" id="kobo.635.1">For this mutation, we are going to use the response to get the </span><strong class="source-inline"><span class="kobospan" id="kobo.636.1">id</span></strong><span class="kobospan" id="kobo.637.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.638.1">title</span></strong><span class="kobospan" id="kobo.639.1"> of the created post. </span><span class="kobospan" id="kobo.639.2">We are going to make use of this data to show a link to the post upon </span><span><span class="kobospan" id="kobo.640.1">successful creation.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.641.1">Then, edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.642.1">src/components/CreatePost.jsx</span></strong><span class="kobospan" id="kobo.643.1"> and </span><em class="italic"><span class="kobospan" id="kobo.644.1">replace</span></em><span class="kobospan" id="kobo.645.1"> the TanStack React Query import with an import of the </span><span><span class="kobospan" id="kobo.646.1">mutation hook:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.647.1">
import { useMutation as useGraphQLMutation } from '@apollo/client/react/index.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.648.1">Also, import the </span><strong class="source-inline1"><span class="kobospan" id="kobo.649.1">Link</span></strong><span class="kobospan" id="kobo.650.1"> component and </span><strong class="source-inline1"><span class="kobospan" id="kobo.651.1">slug</span></strong><span class="kobospan" id="kobo.652.1"> function to show a link to the </span><span><span class="kobospan" id="kobo.653.1">created post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.654.1">
import { Link } from 'react-router-dom'
import slug from 'slug'</span></pre></li> <li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.655.1">Replace</span></em><span class="kobospan" id="kobo.656.1"> the</span><a id="_idIndexMarker750" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.657.1"> import of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.658.1">createPost</span></strong><span class="kobospan" id="kobo.659.1"> function with imports of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.660.1">CREATE_POST</span></strong><span class="kobospan" id="kobo.661.1"> mutation and the </span><strong class="source-inline1"><span class="kobospan" id="kobo.662.1">GET_POSTS</span></strong><span class="kobospan" id="kobo.663.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.664.1">GET_POSTS_BY_AUTHOR</span></strong><span class="kobospan" id="kobo.665.1"> queries. </span><span class="kobospan" id="kobo.665.2">We are going to use these query definitions to make Apollo Client re-fetch them for </span><span><span class="kobospan" id="kobo.666.1">us later:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.667.1">
import {
  CREATE_POST,
  GET_POSTS,
  GET_POSTS_BY_AUTHOR,
} from '../api/graphql/posts.js'</span></pre></li> <li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.668.1">Replace</span></em><span class="kobospan" id="kobo.669.1"> the existing query client and mutation hooks with the following GraphQL mutation, where we pass the </span><strong class="source-inline1"><span class="kobospan" id="kobo.670.1">title</span></strong><span class="kobospan" id="kobo.671.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.672.1">contents</span></strong></span><span><span class="kobospan" id="kobo.673.1"> variables:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.674.1">
  const [createPost, { loading, data }] = useGraphQLMutation(CREATE_POST, {
    variables: { title, contents },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.675.1">Next, we provide the JWT header as </span><strong class="source-inline1"><span class="kobospan" id="kobo.676.1">context</span></strong><span class="kobospan" id="kobo.677.1"> to </span><span><span class="kobospan" id="kobo.678.1">the mutation:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.679.1">
    context: { headers: { Authorization: `Bearer ${token}` } },</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.680.1">Then, we provide a </span><strong class="source-inline1"><span class="kobospan" id="kobo.681.1">refetchQueries</span></strong><span class="kobospan" id="kobo.682.1"> option to the mutation, telling Apollo Client to re-fetch certain queries after the mutation </span><span><span class="kobospan" id="kobo.683.1">was called:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.684.1">
    refetchQueries: [GET_POSTS, GET_POSTS_BY_AUTHOR],
  })</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.685.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.686.1">As re-fetching after a mutation is a common operation, Apollo Client provides a simple way to do this in the mutation hook. </span><span class="kobospan" id="kobo.686.2">Simply pass all queries that should be re-fetched there, and Apollo Client will take care </span><span><span class="kobospan" id="kobo.687.1">of it.</span></span></p>
<ol class="calibre15">
<li value="8" class="calibre11"><span class="kobospan" id="kobo.688.1">Adjust </span><a id="_idIndexMarker751" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.689.1">the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.690.1">handleSubmit</span></strong></span><span><span class="kobospan" id="kobo.691.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.692.1">
  const handleSubmit = (e) =&gt; {
    e.preventDefault()
</span><strong class="bold1"><span class="kobospan1" id="kobo.693.1">    createPost()</span></strong><span class="kobospan1" id="kobo.694.1">
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.695.1">Adjust the </span><span><span class="kobospan" id="kobo.696.1">submit button:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.697.1">
      &lt;input
        type='submit'
        value={</span><strong class="bold1"><span class="kobospan1" id="kobo.698.1">loading</span></strong><span class="kobospan1" id="kobo.699.1"> ? </span><span class="kobospan1" id="kobo.699.2">'Creating...' </span><span class="kobospan1" id="kobo.699.3">: 'Create'}
        disabled={!title || </span><strong class="bold1"><span class="kobospan1" id="kobo.700.1">loading</span></strong><span class="kobospan1" id="kobo.701.1">}
      /&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.702.1">Lastly, we are going to change the success message, showing a link to the </span><span><span class="kobospan" id="kobo.703.1">created post:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.704.1">
      {data?.createPost ? </span><span class="kobospan1" id="kobo.704.2">(
        &lt;&gt;
          &lt;br /&gt;
          Post{' '}
          &lt;Link
            to={`/posts/${data.createPost.id}/${slug(data.createPost.title)}`}
          &gt;
            {data.createPost.title}
          &lt;/Link&gt;{' '}
          created successfully!
</span><span class="kobospan1" id="kobo.704.3">        &lt;/&gt;
      ) : null}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.705.1">Because of the way types and resolvers work in GraphQL, it easily allows us to access fields from the result of a mutation, the same way as if we were fetching a single post. </span><span class="kobospan" id="kobo.705.2">For example, we could even tell GraphQL to fetch the username of the author of the created </span><span><span class="kobospan" id="kobo.706.1">post here!</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.707.1">Try creating a </span><a id="_idIndexMarker752" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.708.1">new post, and you will see that the success message now shows a link to the created post, and the post list automatically re-fetches </span><span><span class="kobospan" id="kobo.709.1">for us!</span></span><p class="calibre3"><span class="kobospan" id="kobo.710.1">The following screenshot shows a new post being successfully created, showing the link to the new post in the success message, and the new post in the post list (automatically re-fetched by </span><span><span class="kobospan" id="kobo.711.1">Apollo Client):</span></span></p></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer109">
<span class="kobospan" id="kobo.712.1"><img alt="Figure 12.1: Creating a post using GraphQL mutations, with a re-fetching post list" src="image/B19385_12_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.713.1">Figure 12.1: Creating a post using GraphQL mutations, with a re-fetching post list</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.714.1">Now that we have successfully implemented creating posts with GraphQL, our blog app is fully connected to our </span><span><span class="kobospan" id="kobo.715.1">GraphQL server.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.716.1">There are many more advanced concepts in GraphQL that we have not covered yet in this book, such as advanced re-fetching, subscriptions (getting real-time updates from the GraphQL server), error handling, suspense, pagination, and caching. </span><span class="kobospan" id="kobo.716.2">The GraphQL chapters in this book only serve as an introduction </span><span><span class="kobospan" id="kobo.717.1">to GraphQL.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.718.1">If you wish to learn more about GraphQL and Apollo, I recommend checking out the extensive </span><a id="_idIndexMarker753" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.719.1">Apollo docs (</span><a href="https://www.apollographql.com/docs/" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.720.1">https://www.apollographql.com/docs/</span></a><span class="kobospan" id="kobo.721.1">), which contain detailed information and hands-on examples about using Apollo Server and </span><span><span class="kobospan" id="kobo.722.1">Apollo Client.</span></span></p>
<h1 id="_idParaDest-240" class="calibre5"><a id="_idTextAnchor243" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.723.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.724.1">In this chapter, we connected our previously created GraphQL backend to the frontend using Apollo Client. </span><span class="kobospan" id="kobo.724.2">We started by setting up Apollo Client and making a GraphQL query to fetch all posts. </span><span class="kobospan" id="kobo.724.3">Then, we improved the performance of the post list by fetching author usernames in a single request, leveraging the power </span><span><span class="kobospan" id="kobo.725.1">of GraphQL.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.726.1">Next, we introduced variables in our query and re-implemented sorting and filtering by author. </span><span class="kobospan" id="kobo.726.2">We also introduced fragments in our queries to reuse the same fields. </span><span class="kobospan" id="kobo.726.3">Lastly, we implemented GraphQL mutations in the frontend to sign up, log in, and create posts. </span><span class="kobospan" id="kobo.726.4">We also learned about re-fetching queries in Apollo Client along the way and briefly mentioned advanced concepts of GraphQL </span><span><span class="kobospan" id="kobo.727.1">and Apollo.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.728.1">In the next chapter, </span><a href="B19385_13.xhtml#_idTextAnchor245" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.729.1">Chapter 13</span></em></span></a><span class="kobospan" id="kobo.730.1">, </span><em class="italic"><span class="kobospan" id="kobo.731.1">Building a Backend Based on Event-Driven Architecture Using Express and Socket.IO</span></em><span class="kobospan" id="kobo.732.1">, we are going to depart from traditional full-stack architectures and build a new app using a special kind of full-stack architecture: an </span><span><span class="kobospan" id="kobo.733.1">event-based application.</span></span></p>
</div>
</body></html>