<html><head></head><body>
		<div id="_idContainer009">
			<h1 id="_idParaDest-49"><em class="italic"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.1.1">Chapter 3</span></em><span class="koboSpan" id="kobo.2.1">: Sharing Component State with Context</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">React has provided Context since version 16.3. </span><span class="koboSpan" id="kobo.3.2">Context has nothing to do with states, but it's a mechanism for passing data from component to component instead of using props. </span><span class="koboSpan" id="kobo.3.3">By combining Context with a component state, we can provide a global state.</span></p>
			<p><span class="koboSpan" id="kobo.4.1">In addition to the Context support provided since React 16.3, React 16.8 introduced the </span><strong class="source-inline"><span class="koboSpan" id="kobo.5.1">useContext</span></strong><span class="koboSpan" id="kobo.6.1"> hook. </span><span class="koboSpan" id="kobo.6.2">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.7.1">useContext</span></strong><span class="koboSpan" id="kobo.8.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.9.1">useState</span></strong><span class="koboSpan" id="kobo.10.1"> (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.11.1">useReducer</span></strong><span class="koboSpan" id="kobo.12.1">), we can create custom hooks for a global state.</span></p>
			<p><span class="koboSpan" id="kobo.13.1">Context is not fully designed for global states. </span><span class="koboSpan" id="kobo.13.2">One of the known limitations is that all Context consumers re-render upon updates, which can lead to extra re-renders. </span><span class="koboSpan" id="kobo.13.3">It's a general recommendation to split a global state into pieces.</span></p>
			<p><span class="koboSpan" id="kobo.14.1">In this chapter, we discuss the general recommendations for using Context and show some concrete examples. </span><span class="koboSpan" id="kobo.14.2">We also discuss some techniques to use Context with TypeScript. </span><span class="koboSpan" id="kobo.14.3">The goal is to make you feel confident with using Context for a global state.</span></p>
			<p><span class="koboSpan" id="kobo.15.1">In this chapter, we will cover the following topics:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.16.1">Exploring </span><strong class="source-inline"><span class="koboSpan" id="kobo.17.1">useState</span></strong><span class="koboSpan" id="kobo.18.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.19.1">useContext</span></strong></li>
				<li><span class="koboSpan" id="kobo.20.1">Understanding Context</span></li>
				<li><span class="koboSpan" id="kobo.21.1">Creating a Context for a global state</span></li>
				<li><span class="koboSpan" id="kobo.22.1">Best practices for using Context</span></li>
			</ul>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
			<p><span class="koboSpan" id="kobo.24.1">If you are new to React Context, it's highly recommended to learn some basics; check out the official documentation (</span><a href="https://reactjs.org/docs/context.html"><span class="koboSpan" id="kobo.25.1">https://reactjs.org/docs/context.html</span></a><span class="koboSpan" id="kobo.26.1">) and the official blog (</span><a href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html"><span class="koboSpan" id="kobo.27.1">https://reactjs.org/blog/2018/03/29/react-v-16-3.html</span></a><span class="koboSpan" id="kobo.28.1">).</span></p>
			<p><span class="koboSpan" id="kobo.29.1">You are also expected to have general knowledge around React including React hooks; you can refer to the official site (</span><a href="https://reactjs.org"><span class="koboSpan" id="kobo.30.1">https://reactjs.org</span></a><span class="koboSpan" id="kobo.31.1">) to learn more. </span></p>
			<p><span class="koboSpan" id="kobo.32.1">In some code, we use TypeScript, which you should have basic knowledge of; you can find out more here: </span><a href="https://www.typescriptlang.org"><span class="koboSpan" id="kobo.33.1">https://www.typescriptlang.org</span></a><span class="koboSpan" id="kobo.34.1">.</span></p>
			<p><span class="koboSpan" id="kobo.35.1">The code in this chapter is available on GitHub at </span><a href="https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_03"><span class="koboSpan" id="kobo.36.1">https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_03</span></a><span class="koboSpan" id="kobo.37.1">.</span></p>
			<p><span class="koboSpan" id="kobo.38.1">To run the code snippets in this chapter, you need a React environment—for example, Create React App (</span><a href="https://create-react-app.dev"><span class="koboSpan" id="kobo.39.1">https://create-react-app.dev</span></a><span class="koboSpan" id="kobo.40.1">) or CodeSandbox (</span><a href="https://codesandbox.io"><span class="koboSpan" id="kobo.41.1">https://codesandbox.io</span></a><span class="koboSpan" id="kobo.42.1">).</span></p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.43.1">Exploring useState and useContext</span></h1>
			<p><span class="koboSpan" id="kobo.44.1">By combining </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">useState</span></strong><span class="koboSpan" id="kobo.46.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">useContext</span></strong><span class="koboSpan" id="kobo.48.1">, we can create a simple global state. </span><span class="koboSpan" id="kobo.48.2">Let's recap </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.49.1">on how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">useState</span></strong><span class="koboSpan" id="kobo.51.1"> without </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">useContext</span></strong><span class="koboSpan" id="kobo.53.1">, how </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">useContext</span></strong><span class="koboSpan" id="kobo.55.1"> works for </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.56.1">static values, and how we combine </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">useState</span></strong><span class="koboSpan" id="kobo.58.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">useContext</span></strong><span class="koboSpan" id="kobo.60.1">.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.61.1">Using useState without useContext</span></h2>
			<p><span class="koboSpan" id="kobo.62.1">Before diving into </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">useContext</span></strong><span class="koboSpan" id="kobo.64.1">, let's be reminded of how to </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">useState</span></strong><span class="koboSpan" id="kobo.66.1">, with a concrete example. </span><span class="koboSpan" id="kobo.66.2">This </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.67.1">example is going to be a reference </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.68.1">for the following examples in the chapter.</span></p>
			<p><span class="koboSpan" id="kobo.69.1">Here, we define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">count</span></strong><span class="koboSpan" id="kobo.71.1"> state with </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">useState</span></strong><span class="koboSpan" id="kobo.73.1"> higher in the component tree and pass the state value and the update function down the tree.</span></p>
			<p><span class="koboSpan" id="kobo.74.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">App</span></strong><span class="koboSpan" id="kobo.76.1"> component, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">useState</span></strong><span class="koboSpan" id="kobo.78.1"> and get </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">count</span></strong><span class="koboSpan" id="kobo.80.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">setCount</span></strong><span class="koboSpan" id="kobo.82.1">, which are passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">Parent</span></strong><span class="koboSpan" id="kobo.84.1"> component. </span><span class="koboSpan" id="kobo.84.2">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.85.1">const App = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.86.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.87.1">  return &lt;Parent count={count} setCount={setCount} /&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.88.1">};</span></p>
			<p><span class="koboSpan" id="kobo.89.1">This is a very basic pattern, which we know as </span><em class="italic"><span class="koboSpan" id="kobo.90.1">lifting the state up</span></em><span class="koboSpan" id="kobo.91.1">, from </span><a href="B17780_02_Final_VK_ePub.xhtml#_idTextAnchor035"><em class="italic"><span class="koboSpan" id="kobo.92.1">Chapter 2</span></em></a><span class="koboSpan" id="kobo.93.1">,</span><em class="italic"><span class="koboSpan" id="kobo.94.1"> Using Local and Global States</span></em><span class="koboSpan" id="kobo.95.1">.</span></p>
			<p><span class="koboSpan" id="kobo.96.1">Now, let's define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">Parent</span></strong><span class="koboSpan" id="kobo.98.1"> component. </span><span class="koboSpan" id="kobo.98.2">It passes the two props to </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">Component1</span></strong><span class="koboSpan" id="kobo.100.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">Component2</span></strong><span class="koboSpan" id="kobo.102.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.103.1">const Parent = ({ count, setCount }) =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.104.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.105.1">    &lt;Component1 count={count} setCount={setCount} /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.106.1">    &lt;Component2 count={count} setCount={setCount} /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.107.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.108.1">);</span></p>
			<p><span class="koboSpan" id="kobo.109.1">This passing </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.110.1">of props from parent to children is a </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.111.1">repetitive task and is often referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">prop drilling</span></strong><span class="koboSpan" id="kobo.113.1">.</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">Component1</span></strong><span class="koboSpan" id="kobo.115.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">Component2</span></strong><span class="koboSpan" id="kobo.117.1"> display the </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">count</span></strong><span class="koboSpan" id="kobo.119.1"> state and a button to increase the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">count</span></strong><span class="koboSpan" id="kobo.121.1"> state with </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">setCount</span></strong><span class="koboSpan" id="kobo.123.1">, as illustrated </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.124.1">in the following code snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.125.1">const Component1 = ({ count, setCount }) =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.126.1">  &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.127.1">    {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.128.1">    &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.129.1">      +1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.130.1">    &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.131.1">  &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.132.1">);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.133.1">const Component2 = ({ count, setCount }) =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.134.1">  &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.135.1">    {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.136.1">    &lt;button onClick={() =&gt; setCount((c) =&gt; c + 2)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.137.1">      +2</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.138.1">    &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.139.1">  &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.140.1">);</span></p>
			<p><span class="koboSpan" id="kobo.141.1">These two components are pure components, which means they receive props and display things based only on those props. </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">Component2</span></strong><span class="koboSpan" id="kobo.143.1"> is slightly different from </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">Component1</span></strong><span class="koboSpan" id="kobo.145.1">, which increases the count by two. </span><span class="koboSpan" id="kobo.145.2">If it were identical, we wouldn't need to define two components.</span></p>
			<p><span class="koboSpan" id="kobo.146.1">There is </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.147.1">nothing wrong with this example. </span><span class="koboSpan" id="kobo.147.2">Only when </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.148.1">the app gets bigger, passing props down the tree, will this not make sense. </span><span class="koboSpan" id="kobo.148.2">In this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">Parent</span></strong><span class="koboSpan" id="kobo.150.1"> component doesn't necessarily need to know about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">count</span></strong><span class="koboSpan" id="kobo.152.1"> state, and it may make sense to hide the existence of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">count</span></strong><span class="koboSpan" id="kobo.154.1"> state in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">Parent</span></strong><span class="koboSpan" id="kobo.156.1"> component.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.157.1">Using useContext with a static value</span></h2>
			<p><span class="koboSpan" id="kobo.158.1">React Context helps to eliminate props. </span><span class="koboSpan" id="kobo.158.2">It's a means to pass a value from a parent component </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.159.1">to its children under the tree, without using props.</span></p>
			<p><span class="koboSpan" id="kobo.160.1">The following </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.161.1">example shows how to use React Context with a static value. </span><span class="koboSpan" id="kobo.161.2">It has multiple providers to provide different values. </span><span class="koboSpan" id="kobo.161.3">Providers can be nested, and a consumer component (a consumer component means a component with </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">useContext</span></strong><span class="koboSpan" id="kobo.163.1">) will pick the closest provider in the component tree to get the Context value. </span><span class="koboSpan" id="kobo.163.2">There is only one component with </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">useContext</span></strong><span class="koboSpan" id="kobo.165.1"> to consume the Context, and the component is used in multiple places.</span></p>
			<p><span class="koboSpan" id="kobo.166.1">Firstly, we define a color Context with </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">createContext</span></strong><span class="koboSpan" id="kobo.168.1">, which takes a default value, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.169.1">const ColorContext = createContext('black');</span></p>
			<p><span class="koboSpan" id="kobo.170.1">In this case, the default value for the color Context is </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">'black'</span></strong><span class="koboSpan" id="kobo.172.1">. </span><span class="koboSpan" id="kobo.172.2">The default value is used if a component is not in any providers.</span></p>
			<p><span class="koboSpan" id="kobo.173.1">Now, we define a consumer component. </span><span class="koboSpan" id="kobo.173.2">It reads the color Context and displays a text in that color. </span><span class="koboSpan" id="kobo.173.3">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.174.1">const Component = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.175.1">  const color = useContext(ColorContext);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.176.1">  return &lt;div style={{ color }}&gt;Hello {color}&lt;/div&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.177.1">};</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">Component</span></strong><span class="koboSpan" id="kobo.179.1"> reads the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">color</span></strong><span class="koboSpan" id="kobo.181.1"> Context value, but at this point, we don't know what the color is, and </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.182.1">it literally depends on the Context.</span></p>
			<p><span class="koboSpan" id="kobo.183.1">Finally, we </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.184.1">define an </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">App</span></strong><span class="koboSpan" id="kobo.186.1"> component. </span><span class="koboSpan" id="kobo.186.2">The component tree in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">App</span></strong><span class="koboSpan" id="kobo.188.1"> component has multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">ColorContext.Provider</span></strong><span class="koboSpan" id="kobo.190.1"> components with different colors. </span><span class="koboSpan" id="kobo.190.2">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.191.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.192.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.193.1">    &lt;Component /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.194.1">    &lt;ColorContext.Provider value="red"&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.195.1">      &lt;Component /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.196.1">    &lt;/ColorContext.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.197.1">    &lt;ColorContext.Provider value="green"&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.198.1">      &lt;Component /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.199.1">    &lt;/ColorContext.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.200.1">    &lt;ColorContext.Provider value="blue"&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.201.1">      &lt;Component /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.202.1">      &lt;ColorContext.Provider value="skyblue"&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.203.1">        &lt;Component /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.204.1">      &lt;/ColorContext.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.205.1">    &lt;/ColorContext.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.206.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.207.1">);</span></p>
			<p><span class="koboSpan" id="kobo.208.1">The first </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">Component</span></strong><span class="koboSpan" id="kobo.210.1"> instance shows the color </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">"black"</span></strong><span class="koboSpan" id="kobo.212.1"> because it's not wrapped by any providers. </span><span class="koboSpan" id="kobo.212.2">The second and the third show </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">"red"</span></strong><span class="koboSpan" id="kobo.214.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">"green"</span></strong><span class="koboSpan" id="kobo.216.1"> respectively. </span><span class="koboSpan" id="kobo.216.2">The fourth </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">Component</span></strong><span class="koboSpan" id="kobo.218.1"> instance shows </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">"blue"</span></strong><span class="koboSpan" id="kobo.220.1">, and the last </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">Component</span></strong><span class="koboSpan" id="kobo.222.1"> instance shows </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">"skyblue"</span></strong><span class="koboSpan" id="kobo.224.1">, because the closest provider has the value </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">"skyblue"</span></strong><span class="koboSpan" id="kobo.226.1"> even though it's inside the provider with </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">"blue"</span></strong><span class="koboSpan" id="kobo.228.1">.</span></p>
			<p><span class="koboSpan" id="kobo.229.1">Multiple </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.230.1">providers and reusing the consumer component </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.231.1">is an important capability of React Context. </span><span class="koboSpan" id="kobo.231.2">If this capability is not important for your use case, you might not need React Context. </span><span class="koboSpan" id="kobo.231.3">We will discuss the subscription method without Context in </span><a href="B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066"><em class="italic"><span class="koboSpan" id="kobo.232.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.233.1">, </span><em class="italic"><span class="koboSpan" id="kobo.234.1">Sharing Module State with Subscription</span></em><span class="koboSpan" id="kobo.235.1">.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.236.1">Using useState with useContext</span></h2>
			<p><span class="koboSpan" id="kobo.237.1">Now, let's learn how the combination of </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">useState</span></strong><span class="koboSpan" id="kobo.239.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">useContext</span></strong><span class="koboSpan" id="kobo.241.1"> structure our code. </span><span class="koboSpan" id="kobo.241.2">We can </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.242.1">pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">state</span></strong><span class="koboSpan" id="kobo.244.1"> value and </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">update</span></strong><span class="koboSpan" id="kobo.246.1"> function in Context instead of props.</span></p>
			<p><span class="koboSpan" id="kobo.247.1">The following </span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.248.1">example implements a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">count</span></strong><span class="koboSpan" id="kobo.250.1"> state with </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">useState</span></strong><span class="koboSpan" id="kobo.252.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">useContext</span></strong><span class="koboSpan" id="kobo.254.1">. </span><span class="koboSpan" id="kobo.254.2">We define a Context that holds both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">count</span></strong><span class="koboSpan" id="kobo.256.1"> state value and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">setCount</span></strong><span class="koboSpan" id="kobo.258.1"> update function. </span><span class="koboSpan" id="kobo.258.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">Parent</span></strong><span class="koboSpan" id="kobo.260.1"> component doesn't take props, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">Component1</span></strong><span class="koboSpan" id="kobo.262.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">Component2</span></strong><span class="koboSpan" id="kobo.264.1"> use </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">useContext</span></strong><span class="koboSpan" id="kobo.266.1"> to get the state.</span></p>
			<p><span class="koboSpan" id="kobo.267.1">First, we create a Context for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">count</span></strong><span class="koboSpan" id="kobo.269.1"> state. </span><span class="koboSpan" id="kobo.269.2">The default value holds a static </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">count</span></strong><span class="koboSpan" id="kobo.271.1"> value and a fallback empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">setCount</span></strong><span class="koboSpan" id="kobo.273.1"> function. </span><span class="koboSpan" id="kobo.273.2">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.274.1">const CountStateContext = createContext({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.275.1">  count: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.276.1">  setCount: () =&gt; {},</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.277.1">});</span></p>
			<p><span class="koboSpan" id="kobo.278.1">The default value helps to infer types in TypeScript. </span><span class="koboSpan" id="kobo.278.2">However, in most cases, we need a state instead of a static value, as the default value is not very useful. </span><span class="koboSpan" id="kobo.278.3">Using the default value is almost unintentional in such cases, so we may throw an error instead. </span><span class="koboSpan" id="kobo.278.4">We will discuss some best practices later in the </span><em class="italic"><span class="koboSpan" id="kobo.279.1">Best practices for using Context</span></em><span class="koboSpan" id="kobo.280.1"> section.</span></p>
			<p><span class="koboSpan" id="kobo.281.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">App</span></strong><span class="koboSpan" id="kobo.283.1"> component has a state with </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">useState</span></strong><span class="koboSpan" id="kobo.285.1">, and passes </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">count</span></strong><span class="koboSpan" id="kobo.287.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">setCount</span></strong><span class="koboSpan" id="kobo.289.1"> to the created Context provider component, as illustrated in the following code snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.290.1">const App = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.291.1">  const [count, setCount] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.292.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.293.1">    &lt;CountStateContext.Provider </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.294.1">      value={{ count, setCount }}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.295.1">    &gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.296.1">      &lt;Parent /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.297.1">    &lt;/CountStateContext.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.298.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.299.1">};</span></p>
			<p><span class="koboSpan" id="kobo.300.1">The Context </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.301.1">value we pass to </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">CountStateContext.Provider</span></strong><span class="koboSpan" id="kobo.303.1"> is an object containing </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">count</span></strong><span class="koboSpan" id="kobo.305.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">setCount</span></strong><span class="koboSpan" id="kobo.307.1">. </span><span class="koboSpan" id="kobo.307.2">This object has the </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.308.1">same structure as the default value.</span></p>
			<p><span class="koboSpan" id="kobo.309.1">We define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">Parent</span></strong><span class="koboSpan" id="kobo.311.1"> component. </span><span class="koboSpan" id="kobo.311.2">Unlike the example in the previous section, we don't need to pass props. </span><span class="koboSpan" id="kobo.311.3">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.312.1">const Parent = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.313.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.314.1">    &lt;Component1 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.315.1">    &lt;Component2 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.316.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.317.1">);</span></p>
			<p><span class="koboSpan" id="kobo.318.1">Even though the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">Parent</span></strong><span class="koboSpan" id="kobo.320.1"> component is in the Context provider in </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">App</span></strong><span class="koboSpan" id="kobo.322.1">, it does not know about the existence of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">count</span></strong><span class="koboSpan" id="kobo.324.1"> state. </span><span class="koboSpan" id="kobo.324.2">The components inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">Parent</span></strong><span class="koboSpan" id="kobo.326.1"> can still use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">count</span></strong><span class="koboSpan" id="kobo.328.1"> state through the Context.</span></p>
			<p><span class="koboSpan" id="kobo.329.1">Finally, we define </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">Component1</span></strong><span class="koboSpan" id="kobo.331.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">Component2</span></strong><span class="koboSpan" id="kobo.333.1">. </span><span class="koboSpan" id="kobo.333.2">They take </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">count</span></strong><span class="koboSpan" id="kobo.335.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">setCount</span></strong><span class="koboSpan" id="kobo.337.1"> from </span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.338.1">the Context value instead of props. </span><span class="koboSpan" id="kobo.338.2">The code is </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.339.1">illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.340.1">const Component1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.341.1">  const { count, setCount } = </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.342.1">    useContext(CountStateContext);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.343.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.344.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.345.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.346.1">      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.347.1">        +1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.348.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.349.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.350.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.351.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.352.1">const Component2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.353.1">  const { count, setCount } = </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.354.1">    useContext(CountStateContext);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.355.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.356.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.357.1">      {count}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.358.1">      &lt;button onClick={() =&gt; setCount((c) =&gt; c + 2)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.359.1">        +2</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.360.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.361.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.362.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.363.1">};</span></p>
			<p><span class="koboSpan" id="kobo.364.1">What is the Context value these components get? </span><span class="koboSpan" id="kobo.364.2">They get the Context value from the closest </span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.365.1">provider. </span><span class="koboSpan" id="kobo.365.2">We can use multiple providers to provide </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.366.1">isolated count states, which, again, is an important capability of using React Context.</span></p>
			<p><span class="koboSpan" id="kobo.367.1">In this section, we learned about React Context and how to create a simple global state with it. </span><span class="koboSpan" id="kobo.367.2">Coming up, we will dive into React Context behavior.</span></p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.368.1">Understanding Context</span></h1>
			<p><span class="koboSpan" id="kobo.369.1">When a Context provider has a new Context value, all Context consumers receive the new value </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.370.1">and re-render. </span><span class="koboSpan" id="kobo.370.2">This means the value in the provider is propagated to all the consumers. </span><span class="koboSpan" id="kobo.370.3">It is important for us to understand how Context propagation works and its limitations.</span></p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.371.1">How Context propagation works</span></h2>
			<p><span class="koboSpan" id="kobo.372.1">If you use a Context provider, you can update the Context value. </span><span class="koboSpan" id="kobo.372.2">When a Context provider </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.373.1">receives a new Context value, it triggers </span><em class="italic"><span class="koboSpan" id="kobo.374.1">all</span></em><span class="koboSpan" id="kobo.375.1"> the Context consumer components to re-render.</span></p>
			<p><span class="koboSpan" id="kobo.376.1">It's sometimes the case that a child component re-renders for two reasons—one because of the parent, and the other because of the Context. </span></p>
			<p><span class="koboSpan" id="kobo.377.1">To stop re-rendering without Context value changes, in this case, we can use the </span><em class="italic"><span class="koboSpan" id="kobo.378.1">lift content up</span></em><span class="koboSpan" id="kobo.379.1"> technique, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">memo</span></strong><span class="koboSpan" id="kobo.381.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">memo</span></strong><span class="koboSpan" id="kobo.383.1"> is a function to wrap a component and is used to prevent re-renders if the component props don't change.</span></p>
			<p><span class="koboSpan" id="kobo.384.1">Let's see an example with some components wrapped with </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">memo</span></strong><span class="koboSpan" id="kobo.386.1"> to understand its behavior.</span></p>
			<p><span class="koboSpan" id="kobo.387.1">As with previous examples, we again use a simple Context that holds a color string, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.388.1">const ColorContext = createContext('black');</span></p>
			<p><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">'black'</span></strong><span class="koboSpan" id="kobo.390.1"> is the default value, which will be used if there are no Context providers found in the component tree.</span></p>
			<p><span class="koboSpan" id="kobo.391.1">We then define </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">ColorComponent</span></strong><span class="koboSpan" id="kobo.393.1">, which is similar to previous examples, but it also has </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">renderCount</span></strong><span class="koboSpan" id="kobo.395.1"> to show </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.396.1">how many times this component is rendered, as illustrated in the following code snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.397.1">const ColorComponent = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.398.1">  const color = useContext(ColorContext);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.399.1">  const renderCount = useRef(1);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.400.1">  useEffect(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.401.1">    renderCount.current += 1;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.402.1">  });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.403.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.404.1">    &lt;div style={{ color }}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.405.1">      Hello {color} (renders: {renderCount.current})</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.406.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.407.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.408.1">};</span></p>
			<p><span class="koboSpan" id="kobo.409.1">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">useRef</span></strong><span class="koboSpan" id="kobo.411.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">renderCount</span></strong><span class="koboSpan" id="kobo.413.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">renderCount.current</span></strong><span class="koboSpan" id="kobo.415.1"> is a number indicating the render count. </span><span class="koboSpan" id="kobo.415.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">renderCount.current</span></strong><span class="koboSpan" id="kobo.417.1"> number is incremented by one with </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">useEffect</span></strong><span class="koboSpan" id="kobo.419.1">.</span></p>
			<p><span class="koboSpan" id="kobo.420.1">Next is </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">MemoedColorComponent</span></strong><span class="koboSpan" id="kobo.422.1">, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">ColorComponent</span></strong><span class="koboSpan" id="kobo.424.1"> wrapped by </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">memo</span></strong><span class="koboSpan" id="kobo.426.1">. </span><span class="koboSpan" id="kobo.426.2">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.427.1">const MemoedColorComponent = memo(ColorComponent);</span></p>
			<p><span class="koboSpan" id="kobo.428.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">memo</span></strong><span class="koboSpan" id="kobo.430.1"> function is to create a memoized component from a base component. </span><span class="koboSpan" id="kobo.430.2">The memoized component produces a stable result for the same props.</span></p>
			<p><span class="koboSpan" id="kobo.431.1">We define another component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">DummyComponent</span></strong><span class="koboSpan" id="kobo.433.1">, which doesn't use </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">useContext</span></strong><span class="koboSpan" id="kobo.435.1">. </span><span class="koboSpan" id="kobo.435.2">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.436.1">const DummyComponent = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.437.1">  const renderCount = useRef(1);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.438.1">  useEffect(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.439.1">    renderCount.current += 1;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.440.1">  });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.441.1">  return &lt;div&gt;Dummy (renders: {renderCount.current})&lt;/div&gt;;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.442.1">};</span></p>
			<p><span class="koboSpan" id="kobo.443.1">This component </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.444.1">is to compare the behavior against </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">ColorComponent</span></strong><span class="koboSpan" id="kobo.446.1">.</span></p>
			<p><span class="koboSpan" id="kobo.447.1">We also define </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">MemoedDummyComponent</span></strong><span class="koboSpan" id="kobo.449.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">DummyComponent</span></strong><span class="koboSpan" id="kobo.451.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">memo</span></strong><span class="koboSpan" id="kobo.453.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.454.1">const MemoedDummyComponent = memo(DummyComponent);</span></p>
			<p><span class="koboSpan" id="kobo.455.1">Next, we define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">Parent</span></strong><span class="koboSpan" id="kobo.457.1"> component; it has four kinds of components we defined previously. </span><span class="koboSpan" id="kobo.457.2">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.458.1">const Parent = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.459.1">  &lt;ul&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.460.1">    &lt;li&gt;&lt;DummyComponent /&gt;&lt;/li&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.461.1">    &lt;li&gt;&lt;MemoedDummyComponent /&gt;&lt;/li&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.462.1">    &lt;li&gt;&lt;ColorComponent /&gt;&lt;/li&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.463.1">    &lt;li&gt;&lt;MemoedColorComponent /&gt;&lt;/li&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.464.1">  &lt;/ul&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.465.1">);</span></p>
			<p><span class="koboSpan" id="kobo.466.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">App</span></strong><span class="koboSpan" id="kobo.468.1"> component has a color state with </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">useState</span></strong><span class="koboSpan" id="kobo.470.1"> and passes the value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">ColorContext.Provider</span></strong><span class="koboSpan" id="kobo.472.1">. </span><span class="koboSpan" id="kobo.472.2">It also shows a text field to change the color state. </span><span class="koboSpan" id="kobo.472.3">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.473.1">const App = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.474.1">  const [color, setColor] = useState('red');</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.475.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.476.1">    &lt;ColorContext.Provider value={color}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.477.1">      &lt;input</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.478.1">        value={color}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.479.1">        onChange={(e) =&gt; setColor(e.target.value)}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.480.1">      /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.481.1">      &lt;Parent /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.482.1">    &lt;/ColorContext.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.483.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.484.1">};</span></p>
			<p><span class="koboSpan" id="kobo.485.1">This example </span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.486.1">behaves in the following way:</span></p>
			<ol>
				<li><span class="koboSpan" id="kobo.487.1">Initially, all the components render.</span></li>
				<li><span class="koboSpan" id="kobo.488.1">If you change the value in the text input, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">App</span></strong><span class="koboSpan" id="kobo.490.1"> component renders because of </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">useState</span></strong><span class="koboSpan" id="kobo.492.1">.</span></li>
				<li><span class="koboSpan" id="kobo.493.1">Then, </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">ColorContext.Provider</span></strong><span class="koboSpan" id="kobo.495.1"> gets a new value, and at the same time, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">Parent</span></strong><span class="koboSpan" id="kobo.497.1"> component renders.</span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">DummyComponent</span></strong><span class="koboSpan" id="kobo.499.1"> renders but </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">MemoedDummyComponent</span></strong><span class="koboSpan" id="kobo.501.1"> doesn't.</span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">ColorComponent</span></strong><span class="koboSpan" id="kobo.503.1"> renders for two reasons—firstly, the parent renders, and secondly, the Context changes.</span></li>
				<li><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">MemoedColorComponent</span></strong><span class="koboSpan" id="kobo.505.1"> renders because the Context changes.</span></li>
			</ol>
			<p><span class="koboSpan" id="kobo.506.1">What's important to learn here is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">memo</span></strong><span class="koboSpan" id="kobo.508.1"> doesn't stop the internal Context consumer from re-rendering. </span><span class="koboSpan" id="kobo.508.2">This is obviously unavoidable because otherwise, components could have inconsistent Context values.</span></p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.509.1">Limitations when using Context for objects</span></h2>
			<p><span class="koboSpan" id="kobo.510.1">Using primitive values for Context values is intuitive, but using object values may require caution due </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.511.1">to their behavior. </span><span class="koboSpan" id="kobo.511.2">An object may contain several values, and Context consumers may not use all of them.</span></p>
			<p><span class="koboSpan" id="kobo.512.1">The following example is to reproduce such a case where a component uses only part of an object.</span></p>
			<p><span class="koboSpan" id="kobo.513.1">First, we define a Context whose value is an object with two counts, </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">count1</span></strong><span class="koboSpan" id="kobo.515.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">count2</span></strong><span class="koboSpan" id="kobo.517.1">, as follows: </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.518.1">const CountContext = createContext({ count1: 0, count2: 0 });</span></p>
			<p><span class="koboSpan" id="kobo.519.1">Using this count Context, we define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">Counter1</span></strong><span class="koboSpan" id="kobo.521.1"> component is to show </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">count1</span></strong><span class="koboSpan" id="kobo.523.1">. </span><span class="koboSpan" id="kobo.523.2">We have </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">renderCount</span></strong><span class="koboSpan" id="kobo.525.1"> to show the render count. </span><span class="koboSpan" id="kobo.525.2">We also define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">MemoedCounter1</span></strong><span class="koboSpan" id="kobo.527.1"> component, which is the memoized component. </span><span class="koboSpan" id="kobo.527.2">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.528.1">const Counter1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.529.1">  const { count1 } = useContext(CountContext);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.530.1">  const renderCount = useRef(1);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.531.1">  useEffect(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.532.1">    renderCount.current += 1;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.533.1">  });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.534.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.535.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.536.1">      Count1: {count1} (renders: {renderCount.current})</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.537.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.538.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.539.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.540.1">const MemoedCounter1 = memo(Counter1);</span></p>
			<p><span class="koboSpan" id="kobo.541.1">Notice that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">Counter1</span></strong><span class="koboSpan" id="kobo.543.1"> component uses only </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">count1</span></strong><span class="koboSpan" id="kobo.545.1"> from the Context value. </span></p>
			<p><span class="koboSpan" id="kobo.546.1">Likewise, we define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">Counter2</span></strong><span class="koboSpan" id="kobo.548.1"> component that shows </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">count2</span></strong><span class="koboSpan" id="kobo.550.1"> and the memoized </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">MemoCounter2</span></strong><span class="koboSpan" id="kobo.552.1"> component, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.553.1">const Counter2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.554.1">  const { count2 } = useContext(CountContext);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.555.1">  const renderCount = useRef(1);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.556.1">  useEffect(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.557.1">    renderCount.current += 1;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.558.1">  });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.559.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.560.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.561.1">      Count2: {count2} (renders: {renderCount.current})</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.562.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.563.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.564.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.565.1">const MemoCounter2 = memo(Counter2);</span></p>
			<p><span class="koboSpan" id="kobo.566.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">Parent</span></strong><span class="koboSpan" id="kobo.568.1"> component </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.569.1">has two memoized components, as illustrated in the following code snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.570.1">const Parent = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.571.1">  &lt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.572.1">    &lt;MemoCounter1 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.573.1">    &lt;MemoCounter2 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.574.1">  &lt;/&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.575.1">);</span></p>
			<p><span class="koboSpan" id="kobo.576.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">App</span></strong><span class="koboSpan" id="kobo.578.1"> component has two counts with two </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">useState</span></strong><span class="koboSpan" id="kobo.580.1"> hooks and provides the two counts with one Context. </span><span class="koboSpan" id="kobo.580.2">It has two buttons to increment two counts respectively, as illustrated in the following code snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.581.1">const App = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.582.1">  const [count1, setCount1] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.583.1">  const [count2, setCount2] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.584.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.585.1">    &lt;CountContext.Provider value={{ count1, count2 }}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.586.1">      &lt;button onClick={() =&gt; setCount1((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.587.1">        {count1}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.588.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.589.1">      &lt;button onClick={() =&gt; setCount2((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.590.1">        {count2}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.591.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.592.1">      &lt;Parent /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.593.1">    &lt;/CountContext.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.594.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.595.1">};</span></p>
			<p><span class="koboSpan" id="kobo.596.1">Notice again </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.597.1">that the place of two buttons is not very important.</span></p>
			<p><span class="koboSpan" id="kobo.598.1">The two counts, </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">count1</span></strong><span class="koboSpan" id="kobo.600.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">count2</span></strong><span class="koboSpan" id="kobo.602.1">, are totally separate—</span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">Counter1</span></strong><span class="koboSpan" id="kobo.604.1"> uses only </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">count1</span></strong><span class="koboSpan" id="kobo.606.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">Counter2</span></strong><span class="koboSpan" id="kobo.608.1"> uses only </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">count2</span></strong><span class="koboSpan" id="kobo.610.1">. </span><span class="koboSpan" id="kobo.610.2">Hence, ideally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">Counter1</span></strong><span class="koboSpan" id="kobo.612.1"> should re-render only when </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">count1</span></strong><span class="koboSpan" id="kobo.614.1"> is changed. </span><span class="koboSpan" id="kobo.614.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">Counter1</span></strong><span class="koboSpan" id="kobo.616.1"> re-renders without changing </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">count1</span></strong><span class="koboSpan" id="kobo.618.1">, it produces the same result, which means that was just an extra re-render. </span><span class="koboSpan" id="kobo.618.2">In this example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">Counter1</span></strong><span class="koboSpan" id="kobo.620.1"> re-renders even when only </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">count2</span></strong><span class="koboSpan" id="kobo.622.1"> is changed. </span></p>
			<p><span class="koboSpan" id="kobo.623.1">This is the extra re-render limitation in the behavior that we should be aware of when we utilize React Context.</span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.624.1">Extra Re-Renders</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.625.1">Extra re-renders </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.626.1">are a pure overhead that should be technically avoided. </span><span class="koboSpan" id="kobo.626.2">However, this would be fine unless performance is a big concern because users wouldn't notice a few extra re-renders. </span><span class="koboSpan" id="kobo.626.3">Overengineering to avoid a few extra re-renders might not be worth resolving in practice.</span></p>
			<p><span class="koboSpan" id="kobo.627.1">In this </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.628.1">section, we learned about the behavior of React Context and why it's limited to being used with objects. </span><span class="koboSpan" id="kobo.628.2">Coming up, we learn some typical patterns for implementing a global state with Context.</span></p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.629.1">Creating a Context for a global state</span></h1>
			<p><span class="koboSpan" id="kobo.630.1">Based on </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.631.1">the React Context behavior, we will discuss two solutions regarding using Context with a global state, as follows:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.632.1">Creating small state pieces</span></li>
				<li><span class="koboSpan" id="kobo.633.1">Creating one state with </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">useReducer</span></strong><span class="koboSpan" id="kobo.635.1"> and propagating with multiple Contexts</span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.636.1">Let's take a look at each solution.</span></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.637.1">Creating small state pieces</span></h2>
			<p><span class="koboSpan" id="kobo.638.1">The first solution is to split a global state into pieces. </span><span class="koboSpan" id="kobo.638.2">So, instead of using a big combined object, create </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.639.1">a global state and a Context for each piece.</span></p>
			<p><span class="koboSpan" id="kobo.640.1">The following example creates two </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">count</span></strong><span class="koboSpan" id="kobo.642.1"> states, with a Context and a provider component for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">count</span></strong><span class="koboSpan" id="kobo.644.1"> state.</span></p>
			<p><span class="koboSpan" id="kobo.645.1">Firstly, we define two Contexts, </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">Count1Context</span></strong><span class="koboSpan" id="kobo.647.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">Count2Context</span></strong><span class="koboSpan" id="kobo.649.1">, one for each piece, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.650.1">type CountContextType = [</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.651.1">  number,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.652.1">  Dispatch&lt;SetStateAction&lt;number&gt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.653.1">];</span></p>
			<p class="source-code"> </p>
			<p class="source-code"><span class="koboSpan" id="kobo.654.1">const Count1Context = createContext&lt;CountContextType&gt;([</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.655.1">  0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.656.1">  () =&gt; {}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.657.1">]);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.658.1">const Count2Context = createContext&lt;CountContextType&gt;([</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.659.1">  0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.660.1">  () =&gt; {}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.661.1">]);</span></p>
			<p><span class="koboSpan" id="kobo.662.1">The Context </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.663.1">value is a tuple of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">count</span></strong><span class="koboSpan" id="kobo.665.1"> value and an updating function. </span><span class="koboSpan" id="kobo.665.2">We specified a static value and a dummy function as a default value.</span></p>
			<p><span class="koboSpan" id="kobo.666.1">We then define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">Counter1</span></strong><span class="koboSpan" id="kobo.668.1"> component that only uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">Count1Context</span></strong><span class="koboSpan" id="kobo.670.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.671.1">const Counter1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.672.1">  const [count1, setCount1] = useContext(Count1Context);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.673.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.674.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.675.1">      Count1: {count1}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.676.1">      &lt;button onClick={() =&gt; setCount1((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.677.1">        +1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.678.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.679.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.680.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.681.1">};</span></p>
			<p><span class="koboSpan" id="kobo.682.1">Notice the implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">Counter1</span></strong><span class="koboSpan" id="kobo.684.1"> only depends on </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">Count1Context</span></strong><span class="koboSpan" id="kobo.686.1">, and it doesn't know about any other Contexts.</span></p>
			<p><span class="koboSpan" id="kobo.687.1">Likewise, we define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">Counter2</span></strong><span class="koboSpan" id="kobo.689.1"> component that uses only </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">Count2Context</span></strong><span class="koboSpan" id="kobo.691.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.692.1">const Counter2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.693.1">  const [count2, setCount2] = useContext(Count2Context);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.694.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.695.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.696.1">      Count2: {count2}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.697.1">      &lt;button onClick={() =&gt; setCount2((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.698.1">        +1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.699.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.700.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.701.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.702.1">};</span></p>
			<p><span class="koboSpan" id="kobo.703.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">Parent</span></strong><span class="koboSpan" id="kobo.705.1"> component </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.706.1">has </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">Counter1</span></strong><span class="koboSpan" id="kobo.708.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">Counter2</span></strong><span class="koboSpan" id="kobo.710.1"> components, as illustrated in the following code snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.711.1">const Parent = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.712.1">  &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.713.1">    &lt;Counter1 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.714.1">    &lt;Counter1 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.715.1">    &lt;Counter2 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.716.1">    &lt;Counter2 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.717.1">  &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.718.1">);</span></p>
			<p><span class="koboSpan" id="kobo.719.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">Parent</span></strong><span class="koboSpan" id="kobo.721.1"> component has two counters each, just for demonstration purposes.</span></p>
			<p><span class="koboSpan" id="kobo.722.1">We define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">Count1Provider</span></strong><span class="koboSpan" id="kobo.724.1"> component for </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">Count1Context</span></strong><span class="koboSpan" id="kobo.726.1">. </span><span class="koboSpan" id="kobo.726.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">Count1Provider</span></strong><span class="koboSpan" id="kobo.728.1"> component has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">count</span></strong><span class="koboSpan" id="kobo.730.1"> state with </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">useState</span></strong><span class="koboSpan" id="kobo.732.1"> and passes the count value and </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">update</span></strong><span class="koboSpan" id="kobo.734.1"> function </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.735.1">to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">Count1Context.Provider</span></strong><span class="koboSpan" id="kobo.737.1"> component, as illustrated in the following code snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.738.1">const Count1Provider = ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.739.1">  children</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.740.1">}: {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.741.1">  children: ReactNode</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.742.1">}) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.743.1">  const [count1, setCount1] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.744.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.745.1">    &lt;Count1Context.Provider value={[count1, setCount1]}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.746.1">      {children}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.747.1">    &lt;/Count1Context.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.748.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.749.1">};</span></p>
			<p><span class="koboSpan" id="kobo.750.1">Likewise, we define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">Count2Provider</span></strong><span class="koboSpan" id="kobo.752.1"> component for </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">Count2Context</span></strong><span class="koboSpan" id="kobo.754.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.755.1">const Count2Provider = ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.756.1">  children</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.757.1">}: {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.758.1">  children: ReactNode</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.759.1">}) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.760.1">  const [count2, setCount2] = useState(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.761.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.762.1">    &lt;Count2Context.Provider value={[count2, setCount2]}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.763.1">      {children}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.764.1">    &lt;/Count2Context.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.765.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.766.1">};</span></p>
			<p><span class="koboSpan" id="kobo.767.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">Count1Provider</span></strong><span class="koboSpan" id="kobo.769.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">Count2Provider</span></strong><span class="koboSpan" id="kobo.771.1"> components are similar; the only difference is the Context to provide a value.</span></p>
			<p><span class="koboSpan" id="kobo.772.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">App</span></strong><span class="koboSpan" id="kobo.774.1"> component has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">Parent</span></strong><span class="koboSpan" id="kobo.776.1"> component with two provider components, as illustrated </span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.777.1">in the following code snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.778.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.779.1">  &lt;Count1Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.780.1">    &lt;Count2Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.781.1">      &lt;Parent /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.782.1">    &lt;/Count2Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.783.1">  &lt;/Count1Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.784.1">);</span></p>
			<p><span class="koboSpan" id="kobo.785.1">Notice the </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">App</span></strong><span class="koboSpan" id="kobo.787.1"> component has two provider components nested. </span><span class="koboSpan" id="kobo.787.2">Having more provider components lead to deeper nesting. </span><span class="koboSpan" id="kobo.787.3">We will discuss mitigating nesting in the </span><em class="italic"><span class="koboSpan" id="kobo.788.1">Best practices for using Context</span></em><span class="koboSpan" id="kobo.789.1"> section.</span></p>
			<p><span class="koboSpan" id="kobo.790.1">This example doesn't suffer from the extra re-render limitation we described in the previous section. </span><span class="koboSpan" id="kobo.790.2">This is because Contexts hold only primitive values. </span><span class="koboSpan" id="kobo.790.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">Counter1</span></strong><span class="koboSpan" id="kobo.792.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">Counter2</span></strong><span class="koboSpan" id="kobo.794.1"> components only re-render when </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">count1</span></strong><span class="koboSpan" id="kobo.796.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">count2</span></strong><span class="koboSpan" id="kobo.798.1"> are changed respectively. </span><span class="koboSpan" id="kobo.798.2">It is necessary to create a provider for each state; otherwise, </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">useState</span></strong><span class="koboSpan" id="kobo.800.1"> would return a new tuple object and a Context would trigger re-renders.</span></p>
			<p><span class="koboSpan" id="kobo.801.1">If you are sure that an object is used at once and the usage doesn't hit the limitation of the Context behavior, putting an object as a Context value is totally acceptable. </span><span class="koboSpan" id="kobo.801.2">Here's an example of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">user</span></strong><span class="koboSpan" id="kobo.803.1"> object that would be used at once:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.804.1">const [user, setUser] = useState({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.805.1">  firstName: 'react',</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.806.1">  lastName: 'hooks'</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.807.1">});</span></p>
			<p><span class="koboSpan" id="kobo.808.1">In this case, it </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.809.1">doesn't make sense to split it into Contexts. </span><span class="koboSpan" id="kobo.809.2">Using a single Context for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">user</span></strong><span class="koboSpan" id="kobo.811.1"> object would be better.</span></p>
			<p><span class="koboSpan" id="kobo.812.1">Next, let's look at another solution.</span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.813.1">Creating one state with useReducer and propagating with multiple Contexts</span></h2>
			<p><span class="koboSpan" id="kobo.814.1">The </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.815.1">second solution is to create a single state and use multiple Contexts to distribute state pieces. </span><span class="koboSpan" id="kobo.815.2">In this </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.816.1">case, distributing a function to update the state should be done with a separate Context.</span></p>
			<p><span class="koboSpan" id="kobo.817.1">The following example is based on </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">useReducer</span></strong><span class="koboSpan" id="kobo.819.1">. </span><span class="koboSpan" id="kobo.819.2">It has three Contexts; two are for state pieces, and the last one is for a dispatch function.</span></p>
			<p><span class="koboSpan" id="kobo.820.1">First, we create two value Contexts for two counts, and one Context for the dispatch function that will be used to update the two counts, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.821.1">type Action = { type: "INC1" } | { type: "INC2" };</span></p>
			<p class="source-code"> </p>
			<p class="source-code"><span class="koboSpan" id="kobo.822.1">const Count1Context = createContext&lt;number&gt;(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.823.1">const Count2Context = createContext&lt;number&gt;(0);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.824.1">const DispatchContext = createContext&lt;Dispatch&lt;Action&gt;&gt;(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.825.1">  () =&gt; {}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.826.1">);</span></p>
			<p><span class="koboSpan" id="kobo.827.1">In this case, if we have more counts, we create more count Contexts, but the dispatch Context will remain just one.</span></p>
			<p><span class="koboSpan" id="kobo.828.1">We define a reducer for the dispatch function later in this example.</span></p>
			<p><span class="koboSpan" id="kobo.829.1">Next, we define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">Counter1</span></strong><span class="koboSpan" id="kobo.831.1"> component that uses two Contexts—one for the value and another for the dispatch function, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.832.1">const Counter1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.833.1">  const count1 = useContext(Count1Context);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.834.1">  const dispatch = useContext(DispatchContext);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.835.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.836.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.837.1">      Count1: {count1}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.838.1">      &lt;button onClick={() =&gt; dispatch({ type: "INC1" })}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.839.1">        +1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.840.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.841.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.842.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.843.1">};</span></p>
			<p><span class="koboSpan" id="kobo.844.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">Counter1</span></strong><span class="koboSpan" id="kobo.846.1"> component reads </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">count1</span></strong><span class="koboSpan" id="kobo.848.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">Count1Context</span></strong><span class="koboSpan" id="kobo.850.1">.</span></p>
			<p><span class="koboSpan" id="kobo.851.1">We </span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.852.1">define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">Counter2</span></strong><span class="koboSpan" id="kobo.854.1"> component, which is just like </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">Counter1</span></strong><span class="koboSpan" id="kobo.856.1"> except that it reads </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">count2</span></strong><span class="koboSpan" id="kobo.858.1"> from a different </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.859.1">Context. </span><span class="koboSpan" id="kobo.859.2">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.860.1">const Counter2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.861.1">  const count2 = useContext(Count2Context);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.862.1">  const dispatch = useContext(DispatchContext);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.863.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.864.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.865.1">      Count2: {count2}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.866.1">      &lt;button onClick={() =&gt; dispatch({ type: "INC2" })}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.867.1">        +1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.868.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.869.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.870.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.871.1">};</span></p>
			<p><span class="koboSpan" id="kobo.872.1">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">Counter1</span></strong><span class="koboSpan" id="kobo.874.1"> and  </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">Counter2</span></strong><span class="koboSpan" id="kobo.876.1"> components use the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">DispatchContext</span></strong><span class="koboSpan" id="kobo.878.1"> Context.</span></p>
			<p><span class="koboSpan" id="kobo.879.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">Parent</span></strong><span class="koboSpan" id="kobo.881.1"> component </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.882.1">is the same as the previous example, as we can see here:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.883.1">const Parent = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.884.1">  &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.885.1">    &lt;Counter1 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.886.1">    &lt;Counter1 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.887.1">    &lt;Counter2 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.888.1">    &lt;Counter2 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.889.1">  &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.890.1">);</span></p>
			<p><span class="koboSpan" id="kobo.891.1">Now, we </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.892.1">define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">Provider</span></strong><span class="koboSpan" id="kobo.894.1"> component that is unique in this example. </span><span class="koboSpan" id="kobo.894.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">Provider</span></strong><span class="koboSpan" id="kobo.896.1"> component uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">useReducer</span></strong><span class="koboSpan" id="kobo.898.1">. </span><span class="koboSpan" id="kobo.898.2">The reducer function handles two action types—</span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">INC1</span></strong><span class="koboSpan" id="kobo.900.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">INC2</span></strong><span class="koboSpan" id="kobo.902.1">. </span><span class="koboSpan" id="kobo.902.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">Provider</span></strong><span class="koboSpan" id="kobo.904.1"> component includes providers from three Contexts that we defined previously. </span><span class="koboSpan" id="kobo.904.2">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.905.1">const Provider = ({ children }: { children: ReactNode }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.906.1">  const [state, dispatch] = useReducer(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.907.1">    (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.908.1">      prev: { count1: number; count2: number },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.909.1">      action: Action</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.910.1">    ) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.911.1">      if (action.type === "INC1") {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.912.1">        return { ...prev, count1: prev.count1 + 1 };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.913.1">      }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.914.1">      if (action.type === "INC2") {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.915.1">        return { ...prev, count2: prev.count2 + 1 };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.916.1">      }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.917.1">      throw new Error("no matching action");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.918.1">    },</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.919.1">    {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.920.1">      count1: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.921.1">      count2: 0,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.922.1">    }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.923.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.924.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.925.1">    &lt;DispatchContext.Provider value={dispatch}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.926.1">      &lt;Count1Context.Provider value={state.count1}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.927.1">        &lt;Count2Context.Provider value={state.count2}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.928.1">          {children}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.929.1">        &lt;/Count2Context.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.930.1">      &lt;/Count1Context.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.931.1">    &lt;/DispatchContext.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.932.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.933.1">};</span></p>
			<p><span class="koboSpan" id="kobo.934.1">The code </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.935.1">is a bit long </span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.936.1">because of the reducer, which can be more complex. </span><span class="koboSpan" id="kobo.936.2">The point is nested providers, providing each state piece and one dispatch function.</span></p>
			<p><span class="koboSpan" id="kobo.937.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">App</span></strong><span class="koboSpan" id="kobo.939.1"> component just has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">Provider</span></strong><span class="koboSpan" id="kobo.941.1"> component and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">Parent</span></strong><span class="koboSpan" id="kobo.943.1"> component in it, as illustrated in the following code snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.944.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.945.1">  &lt;Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.946.1">    &lt;Parent /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.947.1">  &lt;/Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.948.1">);</span></p>
			<p><span class="koboSpan" id="kobo.949.1">This example also doesn't suffer from the extra re-render limitation; changing </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">count1</span></strong><span class="koboSpan" id="kobo.951.1"> in the state only triggers </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">Counter1</span></strong><span class="koboSpan" id="kobo.953.1"> to re-render, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">Counter2</span></strong><span class="koboSpan" id="kobo.955.1"> is not affected.</span></p>
			<p><span class="koboSpan" id="kobo.956.1">The </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.957.1">benefit of using </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.958.1">a single state over using multiple states in the previous example is that the single state can update multiple pieces with one action. </span><span class="koboSpan" id="kobo.958.2">For example, you can add something like this in the reducer:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.959.1">      if (action.type === "INC_BOTH") {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.960.1">        return {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.961.1">          ...prev,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.962.1">          count1: prev.count1 + 1,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.963.1">          count2: prev.count2 + 1,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.964.1">        };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.965.1">      }</span></p>
			<p><span class="koboSpan" id="kobo.966.1">As we discussed in the first solution, it is acceptable to create a Context for an object (such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">user</span></strong><span class="koboSpan" id="kobo.968.1"> object) in this solution too.</span></p>
			<p><span class="koboSpan" id="kobo.969.1">In this section, we learned two solutions to use Context for a global state. </span><span class="koboSpan" id="kobo.969.2">They are typical solutions, but there would be many variants. </span><span class="koboSpan" id="kobo.969.3">The key point is to use multiple Contexts to avoid extra re-renders. </span><span class="koboSpan" id="kobo.969.4">In the next section, we learn some best practices to deal with a global state based on multiple Contexts.</span></p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.970.1">Best practices for using Context</span></h1>
			<p><span class="koboSpan" id="kobo.971.1">In this </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.972.1">section, we will learn three patterns to deal with Contexts for a global state, as follows:</span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.973.1">Creating custom hooks and provider components</span></li>
				<li><span class="koboSpan" id="kobo.974.1">A factory pattern with a custom hook</span></li>
				<li><span class="koboSpan" id="kobo.975.1">Avoiding provider nesting with </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">reduceRight</span></strong></li>
			</ul>
			<p><span class="koboSpan" id="kobo.977.1">Let's take a look at each one.</span></p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.978.1">Creating custom hooks and provider components</span></h2>
			<p><span class="koboSpan" id="kobo.979.1">In the previous examples in this chapter, we directly used </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">useContext</span></strong><span class="koboSpan" id="kobo.981.1"> to get Context values. </span><span class="koboSpan" id="kobo.981.2">Now, we will explicitly create custom hooks to access Context values as well as provider components. </span><span class="koboSpan" id="kobo.981.3">This allows us to hide Contexts and restrict their usage.</span></p>
			<p><span class="koboSpan" id="kobo.982.1">The </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.983.1">following example creates custom hooks and provider components. </span><span class="koboSpan" id="kobo.983.2">We make a default Context value </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">null</span></strong><span class="koboSpan" id="kobo.985.1"> and check if the value is </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">null</span></strong><span class="koboSpan" id="kobo.987.1"> in the custom hooks. </span><span class="koboSpan" id="kobo.987.2">This checks if the custom hooks are used under the providers.</span></p>
			<p><span class="koboSpan" id="kobo.988.1">The first thing we do, as always, is to create a Context; this time, the default value of the Context is </span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">null</span></strong><span class="koboSpan" id="kobo.990.1">, which indicates that the default value can't be used and the provider is always is required. </span><span class="koboSpan" id="kobo.990.2">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.991.1">type CountContextType = [</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.992.1">  number,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.993.1">  Dispatch&lt;SetStateAction&lt;number&gt;&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.994.1">];</span></p>
			<p class="source-code"> </p>
			<p class="source-code"><span class="koboSpan" id="kobo.995.1">const Count1Context = createContext&lt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.996.1">  CountContextType | null</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.997.1">&gt;(null);</span></p>
			<p><span class="koboSpan" id="kobo.998.1">We then define </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">Count1Provider</span></strong><span class="koboSpan" id="kobo.1000.1">, which creates a state with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">useState</span></strong><span class="koboSpan" id="kobo.1002.1"> and passes it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">Count1Context.Provider</span></strong><span class="koboSpan" id="kobo.1004.1">, as illustrated in the following code snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1005.1">export const Count1Provider = ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1006.1">  children</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1007.1">}: {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1008.1">  children: ReactNode</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1009.1">}) =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1010.1">  &lt;Count1Context.Provider value={useState(0)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1011.1">    {children}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1012.1">  &lt;/Count1Context.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1013.1">);</span></p>
			<p><span class="koboSpan" id="kobo.1014.1">Notice </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.1015.1">that we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">useState(0)</span></strong><span class="koboSpan" id="kobo.1017.1"> in the </span><strong class="bold"><span class="koboSpan" id="kobo.1018.1">JavaScript syntax extension</span></strong><span class="koboSpan" id="kobo.1019.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1020.1">JSX</span></strong><span class="koboSpan" id="kobo.1021.1">) form. </span><span class="koboSpan" id="kobo.1021.2">This is valid, and </span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.1022.1">it's short for having </span><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">const [count, setCount] = useState(0);</span></strong><span class="koboSpan" id="kobo.1024.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">return &lt;Count1Context.Provider value={[count, setCount]}&gt;</span></strong><span class="koboSpan" id="kobo.1026.1"> in one line.</span></p>
			<p><span class="koboSpan" id="kobo.1027.1">Next, we define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">useCount1</span></strong><span class="koboSpan" id="kobo.1029.1"> hook to return a value from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">Count1Context</span></strong><span class="koboSpan" id="kobo.1031.1">. </span><span class="koboSpan" id="kobo.1031.2">Here, we check that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">null</span></strong><span class="koboSpan" id="kobo.1033.1"> from the Context value throws a meaningful error. </span><span class="koboSpan" id="kobo.1033.2">Developers often make mistakes, and having explicit errors would make it easier for us to detect bugs. </span><span class="koboSpan" id="kobo.1033.3">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1034.1">export const useCount1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1035.1">  const value = useContext(Count1Context);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1036.1">  if (value === null) throw new Error("Provider missing");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1037.1">  return value;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1038.1">};</span></p>
			<p><span class="koboSpan" id="kobo.1039.1">Following on, we create </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">Count2Context</span></strong><span class="koboSpan" id="kobo.1041.1">, define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">Count2Provider</span></strong><span class="koboSpan" id="kobo.1043.1"> component and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">useCount2</span></strong><span class="koboSpan" id="kobo.1045.1"> hook (they are the same as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">Count1Context</span></strong><span class="koboSpan" id="kobo.1047.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">Count1Provider</span></strong><span class="koboSpan" id="kobo.1049.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">useCount1</span></strong><span class="koboSpan" id="kobo.1051.1">, except for the names). </span><span class="koboSpan" id="kobo.1051.2">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1052.1">const Count2Context = createContext&lt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1053.1">  CountContextType | null</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1054.1">&gt;(null);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1055.1">export const Count2Provider = ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1056.1">  children</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1057.1">}: {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1058.1">  children: ReactNode</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1059.1">}) =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1060.1">  &lt;Count2Context.Provider value={useState(0)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1061.1">    {children}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1062.1">  &lt;/Count2Context.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1063.1">);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1064.1">export const useCount2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1065.1">  const value = useContext(Count2Context);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1066.1">  if (value === null) throw new Error("Provider missing");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1067.1">  return value;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1068.1">};</span></p>
			<p><span class="koboSpan" id="kobo.1069.1">Next, we </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.1070.1">define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">Counter1</span></strong><span class="koboSpan" id="kobo.1072.1"> component to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">count1</span></strong><span class="koboSpan" id="kobo.1074.1"> state and show the count and a button. </span><span class="koboSpan" id="kobo.1074.2">Notice in the following code snippet that this component doesn't know about a Context, which is hidden in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1075.1">useCount1</span></strong><span class="koboSpan" id="kobo.1076.1"> hook:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1077.1">const Counter1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1078.1">  const [count1, setCount1] = useCount1();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1079.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1080.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1081.1">      Count1: {count1}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1082.1">      &lt;button onClick={() =&gt; setCount1((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1083.1">        +1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1084.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1085.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1086.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1087.1">};</span></p>
			<p><span class="koboSpan" id="kobo.1088.1">Likewise, we </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.1089.1">define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1090.1">Counter2</span></strong><span class="koboSpan" id="kobo.1091.1"> component, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1092.1">const Counter2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1093.1">  const [count2, setCount2] = useCount2();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1094.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1095.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1096.1">      Count2: {count2}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1097.1">      &lt;button onClick={() =&gt; setCount2((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1098.1">        +1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1099.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1100.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1101.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1102.1">};</span></p>
			<p><span class="koboSpan" id="kobo.1103.1">Notice the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">Counter2</span></strong><span class="koboSpan" id="kobo.1105.1"> component is almost similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">Counter1</span></strong><span class="koboSpan" id="kobo.1107.1"> component. </span><span class="koboSpan" id="kobo.1107.2">The major difference is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1108.1">Counter2</span></strong><span class="koboSpan" id="kobo.1109.1"> component uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">useCount2</span></strong><span class="koboSpan" id="kobo.1111.1"> hook instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">useCount1</span></strong><span class="koboSpan" id="kobo.1113.1"> hook.</span></p>
			<p><span class="koboSpan" id="kobo.1114.1">We define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">Parent</span></strong><span class="koboSpan" id="kobo.1116.1"> component that has </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">Counter1</span></strong><span class="koboSpan" id="kobo.1118.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1119.1">Counter2</span></strong><span class="koboSpan" id="kobo.1120.1"> defined previously, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1121.1">const Parent = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1122.1">  &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1123.1">    &lt;Counter1 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1124.1">    &lt;Counter1 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1125.1">    &lt;Counter2 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1126.1">    &lt;Counter2 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1127.1">  &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1128.1">);</span></p>
			<p><span class="koboSpan" id="kobo.1129.1">Finally, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">App</span></strong><span class="koboSpan" id="kobo.1131.1"> component is defined to complete the example. </span><span class="koboSpan" id="kobo.1131.2">It wraps the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1132.1">Parent</span></strong><span class="koboSpan" id="kobo.1133.1"> component </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.1134.1">with two provider components, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1135.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1136.1">  &lt;Count1Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1137.1">    &lt;Count2Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1138.1">      &lt;Parent /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1139.1">    &lt;/Count2Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1140.1">  &lt;/Count1Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1141.1">);</span></p>
			<p><span class="koboSpan" id="kobo.1142.1">Although it's not very explicit with this snippet, we typically have a separate file such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1143.1">contexts/count1.jsx</span></strong><span class="koboSpan" id="kobo.1144.1"> for each Context and export only custom hooks such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">useCount1</span></strong><span class="koboSpan" id="kobo.1146.1"> and provider components such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1147.1">Count1Provider</span></strong><span class="koboSpan" id="kobo.1148.1">. </span><span class="koboSpan" id="kobo.1148.2">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1149.1">Count1Context</span></strong><span class="koboSpan" id="kobo.1150.1"> is not exported.</span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.1151.1">Factory pattern with a custom hook</span></h2>
			<p><span class="koboSpan" id="kobo.1152.1">Creating a custom hook and a provider component is a somewhat repetitive task; however, we </span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.1153.1">can create a function that does the task.</span></p>
			<p><span class="koboSpan" id="kobo.1154.1">The following example shows </span><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">createStateContext</span></strong><span class="koboSpan" id="kobo.1156.1"> as a concrete implementation. </span></p>
			<p><span class="koboSpan" id="kobo.1157.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">createStateContext</span></strong><span class="koboSpan" id="kobo.1159.1"> function takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">useValue</span></strong><span class="koboSpan" id="kobo.1161.1"> custom hook that takes an initial value and returns a state. </span><span class="koboSpan" id="kobo.1161.2">If you use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">useState</span></strong><span class="koboSpan" id="kobo.1163.1">, it returns a tuple of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1164.1">state</span></strong><span class="koboSpan" id="kobo.1165.1"> value and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1166.1">setState</span></strong><span class="koboSpan" id="kobo.1167.1"> function. </span><span class="koboSpan" id="kobo.1167.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1168.1">createStateContext</span></strong><span class="koboSpan" id="kobo.1169.1"> function returns a tuple of a provider component and a custom hook to get the state. </span><span class="koboSpan" id="kobo.1169.2">This is the pattern we learned in the previous sections.</span></p>
			<p><span class="koboSpan" id="kobo.1170.1">In addition, this provides a new feature; the provider component accepts an optional </span><strong class="source-inline"><span class="koboSpan" id="kobo.1171.1">initialValue</span></strong><span class="koboSpan" id="kobo.1172.1"> prop that is passed into </span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">useValue</span></strong><span class="koboSpan" id="kobo.1174.1">. </span><span class="koboSpan" id="kobo.1174.2">This allows you to set the initial value of the </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.1175.1">state at runtime instead of defining an initial value at creation. </span><span class="koboSpan" id="kobo.1175.2">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1176.1">const createStateContext = (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1177.1">  useValue: (init) =&gt; State,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1178.1">) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1179.1">  const StateContext = createContext(null);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1180.1">  const StateProvider = ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1181.1">    initialValue,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1182.1">    children,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1183.1">  }) =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1184.1">    &lt;StateContext.Provider value={useValue(initialValue)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1185.1">      {children}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1186.1">    &lt;/StateContext.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1187.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1188.1">  const useContextState = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1189.1">    const value = useContext(StateContext);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1190.1">    if (value === null) throw new Error("Provider</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1191.1">      missing");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1192.1">    return value;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1193.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1194.1">  return [StateProvider, useContextState] as const;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1195.1">};</span></p>
			<p><span class="koboSpan" id="kobo.1196.1">Now, let's see how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">createStateContext</span></strong><span class="koboSpan" id="kobo.1198.1">. </span><span class="koboSpan" id="kobo.1198.2">We define a custom hook, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1199.1">useNumberState</span></strong><span class="koboSpan" id="kobo.1200.1">; it takes an optional </span><strong class="source-inline"><span class="koboSpan" id="kobo.1201.1">init</span></strong><span class="koboSpan" id="kobo.1202.1"> parameter. </span><span class="koboSpan" id="kobo.1202.2">We then invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.1203.1">useState</span></strong><span class="koboSpan" id="kobo.1204.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1205.1">init</span></strong><span class="koboSpan" id="kobo.1206.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1207.1">const useNumberState = (init) =&gt; useState(init || 0);</span></p>
			<p><span class="koboSpan" id="kobo.1208.1">By passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1209.1">useNumberState</span></strong><span class="koboSpan" id="kobo.1210.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1211.1">createStateContext</span></strong><span class="koboSpan" id="kobo.1212.1">, we can create as many state Contexts </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.1213.1">as we want; we created two sets of them. </span><span class="koboSpan" id="kobo.1213.2">The types of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">useCount1</span></strong><span class="koboSpan" id="kobo.1215.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1216.1">useCount2</span></strong><span class="koboSpan" id="kobo.1217.1"> are inferred from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">useNumberState</span></strong><span class="koboSpan" id="kobo.1219.1">. </span><span class="koboSpan" id="kobo.1219.2">The code is illustrated in the following snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1220.1">const [Count1Provider, useCount1] =</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1221.1">  createStateContext(useNumberState);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1222.1">const [Count2Provider, useCount2] =</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1223.1">  createStateContext(useNumberState);</span></p>
			<p><span class="koboSpan" id="kobo.1224.1">Notice we avoid the repetitive definition thanks to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1225.1">createStateContext</span></strong><span class="koboSpan" id="kobo.1226.1">.</span></p>
			<p><span class="koboSpan" id="kobo.1227.1">We then define </span><strong class="source-inline"><span class="koboSpan" id="kobo.1228.1">Counter1</span></strong><span class="koboSpan" id="kobo.1229.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1230.1">Counter2</span></strong><span class="koboSpan" id="kobo.1231.1"> components. </span><span class="koboSpan" id="kobo.1231.2">The way to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1232.1">useCount1</span></strong><span class="koboSpan" id="kobo.1233.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">useCount2</span></strong><span class="koboSpan" id="kobo.1235.1"> is identical to the previous example, as we can see in the following code snippet:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1236.1">const Counter1 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1237.1">  const [count1, setCount1] = useCount1();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1238.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1239.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1240.1">      Count1: {count1}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1241.1">      &lt;button onClick={() =&gt; setCount1((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1242.1">        +1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1243.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1244.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1245.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1246.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1247.1">const Counter2 = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1248.1">  const [count2, setCount2] = useCount2();</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1249.1">  return (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1250.1">    &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1251.1">      Count2: {count2}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1252.1">      &lt;button onClick={() =&gt; setCount2((c) =&gt; c + 1)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1253.1">        +1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1254.1">      &lt;/button&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1255.1">    &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1256.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1257.1">};</span></p>
			<p><span class="koboSpan" id="kobo.1258.1">Finally, we </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.1259.1">create </span><strong class="source-inline"><span class="koboSpan" id="kobo.1260.1">Parent</span></strong><span class="koboSpan" id="kobo.1261.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">App</span></strong><span class="koboSpan" id="kobo.1263.1"> components. </span><span class="koboSpan" id="kobo.1263.2">The way to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">Count1Provider </span></strong><span class="koboSpan" id="kobo.1265.1">and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">Count2Provider</span></strong><span class="koboSpan" id="kobo.1267.1"> is also the same, as we can see here:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1268.1">const Parent = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1269.1">  &lt;div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1270.1">    &lt;Counter1 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1271.1">    &lt;Counter1 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1272.1">    &lt;Counter2 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1273.1">    &lt;Counter2 /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1274.1">  &lt;/div&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1275.1">);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1276.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1277.1">  &lt;Count1Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1278.1">    &lt;Count2Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1279.1">      &lt;Parent /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1280.1">    &lt;/Count2Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1281.1">  &lt;/Count1Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1282.1">);</span></p>
			<p><span class="koboSpan" id="kobo.1283.1">Notice how we reduce our code from the previous example. </span><span class="koboSpan" id="kobo.1283.2">The whole point of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1284.1">createStateContext</span></strong><span class="koboSpan" id="kobo.1285.1"> is to avoid repetitive code and provide the same functionality.</span></p>
			<p><span class="koboSpan" id="kobo.1286.1">Instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1287.1">useNumberState</span></strong><span class="koboSpan" id="kobo.1288.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1289.1">useState</span></strong><span class="koboSpan" id="kobo.1290.1">, we could make the custom hook with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">useReducer</span></strong><span class="koboSpan" id="kobo.1292.1">, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1293.1">const useMyState = () =&gt; useReducer({}, (prev, action) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1294.1">  if (action.type === 'SET_FOO') {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1295.1">    return { ...prev, foo: action.foo };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1296.1">  }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1297.1">  // ...</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1298.1">};</span></p>
			<p><span class="koboSpan" id="kobo.1299.1">We </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.1300.1">could also create a more complex hook. </span><span class="koboSpan" id="kobo.1300.2">The following example has </span><strong class="source-inline"><span class="koboSpan" id="kobo.1301.1">inc1</span></strong><span class="koboSpan" id="kobo.1302.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1303.1">inc2</span></strong><span class="koboSpan" id="kobo.1304.1"> custom action functions. </span><span class="koboSpan" id="kobo.1304.2">It uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1305.1">useEffect</span></strong><span class="koboSpan" id="kobo.1306.1"> to show an updated log in the console:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1307.1">const useMyState = (initialState = { count1: 0, count2: 0 }) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1308.1">  const [state, setState] = useState(initialState);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1309.1">  useEffect(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1310.1">    console.log('updated', state);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1311.1">  });</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1312.1">  const inc1 = useCallback(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1313.1">    setState((prev) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1314.1">      ...prev,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1315.1">      count1: prev.count1 + 1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1316.1">    }));</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1317.1">  }, []);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1318.1">  const inc2 = useCallback(() =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1319.1">    setState((prev) =&gt; ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1320.1">      ...prev,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1321.1">      count2: prev.count2 + 1</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1322.1">    }));</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1323.1">  }, []);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1324.1">  return [state, { inc1, inc2 }];</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1325.1">};</span></p>
			<p><span class="koboSpan" id="kobo.1326.1">We can still use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1327.1">createStateContext</span></strong><span class="koboSpan" id="kobo.1328.1"> function for these </span><strong class="source-inline"><span class="koboSpan" id="kobo.1329.1">useMyState</span></strong><span class="koboSpan" id="kobo.1330.1"> hooks and any other custom hooks.</span></p>
			<p><span class="koboSpan" id="kobo.1331.1">It's </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.1332.1">worth noting that this factory pattern works well in TypeScript. </span><span class="koboSpan" id="kobo.1332.2">TypeScript provides extra checks with types, and developers can get better experience from type checking. </span><span class="koboSpan" id="kobo.1332.3">The following code snippet shows the typed version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">createStateContext</span></strong><span class="koboSpan" id="kobo.1334.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1335.1">useNumberState</span></strong><span class="koboSpan" id="kobo.1336.1">:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1337.1">const createStateContext = &lt;Value, State&gt;(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1338.1">  useValue: (init?: Value) =&gt; State</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1339.1">) =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1340.1">  const StateContext = createContext&lt;State | null&gt;(null);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1341.1">  const StateProvider = ({</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1342.1">    initialValue,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1343.1">    children,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1344.1">  }: {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1345.1">    initialValue?: Value;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1346.1">    children?: ReactNode;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1347.1">  }) =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1348.1">    &lt;StateContext.Provider value={useValue(initialValue)}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1349.1">      {children}</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1350.1">    &lt;/StateContext.Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1351.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1352.1">  const useContextState = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1353.1">    const value = useContext(StateContext);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1354.1">    if (value === null){ </span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1355.1">     throw new Error("Provider missing");</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1356.1">    }</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1357.1">    return value;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1358.1">  };</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1359.1">  return [StateProvider, useContextState] as const;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1360.1">};</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1361.1">const useNumberState = (init?: number) =&gt; useState(init || 0);</span></p>
			<p><span class="koboSpan" id="kobo.1362.1">If we </span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.1363.1">use the typed version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1364.1">createStateContext</span></strong><span class="koboSpan" id="kobo.1365.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1366.1">useNumberState</span></strong><span class="koboSpan" id="kobo.1367.1">, the result is also typed.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.1368.1">Avoiding provider nesting with reduceRight</span></h2>
			<p><span class="koboSpan" id="kobo.1369.1">With </span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.1370.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1371.1">createStateContext</span></strong><span class="koboSpan" id="kobo.1372.1"> function, it's very easy to create many states. </span><span class="koboSpan" id="kobo.1372.2">Let's suppose we created five of them, as follows:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1373.1">const [Count1Provider, useCount1] =</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1374.1">  createStateContext(useNumberState);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1375.1">const [Count2Provider, useCount2] =</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1376.1">  createStateContext(useNumberState);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1377.1">const [Count3Provider, useCount3] =</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1378.1">  createStateContext(useNumberState);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1379.1">const [Count4Provider, useCount4] =</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1380.1">  createStateContext(useNumberState);</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1381.1">const [Count5Provider, useCount5] =</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1382.1">  createStateContext(useNumberState);</span></p>
			<p><span class="koboSpan" id="kobo.1383.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1384.1">App</span></strong><span class="koboSpan" id="kobo.1385.1"> component </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.1386.1">would then look like this:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1387.1">const App = () =&gt; (</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1388.1">  &lt;Count1Provider initialValue={10}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1389.1">    &lt;Count2Provider initialValue={20}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1390.1">      &lt;Count3Provider initialValue={30}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1391.1">        &lt;Count4Provider initialValue={40}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1392.1">          &lt;Count5Provider initialValue={50}&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1393.1">            &lt;Parent /&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1394.1">          &lt;/Count5Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1395.1">        &lt;/Count4Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1396.1">      &lt;/Count3Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1397.1">    &lt;/Count2Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1398.1">  &lt;/Count1Provider&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1399.1">);</span></p>
			<p><span class="koboSpan" id="kobo.1400.1">This is absolutely correct, and it captures how a component tree is structured. </span><span class="koboSpan" id="kobo.1400.2">However, too much nesting is not very comfortable while coding. </span><span class="koboSpan" id="kobo.1400.3">To mitigate this coding style, we could use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1401.1">reduceRight</span></strong><span class="koboSpan" id="kobo.1402.1">. </span><span class="koboSpan" id="kobo.1402.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1403.1">App</span></strong><span class="koboSpan" id="kobo.1404.1"> component can be refactored, as shown in the following example:</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1405.1">const App = () =&gt; {</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1406.1">  const providers = [</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1407.1">    [Count1Provider, { initialValue: 10 }],</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1408.1">    [Count2Provider, { initialValue: 20 }],</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1409.1">    [Count3Provider, { initialValue: 30 }],</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1410.1">    [Count4Provider, { initialValue: 40 }],</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1411.1">    [Count5Provider, { initialValue: 50 }],</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1412.1">  ] as const;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1413.1">  return providers.reduceRight(</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1414.1">    (children, [Component, props]) =&gt;</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1415.1">      createElement(Component, props, children),</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1416.1">    &lt;Parent /&gt;,</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1417.1">  );</span></p>
			<p class="source-code"><span class="koboSpan" id="kobo.1418.1">};</span></p>
			<p><span class="koboSpan" id="kobo.1419.1">There </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.1420.1">could be some variations of this technique, such as creating a </span><strong class="bold"><span class="koboSpan" id="kobo.1421.1">higher-order component</span></strong><span class="koboSpan" id="kobo.1422.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1423.1">HOC</span></strong><span class="koboSpan" id="kobo.1424.1">), but </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.1425.1">the key point is using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1426.1">reduceRight</span></strong><span class="koboSpan" id="kobo.1427.1"> to construct a provider tree.</span></p>
			<p><span class="koboSpan" id="kobo.1428.1">This technique is not only for a global state with Context but also for any components.</span></p>
			<p><span class="koboSpan" id="kobo.1429.1">In this section, we learned some best practices to work with a global state with Contexts. </span><span class="koboSpan" id="kobo.1429.2">These are not something you must follow. </span><span class="koboSpan" id="kobo.1429.3">As long as you understand the behavior of Context and its limitations, any pattern would work fine.</span></p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.1430.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.1431.1">In this chapter, we learned how to create global states with React Context. </span><span class="koboSpan" id="kobo.1431.2">The Context propagation works to avoid passing props. </span><span class="koboSpan" id="kobo.1431.3">If you understand the Context behavior correctly, implementing global states with Context is straightforward. </span><span class="koboSpan" id="kobo.1431.4">Basically, we should create a Context for each state piece to avoid extra re-renders. </span><span class="koboSpan" id="kobo.1431.5">Some best practices will help in the implementation of a global state with Context, particularly the concrete implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1432.1">createStateContext</span></strong><span class="koboSpan" id="kobo.1433.1">, which will help when organizing your app code.</span></p>
			<p><span class="koboSpan" id="kobo.1434.1">In the next chapter, we will learn another pattern of implementing a global state with subscriptions.</span></p>
		</div>
	</body></html>