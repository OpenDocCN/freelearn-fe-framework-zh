- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Styling React Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Style JSX elements via inline style assignments or with the help of CSS classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set inline and class styles, both statically and dynamically or conditionally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build reusable components that allow for style customization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize CSS Modules to scope styles to components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the core idea behind `styled-components` , a third-party CSS-in-JS
    library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Tailwind CSS to style React apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React.js is a frontend JavaScript library. This means that it’s all about building
    (web) user interfaces and handling user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, this book has extensively explored how React can be used to
    add interactivity to a web app. State, event handling, and dynamic content are
    key concepts relating to this.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, websites and web apps are not just about interactivity. You could
    build an amazing web app that offers interactive and engaging features, and yet
    it may still be unpopular if it lacks appealing visuals. Presentation is key,
    and the web is no exception.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, like all other apps and websites, React apps and websites need proper
    styling, and when working with web technologies, **Cascading Style Sheets** (
    **CSS** ) is the language of choice.
  prefs: []
  type: TYPE_NORMAL
- en: However, this book is not about CSS. It won’t explain or teach you how to use
    CSS, as there are dedicated, better resources for that (e.g., the free CSS guides
    at [https://developer.mozilla.org/en-US/docs/Learn/CSS](https://developer.mozilla.org/en-US/docs/Learn/CSS)
    ). But this chapter will teach you how to combine CSS code with JSX and React
    concepts, such as state and props. You will learn how to add styles to your JSX
    elements, style custom components, and make those components’ styles configurable.
    This chapter will also teach you how to set styles dynamically and conditionally
    and explore popular third-party libraries, like styled-components and Tailwind
    CSS, that can be used for styling.
  prefs: []
  type: TYPE_NORMAL
- en: How Does Styling Work in React Apps?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, the apps and examples presented in this book have only had
    minimal styling. But they at least had some basic styling, rather than no styling
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: But how was that styling added? How can styles be added to user interface elements
    (such as DOM elements) when using React?
  prefs: []
  type: TYPE_NORMAL
- en: The short answer is, “Just as you would to non-React apps.” You can add CSS
    styles and classes to JSX elements just as you would to regular HTML elements.
    And in your CSS code, you can use all the features and selectors you know from
    CSS. There are no React-specific changes you have to make when writing CSS code.
  prefs: []
  type: TYPE_NORMAL
- en: The code examples used so far (i.e., the activities or other examples hosted
    on GitHub) always used regular CSS styling, with the help of CSS selectors, to
    apply some basic styles to the final user interface. Those CSS rules were defined
    in an `index.css` file, which is part of every newly created React project (when
    using Vite for project creation, as shown in *Chapter 1* , *React – What and Why*
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s the `index.css` file used in *Activity 5.2* of the previous
    chapter ( *Chapter 5* , *Rendering Lists and Conditional Content* ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The actual CSS code and its meaning are not important (as mentioned, this book
    is not about CSS). However, what is important is the fact that this code contains
    no JavaScript or React code at all. As mentioned, the CSS code you write is totally
    independent of the fact that you’re using React in your app.
  prefs: []
  type: TYPE_NORMAL
- en: The more interesting question is, how is that code actually applied to the rendered
    web page? How is it imported into that page?
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, you would expect style file imports (via `<link href="…">` ) inside
    of the HTML files that are served. Since React apps are typically about building
    **single-page applications** (see *Chapter 1* , *React – What and Why* ), you
    only have one HTML file—the `index.html` file. But if you inspect that file, you
    won’t find any `<link href="…">` import that would point to the `index.css` file
    (only some other `<link>` element that imports a favicon), as you can see in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: The <head> section of the index.html file contains no <link> import
    that points to the index.css file'
  prefs: []
  type: TYPE_NORMAL
- en: How are the styles defined in `index.css` imported and applied then?
  prefs: []
  type: TYPE_NORMAL
- en: 'You find an `import` statement in the root entry file (this is the `main.jsx`
    file in projects generated via `Vite` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `import './index.css';` statement leads to the CSS file being imported and
    the defined CSS code being applied to the rendered web page.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that this is not standard JavaScript behavior. You can’t
    import CSS files into JavaScript—at least, not if you’re just using vanilla JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: CSS works this way in React apps because the code is transpiled before it’s
    loaded into the browser. Therefore, you won’t find that `import` statement in
    the final JavaScript code that’s executed in the browser. Instead, during the
    **transpilation process** , the transpiler identifies the CSS import, removes
    it from the JavaScript file, and injects the CSS code (or an appropriate link
    to the potentially bundled and optimized CSS file) into the `index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: You can confirm this by inspecting the rendered **Document Object Model** (
    **DOM** ) content of the loaded web page in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, select the **Elements** tab in developer tools in Chrome, as shown
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Injected CSS <style> elements can be found in the DOM at runtime'
  prefs: []
  type: TYPE_NORMAL
- en: You can define any styles you want to apply to your HTML elements (that is,
    to your JSX elements in your components) directly inside of the `index.css` file,
    or in any other CSS files that are imported by the `index.css` file.
  prefs: []
  type: TYPE_NORMAL
- en: You could also add additional CSS import statements, pointing at other CSS files,
    to the `main.jsx` file or any other JavaScript files (including files that store
    components). However, it is important to keep in mind that CSS styles are always
    global. No matter whether you import a CSS file into `main.jsx` or a component-specific
    JavaScript file, the styles defined in that CSS file will be applied globally.
  prefs: []
  type: TYPE_NORMAL
- en: That means that styles defined in a `goal-list.css` file, which may be imported
    in a `GoalList.jsx` file, could still affect JSX elements defined in a totally
    different component. Later in this chapter, you will learn about techniques that
    allow you to prevent accidental style clashes and implement style scoping.
  prefs: []
  type: TYPE_NORMAL
- en: Using Inline Styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use CSS files to define global CSS styles and use different CSS selectors
    to target different JSX elements (or groups of elements).
  prefs: []
  type: TYPE_NORMAL
- en: But even though it’s typically discouraged, you can also set inline styles directly
    on JSX elements via the `style` prop.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re wondering why inline styles are discouraged, the following discussion
    on Stack Overflow provides many arguments against inline styles: [https://stackoverflow.com/questions/2612483/whats-so-bad-about-in-line-css](https://stackoverflow.com/questions/2612483/whats-so-bad-about-in-line-css)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting inline styles in JSX code works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `style` prop is added to the `<li>` element (all JSX elements
    support the `style` prop), and both the `color` and `size` properties of the text
    are set via CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach differs from what you would use to set inline styles when working
    with just HTML (instead of JSX). When using plain HTML, you would set inline styles
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The difference is that the `style` prop expects to receive a JavaScript object
    that contains the style settings—not a plain string. This is something that must
    be kept in mind, since, as mentioned previously, inline styles typically aren’t
    used that often.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `style` object is an object and not a plain string, it is passed as
    a value between curly braces—just as an array, a number, or any other non-string
    value would have to be set between curly braces (anything between double or single
    quotes is treated as a string value). Therefore, it’s worth noting that the preceding
    example does not use any kind of special “double curly-braces” syntax and, instead,
    uses one pair of curly braces to surround the non-string value and another pair
    to surround the object data.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `style` object, any CSS style properties supported by the underlying
    DOM element can be set. The property names are those defined for the HTML element
    (i.e., the same CSS property names you could target and set with vanilla JavaScript,
    when mutating an HTML element).
  prefs: []
  type: TYPE_NORMAL
- en: When setting styles in JavaScript code (as with the `style` prop shown above),
    JavaScript CSS property names have to be used. Those names are similar to the
    CSS property names you would use in CSS code but not quite the same. Differences
    occur for property names that consist of multiple words (e.g., `font-size` ).
    When targeting such properties in JavaScript, camelCase notation must be used
    ( `fontSize` instead of `font-size` ), as JavaScript properties cannot contain
    dashes. Alternatively, you could wrap the property name with quotes ( `'font-size'`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about the HTML element style property and JavaScript
    CSS property names here: [https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Setting Styles via CSS Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, using inline styles is typically discouraged, and therefore, CSS
    styles defined in CSS files (or between `<style>` tags in the document `<head>`
    section) are preferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'In those CSS code blocks, you can write regular CSS code and use CSS selectors
    to apply CSS styles to certain elements. You could, for example, style all `<li>`
    elements on a page (no matter which component may have rendered them) like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As long as this code gets added to the page (because the CSS file in which it
    is defined is imported into `main.jsx` , for instance), the styling will be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quite frequently, developers aim to target specific elements or groups of elements.
    Instead of applying some style to all `<li>` elements on a page, the goal could
    be to only target the `<li>` elements that are part of a specific list. Consider
    this HTML structure that’s rendered to the page (it may be split across multiple
    components, but this doesn’t matter here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the navigation list items will most likely not receive the
    same styling as the `course goal` list items (and vice versa).
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, this problem would be solved with the help of CSS classes and the
    class selector. You could adjust the HTML code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following CSS code would then only target the course goal list items but
    not the navigation list items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This approach almost works in React apps as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you try to add CSS classes to JSX elements, as shown in the previous
    example, you will face a warning in the browser’s developer tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A white background with red text  Description automatically generated](img/B31339_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: A warning output by React'
  prefs: []
  type: TYPE_NORMAL
- en: 'As illustrated in the preceding figure, you should not add `class` as a prop
    and, instead, use `className` . Indeed, if you swap `class` for `className` as
    a prop name, the warning will disappear, and the class CSS styles will be applied.
    Hence, the proper JSX code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: But why is React suggesting you use `className` instead of `class` ?
  prefs: []
  type: TYPE_NORMAL
- en: It’s similar to using `htmlFor` instead of `for` when working with `<label>`
    objects (as discussed in *Chapter 4* , *Working with Events and State* ). Just
    like `for` , `class` is a keyword in JavaScript, and therefore, `className` is
    used as a prop name instead.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Styles Dynamically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With inline styles and CSS classes (and global CSS styles in general), there
    are various ways of applying styles to elements. Thus far, all examples have shown
    static styles—that is, styles that will never change once a page has been loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'But while most page elements don’t change their styles after a page is loaded,
    you also typically have some elements that should be styled dynamically or conditionally.
    Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: A to-do app where different to-do priorities receive different colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An input form where invalid form elements should be highlighted following an
    unsuccessful form submission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web-based game where players can choose colors for their avatars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In such cases, applying static styles is not enough, and dynamic styles should
    be used instead. Setting styles dynamically is straightforward. Again, it’s just
    about applying the key React concepts covered earlier (most importantly, those
    regarding the setting of dynamic values from *Chapter 2* , *Understanding React
    Components and JSX* , and *Chapter 4* , *Working with Events and State* ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example where the color of a paragraph is set dynamically to the
    color that a user enters into an input field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The text entered in the `<input>` field is stored in the `enteredColor` state.
    This state is then used to set the `color` CSS property of the `<p>` element dynamically.
    This is achieved by passing a `style` object, with the `color` property set to
    the `enteredColor` value as a value to the `style` prop of the `<p>` element.
    The text color of the paragraph is, therefore, set dynamically to the value entered
    by the user (assuming that users enter valid CSS color values into the `<input>`
    field).
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re not limited to inline styles; CSS classes can also be set dynamically,
    as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `chosenPriority` state will alternate between `low-prio`
    and `high-prio` , depending on the drop-down selection. The state value is then
    output as text inside the paragraph and is also used as a dynamic CSS class name,
    applied to the `<p>` element. For this to have any visual effect, there must,
    of course, be `low-prio` and `high-prio` CSS classes defined in some CSS file
    or `<style>` block. For example, consider the following code in `index.css` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Conditional Styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Closely related to **dynamic styles** are **conditional styles** . In fact,
    ultimately, they are really just a special case of dynamic styles. In the previous
    examples, inline style values and class names were set as equal to values chosen
    or entered by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can also derive styles or class names dynamically based on different
    conditions, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a wrapper component around the standard `<input>` element is
    built. (For more information about wrapper components, see *Chapter 3* , *Components
    and Props* .) The main purpose of this wrapper component is to set some default
    styles for the wrapped `<input>` element. The **wrapper component** is built to
    provide a pre-styled input element that can be used anywhere in the app. Indeed,
    providing pre-styled elements is one of the most common and popular use cases
    for building wrapper components.
  prefs: []
  type: TYPE_NORMAL
- en: In this concrete example, the default styles are applied using CSS classes.
    If the `isValid` prop value is `true` and the value of the `isRecommended` prop
    is `false` , the `input-default` CSS class will be applied to the `<input>` element,
    since neither of the two `if` statements become active.
  prefs: []
  type: TYPE_NORMAL
- en: If `isRecommended` is `true` (but `isValid` is `false` ), the `input-recommended`
    CSS class would be applied. If `isValid` is `false` , the `input-invalid` class
    is added instead. Of course, the CSS classes must be defined in some imported
    CSS files (for example, in `index.css` ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inline styles could be set in a similar way, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the background color of the `<input>` element is set conditionally,
    based on the values received via the `isValid` and `isRecommended` props.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Multiple Dynamic CSS Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous examples, a maximum of one CSS class was set dynamically at a time.
    However, it’s not uncommon to encounter scenarios where multiple dynamically derived
    CSS classes should be merged and added to an element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, two CSS classes are added to `<p>` by simply combining them into one
    string. Alternatively, you could directly add a string with the two classes like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This code will work, but what if the goal is to also add another class name
    to the list of classes, based on the `isImportant` prop value (which is ignored
    in the preceding example)?
  prefs: []
  type: TYPE_NORMAL
- en: 'Replacing the default list of classes is easy, as you have learned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: But what if the goal is not to replace the list of default classes? What if
    `text-important` should be added as a class to `<p>` , in addition to `text-default`
    and `text-expl` ?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `className` prop expects to receive a string value, so passing an array
    of classes isn’t an option. However, you can simply merge multiple classes into
    one string, and there are a couple of different ways to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'String concatenation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using a template literal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Joining an array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These examples could all be used inside the `if` statement ( `if (isImportant)`
    ) to conditionally add the `text-important` class, based on the `isImportant`
    prop value. All three approaches, as well as variations of these approaches, will
    work because all these approaches produce a string. In general, any approach that
    yields a string can be used to generate values for `className` .
  prefs: []
  type: TYPE_NORMAL
- en: Merging Multiple Inline Style Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with inline styles, instead of CSS classes, you can also merge
    multiple style objects. The main difference is that you don’t produce a string
    with all values but, rather, an object with all combined style values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be achieved by using standard JavaScript techniques to merge multiple
    objects into one object. The most popular technique involves using the **spread
    operator** , as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, you will observe that `defaultStyle` is an object with a `color` property.
    If `isImportant` is `true` , it’s replaced with an object that contains all the
    properties it had before (via the spread operator, `...defaultStyle` ) as well
    as the `backgroundColor` property.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the function and use of the spread operator, see *Chapter
    5* , *Rendering Lists and Conditional Content* .
  prefs: []
  type: TYPE_NORMAL
- en: Building Components with Customizable Styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you are aware by now, components can be reused. This is supported by the
    fact that they can be configured via props. The same component can be used in
    different places on a page with different configurations to yield a different
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Since styles can be set both statically and dynamically, you can also make the
    styling of your components customizable. The preceding examples already show such
    customization in action; for example, the `isImportant` prop was used in the previous
    example to conditionally add a `red` background color to a paragraph. The `ExplanationText`
    component therefore already allows indirect style customization via the `isImportant`
    prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides this form of customization, you could also build components that accept
    props already holding CSS class names or style objects. For example, the following
    wrapper component accepts a `className` prop that is merged with a default CSS
    class ( `btn` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This component could be used in another component in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If used like this, the final `<button>` element would receive both the `btn`
    as well as `btn-alert` classes.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t have to use `className` as a prop name; any name can be used, since
    it’s your component. However, it’s not a bad idea to use `className` because you
    can then keep your mental model of setting CSS classes via `className` (for built-in
    components, you will not have that choice).
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of merging prop values with default CSS class names or style objects,
    you can overwrite default values. This allows you to build components that come
    with some styling out of the box without enforcing that styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see how all the different concepts covered throughout this book are
    coming together here: props allow customization, values can be set, swapped, and
    changed dynamically and conditionally, and therefore, highly reusable and configurable
    components can be built.'
  prefs: []
  type: TYPE_NORMAL
- en: Customization with Fixed Configuration Options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides exposing props such as `className` or `style` , which are merged with
    other classes or styles defined inside a component function, you can also build
    components that apply different styles or class names based on other prop values.
  prefs: []
  type: TYPE_NORMAL
- en: This has been shown in the previous examples where props such as `isValid` or
    `isImportant` were used to apply certain styles conditionally. This way of applying
    styles could, therefore, be called “indirect styling” (although this is not an
    official term).
  prefs: []
  type: TYPE_NORMAL
- en: Both approaches can shine in different circumstances. For wrapper components,
    for example, accepting `className` or `style` props (which can be merged with
    other styles inside the component) enables the component to be used just like
    a built-in component (e.g., like the component it wraps). Indirect styling, on
    the other hand, can be very useful if you want to build components that provide
    a couple of pre-defined variations.
  prefs: []
  type: TYPE_NORMAL
- en: A good example is a text box that provides two built-in themes that can be selected
    via a specific prop.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a phone  Description automatically generated](img/B31339_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: A TextBox is styled based on the value of the “mode” prop'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the `TextBox` component could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This `TextBox` component always yields a paragraph element. If the `mode` prop
    is set to any value other than `'alert'` or `'info'` , the paragraph doesn’t receive
    any special styling. But if `mode` is equal to `'alert'` or `'info'` , specific
    CSS classes are added to the paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: This component, therefore, doesn’t allow direct styling via some `className`
    or `style` prop that would be merged, but it does offer different variations or
    themes that can be set with the help of a specific prop (the `mode` prop in this
    case).
  prefs: []
  type: TYPE_NORMAL
- en: The Problem with Unscoped Styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you consider the different examples you’ve so far dealt with in this chapter,
    there’s one specific use case that occurs quite frequently: styles are relevant
    to a specific component only.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the `TextBox` component in the previous section, `'box-alert'`
    and `'box-info'` are CSS classes that are likely only relevant for this specific
    component and its markup. If any other JSX element in the app had a `'box-alert'`
    class applied to it (even though that might be unlikely), it probably shouldn’t
    be styled the same as the `<p>` element in the `TextBox` component.
  prefs: []
  type: TYPE_NORMAL
- en: Styles from different components could clash with each other and overwrite each
    other because styles are not scoped (i.e., restricted) to a specific component.
    CSS styles are always global, unless inline styles are used (which is discouraged,
    as mentioned earlier).
  prefs: []
  type: TYPE_NORMAL
- en: When working with component-based libraries such as React, this lack of scoping
    is a common issue. It’s easy to write conflicting styles as app sizes and complexities
    grow (or, in other words, as more and more components are added to the code base
    of a React app).
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why various solutions for this problem have been developed by members
    of the React community. The following are three of the most popular solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: CSS Modules (supported out of the box in React projects created with Vite)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styled components (using a third-party library called `styled-components` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tailwind CSS (a popular CSS library)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scoped Styles with CSS Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CSS Modules** is the name for an approach where individual CSS files are
    linked to specific JavaScript files and the components defined in those files.
    This link is established by transforming CSS class names, such that every JavaScript
    file receives its own, unique CSS class names. This transformation is performed
    automatically as part of the code build workflow. Therefore, a given project setup
    must support CSS Modules by performing the described CSS class name transformation.
    Projects created via Vite support CSS Modules by default.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a program  Description automatically generated](img/B31339_06_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: CSS modules in action. CSS class names are transformed into unique
    names during the build workflow'
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS Modules are enabled and used by naming CSS files in a very specific and
    clearly defined way: `<anything>.module.css` . `<anything>` is any value of your
    choosing, but the `.module` part in front of the file extension is required, as
    it signals (to the project build workflow) that this CSS file should be transformed
    according to the CSS Modules approach.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, CSS files named like this must be imported into components in a
    specific way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This `import` syntax is different from the `import` syntax shown at the beginning
    of this section for `index.css` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When importing CSS files as shown in the second snippet, the CSS code is simply
    merged into the `index.html` file and applied globally. When using CSS Modules
    instead (first code snippet), the CSS class names defined in the imported CSS
    file are transformed such that they are unique for the JS file that imports the
    CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: Since the CSS class names are transformed and are therefore no longer equal
    to the class names you defined in the CSS file, you import an object ( `classes`
    , in the preceding example) from the CSS file. This object exposes all transformed
    CSS class names under keys that match the CSS class names defined by you in the
    CSS file. The values of those properties are the transformed class names (as strings).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a complete example, starting with a component-specific CSS file ( `TextBox.module.css`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The JavaScript file ( `TextBox.jsx` ) for the component to which the CSS code
    should belong looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The full example code can also be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/01-css-modules-intro](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/01-css-modules-intro)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'If you inspect the rendered text element in the browser developer tools, you
    will note that the CSS class name applied to the `<p>` element does not match
    the class name specified in the `TextBox.module.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_06_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: CSS class name transforms because of CSS Modules usage'
  prefs: []
  type: TYPE_NORMAL
- en: This is the case because, as described previously, the class name was transformed
    during the build process to be unique. If any other CSS file, imported by another
    JavaScript file, were to define a class with the same name ( `info` in this case),
    the styles would not clash and not overwrite each other, as the interfering class
    names would be transformed into different class names before being applied to
    the DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, in the example provided on GitHub, you can find another `info` CSS
    class defined in the `index.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: That file is still imported into `main.jsx` , and hence its styles are applied
    globally to the entire document. Nonetheless, the `.info` styles clearly aren’t
    affecting `<p>` rendered by `TextBox` (there is no red border around the text
    box in *Figure 6.6* ). They aren’t affecting that element because it doesn’t have
    an `info` class anymore; the class was renamed `_info_1mtzh_8` by the build workflow
    (although the name you see will differ, as it contains a random element).
  prefs: []
  type: TYPE_NORMAL
- en: It’s also worth noting that the `index.css` file is still imported into `main.jsx`
    , as shown at the beginning of this chapter. The `import` statement is not changed
    to `import classes from './index.css';` , nor is the CSS file called `index.module.css`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Note, too, that you can use CSS Modules to scope styles to components and can
    also mix the usage of CSS Modules with regular CSS files, which are imported into
    JavaScript files without using CSS Modules (i.e., without scoping).
  prefs: []
  type: TYPE_NORMAL
- en: One other important aspect of using CSS Modules is that you can only use CSS
    class selectors (that is, in your `.module.css` files) because CSS Modules rely
    on CSS classes. You can write selectors that combine classes with other selectors,
    such as `input.invalid` , but you can’t add selectors that don’t use classes at
    all in your `.module.css` files. For example, `input { ... }` or `#some-id { ...
    }` selectors wouldn’t work here.
  prefs: []
  type: TYPE_NORMAL
- en: CSS Modules are a very popular way of scoping styles to (React) components,
    and they will be used throughout many examples for the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The styled-components Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `styled-components` library is a so-called **CSS-in-JS** solution. CSS-in-JS
    solutions aim to remove the separation between CSS code and JavaScript code by
    merging them into the same file. Component styles would be defined right next
    to the component logic. It comes down to personal preference whether you favor
    separation (as enforced by using CSS files) or keeping the two languages close
    to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `styled-components` is a third-party library that’s not pre-installed
    in newly created React projects, you have to install this library as a first step
    if you want to use it. This can be done via `npm` (which was automatically installed
    together with Node.js in *Chapter 1* , *React – What and Why* ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `styled-components` library essentially provides wrapper components around
    all built-in core components (as in, around `p` , `a` , `button` , `input` , and
    so on). It exposes all these wrapper components as **tagged templates** —JavaScript
    functions that aren’t called like regular functions but, instead, are executed
    by adding backticks (a template literal) right after the function name, for example,
    `` doSomething`text data` `` .
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Tagged templates can be confusing when you see them for the first time, especially
    since it’s a JavaScript feature that isn’t used too frequently. Chances are high
    that you haven’t worked with them too often. It’s even more likely that you have
    never built a custom-tagged template before. You can learn more about tagged templates
    in this excellent documentation on MDN at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a component that imports and uses `styled-components` to set and scope
    styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This component isn’t a component function but, rather, a constant that stores
    the value returned by executing the `styled.button` tagged template. That tagged
    template returns a component function that yields a `<button>` element. The styles
    passed via the tagged template (i.e., inside the template literal) are applied
    to that returned button element. You can see this if you inspect the button in
    the browser’s developer tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer program  Description automatically generated](img/B31339_06_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: The rendered button element receives the defined component styles'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 6.7* , you can also see how the `styled-components` library applies
    your styles to the element. It extracts your style definitions from the tagged
    template string and injects them into a `<style>` element in the `<head>` section
    of the document. The injected styles are then applied via a class selector that
    is generated (and named) by the `styled-components` library. Finally, the automatically
    generated CSS class name is added to the element ( `<button>` , in this case)
    by the library.
  prefs: []
  type: TYPE_NORMAL
- en: The components exposed by the `styled-components` library spread any extra props
    you pass to a component onto the wrapped core component. In addition, any content
    inserted between the opening and closing tags is also inserted between the tags
    of the wrapped component.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why the `Button` created previously can be used like this without adding
    any extra logic to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The complete example code can be found on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/02-styled-components-intro](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/02-styled-components-intro)
    .
  prefs: []
  type: TYPE_NORMAL
- en: You can do more with the `styled-components` library. For example, you can set
    styles dynamically and conditionally. This book is not primarily about that library
    though. It’s just one of many alternatives to CSS Modules. Therefore, it is recommended
    that you explore the official `styled-components` documentation if you want to
    learn more, which you can find at [https://styled-components.com/](https://styled-components.com/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Use the Tailwind CSS Library for Styling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scoping styles with the help of CSS modules or the `styled-component` library
    is a very useful and popular technique.
  prefs: []
  type: TYPE_NORMAL
- en: But no matter which approach you use, you must write all the CSS code on your
    own. Hence you, of course, need to know CSS.
  prefs: []
  type: TYPE_NORMAL
- en: But what if you don’t? Or if you simply don’t like writing CSS code?
  prefs: []
  type: TYPE_NORMAL
- en: In that case, you can use one of the many CSS libraries and frameworks available—for
    example, the **Bootstrap** CSS framework or the **Tailwind CSS** library. Tailwind
    has become a very popular styling solution for React projects (for developers
    who don’t want to write custom CSS code).
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that Tailwind is a CSS library that’s actually not focused on React.
    Instead, you can use Tailwind in any web project to style your HTML code—no matter
    which JavaScript library or framework (if any) is being used there.
  prefs: []
  type: TYPE_NORMAL
- en: 'But Tailwind is a common choice for React apps, since its core philosophy plays
    nicely with the component-focused model of React. This is because when using Tailwind
    for styling, you typically compose overall styles by applying many small CSS classes
    to individual JSX elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When first encountering code that uses Tailwind CSS, the long list of CSS classes
    may look intimidating and chaotic. But when working with Tailwind, you typically
    quickly get used to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, because Tailwind’s approach offers many advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to learn CSS in detail—understanding the Tailwind syntax, which
    is less complex than writing CSS from scratch, suffices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You compose styles by combining CSS classes—similar to how you compose user
    interfaces from components in React.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don’t have to switch between JSX and CSS files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling changes can be applied and tested very quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see in the above code snippet, the core idea of Tailwind essentially
    is that it provides many combinable CSS classes that each do very little. For
    example, the `bg-gray-200` class just sets the background color to a certain shade
    of gray, and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it’s the combination of all those CSS classes that achieves a certain
    look, and Tailwind CSS offers many such classes that you may use and combine.
    You find a full list in the official documentation at [https://tailwindcss.com/docs/utility-first](https://tailwindcss.com/docs/utility-first)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with Tailwind in React projects, you can therefore build React
    components not just to reuse logic or JSX markup but also styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Item` component is built to reuse the Tailwind styles
    applied to the `<li>` element.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You also find this example project on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/03-tailwind](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/examples/03-tailwind)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you plan on using Tailwind in your React project, you must install it as
    a first step. Detailed installation instructions for a broad variety of project
    setups can be found in the official documentation—this includes instructions for
    Vite projects: [https://tailwindcss.com/docs/guides/vite](https://tailwindcss.com/docs/guides/vite)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: The installation process is not as simple as just importing a CSS file but nonetheless
    relatively straightforward. It does require a couple of setup steps, since Tailwind
    needs to plug into the project build process to analyze your JSX files and produce
    CSS code that contains all used class names and style rules.
  prefs: []
  type: TYPE_NORMAL
- en: Besides offering many utility styles that can be combined, Tailwind also provides
    plenty of customization opportunities and configuration options. Therefore, entire
    books could be written about Tailwind alone. However, that’s, of course, not what
    this book is about. Therefore, if you’re interested in using Tailwind in your
    React projects, Tailwind’s official documentation (see the links above) is a great
    place to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Using Other CSS or JavaScript Styling Libraries and Frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Obviously, it comes down to personal preferences whether you want to write custom
    CSS code (potentially scoped with CSS Modules or `styled-components` ) or whether
    you want to work with third-party CSS libraries, like Tailwind CSS. There is no
    wrong or right choice, and you’ll see all kinds of approaches being used in different
    React projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options presented in this chapter are also not exhaustive—there are other
    kinds of CSS and JavaScript libraries, too:'
  prefs: []
  type: TYPE_NORMAL
- en: Utility libraries that solve very specific CSS problems—independent of the fact
    that you’re using them in a React project (for example, `Animate.css` , which
    helps to add animations)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other CSS frameworks or libraries that provide a broad variety of pre-built
    CSS classes that can be applied to elements to quickly achieve a certain look
    (for example, **Bootstrap** )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript libraries that help with styling or specific styling aspects like
    animations (for example, **Framer Motion** )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some libraries and frameworks have React-specific extensions or specifically
    support React, but that does not mean that you can’t use libraries that don’t
    have this.
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Key Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Standard CSS can be used to style React components and JSX elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS files are typically directly imported into JavaScript files, which is possible
    thanks to the project build process, which extracts the CSS code and injects it
    into the document (the HTML file).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an alternative to global CSS styles (with `element` , `id` , `class` , or
    other selectors), inline styles can be used to apply styling to JSX elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using CSS classes for styling, you must use the `className` prop (not `class`
    ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styles can be set statically and dynamically or conditionally with the same
    syntax that is used to inject other dynamic or conditional values into JSX code—a
    pair of curly braces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highly configurable custom components can be built by setting styles (or CSS
    classes) based on prop values, or by merging received prop values with other styles
    or class name strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using just CSS, clashing CSS class names can be a problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS Modules solve this problem by transforming class names into unique names
    (per component) as part of the build workflow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, third-party libraries such as `styled-components` can be used.
    This library is a CSS-in-JS library that also has the advantage or disadvantage
    (depending on your preference) of removing the separation between JS and CSS code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tailwind CSS is another popular styling choice for React projects—it’s a library
    that allows you to compose styles by combining many small CSS classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other CSS libraries or frameworks can be used as well; React does not impose
    any restrictions regarding that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With styling covered, you’re now able to build not just functional but also
    visually appealing user interfaces. Even if you often work with dedicated web
    designers or CSS experts, you still typically need to be able to set and assign
    styles (dynamically) that are delivered to you.
  prefs: []
  type: TYPE_NORMAL
- en: With styling being a general concept that is relatively independent of React,
    the next chapter will dive back into more React-specific features and topics.
    You will learn about **portals** and **refs** , which are two key concepts that
    are built into React. You will discover which problems are solved by these concepts
    and how the two features are used.
  prefs: []
  type: TYPE_NORMAL
- en: Test Your Knowledge!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to examples that can be
    found here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/06-styling/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/06-styling/exercises/questions-answers.md)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: With which language are styles for React components defined?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which important difference, compared to projects without React, has to be kept
    in mind when it comes to assigning classes to elements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can styles be assigned dynamically and conditionally?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does “Scoping” mean in the context of styling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How could styles be scoped to components? Briefly explain at least one concept
    that helps with scoping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply What You Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are now not only able to build interactive user interfaces but also style
    those user interface elements in engaging ways. You can set and change those styles
    dynamically or based on conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will find two activities that allow you to apply your newly
    gained knowledge in combination with what you learned in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.1: Providing Input Validity Feedback upon Form Submission'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will build a basic form that allows users to enter an
    email address and a password. The provided input of each input field is validated,
    and the validation result is stored (for each individual input field).
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to add some general form styling and some conditional
    styling that becomes active once an invalid form has been submitted. The exact
    styles are up to you, but to highlight invalid input fields, the background color
    of the affected input field must be changed, as well as its border color and the
    text color of the related label.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new React project and add a form component to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the form component in the project’s root component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the form component, output a form that contains two input fields: one for
    entering an email address and one for entering a password.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add labels to the input fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store the entered values and check their validity upon form submission (you
    can be creative in forming your own validation logic).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick appropriate CSS classes from the provided `index.css` file (alternatively,
    you can write your own classes as well).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add them to the invalid input fields and their labels once invalid values have
    been submitted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final user interface should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a login screen  Description automatically generated](img/B31339_06_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: The final user interface with invalid input values highlighted
    in red'
  prefs: []
  type: TYPE_NORMAL
- en: Since this book is not about CSS and you may not be a CSS expert, you can use
    the `index.css` file from the solution and focus on the React logic to apply appropriate
    CSS classes to JSX elements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: All code files used for this activity, and a full solution, can be found at
    [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/activities/practice-1)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.2: Using CSS Modules for Style Scoping'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you’ll take the final app built in *Activity 6.1* and adjust
    it to use CSS Modules. The goal is to migrate all component-specific styles into
    a component-specific CSS file, which uses CSS Modules for style scoping.
  prefs: []
  type: TYPE_NORMAL
- en: The final user interface therefore looks the same as it did in the previous
    activity. However, the styles will be scoped to the `Form` component so that clashing
    class names won’t interfere with styling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Finish the previous activity or take the finished code from GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the styles belonging specifically to the `Form` component and move
    them into a new, component-specific CSS file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change CSS selectors to class name selectors and add classes to JSX elements
    as needed (this is because CSS Modules require class name selectors).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the component-specific CSS file as explained throughout this chapter and
    assign the CSS classes to the appropriate JSX elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: All code files used for this activity, and a full solution, can be found at
    [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/06-styling/activities/practice-2)
    .
  prefs: []
  type: TYPE_NORMAL
