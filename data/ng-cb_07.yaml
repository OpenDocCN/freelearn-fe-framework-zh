- en: '*Chapter 7*: Understanding Angular Navigation and Routing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：理解Angular导航和路由'
- en: One of the most amazing things about Angular is that it is an entire ecosystem
    (a framework) rather than a library. In this ecosystem, the Angular router is
    one of the most critical blocks to learn and understand. In this chapter, you'll
    learn some really cool techniques about routing and navigation in Angular. You'll
    learn about how to guard your routes, listen to route changes, and configure global
    actions on route changes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Angular最令人惊奇的事情之一是，它是一个完整的生态系统（一个框架），而不是一个库。在这个生态系统中，Angular路由器是最关键的学习和理解之一。在本章中，您将学习有关Angular中路由和导航的一些非常酷的技术。您将学习如何保护您的路由，监听路由更改，并配置路由更改的全局操作。
- en: 'The following are the recipes we''re going to cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将涵盖的配方：
- en: Creating an Angular app and modules with routes using the CLI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CLI创建带有路由的Angular应用程序和模块
- en: Feature modules and lazily loaded routes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性模块和延迟加载路由
- en: Authorized access to routes using route guards
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路由守卫对路由进行授权访问
- en: Working with route parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理路由参数
- en: Showing a global loader between route changes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在路由更改之间显示全局加载器
- en: Preloading route strategies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预加载路由策略
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the recipes in this chapter, make sure you have **Git** and **Node.js**
    installed on your machine. You also need to have the `@angular/cli` package installed,
    which you can do with `npm install -g @angular/cli` from your terminal. The code
    for this chapter can be found at [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter07](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter07).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的配方，请确保您的机器上已安装**Git**和**Node.js**。您还需要安装`@angular/cli`包，您可以在终端中使用`npm install
    -g @angular/cli`来完成。本章的代码可以在[https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter07](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter07)找到。
- en: Creating an Angular app with routes using the CLI
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CLI创建带有路由的Angular应用程序
- en: If you ask me about how we used to create projects for web applications 7-8
    years ago, you'll be astonished to learn how difficult it was. Luckily, the tools
    and standards have evolved in the software development industry and when it comes
    to Angular, starting a project is super easy. You can even configure different
    things out of the box. In this recipe, you'll create a fresh Angular project using
    the Angular CLI and will also enable the routing configuration as you create the
    project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你问我7-8年前我们是如何创建Web应用程序项目的，你会惊讶地发现当时有多么困难。幸运的是，软件开发行业的工具和标准已经发展，当涉及到Angular时，启动项目变得非常容易。你甚至可以直接配置不同的东西。在这个配方中，您将使用Angular
    CLI创建一个全新的Angular项目，并在创建项目时启用路由配置。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The project that we are going to work on does not have a starter file. So, you
    can open the `chapter07/start_here` folder from the cloned repository directly
    into the Visual Studio Code app.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的项目没有起始文件。所以，你可以直接从克隆的存储库中将`chapter07/start_here`文件夹打开到Visual Studio Code应用程序中。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We''ll be creating the app using the Angular CLI first. It''ll have routing
    enabled out of the box. Similarly, going forward, we''ll create some feature modules
    with components as well, but they''ll have eagerly loaded routes. So, let''s get
    started:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用Angular CLI创建应用程序。它将默认启用路由。同样，接下来，我们将创建一些带有组件的特性模块，但它们将具有急切加载的路由。所以，让我们开始吧：
- en: 'First, open the terminal and make sure you''re inside the `chapter07/start_here`
    folder. Once inside, run the following command:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开终端，确保你在`chapter07/start_here`文件夹内。进入后，运行以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The command should create a new Angular app for you with routing enabled and
    SCSS selected as your styling choice.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应该为您创建一个新的Angular应用程序，并启用路由，并选择SCSS作为您的样式选择。
- en: 'Run the following commands to open up the app in the browser:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令在浏览器中打开应用程序：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s create a top-level component named `landing` by running the following
    command:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过运行以下命令创建一个顶级组件命名为`landing`：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Remove all the content from `app.component.html` and keep only `router-outlet`,
    as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`app.component.html`中删除所有内容，只保留`router-outlet`，如下所示：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We''ll now make `LandingComponent` the default route by adding it to the `app-routing.module.ts`
    file, as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过将其添加到`app-routing.module.ts`文件中，将`LandingComponent`设置为默认路由，如下所示：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Refresh the page and you should see the URL automatically changed to `http://localhost:4200/landing`
    as the app redirected to the default route.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新页面，你应该会看到URL自动更改为`http://localhost:4200/landing`，因为应用程序重定向到默认路由。
- en: 'Replace the contents of `landing.component.html` with the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换`landing.component.html`的内容：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, add some styles for the header in the `landing.component.scss` file, as
    follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`landing.component.scss`文件中为头部添加一些样式，如下所示：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the styles for the links in the header as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示，为头部链接添加样式：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Furthermore, add the styles for the body of the landing page after the `&__header`
    selector, as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在`&__header`选择器之后添加着陆页面主体的样式，如下所示：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, to make it all look good, add the following styles to the `styles.scss`
    file:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了使一切看起来好看，将以下样式添加到`styles.scss`文件中：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, add a feature module for both the `home` and `about` routes by running
    the following commands in the project root:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过在项目根目录中运行以下命令，为`home`和`about`路由添加特性模块：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, import both `HomeModule` and `AboutModule` in your `app.module.ts` file
    as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在你的`app.module.ts`文件中导入`HomeModule`和`AboutModule`如下所示：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can configure the routes. Modify the `app-routing.module.ts` file to
    add the appropriate routes as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以配置路由。修改`app-routing.module.ts`文件以添加适当的路由，如下所示：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can style our `Home` and `About` components in just a bit. Add the following
    CSS to both the `home.component.scss` file and the `about.component.scss` file:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以很快为我们的`Home`和`About`组件添加样式。将以下CSS添加到`home.component.scss`文件和`about.component.scss`文件中：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can bind our links to the appropriate routes in the landing page. Modify
    `landing.component.html` as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的链接绑定到着陆页面的适当路由上。修改`landing.component.html`如下所示：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Awesome! Within a few minutes, and with the help of the amazing Angular CLI
    and Angular router, we were able to create a landing page, two feature modules,
    and feature routes (although eagerly loaded) and we styled some stuff as well.
    The wonders of the modern web!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！在短短几分钟内，借助令人惊叹的Angular CLI和Angular路由器的帮助，我们能够创建一个着陆页面、两个特性模块和特性路由（尽管是急加载的），并且我们也对一些东西进行了样式化。现代网络的奇迹！
- en: Now that you know how basic routing is implemented, see the next section to
    understand how it works.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道了基本路由是如何实现的，接下来请查看下一节以了解它是如何工作的。
- en: How it works…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When we use the `--routing` argument while creating the app, or when creating
    a module, the Angular CLI automatically creates a module file named `<your module>-routing.module.ts`.
    This file basically contains a routing module. In this recipe, we just created
    the feature modules without routing to keep the implementation simpler and faster.
    In the next recipe, you''ll learn about routes within modules as well. Anyway,
    since we''ve created the eagerly loaded feature modules, this means that all the
    JavaScript of all the feature modules loads as soon as the app is loaded. You
    can inspect the **Network** tab in Chrome DevTools and see the content of the
    `main.js` file since it contains all our components and modules. See the following
    screenshot, which shows both the `AboutComponent` and `HomeComponent` code in
    the `main.js` file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在创建应用程序时使用`--routing`参数，或者在创建模块时，Angular CLI会自动创建一个名为`<your module>-routing.module.ts`的模块文件。该文件基本上包含一个路由模块。在这个示例中，我们只是创建了特性模块而没有路由，以使实现更简单和更快。在下一个示例中，您还将了解有关模块内路由的信息。无论如何，由于我们已经创建了急切加载的特性模块，这意味着所有特性模块的JavaScript都会在应用程序加载时加载。您可以检查Chrome
    DevTools中的**Network**选项卡，并查看`main.js`文件的内容，因为它包含了所有我们的组件和模块。请参阅以下屏幕截图，其中显示了`main.js`文件中`AboutComponent`和`HomeComponent`的代码：
- en: '![Figure 7.1 – main.js containing AboutComponent and HomeComponent code'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 - 包含AboutComponent和HomeComponent代码的main.js'
- en: '](image/Figure_7.1_B15150.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.1_B15150.jpg)'
- en: Figure 7.1 – main.js containing AboutComponent and HomeComponent code
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 - 包含AboutComponent和HomeComponent代码的main.js
- en: Since we've established that all our components in the recipe are loaded eagerly
    on the app start, it is necessary to understand that it happens because we import
    `HomeModule` and `AboutModule` in the `imports` array of `AppModule`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经确定了在应用程序启动时所有示例中的组件都是急切加载的，因此有必要了解这是因为我们在`AppModule`的`imports`数组中导入了`HomeModule`和`AboutModule`。
- en: See also
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Angular router docs ([https://angular.io/guide/router](https://angular.io/guide/router))
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular路由器文档（[https://angular.io/guide/router](https://angular.io/guide/router)）
- en: Feature modules and lazily loaded routes
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性模块和延迟加载路由
- en: In the previous recipe, we learned how to create a basic routing app with eagerly
    loaded routes. In this recipe, you'll learn how to work with feature modules to
    lazily load them instead of loading them when the app loads. For this recipe,
    we'll assume that we already have the routes in place and we just need to load
    them lazily.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们学习了如何创建一个具有急切加载路由的基本路由应用程序。在这个示例中，您将学习如何使用特性模块来延迟加载它们，而不是在应用程序加载时加载它们。对于这个示例，我们将假设我们已经有了路由，并且只需要延迟加载它们。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter07/start_here/lazy-loading-modules`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的项目位于`chapter07/start_here/lazy-loading-modules`中：
- en: Open the project in Visual Studio Code.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see the app as
    follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新的浏览器选项卡中打开应用程序，您应该看到应用程序如下所示：
- en: '![Figure 7.2 – lazy-loading-modules app running on http://localhost:4200'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 - lazy-loading-modules应用程序运行在http://localhost:4200'
- en: '](image/Figure_7.2_B15150.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.2_B15150.jpg)'
- en: Figure 7.2 – lazy-loading-modules app running on http://localhost:4200
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 - lazy-loading-modules应用程序运行在http://localhost:4200
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，让我们在下一节中看看这个示例的步骤。
- en: How to do it…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'As shown in *Figure 7.2*, we have all the components and modules inside the
    `main.js` file. Therefore, we have about 23.4 KB in size for the `main.js` file.
    We''ll modify the code and the routing structure to achieve lazy loading. As a
    result, we''ll have the particular files of the routes loading when we actually
    navigate to them:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图7.2*所示，我们在`main.js`文件中有所有的组件和模块。因此，`main.js`文件的大小约为23.4 KB。我们将修改代码和路由结构以实现懒加载。结果，当我们实际导航到它们时，路由的特定文件将被加载：
- en: 'First, we have to make our target modules capable of being lazily loaded. For
    that, we''ll have to create a `<module>-routing.module.ts` file for both `AboutModule`
    and `HomeModule`. So, let''s create a new file in both the `about` and `home`
    folders:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须使我们的目标模块能够被懒加载。为此，我们将不得不为`AboutModule`和`HomeModule`分别创建一个`<module>-routing.module.ts`文件。因此，让我们在`about`和`home`文件夹中都创建一个新文件：
- en: 'a) Name the first file `about-routing.module.ts` and add the following code
    to it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: a) 将第一个文件命名为`about-routing.module.ts`，并向其中添加以下代码：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'b) Name the second file `home-routing.module.ts` and add the following code
    to it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: b) 将第二个文件命名为`home-routing.module.ts`，并向其中添加以下代码：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we''ll add these routing modules to the appropriate modules, that is,
    we''ll import `HomeRoutingModule` in `HomeModule` as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将这些路由模块添加到相应的模块中，也就是说，我们将在`HomeModule`中导入`HomeRoutingModule`，如下所示：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add `AboutRoutingModule` in `AboutModule` as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AboutModule`中添加`AboutRoutingModule`，如下所示：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our modules are now capable of being lazily loaded. We just need to lazy load
    them now. In order to do so, we need to modify `app-routing.module.ts` and change
    our configurations to use the ES6 imports for the `about` and `home` routes, as
    follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的模块现在能够被懒加载。我们现在只需要懒加载它们。为了这样做，我们需要修改`app-routing.module.ts`并更改我们的配置，以便在`about`和`home`路由中使用ES6导入，如下所示：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we will remove the `AboutModule` and `HomeModule` imports from the
    `imports` array of `AppModule` so that we get the desired code-splitting out of
    the box. The content of `app.module.ts` should look as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将从`AppModule`的`imports`数组中移除`AboutModule`和`HomeModule`的导入，以便我们可以直接获得所需的代码拆分。`app.module.ts`的内容应如下所示：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Refresh the app and you''ll see that the bundle size for the `main.js` file
    is down to 18.1 KB, which was about 23.4 KB before. See the following screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新应用程序，您会看到`main.js`文件的捆绑大小已经降至18.1 KB，之前大约为23.4 KB。请参阅以下截图：
- en: '![Figure 7.3 – Reduced size of main.js on app load'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 - 应用程序加载时main.js的大小减小'
- en: '](image/Figure_7.3_B15150.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.3_B15150.jpg)'
- en: Figure 7.3 – Reduced size of main.js on app load
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 - 应用程序加载时main.js的大小减小
- en: 'But what about the Home and About routes? And what about lazy loading? Well,
    tap the **Home** route from the header and you''ll see a new JavaScript file being
    downloaded in the **Network** tab specifically for the route. That''s lazy loading
    in action! See the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但是主页和关于路由呢？懒加载呢？嗯，从标题中点击**主页**路由，您会看到专门为该路由在**网络**选项卡中下载的新JavaScript文件。这就是懒加载的作用！请参阅以下截图：
- en: '![Figure 7.4 – home route being lazily loaded'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 - 主页路由被懒加载'
- en: '](image/Figure_7.4_B15150.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.4_B15150.jpg)'
- en: Figure 7.4 – home route being lazily loaded
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 - 主页路由被懒加载
- en: Awesomesauce! You just became lazy! Just kidding. You just learned the art of
    lazily loading routes and feature modules in your Angular app. You can now show
    this off to your friends as well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你刚刚变得懒惰了！开玩笑的。你刚刚学会了在你的Angular应用程序中懒加载路由和特性模块的艺术。现在你也可以向你的朋友展示这个。
- en: How it works…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Angular works with modules and usually the features are broken down into modules.
    As we know, `AppModule` serves as the entry point for the Angular app and Angular
    will import and bundle anything that is imported in `AppModule` during the build
    process, resulting in the `main.js` file. However, if we want to lazy load our
    routes/feature modules, we need to avoid importing feature modules in `AppModule`
    directly and use the `loadChildren` method for our routes to load the feature
    modules instead, on-demand. That''s what we did in this recipe. It is important
    to note that the routes stayed the same in `AppRoutingModule`. However, we had
    to put `path: ''''` in our feature routing modules since that''ll combine the
    route in `AppRoutingModule` and then in the feature routing module to become what''s
    defined in `AppRoutingModule`. That''s why our routes were still `''about''` and
    `''home''`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 'Angular 使用模块，通常将功能分解为模块。正如我们所知，`AppModule` 作为 Angular 应用的入口点，Angular 将在构建过程中导入和捆绑在
    `AppModule` 中导入的任何内容，从而生成 `main.js` 文件。然而，如果我们想要延迟加载我们的路由/功能模块，我们需要避免直接在 `AppModule`
    中导入功能模块，并使用 `loadChildren` 方法来加载功能模块的路由，以实现按需加载。这就是我们在这个示例中所做的。需要注意的是，路由在 `AppRoutingModule`
    中保持不变。但是，我们必须在我们的功能路由模块中放置 `path: ''''`，因为这将合并 `AppRoutingModule` 中的路由和功能路由模块中的路由，从而成为
    `AppRoutingModule` 中定义的内容。这就是为什么我们的路由仍然是 `''about''` 和 `''home''`。'
- en: See also
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Lazy loading modules in Angular ([https://angular.io/guide/lazy-loading-ngmodules](https://angular.io/guide/lazy-loading-ngmodules))
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Angular 中延迟加载模块（[https://angular.io/guide/lazy-loading-ngmodules](https://angular.io/guide/lazy-loading-ngmodules)）
- en: Authorized access to routes using route guards
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由守卫授权访问路由
- en: Not all routes in your Angular app should be accessible by everyone in the world.
    In this recipe, we'll learn how to create route guards in Angular to prevent unauthorized
    access to routes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 Angular 应用程序中并非所有路由都应该被世界上的每个人访问。在这个示例中，我们将学习如何在 Angular 中创建路由守卫，以防止未经授权的访问路由。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter07/start_here/using-route-guards`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的项目位于 `chapter07/start_here/using-route-guards` 中：
- en: Open the project in Visual Studio Code.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行 `ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see the app as
    follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签中打开应用程序，您应该看到应用程序如下：
- en: '![Figure 7.5 – using-route-guards app running on http://localhost:4200'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5 – using-route-guards 应用程序运行在 http://localhost:4200'
- en: '](image/Figure_7.5_B15150.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.5_B15150.jpg)'
- en: Figure 7.5 – using-route-guards app running on http://localhost:4200
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – using-route-guards 应用程序运行在 http://localhost:4200
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序在本地运行，让我们在下一节中看到示例的步骤。
- en: How to do it…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We have an app with a couple of routes already set up. You can log in as either
    an employee or an admin to get to the bucket list of the app. However, if you
    tap any of the two buttons in the header, you''ll see that you can navigate to
    the Admin and Employee sections even without being logged in. This is what we
    want to prevent from happening. Notice in the `auth.service.ts` file that we already
    have a way for the user to do a login, and we can check whether the user is logged
    in or not using the `isLoggedIn()` method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了一个带有一些路由的应用程序。您可以以员工或管理员身份登录以查看应用程序的待办事项清单。但是，如果您点击标题中的任何两个按钮，您会发现即使没有登录，您也可以导航到管理员和员工部分。这就是我们要防止发生的事情。请注意，在
    `auth.service.ts` 文件中，我们已经有了用户登录的方式，并且我们可以使用 `isLoggedIn()` 方法来检查用户是否已登录。
- en: 'First, let''s create a route guard that will only allow the user to go to the
    particular routes if the user is logged in. We''ll name it `AuthGuard`. Let''s
    create it by running the following command in the project root:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个路由守卫，只有在用户登录时才允许用户转到特定的路由。我们将其命名为`AuthGuard`。通过在项目根目录中运行以下命令来创建它：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once the command is run, you should be able to see some options to select which
    interfaces we'd like to implement.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，您应该能够看到一些选项，选择我们想要实现的接口。
- en: Select the `CanActivate` interface and press *Enter*.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`CanActivate`接口并按“Enter”。
- en: 'Now, add the following logic to the `auth.guard.ts` file to check whether the
    user is logged in, and if the user is not logged in, we''ll redirect the user
    to the login page, which is the `''/auth''` route:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`auth.guard.ts`文件中添加以下逻辑来检查用户是否已登录，如果用户未登录，我们将重定向用户到登录页面，即`'/auth'`路由：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s apply `AuthGuard` to our Admin and Employee routes in the `app-routing.module.ts`
    file, as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`app-routing.module.ts`文件中为Admin和Employee路由应用`AuthGuard`，如下所示：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you now log out and try to tap either the **Employee Section** or **Admin
    Section** buttons in the header, you'll notice that you're now not able to go
    to the routes until you log in. The same is the case if you try to enter the URL
    directly for the routes in the address bar and hit *Enter*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在注销并尝试点击标题中的“员工部门”或“管理员部门”按钮，您会注意到在登录之前无法转到路由。如果您尝试直接在地址栏中输入路由的URL并按“Enter”，情况也是如此。
- en: 'Now we''ll try to create a guard, one for the Employee route and one for the
    Admin route. Run the following commands one by one and select the `CanActivate`
    interface for both the guards:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将尝试创建一个守卫，一个用于员工路由，一个用于管理员路由。依次运行以下命令，并为两个守卫选择`CanActivate`接口：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since we have the guards created, let''s put the logic for `AdminGuard` first.
    We''ll try to see what type of user has logged in. If it is an admin, then we
    allow the navigation, else we prevent it. Add the following code to `admin.guard.ts`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们已经创建了守卫，让我们首先为`AdminGuard`放置逻辑。我们将尝试查看已登录的用户类型。如果是管理员，则允许导航，否则我们会阻止它。在`admin.guard.ts`中添加以下代码：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add `AdminGuard` to the Admin route in `app-routing.module.ts` as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app-routing.module.ts`中的Admin路由中添加`AdminGuard`如下：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Try to log out and log in as an employee now. Then try tapping the **Admin Section**
    button in the header. You'll notice that you can't go to the Admin section of
    the bucket list anymore. This is because we have `AdminGuard` in place and you're
    not logged in as an admin right now. Logging in as an admin should work just fine.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试注销并以员工身份登录。然后尝试点击标题中的“管理员部门”按钮。您会注意到您现在无法转到清单的管理员部分。这是因为我们已经放置了`AdminGuard`，而您现在并未以管理员身份登录。以管理员身份登录应该可以正常工作。
- en: 'Similarly, we''ll add the following code to `employee.guard.ts`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们将在`employee.guard.ts`中添加以下代码：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, add `EmployeeGuard` to the Employee route in `app-routing.module.ts` as
    follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`app-routing.module.ts`中的Employee路由中添加`EmployeeGuard`如下：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, only the appropriate routes should be accessible by checking which type
    of user is logged in.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只有适当的路由应该可以通过检查已登录的用户类型来访问。
- en: Great! You now are an authorization expert when it comes to guarding routes.
    With great power comes great responsibility. Use it wisely.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在在保护路由方面，您是一个授权专家。伴随着强大的力量，也伴随着巨大的责任。明智地使用它。
- en: How it works…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `CanActivate` interface of the route guards is the heart of our recipe because
    it corresponds to the fact that each route in Angular can have an array of guards
    for the `CanActivate` property of the route definition. When a guard is applied,
    it is supposed to return a Boolean value or a `UrlTree`. We've focused on the
    Boolean value's usage in our recipe. We can return the Boolean value directly
    using a promise or even using an Observable. This makes guards really flexible
    for use even with remote data. Anyway, for our recipe, we've kept it easy to understand
    by checking whether the user is logged in (for `AuthGuard`) and by checking whether
    the expected type of user is logged in for the particular routes (`AdminGuard`
    and `EmployeeGuard`).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 路由守卫的`CanActivate`接口是我们的配方的核心，因为它对应于Angular中每个路由都可以具有`CanActivate`属性的守卫数组的事实。当应用守卫时，它应该返回一个布尔值或`UrlTree`。我们在配方中专注于布尔值的使用。我们可以直接使用promise或者使用Observable来返回布尔值。这使得守卫即使在远程数据中也非常灵活。无论如何，对于我们的配方，我们通过检查用户是否已登录（对于`AuthGuard`）以及检查特定路由是否已登录预期类型的用户（`AdminGuard`和`EmployeeGuard`）来使其易于理解。
- en: See also
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Preventing unauthorized access in Angular routes ([https://angular.io/guide/router#preventing-unauthorized-access](https://angular.io/guide/router#preventing-unauthorized-access))
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular路由中防止未经授权的访问（[https://angular.io/guide/router#preventing-unauthorized-access](https://angular.io/guide/router#preventing-unauthorized-access)）
- en: Working with route parameters
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由参数
- en: Whether it is about building a REST API using Node.js or configuring routes
    in Angular, setting up routes is an absolute art, especially when it comes to
    working with parameters. In this recipe, you'll create some routes with parameters
    and will learn how to get those parameters in your components once the route is
    active.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是构建使用Node.js的REST API还是配置Angular中的路由，设置路由都是一门绝对的艺术，特别是在处理参数时。在这个配方中，您将创建一些带参数的路由，并学习如何在路由激活后在组件中获取这些参数。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter07/start_here/working-with-route-params`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的项目位于`chapter07/start_here/working-with-route-params`中：
- en: Open the project in Visual Studio Code.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: This should open the app in a new browser tab. As soon as the page is opened,
    you should see a list of users.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签中打开应用程序。一旦页面打开，你应该看到一个用户列表。
- en: 'Tap the first user, and you should see the following view:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击第一个用户，你应该看到以下视图：
- en: '![Figure 7.6 – user-details not bringing the correct user'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 - 用户详细信息未带来正确的用户'
- en: '](image/Figure_7.6_B15150.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.6_B15150.jpg)'
- en: Figure 7.6 – user-details not bringing the correct user
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 - 用户详细信息未带来正确的用户
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，让我们在下一节中看看配方的步骤。
- en: How to do it…
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The problem right now is that we have a route for opening the user details,
    but we don''t have any idea in `UserDetailComponent` about which user was clicked,
    that is, which user to fetch from the service. Therefore, we''ll implement the
    route parameters to pass the user''s ID (`uuid`) from the home page to the user
    details page:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的问题是，我们有一个用于打开用户详细信息的路由，但在`UserDetailComponent`中我们不知道点击了哪个用户，也就是说，从服务中获取哪个用户。因此，我们将实现路由参数，将用户的ID（`uuid`）从主页传递到用户详细信息页面：
- en: 'First, we have to make our user route capable of accepting the route parameter
    named `uuid`. This is going to be a **required** parameter, which means the route
    will not work without passing this. Let''s modify `app-routing.module.ts` to add
    this required parameter to the route definition, as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须使我们的用户路由能够接受名为`uuid`的路由参数。这将是一个**必需**参数，这意味着没有传递这个参数，路由将无法工作。让我们修改`app-routing.module.ts`来添加这个必需参数到路由定义中，如下所示：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With this change, clicking on a user on the home page will not work anymore.
    If you try it, you''ll see an error as follows and that''s because `uuid` is a
    required parameter:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个改变，在主页上点击用户将不再起作用。如果你尝试，你会看到以下错误，因为`uuid`是一个必需的参数：
- en: '![Figure 7.7 – Angular complaining about not being able to match the requested
    route'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 - Angular抱怨无法匹配请求的路由'
- en: '](image/Figure_7.7_B15150.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.7_B15150.jpg)'
- en: Figure 7.7 – Angular complaining about not being able to match the requested
    route
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 - Angular抱怨无法匹配请求的路由
- en: 'The fix is easy for the error; we need to pass the `uuid` when navigating to
    the user route. Let''s do this by modifying the `user-card.component.ts` file
    as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误的修复很容易；我们需要在导航到用户路由时传递`uuid`。让我们通过修改`user-card.component.ts`文件来实现这一点：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We''re now able to navigate to a particular user''s route, and you should also
    be able to see the UUID in the address bar as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够导航到特定用户的路由，并且你也应该能够在地址栏中看到UUID，如下所示：
- en: '![Figure 7.8 – The UUID being shown in the address bar'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8 - UUID显示在地址栏中'
- en: '](image/Figure_7.8_B15150.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.8_B15150.jpg)'
- en: Figure 7.8 – The UUID being shown in the address bar
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 - UUID显示在地址栏中
- en: 'To get the current user from `UserService`, we need to get the `uuid` value
    in `UserDetailComponent`. Right now, we''re sending `null` when calling the `getUser`
    method of `UserService` from `UserDetailComponent`. In order to use the user''s
    ID, we can fetch the `uuid` value from the route parameters by importing the `ActivatedRoute`
    service. Update `user-detail.component.ts` as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从`UserService`中获取当前用户，我们需要在`UserDetailComponent`中获取`uuid`值。现在，当从`UserDetailComponent`调用`UserService`的`getUser`方法时，我们发送的是`null`。为了使用用户的ID，我们可以通过导入`ActivatedRoute`服务从路由参数中获取`uuid`值。更新`user-detail.component.ts`如下：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We''ll create a new method named `getUserAndSimilarUsers` in `UserDetailComponent`
    and move the code from the `ngOnInit` method into the new method as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`UserDetailComponent`中创建一个名为`getUserAndSimilarUsers`的新方法，并将代码从`ngOnInit`方法移动到新方法中，如下所示：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we have the code refactored a bit, let''s try to access the `uuid`
    from the route parameters using the `ActivatedRoute` service, and pass it into
    our `getUserAndSimilarUsers` method as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经对代码进行了一些重构，让我们尝试使用`ActivatedRoute`服务从路由参数中访问`uuid`，并将其传递到我们的`getUserAndSimilarUsers`方法中，如下所示：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Grrreat!! With this change, you can try refreshing the app on the home page
    and then click any user. You should see the current user as well as similar users
    being loaded. To understand all the magic behind the recipe, see the next section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！通过这个改变，你可以尝试在主页上刷新应用，然后点击任何用户。你应该能够看到当前用户以及加载的相似用户。要了解食谱背后的所有魔法，请参见下一节。
- en: How it works…
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: It all begins when we change our route's path to `user/:userId`. This makes
    `userId` a required parameter for our route. The other piece of the puzzle is
    to retrieve this parameter in `UserDetailComponent` and then use it to get the
    target user, as well as similar users. For that, we use the `ActivatedRoute` service.
    The `ActivatedRoute` service holds a lot of necessary information about the current
    route and, therefore, we were able to fetch the current route's `uuid` parameter
    by subscribing to the `paramMap` Observable, so even if the parameter changes
    while staying on a user's page, we still execute the necessary operations. Notice
    that we also create a property named `componentIsAlive`. As you might have seen
    in our prior recipes, we use it in conjunction with the `takeWhile` operator to
    automatically unsubscribe from the Observable streams as soon as the user navigates
    away from the page, or essentially when the component is destroyed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都始于我们将路由路径更改为 `user/:userId`。这使得 `userId` 成为我们路由的必需参数。拼图的另一部分是在 `UserDetailComponent`
    中检索此参数，然后使用它来获取目标用户，以及类似的用户。为此，我们使用 `ActivatedRoute` 服务。`ActivatedRoute` 服务包含了关于当前路由的许多必要信息，因此我们能够通过订阅
    `paramMap` 可观察对象来获取当前路由的 `uuid` 参数，因此即使在用户页面停留时参数发生变化，我们仍然执行必要的操作。请注意，我们还创建了一个名为
    `componentIsAlive` 的属性。正如您在我们之前的示例中所看到的，我们将它与 `takeWhile` 操作符一起使用，以便在用户从页面导航离开或组件被销毁时自动取消订阅可观察流。
- en: See also
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Tour of Heroes tutorial – sample usage of the `ActivatedRoute` service ([https://angular.io/guide/router-tutorial-toh#route-parameters-in-the-activatedroute-service](https://angular.io/guide/router-tutorial-toh#route-parameters-in-the-activatedroute-service))
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英雄之旅教程 - `ActivatedRoute` 服务的示例用法（[https://angular.io/guide/router-tutorial-toh#route-parameters-in-the-activatedroute-service](https://angular.io/guide/router-tutorial-toh#route-parameters-in-the-activatedroute-service)）
- en: Link parameters array – Angular docs ([https://angular.io/guide/router#link-parameters-array](https://angular.io/guide/router#link-parameters-array))
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接参数数组 - Angular文档（[https://angular.io/guide/router#link-parameters-array](https://angular.io/guide/router#link-parameters-array)）
- en: Showing a global loader between route changes
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在路由更改之间显示全局加载程序
- en: Building user interfaces that are snappy and fast is key to winning users. The
    apps become much more enjoyable for the end users and it could bring a lot of
    value to the owners/creators of the apps. One of the core experiences on the modern
    web is to show a loader when something is happening in the background. In this
    recipe, you'll learn how to create a global user interface loader in your Angular
    app that shows whenever there is a route transition in the app.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 构建快速响应的用户界面对于赢得用户至关重要。对于最终用户来说，应用程序变得更加愉快，对于应用程序的所有者/创建者来说，这可能带来很多价值。现代网络的核心体验之一是在后台发生某些事情时显示加载程序。在这个示例中，您将学习如何在您的Angular应用程序中创建一个全局用户界面加载程序，每当应用程序中发生路由转换时都会显示。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter07/start_here/routing-global-loader`
    inside the cloned repository:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的项目位于克隆存储库中的 `chapter07/start_here/routing-global-loader` 中：
- en: Open the project in Visual Studio Code.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 以安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行 `ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see it as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签页中打开应用程序，您应该会看到如下所示：
- en: '![Figure 7.9 – routing-global-loader app running on http://localhost:4200'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9 - routing-global-loader 应用程序正在 http://localhost:4200 上运行'
- en: '](image/Figure_7.9_B15150.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.9_B15150.jpg)'
- en: Figure 7.9 – routing-global-loader app running on http://localhost:4200
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 - routing-global-loader 应用程序正在 http://localhost:4200 上运行
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，让我们在下一节中看一下这个示例的步骤。
- en: How to do it…
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'For this recipe, we have the bucket app with a couple of routes in it. We also
    have `LoaderComponent` already created, which we have to use during the route
    changes:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们有一个包含几个路由的应用程序。我们已经创建了`LoaderComponent`，在路由更改期间我们必须使用它：
- en: 'We''ll begin showing `LoaderComponent` by default in the entire app. To do
    that, add the `<app-loader>` selector in the `app.component.html` file right before
    the `div` with the `content` class as follows:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从整个应用程序默认显示`LoaderComponent`开始。为此，请在`app.component.html`文件中在具有`content`类的`div`之前添加`<app-loader>`选择器，如下所示：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we''ll create a property in the `AppComponent` class to show the loader
    conditionally. We''ll mark this property as `true` during the routing and will
    mark it as `false` when the routing is finished. Create the property as follows
    in the `app.component.ts` file:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`AppComponent`类中创建一个属性来有条件地显示加载程序。我们将在路由期间将此属性标记为`true`，并在路由完成时将其标记为`false`。在`app.component.ts`文件中创建属性如下：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We''ll now make sure that `<app-loader>` is shown only when the `isLoadingRoute`
    property is `true`. To do that, update the `app.component.html` template file
    to include an `*ngIf` statement as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将确保只有在`isLoadingRoute`属性为`true`时才显示`<app-loader>`。为此，请更新`app.component.html`模板文件，包括以下`*ngIf`语句：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that the `*ngIf` statement is in place, we need to set the `isLoadingRoute`
    property to `true` somehow. To do that, we''ll listen to the router service''s
    `events` property, and take an action upon the `NavigationStart` event. Modify
    the code in the `app.component.ts` file as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`*ngIf`语句已经就位，我们需要以某种方式将`isLoadingRoute`属性设置为`true`。为了做到这一点，我们将监听路由服务的`events`属性，并在`NavigationStart`事件发生时采取行动。修改`app.component.ts`文件中的代码如下：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you refresh the app, you'll notice that `<app-loader>` never goes away. It
    is now being shown forever. That's because we're not marking the `isLoadingRoute`
    property as `false` anywhere.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刷新应用程序，您会注意到`<app-loader>`永远不会消失。它现在一直显示着。这是因为我们没有在任何地方将`isLoadingRoute`属性标记为`false`。
- en: 'To mark `isLoadingRoute` as `false`, we need to check for three different events:
    `NavigationEnd`, `NavigationError`, and `NavigationCancel`. Let''s add some more
    logic to handle these three events and mark the property as `false`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将`isLoadingRoute`标记为`false`，我们需要检查三种不同的事件：`NavigationEnd`，`NavigationError`和`NavigationCancel`。让我们添加一些逻辑来处理这三个事件，并将属性标记为`false`：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: And boom! We now have a global loader that shows during the route navigation
    among different pages.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后！我们现在有一个全局加载程序，在不同页面之间的路由导航期间显示。
- en: Important note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When running the app locally, you experience the best internet conditions possible
    (especially if you're not fetching remote data). Therefore, you might not see
    the loader at all or might see it for only a fraction of a second. In order to
    see it for a longer period, open Chrome DevTools, go to the **Network** tab, simulate
    slow 3G, refresh the app, and then navigate between routes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地运行应用程序时，您将体验到可能是最佳的互联网条件（特别是如果您没有获取远程数据）。因此，您可能根本看不到加载程序，或者只能看到它一小部分时间。为了能够更长时间地看到它，请打开Chrome
    DevTools，转到**网络**选项卡，模拟缓慢的3G，刷新应用程序，然后在路由之间导航。
- en: If the routes have static data, then you'll only see the loader the first time
    you navigate to that route. The next time you navigate to the same route, it would
    already have been cached, so the global loader might not show.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路由具有静态数据，那么您只会在首次导航到该路由时看到加载程序。下次导航到相同的路由时，它可能已经被缓存，因此全局加载程序可能不会显示。
- en: Congrats on finishing the recipe. You now can implement a global loader in Angular
    apps, which will show from the navigation start to the navigation end.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜完成了这个示例。现在你可以在Angular应用程序中实现一个全局加载器，它将从导航开始到导航结束都会显示。
- en: How it works…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The router service is a very powerful service in Angular. It has a lot of methods
    as well as Observables that we can use for different tasks in our apps. For this
    recipe, we used the `events` Observable. By subscribing to the `events` Observable,
    we can listen to all the events that the `Router` service emits through the Observable.
    For this recipe, we were only interested in the `NavigationStart`, `NavigationEnd`,
    `NavigationError`, and `NavigationCancel` events. The `NavigationStart` event
    is emitted when the router starts navigation. The `NavigationEnd` event is emitted
    when the navigation ends successfully. The `NavigationCancel` event is emitted
    when the navigation is canceled due to a **route guard** returning `false`, or
    redirects by using `UrlTree` due to some reason. The `NavigationError` event is
    emitted when there's an error due to any reason during the navigation. All of
    these events are of the `Event` type and we can identify the type of the event
    by checking whether it is an instance of the target event, using the `instanceof`
    keyword. Notice that since we had the subscription to the `Router.events` property
    in `AppComponent`, we didn't have to worry about unsubscribing the subscription
    because there's only one subscription in the app, and `AppComponent` will not
    be destroyed throughout the life cycle of the app.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器服务是Angular中非常强大的服务。它有很多方法以及我们可以在应用程序中用于不同任务的Observables。对于这个示例，我们使用了`events`
    Observable。通过订阅`events` Observable，我们可以监听`Router`服务通过Observable发出的所有事件。对于这个示例，我们只对`NavigationStart`、`NavigationEnd`、`NavigationError`和`NavigationCancel`事件感兴趣。`NavigationStart`事件在路由器开始导航时发出。`NavigationEnd`事件在导航成功结束时发出。`NavigationCancel`事件在导航由于**路由守卫**返回`false`或由于某种原因使用`UrlTree`而被取消时发出。`NavigationError`事件在导航期间由于任何原因出现错误时发出。所有这些事件都是`Event`类型的，我们可以通过检查它是否是目标事件的实例来确定事件的类型，使用`instanceof`关键字。请注意，由于我们在`AppComponent`中订阅了`Router.events`属性，我们不必担心取消订阅，因为应用程序中只有一个订阅，而且`AppComponent`在应用程序的整个生命周期中都不会被销毁。
- en: See also
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Router events docs ([https://angular.io/guide/router#router-events](https://angular.io/guide/router#router-events))
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器事件文档（[https://angular.io/guide/router#router-events](https://angular.io/guide/router#router-events)）
- en: Router service docs ([https://angular.io/api/router/Router](https://angular.io/api/router/Router))
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器服务文档（[https://angular.io/api/router/Router](https://angular.io/api/router/Router)）
- en: Preloading route strategies
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预加载路由策略
- en: We're already familiar with how to lazy load different feature modules upon
    navigation. Although sometimes, you might want to preload subsequent routes to
    make the next route navigation instantaneous or might even want to use a custom
    preloading strategy based on your application's business logic. In this recipe,
    you'll learn about the `PreloadAllModules` strategy and will also implement a
    custom strategy to cherry-pick which modules should be preloaded.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了如何在导航时延迟加载不同的特性模块。尽管有时，您可能希望预加载后续路由，以使下一个路由导航即时进行，甚至可能希望根据应用程序的业务逻辑使用自定义预加载策略。在这个示例中，您将了解`PreloadAllModules`策略，并将实现一个自定义策略来精选应该预加载哪些模块。
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter07/start_here/route-preloading-strategies`
    inside the cloned repository:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的项目位于克隆存储库中的`chapter07/start_here/route-preloading-strategies`中：
- en: Open the project in Visual Studio Code.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab and you should see something
    like the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签中打开应用程序，你应该看到类似以下的内容：
- en: '![Figure 7.10 – route-preloading-strategies app running on http://localhost:4200'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10 - 在http://localhost:4200上运行的route-preloading-strategies应用程序'
- en: '](image/Figure_7.10_B15150.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.10_B15150.jpg)'
- en: Figure 7.10 – route-preloading-strategies app running on http://localhost:4200
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 - 在http://localhost:4200上运行的route-preloading-strategies应用程序
- en: Open Chrome DevTools by pressing *Ctrl* + *Shift* + *C* on Windows or *Cmd*
    + *Shift* + *C* on Mac.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *Shift* + *C*在Windows上或*Cmd* + *Shift* + *C*在Mac上打开Chrome DevTools。
- en: 'Navigate to the **Network** tab and filter on JavaScript files only. You should
    see something like this:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**网络**选项卡，并仅筛选JavaScript文件。你应该看到类似这样的内容：
- en: '![Figure 7.11 – JavaScript files loaded on app load'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.11 - 应用加载时加载的JavaScript文件'
- en: '](image/Figure_7.11_B15150.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.11_B15150.jpg)'
- en: Figure 7.11 – JavaScript files loaded on app load
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 - 应用加载时加载的JavaScript文件
- en: Now that we have the app running locally, let's see the next section for this
    recipe
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，让我们看看下一节
- en: How to do it…
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Notice in *Figure 7.11* how we''re automatically loading the `auth-auth-module.js`
    file since we''re logged out. Although the routes in `AuthModule` are all configured
    to be lazily loaded, we can still look into what happens if we use the `PreloadAllModules`
    strategy, and then a custom preload strategy:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意*图7.11*中我们如何在注销状态下自动加载`auth-auth-module.js`文件。尽管`AuthModule`中的路由都配置为惰性加载，但我们仍然可以看看如果我们使用`PreloadAllModules`策略，然后自定义预加载策略会发生什么：
- en: 'We''re going to try out the `PreloadAllModules` strategy first. To use it,
    let''s modify the `app-routing.module.ts` file as follows:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先尝试`PreloadAllModules`策略。要使用它，让我们修改`app-routing.module.ts`文件如下：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you refresh the app, you should see not only the `auth-auth-module.js` file
    but also the module files for Admin and Employee, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果刷新应用程序，你应该看到不仅`auth-auth-module.js`文件，还有Admin和Employee的模块文件，如下所示：
- en: '![Figure 7.12 – JavaScript files loaded with the PreloadAllModules strategy'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.12 - 使用PreloadAllModules策略加载的JavaScript文件'
- en: '](image/Figure_7.12_B15150.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.12_B15150.jpg)'
- en: Figure 7.12 – JavaScript files loaded with the PreloadAllModules strategy
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 - 使用PreloadAllModules策略加载的JavaScript文件
- en: So far so good. But what if we wanted to preload only the Admin module, supposing
    our app is intended for admins mostly? We'll create a custom preload strategy
    for that.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。但是如果我们只想预加载Admin模块，假设我们的应用主要面向管理员？我们将为此创建一个自定义预加载策略。
- en: 'Let''s create a service named `CustomPreloadStrategy` by running the following
    command in our project:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过在项目中运行以下命令来创建一个名为`CustomPreloadStrategy`的服务：
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In order to use our preload strategy service with Angular, our service needs
    to implement the `PreloadingStrategy` interface from the `@angular/router` package.
    Modify the newly created service as follows:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在Angular中使用我们的预加载策略服务，我们的服务需要实现`@angular/router`包中的`PreloadingStrategy`接口。修改新创建的服务如下：
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we need to implement the `preload` method from the `PreloadingStrategy`
    interface for our service to work properly. Let''s modify `CustomPreloadStrategyService`
    to implement the `preload` method, as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现我们的服务的`PreloadingStrategy`接口中的`preload`方法，以使其正常工作。让我们修改`CustomPreloadStrategyService`以实现`preload`方法，如下所示：
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Right now, our `preload` method returns `of(null)`. Instead, in order to decide
    which routes to preload, we''re going to add an object to our route definitions
    as the `data` object having a Boolean named `shouldPreload`. Let''s quickly do
    that by modifying `app-routing.module.ts` as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的`preload`方法返回`of(null)`。相反，为了决定要预加载哪些路由，我们将在我们的路由定义中添加一个对象作为`data`对象，其中包含一个名为`shouldPreload`的布尔值。让我们通过修改`app-routing.module.ts`来快速完成这一点：
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'All the routes with `shouldPreload` set to `true` should be preloaded and if
    they are set to `false`, then they should not be preloaded. We''ll create two
    methods. One for the case where we want to preload a route and one for the route
    which we don''t want to preload a route. Let''s modify `custom-preload-strategy.service.ts`
    to add the methods as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有`shouldPreload`设置为`true`的路由应该被预加载，如果它们设置为`false`，那么它们就不应该被预加载。我们将创建两种方法。一种是我们想要预加载路由的情况，另一种是我们不想要预加载路由的情况。让我们修改`custom-preload-strategy.service.ts`，添加以下方法：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Awesome! Now we have to use the methods created in *Step 6* inside the `preload`
    method. Let''s modify the method to use the `shouldPreload` property of the `data`
    object from the route definitions. The code should look as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太棒了！现在我们必须在`preload`方法中使用*步骤6*中创建的方法。让我们修改方法，使用路由定义中`data`对象的`shouldPreload`属性。代码应该如下所示：
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The final step is to use our custom preload strategy. In order to do so, modify
    the `app-routing-module.ts` file as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是使用我们自定义的预加载策略。为了这样做，修改`app-routing-module.ts`文件如下：
- en: '[PRE46]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Voilà! If you refresh the app now and monitor the **Network** tab, you''ll
    notice that only the JavaScript files for Auth and Admin are preloaded, and there''s
    no preloading of the Employee module, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 看！如果您现在刷新应用并监视**网络**选项卡，您会注意到只有Auth和Admin的JavaScript文件被预加载，而Employee模块没有预加载，如下所示：
- en: '![Figure 7.13 – Preloading only the Auth and Admin modules using a custom preload
    strategy'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.13-仅使用自定义预加载策略预加载Auth和Admin模块'
- en: '](image/Figure_7.13_B15150.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.13_B15150.jpg)'
- en: Figure 7.13 – Preloading only the Auth and Admin modules using a custom preload
    strategy
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13-仅使用自定义预加载策略预加载Auth和Admin模块
- en: 'You can also have a look at the console logs to see which routes were preloaded.
    You should see the logs as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以查看控制台日志，查看哪些路由已经预加载。您应该看到以下日志：
- en: '![Figure 7.14 – Logs for preloading only the Auth and Admin modules'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.14-仅预加载Auth和Admin模块的日志'
- en: '](image/Figure_7.14_B15150.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.14_B15150.jpg)'
- en: Figure 7.14 – Logs for preloading only the Auth and Admin modules
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14-仅预加载Auth和Admin模块的日志
- en: Now that you've finished the recipe, see the next section on how this works.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经完成了这个教程，看看下一节关于这是如何工作的。
- en: How it works…
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Angular provides a great way to implement our own custom preloading strategy
    for our feature modules. We can decide easily which modules should be preloaded
    and which should not. In the recipe, we learned a very simple way to configure
    the preloading using the `data` object of the routes configuration by adding a
    property named `shouldPreload`. We created our own custom preload strategy service
    named `CustomPreloadStrategyService`, which implements the `PreloadingStrategy`
    interface from the `@angular/router` package. The idea is to use the `preload`
    method from the `PreloadingStrategy` interface, which allows us to decide whether
    a route should be preloaded. That's because Angular goes through each route using
    our custom preload strategy and decides which routes to preload. And that's it.
    We can now assign the `shouldPreload` property in the `data` object to any route
    we want to preload on app start.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了一种很好的方法来为我们的特性模块实现自定义预加载策略。我们可以很容易地决定哪些模块应该预加载，哪些不应该。在这个教程中，我们学习了一种非常简单的方法，通过在路由配置的`data`对象中添加一个名为`shouldPreload`的属性来配置预加载。我们创建了自己的自定义预加载策略服务，命名为`CustomPreloadStrategyService`，它实现了`@angular/router`包中的`PreloadingStrategy`接口。这个想法是使用`PreloadingStrategy`接口中的`preload`方法，它允许我们决定一个路由是否应该预加载。这是因为Angular会使用我们的自定义预加载策略遍历每个路由，并决定哪些路由应该预加载。就是这样。现在我们可以将`data`对象中的`shouldPreload`属性分配给我们想要在应用启动时预加载的任何路由。
- en: See also
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Route preloading strategies article on `web.dev` ([https://web.dev/route-preloading-in-angular/](https://web.dev/route-preloading-in-angular/))
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web.dev`上的路由预加载策略文章（[https://web.dev/route-preloading-in-angular/](https://web.dev/route-preloading-in-angular/)）'
