- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Handling Gestures in React Native
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React Native中处理手势
- en: One of the most important things that makes good apps stand out against bad
    apps or mobile websites is good gesture handling. While mobile websites only listen
    to simple clicks in most cases, apps can and should be controlled with different
    gestures such as short touches, long touches, swipes, pinching to zoom, or touches
    with multiple fingers. Using these gestures in a very intuitive way is one of
    the most important things to consider when developing an app.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使好的应用在众多不良应用或移动网站中脱颖而出的最重要的事情之一就是良好的手势处理。虽然大多数情况下移动网站只监听简单的点击，但应用可以通过不同的手势来控制，例如短按、长按、滑动、捏合缩放或多指触摸。以非常直观的方式使用这些手势是开发应用时需要考虑的最重要的事情之一。
- en: But it doesn’t stop with just listening to these gestures – you have to give
    an immediate response to the user so that they can see (and maybe abort) what
    they are doing. Some gestures need to trigger or control animations and therefore
    have to play together very well with the animation solutions we learned about
    in [*Chapter 6*](B16694_06.xhtml#_idTextAnchor130), *Working with Animations*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但不仅仅只是监听这些手势 – 你必须立即对用户做出响应，以便他们可以看到（并且可能取消）他们正在做的事情。一些手势需要触发或控制动画，因此必须与我们在[*第6章*](B16694_06.xhtml#_idTextAnchor130)中学习到的动画解决方案配合得非常好，即*与动画一起工作*。
- en: In React Native, there are multiple ways to handle gestures. From simple built-in
    components to very complex third-party gesture handling solutions, you have a
    lot of different options to choose from.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Native中，有多种处理手势的方法。从简单的内置组件到非常复杂的第三方手势处理解决方案，你有很多不同的选项可以选择。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Using built-in components to respond to user gestures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置组件来响应用户手势
- en: Working with the React Native gesture responder system and React Native `PanResponder`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与React Native手势响应系统以及React Native `PanResponder`一起工作
- en: Understanding React Native Gesture Handler
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解React Native手势处理器
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to run the code in this chapter, you have to set up the following
    things:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码，你必须设置以下事项：
- en: A working React Native environment ([bit.ly/prn-setup-rn](http://bit.ly/prn-setup-rn)
    – React Native CLI Quickstart)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可工作的React Native环境 ([bit.ly/prn-setup-rn](http://bit.ly/prn-setup-rn) – React
    Native CLI 快速入门)
- en: A real iOS or Android device for testing gestures and multitouch
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于测试手势和多点触控的真实的iOS或Android设备
- en: 'To access the code for this chapter, follow this link to the book’s GitHub
    repository:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章的代码，请点击以下链接进入本书的GitHub仓库：
- en: Using built-in components to respond to user gestures
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置组件来响应用户手势
- en: React Native ships with multiple components that have built-in gesture responder
    support. Basically, these components are an abstracted use of the gesture responder
    system, which you will learn about in the next section. The gesture responder
    system provides support for handling gestures in React Native, as well as support
    for negotiating which component should handle the user gesture.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: React Native附带多个具有内置手势响应支持的组件。基本上，这些组件是对手势响应系统的抽象使用，你将在下一节中学习。手势响应系统为处理React
    Native中的手势提供了支持，同时也支持协商哪个组件应该处理用户手势。
- en: The simplest user interaction is a tap with one finger. With different `Touchable`
    components, a `Pressable` component, and a `Button` component, React Native provides
    different options for how to recognize the tap and respond to the user interaction.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的用户交互是用一个手指点击。通过不同的`Touchable`组件、一个`Pressable`组件和一个`Button`组件，React Native提供了不同的选项来识别点击并响应用户交互。
- en: Using components to respond to simple taps
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用组件来响应简单的点击
- en: The simplest components to record user taps are the React Native `Touchable`
    components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 记录用户点击操作最简单的组件是React Native的`Touchable`组件。
- en: Working with Touchable components
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与`Touchable`组件一起工作
- en: 'React Native provides three different `Touchable` components on iOS and an
    extra fourth `Touchable` component just for Android:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: React Native在iOS上提供了三个不同的`Touchable`组件，以及一个仅适用于Android的额外第四个`Touchable`组件：
- en: '`TouchableOpacity`: Provides user feedback automatically by reducing the opacity
    of the tapped element (and all child elements), letting the underlying view shine
    through. You can configure the opacity reduction by setting `activeOpacity`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchableOpacity`：通过减少被点击元素（及其所有子元素）的不透明度来自动提供用户反馈，让底层视图透过来。你可以通过设置`activeOpacity`来配置不透明度的减少。'
- en: '`TouchableHighlight`: Provides user feedback automatically by reducing the
    opacity and showing an underlying color, which darkens or lightens the tapped
    element. You can define the underlying color by setting `underlayColor` and the
    opacity reduction by setting `activeOpacity`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchableHighlight`: 通过减少不透明度和显示底层颜色来自动提供用户反馈，这会使被点击的元素变暗或变亮。你可以通过设置 `underlayColor`
    来定义底层颜色，通过设置 `activeOpacity` 来定义不透明度的减少。'
- en: '`TouchableWithoutFeedback`: Provides no user feedback. You should only use
    this if you have a good reason since every element that responds to touches should
    show visual feedback. One reason could be that you handle the visual feedback
    somewhere else.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchableWithoutFeedback`: 不提供用户反馈。只有在你有充分的理由时才应使用此功能，因为每个响应触摸的元素都应该显示视觉反馈。一个可能的原因是你已经在其他地方处理了视觉反馈。'
- en: '`TouchableNativeFeedback`: For Android only. Provides user feedback automatically
    by triggering the native Android touch effect. On most devices, this is the well-known
    Android ripple effect, where the component changes the color by growing a circle
    from the point of touch. You can define the ripple effect by setting the `background`
    property.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchableNativeFeedback`: 仅适用于 Android。通过触发原生 Android 触摸效果来自动提供用户反馈。在大多数设备上，这是众所周知的
    Android 波纹效果，其中组件通过从触摸点扩展一个圆圈来改变颜色。你可以通过设置 `background` 属性来定义波纹效果。'
- en: 'All four `Touchable` components provide four methods to listen to user interaction.
    These methods are called in the order of the following figure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所有四个 `Touchable` 组件都提供了四种方法来监听用户交互。这些方法的调用顺序如下图的顺序：
- en: '![Figure 7.1 – The onPress call order'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.1 – The onPress call order'
- en: '](img/B16694_07_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16694_07_01.jpg]'
- en: Figure 7.1 – The onPress call order
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – `onPress` 调用顺序
- en: 'The important thing to always keep in mind is that `onPress` is called after
    `onPressOut`, while `onLongPress` is called before `onPressOut`. Let’s have a
    look at the methods in more detail:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是始终记住，`onPress` 在 `onPressOut` 之后被调用，而 `onLongPress` 在 `onPressOut` 之前被调用。让我们更详细地看看这些方法：
- en: '`onPressIn`: The method is called immediately when the user starts tapping
    the button.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPressIn`: 当用户开始点击按钮时，立即调用此方法。'
- en: '`onPressOut`: The method is called when the user releases the tap or when the
    user moves the finger outside of the component.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPressOut`: 当用户释放点击或当用户将手指移出组件外部时调用此方法。'
- en: '`onPress`: The method is called when the user completes the tap before a long
    press delay (defined in `delayLongPress`) is reached.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPress`: 当用户在达到长按延迟（在 `delayLongPress` 中定义）之前完成点击时调用此方法。'
- en: '`onLongPress`: The method is called when the long press delay (defined in `delayLongPress`)
    is reached and the tap wasn’t released in the meantime.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onLongPress`: 当达到长按延迟（在 `delayLongPress` 中定义）并且在此期间没有释放点击时调用此方法。'
- en: With these methods, you can already handle a lot of different use cases and
    – never forget – give immediate visual feedback to user touches.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法，你已可以处理许多不同的用例，并且——永远不要忘记——对用户的触摸提供即时视觉反馈。
- en: While the `Touchable` components need some own styling, React Native also provides
    a `Button` component, which comes with predefined styles.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Touchable` 组件需要一些自定义样式，但 React Native 还提供了一个 `Button` 组件，它带有预定义的样式。
- en: Working with the Button component
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Button 组件
- en: 'Under the hood, `Button` uses `TouchableOpacity` on iOS and `TouchableNativeFeedback`
    on Android. `Button` comes with some predefined styling so that you can use it
    without styling it on your own. The following code example shows how simple it
    is to use `Button`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，`Button` 在 iOS 上使用 `TouchableOpacity`，在 Android 上使用 `TouchableNativeFeedback`。`Button`
    带有一些预定义的样式，这样你就可以在不自己设置样式的情况下使用它。以下代码示例显示了使用 `Button` 的简单性：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You only have to define an `onPress` method, a button `title`, and the `color`
    of the button. `Button` then handles the rest such as styling and visual user
    feedback. Of course, you can use all other methods of the `Touchable` components,
    too.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需定义一个 `onPress` 方法、一个按钮 `标题` 和按钮的 `颜色`。`Button` 将处理其余部分，例如样式和视觉用户反馈。当然，你也可以使用
    `Touchable` 组件的所有其他方法。
- en: '`Button` and `Touchable` are quite old components in React Native. Since they
    work well, you can use them in most cases. But there is also a new implementation
    for handling user taps.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button` 和 `Touchable` 是 React Native 中相当老旧的组件。由于它们工作良好，你可以在大多数情况下使用它们。但还有一个新的实现来处理用户点击。'
- en: Working with the Pressable component
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Pressable 组件
- en: Besides the `Touchable` and `Button` components, React Native also comes with
    a `Pressable` component. This is the latest component and is recommended to be
    used due to its advanced support for platform-specific visual feedback.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Touchable`和`Button`组件外，React Native还提供了一个`Pressable`组件。这是最新的组件，由于其针对特定平台视觉反馈的高级支持，建议使用。
- en: 'Have a look at the following code example to understand the advantages of `Pressable`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码示例，了解`Pressable`的优点：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It provides the same methods as the `Touchable` components, but it also has
    ripple support on Android and works with custom styling on iOS. You can provide
    the `style` property as a function and listen to the `pressed` state.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了与`Touchable`组件相同的方法，但在Android上还有涟漪支持，并在iOS上与自定义样式一起工作。你可以提供`style`属性作为一个函数，并监听`pressed`状态。
- en: You can also pass a functional component as a child to the `Pressable` component
    and use the `pressed` state there. This means you can change the styling and content
    of the `Pressable` component based on whether it is pressed at the moment or not.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将一个功能组件作为子组件传递给`Pressable`组件，并使用那里的`pressed`状态。这意味着你可以根据它是否被按下改变`Pressable`组件的样式和内容。
- en: 'Another advantage is that you can define hit and offset areas for the `Pressable`
    component:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是你可以为`Pressable`组件定义点击和偏移区域：
- en: '![Figure 7.2 – Pressable Hit and Press Areas'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – `Pressable`点击和按下区域'
- en: '](img/B16694_07_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16694_07_02.jpg]'
- en: Figure 7.2 – Pressable Hit and Press Areas
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – `Pressable`点击和按下区域
- en: In *Figure 7.2*, you can see the visible `Pressable` component in the center.
    If you want the touchable area to be larger than the visible element, you can
    do this by setting `hitSlop`. This is a very common thing to do for important
    buttons or important tappable areas of the screen.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图7.2*中，你可以看到中心可见的`Pressable`组件。如果你想触摸区域大于可见元素，你可以通过设置`hitSlop`来实现。这对于重要的按钮或屏幕上重要的可触摸区域来说是一个非常常见的事情。
- en: While `hitSlop` defines the area where the tap starts, `pressRetentionOffset`
    defines the additional distance outside of the `Pressable` component where the
    tap does not stop. This means when you start a tap inside the Hit Area and move
    your finger outside of the Hit Area, normally `onPressOut` is fired and the tap
    gesture is completed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`hitSlop`定义了点击开始的位置，但`pressRetentionOffset`定义了在`Pressable`组件外部，点击不会停止的额外距离。这意味着当你开始在点击区域内部开始点击并移动你的手指到点击区域外部时，通常`onPressOut`会被触发，点击手势完成。
- en: But if you have defined an additional Press Area and your gesture stays inside
    this Press Area, the tap gesture is considered a lasting gesture as long as your
    finger moves outside this Press Area. `hitSlop` and `pressRetention` can either
    be set as a `number` value or as a `Rect` value, which means as an `Object` with
    `bottom`, `left`, `right`, and `top` properties.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你已经定义了一个额外的按下区域，并且你的手势停留在该按下区域内，只要你的手指移动到该按下区域外，则点击手势被视为持续手势。`hitSlop`和`pressRetention`可以设置为`number`值或`Rect`值，这意味着作为一个具有`bottom`、`left`、`right`和`top`属性的`Object`。
- en: Hit Area and Press Area are both great methods to improve the user experience
    of your app as, for example, they can make it easier for users to press important
    buttons.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 点击区域和按下区域都是提高你应用用户体验的绝佳方法，例如，它们可以使用户更容易按下重要的按钮。
- en: After looking at simple tap handling, let’s continue with scroll gestures.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看简单的点击处理之后，让我们继续看滚动手势。
- en: Working with ScrollView
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与`ScrollView`一起工作
- en: 'The simplest method to handle scroll gestures is React Native `ScrollView`.
    This component makes the content inside of it scrollable if the content is larger
    than `ScrollView` itself. `ScrollView` detects and handles scroll gestures automatically.
    It has a lot of options you can configure, so let’s have a look at the most important
    ones:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 处理滚动手势最简单的方法是React Native的`ScrollView`组件。如果内容比`ScrollView`本身大，这个组件可以使内容可滚动。`ScrollView`会自动检测和处理滚动手势。它有很多可配置的选项，所以让我们看看最重要的几个：
- en: '`horizontal`: Defines whether `ScrollView` should be horizontal or vertical.
    The default is vertical.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`horizontal`: 定义`ScrollView`应该是水平还是垂直。默认是垂直。'
- en: '`decelerationRate`: Defines how fast the scrolling will decelerate when the
    user releases the touch while scrolling.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decelerationRate`：定义用户在滚动时释放触摸时滚动减速的速度。'
- en: '`snapToInterval` or `snapToOffsets`: With these two methods, you can define
    intervals or offsets at which `ScrollView` should stop. This can improve the user
    experience a lot because the scroll view can, for example, always stop so that
    the user can see a complete list element.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snapToInterval`或`snapToOffsets`：使用这两个方法，你可以定义`ScrollView`应该停止的间隔或偏移量。这可以极大地改善用户体验，因为滚动视图可以始终停止，以便用户可以看到一个完整的列表元素。'
- en: '`scrollEventThrottle` for iOS only: Defines how often a scroll event will be
    triggered while scrolling. This is very important for performance and UX reasons.
    The best value for UX is 16, which means the scroll event is fired every 16 ms
    (until RN supports 120 Hz – then, it will become 8 ms).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scrollEventThrottle`仅适用于iOS：定义在滚动时滚动事件将被触发的频率。这对于性能和用户体验非常重要。对于用户体验来说，最佳值是16，这意味着滚动事件每16毫秒触发一次（直到RN支持120
    Hz - 然后，它将变为8毫秒）。'
- en: Based on what you are doing with the scroll event, this can lead to performance
    problems because the scroll event is sent over the bridge every single time (unless
    you process it directly via the Animated API, as described in [*Chapter 6*](B16694_06.xhtml#_idTextAnchor130),
    *Working with Animations*). So, think about what value you need here and perhaps
    increase it to prevent performance problems.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你对滚动事件的操作，这可能会导致性能问题，因为每次滚动事件都会通过桥接发送（除非你直接通过动画API处理，如[第6章](B16694_06.xhtml#_idTextAnchor130)中所述，*与动画一起工作*）。因此，考虑你需要在这里设置什么值，并可能将其增加以防止性能问题。
- en: Tip
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: There are a lot more configuration options such as defining over-scroll effects,
    sticky headers, or bounces. If you want to have a complete overview, please have
    a look at the documentation ([https://bit.ly/prn-scrollview](https://bit.ly/prn-scrollview)).
    Since this is not a beginner’s guide, we are focusing on the parts that are important
    to optimize your application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多配置选项，例如定义过度滚动效果、粘性头部或弹跳。如果你想有一个完整的概述，请查看文档([https://bit.ly/prn-scrollview](https://bit.ly/prn-scrollview))。由于这不是初学者指南，我们专注于优化应用程序的重要部分。
- en: 'Speaking of which, you can of course handle the scroll events by yourself when
    using the `ScrollView` component. This gives you a variety of options on how to
    optimize your UX. `ScrollView` provides the following methods:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，当然，你可以通过使用`ScrollView`组件来自行处理滚动事件。这为你提供了优化UX的多种选择。`ScrollView`提供了以下方法：
- en: '`onScroll`: Fires continuously during scrolling. This is a great tool to add
    awesome user feedback to the scroll gesture by coupling custom animations to the
    scroll event, as we did in [*Chapter 6*](B16694_06.xhtml#_idTextAnchor130), *Working
    with Animations*. But when doing so, you should either work with the Animated
    API with the native driver to prevent the scroll events from being transferred
    over the bridge every 16 ms or use `scrollEventThrottle` to limit the event count.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onScroll`: 在滚动过程中持续触发。这是一个很好的工具，可以通过将自定义动画与滚动事件结合来添加令人惊叹的用户反馈，就像我们在[第6章](B16694_06.xhtml#_idTextAnchor130)中做的那样，*与动画一起工作*。但是，在这样做的时候，你应该要么使用带有本地驱动程序的Animated
    API来防止滚动事件每16毫秒传输一次，要么使用`scrollEventThrottle`来限制事件数量。'
- en: '`onScrollBeginDrag`: Fires when the user starts the scrolling gesture.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onScrollBeginDrag`: 当用户开始滚动手势时触发。'
- en: '`onScrollEndDrag`: Fires when the user stops the scrolling gesture.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onScrollEndDrag`: 当用户停止滚动手势时触发。'
- en: '`onMomentumScrollBegin`: Fires when `ScrollView` starts moving.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMomentumScrollBegin`: 当`ScrollView`开始移动时触发。'
- en: '`onMomentumScrollEnd`: Fires when `ScrollView` stops moving.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMomentumScrollEnd`: 当`ScrollView`停止移动时触发。'
- en: With these five methods, you can give your users a lot of different feedback
    for a scroll gesture. From simply informing the user when they are scrolling to
    building advanced animations with `onScroll`, everything is possible.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这五个方法，你可以为用户的滚动手势提供很多不同的反馈。从简单地通知用户他们正在滚动到使用`onScroll`构建高级动画，一切皆有可能。
- en: Notice
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`ScrollView` can become quite slow and memory hungry when it has a very long
    list of elements as children. This is due to `ScrollView` rendering all children
    at once. If you need a more performant version with lazy loading of elements,
    please have a look at React Native `FlatList` or `SectionList`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ScrollView`有非常长的子元素列表时，它可能会变得相当慢和占用大量内存。这是由于`ScrollView`一次性渲染所有子元素造成的。如果你需要一个具有元素懒加载的更高效版本，请查看React
    Native的`FlatList`或`SectionList`。
- en: After working with the built-in React Native components, it’s time to have a
    look at handling touches completely by yourself. The first option to do that is
    to work directly with the React Native gesture responder system.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用内置的React Native组件之后，是时候看看如何完全自己处理触摸了。完成这一点的第一个选项是直接与React Native手势响应者系统一起工作。
- en: Working with the gesture responder system and PanResponder
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与手势响应者系统和PanResponder一起工作
- en: The gesture responder system is the foundation of handling gestures in React
    Native. All the `Touchable` components are based on the gesture responder system.
    With this system, you can not only listen to gestures but you can also specify
    which component should be the touch responder.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸响应者系统是处理React Native中手势的基础。所有`Touchable`组件都基于触摸响应者系统。使用此系统，您不仅可以监听手势，还可以指定哪个组件应该是触摸响应者。
- en: This is very important because there are several scenarios in which you have
    multiple touch responders on your screen (for example, `Slider` in a `ScrollView`).
    While most of the built-in components negotiate which component should become
    a touch responder and should handle the user input on their own, you have to think
    about it yourself when working directly with the gesture responder system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常重要，因为在您的屏幕上有多个触摸响应者的情况下（例如，`ScrollView`中的`Slider`），存在几种场景。虽然大多数内置组件协商哪个组件应该成为触摸响应者并自行处理用户输入，但在直接与手势响应者系统一起工作时，您必须自己考虑这一点。
- en: The gesture responder system provides a simple API and can be used on any component.
    The first thing you have to do when working with the gesture responder system
    is to negotiate which component should become the responder to handle the gesture.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸响应者系统提供了一个简单的API，并且可以在任何组件上使用。当与触摸响应者系统一起工作时，您必须做的第一件事是协商哪个组件应该成为处理手势的响应者。
- en: Becoming a responder
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成为响应者
- en: 'To become a responder, a component must implement one of these negotiation
    methods:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为响应者，组件必须实现以下协商方法之一：
- en: '`onStartShouldSetResponder`: If this method returns `true`, the component wants
    to become the responder at the start of a touch event.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStartShouldSetResponder`: 如果此方法返回`true`，组件想要在触摸事件的开始时成为响应者。'
- en: '`onMoveShouldSetResponder`: If this method returns `true`, the component wants
    to become the responder of a touch event. This method is called for every touch
    move event, as long as the component is not the responder.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMoveShouldSetResponder`: 如果此方法返回`true`，组件想要成为触摸事件的响应者。只要组件不是响应者，就会为每个触摸移动事件调用此方法。'
- en: Important tip
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: These two methods are called on the deepest node first. This means that the
    deepest component will become the responder to the touch event when multiple components
    implement these methods and return `true`. Please keep that in mind when manually
    negotiating the responders.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法首先在最深层的节点上调用。这意味着当多个组件实现这些方法并返回`true`时，最深层的组件将成为触摸事件的响应者。请在手动协商响应者时记住这一点。
- en: You can prevent a child component from becoming the responder by implementing
    `onStartShouldSetResponderCapture` or `onMoveShouldSetResponderCapture`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过实现`onStartShouldSetResponderCapture`或`onMoveShouldSetResponderCapture`来防止子组件成为响应者。
- en: 'For these responder negotiations, it is important for a component to release
    control if another component asks for it. The gesture responder system also provides
    handlers for this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些响应者协商，如果另一个组件请求，组件释放控制权是很重要的。触摸响应者系统还为此提供了处理程序：
- en: '`onResponderTerminationRequest`: If this handler returns `true`, the component
    releases the responder when another component wants to become the responder.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResponderTerminationRequest`: 如果此处理程序返回`true`，当另一个组件想要成为响应者时，组件会释放响应者。'
- en: '`onResponseTerminate`: This handler is called when the responder was released.
    This can be due to `onResponderTerminationRequest` returning `true` or due to
    OS behavior.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResponseTerminate`: 当响应者被释放时，此处理程序会被调用。这可能是由于`onResponderTerminationRequest`返回`true`，或者由于操作系统行为。'
- en: 'When a component tries to become the responder, there are two possible outcomes
    from the negotiation, which can both be handled with a handler method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件尝试成为响应者时，协商有两种可能的结果，都可以通过处理程序方法来处理：
- en: '`onResponderGrant`: This handler is called when it successfully became the
    responder and will then listen to touch events. It is best practice to use this
    method to highlight the component so that the user can see the element that responds
    to their touches.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResponderGrant`: 当它成功成为响应者并随后监听触摸事件时，此处理程序会被调用。最佳实践是使用此方法来突出显示组件，以便用户可以看到响应他们触摸的元素。'
- en: '`onResponderReject`: This handler is called when another component is currently
    the responder and will not release control.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResponderReject`: 当另一个组件当前是响应者且不会释放控制权时，此处理程序会被调用。'
- en: When your component successfully becomes the responder, you can use handlers
    to listen to the touch events.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的组件成功成为响应者时，你可以使用处理程序来监听触摸事件。
- en: Handling touches
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理触摸
- en: 'After becoming the responder, there are two handlers you can use to capture
    the touch events:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 成为响应者后，你可以使用两个处理程序来捕获触摸事件：
- en: '`onResponderMove`: This handler is called when the user moves their finger
    on the screen.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResponderMove`: 当用户在屏幕上移动手指时，此处理程序会被调用。'
- en: '`onResponderRelease`: This handler is called when the user releases their touch
    from the device’s screen.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResponderRelease`: 当用户从设备的屏幕上释放触摸时，此处理程序会被调用。'
- en: When working with gestures, you normally use `onResponderMove` and process the
    position values of the event it returns. When concatenating the positions, you
    can recreate the path the user draws on the screen. You can then respond to this
    path in the way you want.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理手势时，你通常使用 `onResponderMove` 并处理它返回的事件的位置值。当连接位置值时，你可以重新创建用户在屏幕上绘制的路径。然后你可以按你想要的方式对此路径做出响应。
- en: 'How this works in practice is shown in the following example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上是如何工作的，以下示例展示了：
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example contains two `View`. The outer `View` serves as the touch responder,
    while the inner `View` is a small circle, which changes position based on where
    the user moves the finger. The outer `View` implements the gesture responder system
    handlers, while the inner `View` just returns `false` for `onStartShouldSetResponder`,
    to not become the responder.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例包含两个 `View`。外部的 `View` 作为触摸响应者，而内部的 `View` 是一个小圆圈，其位置根据用户移动手指的位置而改变。外部 `View`
    实现了手势响应系统处理程序，而内部 `View` 只是对于 `onStartShouldSetResponder` 返回 `false`，以避免成为响应者。
- en: You also can see how the gesture responder system works with React Native Animated.
    When `onResponerMove` is called, we process the touch event and set the `pageX`
    and `pageY` values of the event to an `Animated.ValueXY`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到手势响应系统与 React Native Animated 一起是如何工作的。当 `onResponerMove` 被调用时，我们处理触摸事件并将事件的
    `pageX` 和 `pageY` 值设置为 `Animated.ValueXY`。
- en: This is the value we then use to calculate the position of the inner `View`.
    When the user removes the finger from the device, `onResponderRelease` is called
    and we use an `Animated.spring` function to revert the `Animated.ValueXY` value
    back to its starting value. This positions the inner `View` back in the middle
    of the screen.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们用来计算内部 `View` 位置的值。当用户从设备上移除手指时，`onResponderRelease` 会被调用，我们使用 `Animated.spring`
    函数将 `Animated.ValueXY` 值恢复到其起始值。这使内部 `View` 回到屏幕中间的位置。
- en: 'The following image shows how the code from the example looks on the screen:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了示例中的代码在屏幕上的样子：
- en: '![Figure 7.3 – An example of the gesture responder system running on an iPhone'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3 – 在 iPhone 上运行的手势响应系统示例'
- en: '](img/B16694_07_03.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B16694_07_03.jpg](img/B16694_07_03.jpg)'
- en: Figure 7.3 – An example of the gesture responder system running on an iPhone
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 在 iPhone 上运行的手势响应系统示例
- en: Here, you can see the starting state (the left-hand screen). Then, the user
    touches the bottom right of the screen and the blue circle follows the touch (mid-screen).
    After the user releases the touch, the blue circle returns to the center of the
    screen from the position where the user last touched the screen over a given time
    period (the right-hand screen shows the circle during the return animation).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到初始状态（左侧屏幕）。然后，用户触摸屏幕的右下角，蓝色圆圈跟随触摸移动（中间屏幕）。当用户释放触摸后，蓝色圆圈会在给定的时间段内从用户最后触摸屏幕的位置返回到屏幕中心（右侧屏幕显示了返回动画中的圆圈）。
- en: Even with this simple example, you can see that the gesture responder system
    is a very powerful tool. You have full control over the touch events and can combine
    them with animations very easily. Nevertheless, most of the time, you won’t use
    the gesture responder system directly. This is because of `PanResponder`, which
    is a lightweight layer on top of the gesture responder system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个简单的例子中，你也可以看到手势响应器系统是一个非常强大的工具。你可以完全控制触摸事件，并且可以非常容易地将它们与动画结合。尽管如此，大多数时候你不会直接使用手势响应器系统。这是因为`PanResponder`，它是在手势响应器系统之上的一层轻量级层。
- en: Using PanResponder
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PanResponder
- en: '`PanResponder` basically works exactly as the gesture responder system does.
    It provides a similar API; however, you just have to replace `Responder` with
    `PanResponder`. For example, `onResponderMove` becomes `onPanResponderMove`. The
    difference is that you don’t just get the raw touch events. `PanResponder` also
    provides a state object, which represents the state of the whole gesture. This
    includes the following properties:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`PanResponder`基本上与手势响应器系统的工作方式完全相同。它提供了一个相似的API；然而，你只需要将`Responder`替换为`PanResponder`。例如，`onResponderMove`变为`onPanResponderMove`。区别在于你不仅得到原始的触摸事件。`PanResponder`还提供了一个状态对象，它代表了整个手势的状态。这包括以下属性：'
- en: '`stateID`: A unique identifier of the gesture'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stateID`: 手势的唯一标识符'
- en: '`dx`: The horizontal distance since the start of the touch gesture'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dx`: 自触摸手势开始以来的水平距离'
- en: '`dy`: The vertical distance since the start of the touch gesture'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dy`: 自触摸手势开始以来的垂直距离'
- en: '`vx`: The current horizontal velocity of the touch gesture'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vx`: 触摸手势的当前水平速度'
- en: '`vy`: The current vertical velocity of the touch gesture'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vy`: 触摸手势的当前垂直速度'
- en: This state object can be very useful when it comes to interpreting and processing
    more complex gestures. Due to this, most libraries and projects use `PanResponder`
    instead of working directly with the gesture responder system.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到解释和处理更复杂的手势时，这个状态对象非常有用。因此，大多数库和项目使用`PanResponder`而不是直接与手势响应器系统交互。
- en: While the gesture responder system and `PanResponder` are very good options
    to respond to user touches, they also come with some downsides. First of all,
    they have the same limitations as the Animated API without the native driver.
    Since the touch events have to be transferred via the bridge to the JavaScript
    thread, we always are one frame behind.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然手势响应器系统和`PanResponder`是响应用户触摸的非常好的选项，但它们也带来了一些缺点。首先，它们与没有原生驱动程序的Animated API具有相同的限制。由于触摸事件必须通过桥接传输到JavaScript线程，我们总是落后一帧。
- en: This may become better with the JSI, but this has to be proven at this point.
    Another limitation is that no API allows us to define any interaction between
    the native gesture handlers. This means there will always be cases, which are
    not solvable with the gesture responder system API.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能随着JSI的改进而变得更好，但这一点目前必须得到证明。另一个限制是没有任何API允许我们定义任何原生手势处理器的交互。这意味着总会有一些情况，无法通过手势响应器系统API解决。
- en: Because of these limitations, the team at Software Mansion with the support
    of Shopify and Expo built a new solution – React Native Gesture Handler.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些限制，Software Mansion团队在Shopify和Expo的支持下构建了一个新的解决方案——React Native手势处理器。
- en: Understanding React Native Gesture Handler
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解React Native手势处理器
- en: React Native Gesture Handler is a third-party library that completely replaces
    the built-in gesture responder system while offering more control and higher performance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: React Native手势处理器是一个第三方库，它完全取代了内置的手势响应器系统，同时提供了更多的控制和更高的性能。
- en: React Native Gesture Handler works best in combination with Reanimated 2 because
    it was written by the same team and relies on the worklets provided by Reanimated
    2\.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: React Native手势处理器与Reanimated 2结合使用效果最佳，因为它是由同一团队编写的，并依赖于Reanimated 2提供的工作lets。
- en: Information
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: This book refers to React Native Gesture Handler version 2.0\. Version 1 is
    also used in a lot of projects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本书参考的是React Native手势处理器2.0版本。版本1也被许多项目使用。
- en: The React Native Gesture Handler 2 API is based on `GestureDetectors` and `Gestures`.
    While it does also support the API from version 1, I would recommend using the
    new API, as it is easier to read and understand.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: React Native手势处理器2 API基于`GestureDetectors`和`Gestures`。虽然它也支持版本1的API，但我建议使用新的API，因为它更容易阅读和理解。
- en: 'Let’s create the draggable circle example from the previous section, but this
    time we use React Native Gesture Handler and Reanimated 2:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建上一节中的可拖动圆形示例，但这次我们使用React Native手势处理器和Reanimated 2：
- en: '[PRE3]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, you can see how React Native Gesture Handler works. We create
    `GestureDetector` and wrap it with the element representing the target of the
    touch gesture. Then, we create a `Gesture` and assign it to `GestureDetector`.
    In this example, this is a `Pan` gesture, which means it recognizes dragging on
    the screen. `Gesture.Pan` provides a lot of different handlers. In this example,
    we use two:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到 React Native Gesture Handler 的工作原理。我们创建 `GestureDetector` 并将其包裹在代表触摸手势目标的元素周围。然后，我们创建一个
    `Gesture` 并将其分配给 `GestureDetector`。在这个例子中，这是一个 `Pan` 手势，意味着它识别屏幕上的拖动。`Gesture.Pan`
    提供了许多不同的处理程序。在这个例子中，我们使用了两个：
- en: '`onUpdate`: This handler is called every time any position of the gesture updates'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onUpdate`：每次任何手势位置更新时，此处理程序都会被调用'
- en: '`onEnd`: This handler is called when the gesture is released'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onEnd`：当手势释放时，此处理程序被调用'
- en: We use `onUpdate` to change the value of our Reanimated `sharedValue` and `onEnd`
    to reset the `sharedValue` to the initial state.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `onUpdate` 来改变 Reanimated 的 `sharedValue` 值，并使用 `onEnd` 来将 `sharedValue`
    重置到初始状态。
- en: We then use the `sharedValue` to create `animatedStyle`, which we assign to
    our `Animated.View`, which is our circle.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `sharedValue` 来创建 `animatedStyle`，并将其分配给我们的 `Animated.View`，即我们的圆形。
- en: 'The outcome on the screen is the same as in the previous section, but we have
    two important advantages here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上的结果与上一节相同，但这里有两个重要的优势：
- en: '**Better performance**: Since we use Reanimated 2 worklets, our values and
    our calculation don’t have to pass the bridge. The gesture input and the animation
    are completely calculated on the UI thread.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的性能**：由于我们使用了 Reanimated 2 worklets，我们的值和计算不需要通过桥接。手势输入和动画完全在 UI 线程上计算。'
- en: '`Race`) or whether multiple gestures can become active at a time (`Simultaneous`).'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Race`）或者是否可以在同一时间激活多个手势（`Simultaneous`）。'
- en: In addition to that, React Native Gesture Handler ships with a lot of different
    gestures, such as `Tap`, `Rotation`, `Pinch`, `Fling`, or `ForceTouch`, as well
    as built-in components such as `Button`, `Swipeable`, `Touchable`, or `DrawerLayout`,
    which makes it a very good replacement for the built-in gesture responder system.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，React Native Gesture Handler 包含了许多不同的手势，例如 `Tap`（点击）、`Rotation`（旋转）、`Pinch`（捏合）、`Fling`（抛掷）或
    `ForceTouch`（强触），以及内置组件如 `Button`（按钮）、`Swipeable`（可滑动）、`Touchable`（可触摸）或 `DrawerLayout`（抽屉布局），这使得它成为内置手势响应系统的优秀替代品。
- en: 'If you want to get a deeper understanding of all the possible options you have
    with React Native Gesture Handler, please have a look at the documentation: [bit.ly/prn-gesture-handler](http://bit.ly/prn-gesture-handler).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解 React Native Gesture Handler 所提供的所有可能选项，请查看文档：[bit.ly/prn-gesture-handler](http://bit.ly/prn-gesture-handler)。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about React Native’s built-in components and solutions
    to handle user gestures. From simple gestures such as single taps to more complex
    gestures, React Native provides stable solutions to handle gestures. We also had
    a look at React Native Gesture Handler, which is a great third-party replacement
    for these built-in solutions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 React Native 的内置组件以及处理用户手势的解决方案。从简单的点击手势到更复杂的手势，React Native 提供了稳定的解决方案来处理手势。我们还了解了
    React Native Gesture Handler，这是一个针对这些内置解决方案的优秀第三方替代品。
- en: I would recommend using React Native’s built-in components and solutions for
    all use cases where you can stick to the standard components. As soon as you start
    writing your own gesture handling, I would recommend using React Native Gesture
    Handler.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在所有可以坚持使用标准组件的使用场景中，使用 React Native 的内置组件和解决方案。一旦你开始编写自己的手势处理，我建议使用 React
    Native Gesture Handler。
- en: After Animations and Gesture Handling, we will proceed with another topic, which
    is very important in terms of performance.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画和手势处理之后，我们将继续探讨另一个在性能方面非常重要的主题。
- en: In the next chapter, you will learn what different JavaScript engines are, what
    options you have in React Native, and what impact the different engines have on
    performance and other important key metrics.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解不同的 JavaScript 引擎是什么，React Native 中有哪些选项，以及不同的引擎对性能和其他重要关键指标的影响。
