<html><head></head><body>
<div id="_idContainer036">
<h1 class="chapter-number" id="_idParaDest-153"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-154"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.2.1">Enhancing the Performance and Security of Angular Applications</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, you’ll learn how to improve the performance and security of your Angular applications. </span><span class="koboSpan" id="kobo.3.2">You will do a deep dive into the change detection mechanism of Angular so you will know how you can reduce the number of components Angular has to check for changes and re-render in the browser. </span><span class="koboSpan" id="kobo.3.3">Next, you will learn about actions you can take to optimize the page load times and runtime performance of your Angular applications. </span><span class="koboSpan" id="kobo.3.4">Once you know how to enhance your Angular applications’ performance, you will learn about security. </span><span class="koboSpan" id="kobo.3.5">You will learn what risks you can encounter when building Angular applications and how you can mitigate these risks so you can build safe applications for your </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">end users.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This chapter will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Understanding Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">change detection</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Enhancing the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Angular applications</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Building secure </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Angular applications</span></span></li>
</ul>
<h1 id="_idParaDest-155"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.13.1">Understanding Angular change detection</span></h1>
<p><span class="koboSpan" id="kobo.14.1">For small applications, performance isn’t usually a bottleneck. </span><span class="koboSpan" id="kobo.14.2">Still, when applications grow and you start to add and compose more components, your application can become slow, impairing the user experience and decreasing user retention. </span><span class="koboSpan" id="kobo.14.3">One of the reasons your applications become slow is that Angular will check more and more components for changes if you develop without taking measures to help Angular perform better change detection. </span><span class="koboSpan" id="kobo.14.4">So, to build performant Angular applications, you need to understand </span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.15.1">how the </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">change detection mechanism</span></strong><span class="koboSpan" id="kobo.17.1"> works so you can reduce the number of components the framework has to check for changes and re-render in </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">the browser.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">To better understand the problem, you must first understand how Angular performs change detection and where the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">problems start.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">Let’s say you have a simple component with a title property and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">changeTitle()</span></strong><span class="koboSpan" id="kobo.23.1"> function, </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.25.1">
title = 'Some title';
changeTitle(newTitle) { this.title = newTitle }</span></pre> <p><span class="koboSpan" id="kobo.26.1">If you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">changeTitle()</span></strong><span class="koboSpan" id="kobo.28.1"> function, Angular can keep everything synchronized after changing the title. </span><span class="koboSpan" id="kobo.28.2">Inside the call stack, Angular will first call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">changeTitle()</span></strong><span class="koboSpan" id="kobo.30.1"> function, and all subsequent functions will be called due to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">changeTitle()</span></strong><span class="koboSpan" id="kobo.32.1"> function being called. </span><span class="koboSpan" id="kobo.32.2">Then, behind the scenes, Angular will call a </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">tick()</span></strong><span class="koboSpan" id="kobo.34.1"> function to run the change detection. </span><span class="koboSpan" id="kobo.34.2">The change detection will run for the entire component tree because you might change a value inside a service that is used in one or more components inside the component tree. </span><span class="koboSpan" id="kobo.34.3">This scenario will work as expected; although Angular must check the entire</span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.35.1"> component tree, it will keep the application state and the </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">view synchronized.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">Now, imagine you run some asynchronous code before updating the title property; the problems will start in this scenario. </span><span class="koboSpan" id="kobo.37.2">Angular will detect that </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">changeTitle()</span></strong><span class="koboSpan" id="kobo.39.1"> has been called and run the change detection. </span><span class="koboSpan" id="kobo.39.2">Because of how the call stack works, Angular will not wait for the asynchronous operations to complete before calling a function to run the change detection behind the scenes. </span><span class="koboSpan" id="kobo.39.3">As a result, Angular will run change detection before you update the title property, resulting in a broken application because the old value is </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">still shown.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.41.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.42.1">In reality, asynchronous changes don’t break the synchronization between the code and view because Angular uses Zone.js to tackle </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">this issue!</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Now you know that asynchronous changes can lead to undetected changes. </span><span class="koboSpan" id="kobo.44.2">Next, let’s learn about Zone.js and how Angular uses it to account for this issue so it can perform successful change detection for synchronous and </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">asynchronous changes.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.46.1">Zone.js and Angular</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.47.1">Zone.js</span></strong><span class="koboSpan" id="kobo.48.1"> has </span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.49.1">been used by Angular since Angular 2.0. </span><span class="koboSpan" id="kobo.49.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">Zone.JS</span></strong><span class="koboSpan" id="kobo.51.1"> library monkey patches (i.e., dynamically updates the behavior at runtime) the browser API and allows you to hook into the life cycle of browser events. </span><span class="koboSpan" id="kobo.51.2">This means you can run code before and after browser events happen. </span><span class="koboSpan" id="kobo.51.3">Using Zone.js, you can create a </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">Zone</span></strong><span class="koboSpan" id="kobo.53.1"> and run code before the code inside the Zone is executed </span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.54.1">and after all code within the Zone has finished, including </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">asynchronous events.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">To demonstrate this, here is a </span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.57.1">simple example of such </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">a Zone:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.59.1">
const zone = Zone.current.fork({
  onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) =&gt; {
    console.log(‹Before zone.run code is executed');
    delegate.invokeTask(target, task, applyThis, applyArgs);
    console.log('After zone.run code is executed');
  }
});
zone.run(() =&gt; {
  setTimeout(() =&gt; {
    console.log(‹Hello from inside the zone!›);
  }, 1000);
});</span></pre> <p><span class="koboSpan" id="kobo.60.1">In the preceding code, a Zone is created, and inside the Zone, we perform asynchronous code – in our case, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">setTimeout</span></strong><span class="koboSpan" id="kobo.62.1"> function. </span><span class="koboSpan" id="kobo.62.2">The preceding code will first log the message we declared before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">delegate.InvokeTask()</span></strong><span class="koboSpan" id="kobo.64.1"> method. </span><span class="koboSpan" id="kobo.64.2">Next, it will run the code we declared inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">zone.run()</span></strong><span class="koboSpan" id="kobo.66.1"> callback function; this can be both synchronous and asynchronous code. </span><span class="koboSpan" id="kobo.66.2">Lastly, when the code inside the callback is finished, the message we declared after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">delegate.InvokeTask()</span></strong><span class="koboSpan" id="kobo.68.1"> method will </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">be logged.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">Behind the scenes, Angular uses a similar approach to our </span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.71.1">Zone example to create a Zone wrapped around our entire application called </span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.72.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.73.1">NgZone</span></strong><span class="koboSpan" id="kobo.74.1">. </span><span class="koboSpan" id="kobo.74.2">The NgZone includes an Observable named </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">onMicrotaskEmpty</span></strong><span class="koboSpan" id="kobo.76.1"> that emits a value when no more microtasks are in the queue. </span><span class="koboSpan" id="kobo.76.2">Angular uses this </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">onMicrotaskEmpty</span></strong><span class="koboSpan" id="kobo.78.1"> Observable to determine when all synchronous and asynchronous code within the NgZone is finished, and Angular can safely run change detection without potentially missing </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">changed values.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.81.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.82.1">.1</span></em><span class="koboSpan" id="kobo.83.1">, you can see an illustration of how the NgZone created by Angular wraps around the entire component tree, allowing</span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.84.1"> Angular to safely monitor </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">asynchronous changes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.86.1"><img alt="Figure 9.1: Component tree inside NgZone" src="image/B21625_09_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.87.1">Figure 9.1: Component tree inside NgZone</span></p>
<p><span class="koboSpan" id="kobo.88.1">When running change detection, Angular will check all components in the component tree and update and re-render the components if any bindings are changed (bindings are values bound to the </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">HTML template).</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">Now you know how Angular uses Zone.js to trigger change detection when all synchronous and asynchronous tasks are finished, and that Angular checks the entire component tree when change detection runs. </span><span class="koboSpan" id="kobo.90.2">Let’s learn why Angular checks the entire component tree and how you can reduce the number of components Angular has to check and re-render when change </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">detection runs.</span></span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.92.1">Improving change detection efficiency</span></h2>
<p><span class="koboSpan" id="kobo.93.1">Angular </span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.94.1">marks components as </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">dirty</span></strong><span class="koboSpan" id="kobo.96.1"> when bindings or values change inside the components. </span><span class="koboSpan" id="kobo.96.2">When a component is marked as dirty, it is indicating the component must be updated and re-rendered. </span><span class="koboSpan" id="kobo.96.3">Even though components can be marked as dirty, by default, Angular will check both dirty and non-dirty components when it runs change detection. </span><span class="koboSpan" id="kobo.96.4">You can improve this by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">OnPush</span></strong><span class="koboSpan" id="kobo.98.1"> change detection strategy in your components, like in the </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.100.1">
@Component({
  changeDetection: ChangeDetectionStrategy.OnPush
})</span></pre> <p><span class="koboSpan" id="kobo.101.1">When using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">OnPush</span></strong><span class="koboSpan" id="kobo.103.1"> change detection strategy, Angular only runs change detection for components marked as dirty, significantly reducing the number of components that must be checked and re-rendered. </span><span class="koboSpan" id="kobo.103.2">There are a couple of things that mark a component </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">as dirty:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.105.1">Browser events handled inside the component (hover, click, </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">keydown, etc.)</span></span></li>
<li><span class="koboSpan" id="kobo.107.1">Changed component </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">input values</span></span></li>
<li><span class="koboSpan" id="kobo.109.1">Component </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">output emissions</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.111.1">When a component is marked as dirty, Angular will also mark all ancestors of the component as dirty. </span><span class="koboSpan" id="kobo.111.2">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.112.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.113.1">.2</span></em><span class="koboSpan" id="kobo.114.1">, you can see this visualized to better grasp </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">the concept:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.116.1"><img alt="Figure 9.2: Dirty component tree" src="image/B21625_09_002.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.117.1">Figure 9.2: Dirty component tree</span></p>
<p><span class="koboSpan" id="kobo.118.1">Now, components </span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.119.1">that use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">OnPush</span></strong><span class="koboSpan" id="kobo.121.1"> change detection strategy and aren’t dirty will not be checked for changes when Angular runs change detection, reducing the number of components that must be checked by the framework. </span><span class="koboSpan" id="kobo.121.2">Angular will also skip all child components of the components that use </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">OnPush</span></strong><span class="koboSpan" id="kobo.123.1"> and aren’t marked </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">as dirty.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.125.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.126.1">.3</span></em><span class="koboSpan" id="kobo.127.1"> illustrates the mechanism of change detection with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">OnPush</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.129.1"> strategy:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.130.1"><img alt="Figure 9.3: Change detection with the OnPush strategy" src="image/B21625_09_003.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.131.1">Figure 9.3: Change detection with the OnPush strategy</span></p>
<p><span class="koboSpan" id="kobo.132.1">As you can see in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.133.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.134.1">.3</span></em><span class="koboSpan" id="kobo.135.1">, Angular </span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.136.1">will not check whether it must refresh the bindings for all child components of non-dirty components using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">OnPush</span></strong><span class="koboSpan" id="kobo.138.1"> change detection strategy. </span><span class="koboSpan" id="kobo.138.2">This also illustrates why all ancestor components must be marked as dirty when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">OnPush</span></strong><span class="koboSpan" id="kobo.140.1">. </span><span class="koboSpan" id="kobo.140.2">Angular checks whether it must refresh bindings from the top down, starting at the root component. </span><span class="koboSpan" id="kobo.140.3">So, if you click on a component at the bottom of the component tree, Angular starts at the root and works its way down the component tree. </span><span class="koboSpan" id="kobo.140.4">If the parent of the clicked component uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">OnPush</span></strong><span class="koboSpan" id="kobo.142.1"> change detection strategy, Angular will skip the children if the component isn’t marked as dirty. </span><span class="koboSpan" id="kobo.142.2">As a result, Angular wouldn’t check the component where you click, resulting in a mismatch between the code and view because the changes related to the click will not be processed. </span><span class="koboSpan" id="kobo.142.3">Because of the aforementioned reason, Angular must mark all parent components as dirty when the components use </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">OnPush</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.144.1">change detection.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">Another interesting case for </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">OnPush</span></strong><span class="koboSpan" id="kobo.147.1"> change detection is Observables. </span><span class="koboSpan" id="kobo.147.2">Observables are the primary tool within the Angular framework to handle asynchronous events and data streams, yet Observables receiving new values will not mark the component as dirty. </span><span class="koboSpan" id="kobo.147.3">So, when using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">OnPush</span></strong><span class="koboSpan" id="kobo.149.1"> change detection strategy, the component will not be updated if the Observable receives a new value. </span><span class="koboSpan" id="kobo.149.2">To tackle this issue, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">async</span></strong><span class="koboSpan" id="kobo.151.1"> pipe because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">async</span></strong><span class="koboSpan" id="kobo.153.1"> pipe will automatically mark the component to be checked and handle the update like a regular event, marking the component as dirty and running change detection afterward. </span><span class="koboSpan" id="kobo.153.2">Alternatively, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">ChangeDetectorRef</span></strong><span class="koboSpan" id="kobo.155.1"> and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">markForCheck()</span></strong><span class="koboSpan" id="kobo.157.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">detectChanges()</span></strong><span class="koboSpan" id="kobo.159.1"> method manually, </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.161.1">
cd = inject(ChangeDetectorRef)
this.cd.markForCheck();
this.cd.detectChanges();</span></pre> <p><span class="koboSpan" id="kobo.162.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">markForCheck()</span></strong><span class="koboSpan" id="kobo.164.1"> method will mark the component to be checked during the next change detection cycle, whereas </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">detectChanges()</span></strong><span class="koboSpan" id="kobo.166.1"> will mark the component as dirty and immediately trigger change detection for that </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">specific component.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">However, you have to be careful when using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">detectChanges()</span></strong><span class="koboSpan" id="kobo.170.1"> method because it can also cause performance issues. </span><span class="koboSpan" id="kobo.170.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">detectChanges()</span></strong><span class="koboSpan" id="kobo.172.1"> method will run the entire change detection in a single browser task, blocking the main threat until that task is completed. </span><span class="koboSpan" id="kobo.172.2">When, for example, you display a large array on the screen and must frequently detect change for this array, that results in a lot of work for the browser, slowing down your </span><a id="_idIndexMarker858"/><span class="No-Break"><span class="koboSpan" id="kobo.173.1">Angular application.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">Now that you better understand how </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">OnPush</span></strong><span class="koboSpan" id="kobo.176.1"> change detection works and how you can mark components as dirty or run change detection manually, let’s learn how Signals are handled by the Angular change </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">detection mechanism.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.178.1">Angular change detection and Signals</span></h2>
<p><span class="koboSpan" id="kobo.179.1">In Angular 17, </span><strong class="bold"><span class="koboSpan" id="kobo.180.1">Signals</span></strong><span class="koboSpan" id="kobo.181.1"> was </span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.182.1">released as a developer preview, and with that, the change detection mechanism received an upgrade. </span><span class="koboSpan" id="kobo.182.2">When using a signal inside the template, Angular will </span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.183.1">register an effect that listens to the signal used in the template. </span><span class="koboSpan" id="kobo.183.2">When the value of the signal changes, the effect runs and will mark the component to be checked by Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">change detection.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">The change detection cycle will work differently when the component is marked to be checked because a signal value changed. </span><span class="koboSpan" id="kobo.185.2">First, the component with the signal change will receive a </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">RefreshView</span></strong><span class="koboSpan" id="kobo.187.1"> flag. </span><span class="koboSpan" id="kobo.187.2">Next, it will traverse up the component tree and mark all its ancestors with </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">HAS_CHILD_VIEWS_TO_REFRESH</span></strong><span class="koboSpan" id="kobo.189.1">. </span><span class="koboSpan" id="kobo.189.2">It will not mark ancestors as dirty. </span><span class="koboSpan" id="kobo.189.3">Now, when change detection runs, Angular will perform </span><a id="_idIndexMarker861"/><span class="koboSpan" id="kobo.190.1">so-called </span><strong class="bold"><span class="koboSpan" id="kobo.191.1">glo-cal</span></strong><span class="koboSpan" id="kobo.192.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.193.1">global + local</span></strong><span class="koboSpan" id="kobo.194.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">change detection.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">When running glo-cal change detection, the component tree will be checked top-down, just as usual. </span><span class="koboSpan" id="kobo.196.2">But when Angular encounters a non-dirty </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">OnPush</span></strong><span class="koboSpan" id="kobo.198.1"> component with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">HAS_CHILD_VIEWS_TO_REFRESH</span></strong><span class="koboSpan" id="kobo.200.1"> flag, it will skip the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">OnPush</span></strong><span class="koboSpan" id="kobo.202.1"> component but continue down the component tree to look for the component with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">RefreshView</span></strong><span class="koboSpan" id="kobo.204.1"> flag. </span><span class="koboSpan" id="kobo.204.2">As a result, only the component with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">RefreshView</span></strong><span class="koboSpan" id="kobo.206.1"> flag will be updated and re-rendered; all its parent components with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">OnPush</span></strong><span class="koboSpan" id="kobo.208.1"> change detection strategy will not be checked or re-rendered, further improving the efficiency of the Angular change </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">detection mechanism.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">You now know how Angular change detection works and how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">OnPush</span></strong><span class="koboSpan" id="kobo.212.1"> change detection strategy to make the change detection process more efficient. </span><span class="koboSpan" id="kobo.212.2">Then, you learned how to handle Observables when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">OnPush</span></strong><span class="koboSpan" id="kobo.214.1"> change detection for your components. </span><span class="koboSpan" id="kobo.214.2">You also know how to manually mark components to be checked or run change detection using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">markForCheck()</span></strong><span class="koboSpan" id="kobo.216.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">detectChanges()</span></strong><span class="koboSpan" id="kobo.218.1"> functions. </span><span class="koboSpan" id="kobo.218.2">Lastly, you’ve seen how you can improve change detection even more by using Signals combined with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">OnPush</span></strong><span class="koboSpan" id="kobo.220.1"> change detection strategy and trigger glo-cal change detection. </span><span class="koboSpan" id="kobo.220.2">All </span><a id="_idIndexMarker862"/><span class="koboSpan" id="kobo.221.1">these changes will</span><a id="_idIndexMarker863"/><span class="koboSpan" id="kobo.222.1"> significantly enhance the performance of your application, especially when your application grows and you have large and complex </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">component trees.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">In the next section, we will explore other methods to enhance the performance of your </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">Angular applications.</span></span></p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.226.1">Enhancing the performance of Angular applications</span></h1>
<p><span class="koboSpan" id="kobo.227.1">Understanding </span><a id="_idIndexMarker864"/><span class="koboSpan" id="kobo.228.1">how Angular change detection works using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">OnPush</span></strong><span class="koboSpan" id="kobo.230.1"> change detection strategy on as many components as possible and using Signals to further improve the change detection is a good first step to building a performant application. </span><span class="koboSpan" id="kobo.230.2">However, the framework has more to offer when developing </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">performant applications.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">In this section, we will explore the built-in tools and learn tips you can use to enhance the performance of your Angular applications and ensure swift page loads and good runtime performance. </span><span class="koboSpan" id="kobo.232.2">The first built-in tool to enhance performance that we will explore is the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">runOutsideAngular()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.234.1"> method.</span></span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.235.1">Understanding and using the runOutsideAngular() method</span></h2>
<p><span class="koboSpan" id="kobo.236.1">In Angular applications, optimizing </span><a id="_idIndexMarker865"/><span class="koboSpan" id="kobo.237.1">performance sometimes involves executing specific tasks outside the Angular Zone. </span><span class="koboSpan" id="kobo.237.2">In the previous section, you learned about</span><a id="_idIndexMarker866"/><span class="koboSpan" id="kobo.238.1"> Zone.js, how Angular uses it to create the NgZone, and how it relates to change detection and the update behavior of your application. </span><span class="koboSpan" id="kobo.238.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">runOutsideAngular()</span></strong><span class="koboSpan" id="kobo.240.1"> method provides a way to run specific code outside Angular’s change detection mechanism, which can improve the responsiveness and efficiency of </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">By executing tasks outsideAngular’s Zone using </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">runOutsideAngular()</span></strong><span class="koboSpan" id="kobo.244.1">, you can prevent unnecessary change detection cycles from being triggered. </span><span class="koboSpan" id="kobo.244.2">This can lead to smoother user interactions and reduce the overhead associated with Angular’s change detection mechanism. </span><span class="koboSpan" id="kobo.244.3">Tasks executed outside the Angular Zone are not automatically detected by Angular’s change detection cycle, improving the overall performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.246.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">runOutsideAngular()</span></strong><span class="koboSpan" id="kobo.248.1"> method is provided by Angular’s NgZone service. </span><span class="koboSpan" id="kobo.248.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">runOutsideAngular()</span></strong><span class="koboSpan" id="kobo.250.1"> method can run heavy computational functions outside the NgZone. </span><span class="koboSpan" id="kobo.250.2">Some examples of heavy computational functions are complex mathematical computations, sorting large arrays, and processing large datasets. </span><span class="koboSpan" id="kobo.250.3">Other scenarios in which you might want to run something outside the NgZone are </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.252.1">Running code from third-party libraries</span></strong><span class="koboSpan" id="kobo.253.1">: Running code related to initializing, configuring, or interacting with third-party libraries outside the Angular zone prevents Angular from performing unnecessary change detection, leading to better performance and avoiding potential </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">side effects.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.255.1">Handling WebSocket communication or long-polling requests</span></strong><span class="koboSpan" id="kobo.256.1">: This involves frequent updates to the application state without triggering </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">user-initiated actions.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.258.1">Animations or rendering optimizations that involve low-level DOM manipulation or canvas drawing operations</span></strong><span class="koboSpan" id="kobo.259.1">: Running the related code outside the Angular zone can enhance performance by bypassing Angular’s change detection and allowing for more direct control over </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">rendering updates.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.261.1">By strategically utilizing </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">runOutsideAngular()</span></strong><span class="koboSpan" id="kobo.263.1">, you can improve the performance and responsiveness of your Angular application, particularly when dealing with computationally intensive tasks or interactions with external libraries. </span><span class="koboSpan" id="kobo.263.2">However, it’s crucial to balance performance optimization with maintaining the integrity and functionality of your application. </span><span class="koboSpan" id="kobo.263.3">When running tasks inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">runOutsideAngular()</span></strong><span class="koboSpan" id="kobo.265.1">, change detection will not detect the tasks, so you risk showing incorrect data to the user. </span><span class="koboSpan" id="kobo.265.2">A good countermeasure to this is running the heavy computation inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">runOutsideAngular()</span></strong><span class="koboSpan" id="kobo.267.1"> method, and then assigning the values to your component properties inside the NgZone again by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">run()</span></strong><span class="koboSpan" id="kobo.269.1"> method, as shown in the</span><a id="_idIndexMarker867"/> <span class="No-Break"><span class="koboSpan" id="kobo.270.1">following </span></span><span class="No-Break"><a id="_idIndexMarker868"/></span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.272.1">
@Component({……})
export class ExampleComponent {
  protected readonly ngZone = inject(NgZone);
  performTask(): void {
    this.ngZone.runOutsideAngular(() =&gt; {
      console.log(‹Task performed outside Angular Zone›);
      // Run inside the runOutsideAngular method again
      this.ngZone.run(() =&gt; {
        console.log(‹Running inside NgZone again›);
      });
    });
  }
}</span></pre> <p><span class="koboSpan" id="kobo.273.1">In the preceding code, you can see how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">runOutsideAngular()</span></strong><span class="koboSpan" id="kobo.275.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">run()</span></strong><span class="koboSpan" id="kobo.277.1"> methods. </span><span class="koboSpan" id="kobo.277.2">You inject the NgZone and call the methods on the service provided to you by Angular. </span><span class="koboSpan" id="kobo.277.3">Within the callbacks of each method, you can perform any logic you want to perform inside or outside of </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">the NgZone.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">Now that you know how </span><a id="_idIndexMarker869"/><span class="koboSpan" id="kobo.280.1">to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">runOutsideAngular()</span></strong><span class="koboSpan" id="kobo.282.1"> and run </span><a id="_idIndexMarker870"/><span class="koboSpan" id="kobo.283.1">code outside the NgZone to improve the performance of your application, let’s move on to the next tool Angular offers us to develop more performant applications: the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">NgOptimizedImage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.285.1"> directive.</span></span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.286.1">Understanding and using the NgOptimizedImage directive</span></h2>
<p><span class="koboSpan" id="kobo.287.1">Another</span><a id="_idIndexMarker871"/><span class="koboSpan" id="kobo.288.1"> crucial aspect when building performant applications is optimizing your images. </span><span class="koboSpan" id="kobo.288.2">The load time of your images is a huge factor in the </span><strong class="bold"><span class="koboSpan" id="kobo.289.1">Largest Contentful Paint</span></strong><span class="koboSpan" id="kobo.290.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.291.1">LCP</span></strong><span class="koboSpan" id="kobo.292.1">) of </span><a id="_idIndexMarker872"/><span class="koboSpan" id="kobo.293.1">your website, which is one of the three Core Web Vital metrics [the other two Core Web Vital metrics </span><a id="_idIndexMarker873"/><span class="koboSpan" id="kobo.294.1">are </span><strong class="bold"><span class="koboSpan" id="kobo.295.1">First Input Delay</span></strong><span class="koboSpan" id="kobo.296.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.297.1">FID</span></strong><span class="koboSpan" id="kobo.298.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.299.1">Cumulative Layout Shift</span></strong><span class="koboSpan" id="kobo.300.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.301.1">CLS</span></strong><span class="koboSpan" id="kobo.302.1">)]. </span><span class="koboSpan" id="kobo.302.2">The </span><a id="_idIndexMarker874"/><span class="koboSpan" id="kobo.303.1">LCP indicates the speed at which the primary content of a webpage loads, specifically measuring the duration from when the user triggers the page load to when the largest image or text block is displayed within the visible area of the browser window. </span><span class="koboSpan" id="kobo.303.2">Because images mostly take longer to load</span><a id="_idIndexMarker875"/><span class="koboSpan" id="kobo.304.1"> compared to text content, how your images are loaded and displayed plays a vital role in the LCP of </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">your applications.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">Within the Angular framework, you can improve how images are loaded by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.308.1"> directive. </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.310.1"> focuses on prioritizing the loading of the </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">LCP images.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">By default, this directive enables lazy loading for non-priority images, conserving bandwidth and improving initial page load times. </span><span class="koboSpan" id="kobo.312.2">Additionally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.314.1"> generates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">preconnect</span></strong><span class="koboSpan" id="kobo.316.1"> link tag in the document head, optimizing resource fetching strategies. </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.318.1"> automatically sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">fetchpriority</span></strong><span class="koboSpan" id="kobo.320.1"> attribute on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">img</span></strong><span class="koboSpan" id="kobo.322.1"> tag, emphasizing the loading priority of the LCP image. </span><span class="koboSpan" id="kobo.322.2">Furthermore, the directive streamlines the process of generating </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">srcset</span></strong><span class="koboSpan" id="kobo.324.1"> attributes. </span><span class="koboSpan" id="kobo.324.2">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">srcset</span></strong><span class="koboSpan" id="kobo.326.1"> attributes, the browsers request images at the right size for the user’s viewport and because of that, no time and resources are wasted downloading an image that’s </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">too large.</span></span></p>
<p><span class="koboSpan" id="kobo.328.1">Besides prioritizing the loading of LCP images, </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.330.1"> ensures a series of image best practices </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">are applied:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.332.1">Image CDN utilization</span></strong><span class="koboSpan" id="kobo.333.1">: The directive</span><a id="_idIndexMarker876"/><span class="koboSpan" id="kobo.334.1"> encourages the use of image content delivery network (CDN) URLs, facilitating image optimizations and efficient delivery across </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">global networks.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.336.1">Required width and height</span></strong><span class="koboSpan" id="kobo.337.1">: Setting the width and height attributes for your images when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.339.1"> incorrectly or not setting dimensions results in a warning. </span><span class="koboSpan" id="kobo.339.2">By setting width and height properties, you mitigate layout shifts, improve your CLS, and ensure </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">proper rendering.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.341.1">Visual distortion warning</span></strong><span class="koboSpan" id="kobo.342.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.344.1"> alerts developers to potential visual distortions in </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">rendered images.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.346.1">Now that you </span><a id="_idIndexMarker877"/><span class="koboSpan" id="kobo.347.1">know why you need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.349.1"> directive, let’s see how you can use it. </span><span class="koboSpan" id="kobo.349.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.351.1"> directive is standalone, so you begin by importing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.353.1"> directive directly into the necessary </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">NgModule</span></strong><span class="koboSpan" id="kobo.355.1"> or standalone component. </span><span class="koboSpan" id="kobo.355.2">Next, you </span><a id="_idIndexMarker878"/><span class="koboSpan" id="kobo.356.1">can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.358.1"> by replacing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">src</span></strong><span class="koboSpan" id="kobo.360.1"> attribute on an </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">img</span></strong><span class="koboSpan" id="kobo.362.1"> tag </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">ngSrc</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.366.1">
&lt;img </span><strong class="bold"><span class="koboSpan" id="kobo.367.1">ngSrc</span></strong><span class="koboSpan" id="kobo.368.1">="dog.jpg"&gt;</span></pre> <p><span class="koboSpan" id="kobo.369.1">As mentioned, you also need to set the width and </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">height properties:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.371.1">
&lt;img </span><strong class="bold"><span class="koboSpan" id="kobo.372.1">ngSrc</span></strong><span class="koboSpan" id="kobo.373.1">="dog.jpg" </span><strong class="bold"><span class="koboSpan" id="kobo.374.1">width</span></strong><span class="koboSpan" id="kobo.375.1">="400" </span><strong class="bold"><span class="koboSpan" id="kobo.376.1">height</span></strong><span class="koboSpan" id="kobo.377.1">="200"&gt;</span></pre> <p><span class="koboSpan" id="kobo.378.1">That is everything you need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.380.1"> directive, but there are some additional options you can add. </span><span class="koboSpan" id="kobo.380.2">Let’s start by exploring the </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">priority</span></strong><span class="koboSpan" id="kobo.382.1"> attribute. </span><span class="koboSpan" id="kobo.382.2">When you mark an image with priority, the following optimizations are applied </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">for you:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">fetchpriority=high</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">loading=eager</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.386.1">When you use server-side rendering, it automatically generates a preload </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">link element.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">You can mark an image with priority </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.390.1">
&lt;img ngSrc="dog.jpg" width="400" height="200 </span><strong class="bold"><span class="koboSpan" id="kobo.391.1">priority</span></strong><span class="koboSpan" id="kobo.392.1"> "&gt;</span></pre> <p><span class="koboSpan" id="kobo.393.1">All LCP images should be marked as priority. </span><span class="koboSpan" id="kobo.393.2">If you don’t mark an LCP image as priority during development, Angular will log </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">an error.</span></span></p>
<p><span class="koboSpan" id="kobo.395.1">Besides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">priority</span></strong><span class="koboSpan" id="kobo.397.1"> attribute, another useful attribute used with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.399.1"> directive is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">fill</span></strong><span class="koboSpan" id="kobo.401.1"> attribute, </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.403.1">
&lt;img ngSrc="dog.jpg" </span><strong class="bold"><span class="koboSpan" id="kobo.404.1">fill</span></strong><span class="koboSpan" id="kobo.405.1">&gt;</span></pre> <p><span class="koboSpan" id="kobo.406.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">fill</span></strong><span class="koboSpan" id="kobo.408.1"> attribute is used when you want the image to fill the containing element. </span><span class="koboSpan" id="kobo.408.2">A good use case for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">fill</span></strong><span class="koboSpan" id="kobo.410.1"> attribute is when you want to use the image as a background image, or when you don’t know the exact size of your image and want to fit it inside a container of which you do know the size in relation to the screen size. </span><span class="koboSpan" id="kobo.410.2">When using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">fill</span></strong><span class="koboSpan" id="kobo.412.1"> attribute, you don’t have to set the width and height properties, as Angular will set them for you behind the scenes when the sizes </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">are resolved.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">To control how</span><a id="_idIndexMarker879"/><span class="koboSpan" id="kobo.415.1"> the image will fill the </span><a id="_idIndexMarker880"/><span class="koboSpan" id="kobo.416.1">container, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">object-fit</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.418.1">CSS property.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.419.1">More information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.420.1">Besides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">priority</span></strong><span class="koboSpan" id="kobo.422.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">fill</span></strong><span class="koboSpan" id="kobo.424.1"> attributes, when using a third-party service for your images, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.426.1"> directive has more cool features such as low-resolution placeholders and custom image loaders. </span><span class="koboSpan" id="kobo.426.2">These features are out of scope for this book, but if you want, you can read about them in the official Angular documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">at </span></span><a href="https://angular.io/guide/image-directive"><span class="No-Break"><span class="koboSpan" id="kobo.428.1">https://angular.io/guide/image-directive</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.429.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">Now that you know about </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.432.1"> and how you can use it to optimize your image and improve the LCP of your applications, let’s dive into the next performance optimization step: using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">trackBy</span></strong><span class="koboSpan" id="kobo.434.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">track</span></strong><span class="koboSpan" id="kobo.436.1"> function for loops inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">HTML template.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.438.1">Understanding and using the trackBy and track functions</span></h2>
<p><span class="koboSpan" id="kobo.439.1">In </span><a id="_idIndexMarker881"/><span class="koboSpan" id="kobo.440.1">Angular applications, rendering</span><a id="_idIndexMarker882"/><span class="koboSpan" id="kobo.441.1"> large lists or </span><a id="_idIndexMarker883"/><span class="koboSpan" id="kobo.442.1">collections of data can sometimes </span><a id="_idIndexMarker884"/><span class="koboSpan" id="kobo.443.1">lead to performance issues due to frequent DOM manipulations. </span><span class="koboSpan" id="kobo.443.2">To optimize the performance of your Angular application, it’s crucial you understand and leverage tools such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">trackBy</span></strong><span class="koboSpan" id="kobo.445.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">track</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.447.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">trackBy</span></strong><span class="koboSpan" id="kobo.450.1"> function is a feature provided by Angular that improves the performance when rendering lists using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">*ngFor</span></strong><span class="koboSpan" id="kobo.452.1"> directives. </span><span class="koboSpan" id="kobo.452.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">track</span></strong><span class="koboSpan" id="kobo.454.1"> function is the counterpart of the Angular control flow syntax. </span><span class="koboSpan" id="kobo.454.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">trackBy</span></strong><span class="koboSpan" id="kobo.456.1"> function is optional, whereas the </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">track</span></strong><span class="koboSpan" id="kobo.458.1"> function is required when using the control </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">flow syntax.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">By default, Angular uses object identifiers to track changes in the data provided to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">*ngFor</span></strong><span class="koboSpan" id="kobo.462.1"> directive. </span><span class="koboSpan" id="kobo.462.2">However, this approach can lead to unnecessary re-renders of DOM elements, particularly when dealing with dynamic data. </span><span class="koboSpan" id="kobo.462.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">track</span></strong><span class="koboSpan" id="kobo.464.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">trackBy</span></strong><span class="koboSpan" id="kobo.466.1"> functions allow Angular to efficiently track changes in the collection by providing a unique identifier for each item. </span><span class="koboSpan" id="kobo.466.2">This results in fewer DOM manipulations and significantly improves rendering performance, especially when dealing with </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">large datasets.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">When you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">*ngFor</span></strong><span class="koboSpan" id="kobo.470.1"> directive, you assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">trackBy</span></strong><span class="koboSpan" id="kobo.472.1"> property to a function and declare the corresponding function inside your component class. </span><span class="koboSpan" id="kobo.472.2">The function should return the unique identifier you want to use to track the items inside the list you </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">are rendering:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.474.1">
&lt;div *ngFor="let item of items; </span><strong class="bold"><span class="koboSpan" id="kobo.475.1">trackBy: trackById</span></strong><span class="koboSpan" id="kobo.476.1">"&gt;…&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.477.1">In the preceding code, you can see the HTML code using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">*ngFor</span></strong><span class="koboSpan" id="kobo.479.1"> directive and defining the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">trackBy</span></strong><span class="koboSpan" id="kobo.481.1"> property. </span><span class="koboSpan" id="kobo.481.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">trackBy</span></strong><span class="koboSpan" id="kobo.483.1"> property is assigned with a function named </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">trackById</span></strong><span class="koboSpan" id="kobo.485.1">. </span><span class="koboSpan" id="kobo.485.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">trackById</span></strong><span class="koboSpan" id="kobo.487.1"> function has to be declared inside the component class, </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.489.1">
trackById(index: number, item: Item) { return item.id }</span></pre> <p><span class="koboSpan" id="kobo.490.1">In the preceding</span><a id="_idIndexMarker885"/><span class="koboSpan" id="kobo.491.1"> example, you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">id</span></strong><span class="koboSpan" id="kobo.493.1"> property from </span><a id="_idIndexMarker886"/><span class="koboSpan" id="kobo.494.1">the objects you are rendering with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">*ngFor</span></strong><span class="koboSpan" id="kobo.496.1"> directive as</span><a id="_idIndexMarker887"/><span class="koboSpan" id="kobo.497.1"> the unique identifier (this assumes the objects have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">id</span></strong><span class="koboSpan" id="kobo.499.1"> property, otherwise</span><a id="_idIndexMarker888"/><span class="koboSpan" id="kobo.500.1"> you return another unique property). </span><span class="koboSpan" id="kobo.500.2">It’s important to note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">trackBy</span></strong><span class="koboSpan" id="kobo.502.1"> function should only be used when the items in the collection have a unique identifier. </span><span class="koboSpan" id="kobo.502.2">Using a non-unique identifier or omitting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">trackBy</span></strong><span class="koboSpan" id="kobo.504.1"> function altogether can lead to unexpected behavior and </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">performance issues.</span></span></p>
<p><span class="koboSpan" id="kobo.506.1">When using the control flow syntax to output a list inside your HTML template, the syntax is a bit simplified. </span><span class="koboSpan" id="kobo.506.2">Instead of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">trackBy</span></strong><span class="koboSpan" id="kobo.508.1"> function, you now use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">track</span></strong><span class="koboSpan" id="kobo.510.1"> function and directly provide it with the unique property to check instead of creating a function that returns the unique property, </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.512.1">
@for (item of items; track item.id) { … }</span></pre> <p><span class="koboSpan" id="kobo.513.1">Now that you know why you need to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">trackBy</span></strong><span class="koboSpan" id="kobo.515.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">track</span></strong><span class="koboSpan" id="kobo.517.1"> functions when rendering lists in your HTML templates, let’s explore web workers, the next performance optimization that Angular has at </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">its disposal.</span></span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.519.1">Understanding and using web workers in Angular</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.520.1">Web workers</span></strong><span class="koboSpan" id="kobo.521.1"> allow </span><a id="_idIndexMarker889"/><span class="koboSpan" id="kobo.522.1">you to execute CPU-intensive tasks within a separate thread running in the background, thereby making the primary thread free to update the user interface </span><a id="_idIndexMarker890"/><span class="koboSpan" id="kobo.523.1">and run the main threat without any hiccups. </span><span class="koboSpan" id="kobo.523.2">Whether it involves intricate tasks such as </span><a id="_idIndexMarker891"/><span class="koboSpan" id="kobo.524.1">producing </span><strong class="bold"><span class="koboSpan" id="kobo.525.1">computer-aided design</span></strong><span class="koboSpan" id="kobo.526.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.527.1">CAD</span></strong><span class="koboSpan" id="kobo.528.1">) drawings or conducting complex geometric computations, applications can leverage web workers to enhance overall </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">performance significantly.</span></span></p>
<p><span class="koboSpan" id="kobo.530.1">You add a web worker to your application with an Nx generator. </span><span class="koboSpan" id="kobo.530.2">Open the </span><strong class="bold"><span class="koboSpan" id="kobo.531.1">NX console</span></strong><span class="koboSpan" id="kobo.532.1">, click on </span><strong class="bold"><span class="koboSpan" id="kobo.533.1">generate</span></strong><span class="koboSpan" id="kobo.534.1">, search for web worker, and select the </span><strong class="bold"><span class="koboSpan" id="kobo.535.1">@nx/angular – web worker</span></strong><span class="koboSpan" id="kobo.536.1"> generator. </span><span class="koboSpan" id="kobo.536.2">Next, you need to give your web worker a name and select a project to add the web worker to. </span><span class="koboSpan" id="kobo.536.3">If you work without Nx, you can run the following </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">CLI command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.538.1">
ng generate web-worker &lt;location&gt;</span></pre> <p><span class="koboSpan" id="kobo.539.1">Running the Nx generator or </span><a id="_idIndexMarker892"/><span class="koboSpan" id="kobo.540.1">Angular CLI command will configure your project to use web workers if it isn’t configured already. </span><span class="koboSpan" id="kobo.540.2">It will also generate a file with your web workers. </span><span class="koboSpan" id="kobo.540.3">If you named your web worker </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">heavy-duty</span></strong><span class="koboSpan" id="kobo.542.1">, the generated file will be named </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">heavy-duty.worker.ts</span></strong><span class="koboSpan" id="kobo.544.1">; when using the Angular CLI, the name of the file will equal the location you provided in the </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">CLI command.</span></span></p>
<p><span class="koboSpan" id="kobo.546.1">Inside the generated worker file, you will find the initial scaffolded code you need for your web worker. </span><span class="koboSpan" id="kobo.546.2">When using Nx, you’ll find the following code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">generated file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.548.1">
addEventListener('message', ({ data }) =&gt; {
  const response = `worker response to ${data}`;
  postMessage(response);
});
if (typeof Worker !== 'undefined') {
  const worker = new Worker(new URL(‹./heavy-duty.worker', import.meta.url));
  worker.onmessage = ({ data }) =&gt; {
    console.log(`page got message ${data}`);
  };
  worker.postMessage(‹hello›);
} else { // Fallback for environment. </span><span class="koboSpan" id="kobo.548.2">}</span></pre> <p><span class="koboSpan" id="kobo.549.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">addEventListener</span></strong><span class="koboSpan" id="kobo.551.1"> function will stay in the worker file, and the rest of the code must be located in the component or service where you want to use the web worker. </span><span class="koboSpan" id="kobo.551.2">By moving everything but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">addEventListner</span></strong><span class="koboSpan" id="kobo.553.1"> function, you can send messages from the component or service to the web worker. </span><span class="koboSpan" id="kobo.553.2">As you can see, in the code that must be moved, there is a fallback for environments where the web worker doesn’t work. </span><span class="koboSpan" id="kobo.553.3">This is because when using server-side rendering, web workers do not work and you need to have </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">a fallback.</span></span></p>
<p><span class="koboSpan" id="kobo.555.1">To work with the web worker, you </span><a id="_idIndexMarker893"/><span class="koboSpan" id="kobo.556.1">need to send messages to and from the web worker </span><a id="_idIndexMarker894"/><span class="koboSpan" id="kobo.557.1">to perform the logic you need to perform. </span><span class="koboSpan" id="kobo.557.2">For example, let’s say you want to use the web worker when a component is initialized. </span><span class="koboSpan" id="kobo.557.3">To achieve this, you add the following code inside the component where you want to use the </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">web worker:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.559.1">
@Component({……})
export class FooComponent {
  heavyDutyResult;
  heavyDutyInput = {……};
  constructor() { this.runWebWorker() }
  runWebWorker () {
    if (typeof Worker !== ‹undefined›) {
      const worker = new Worker(new URL(‹./heavy-duty.worker›, import.meta.url));
      worker.onmessage = ({ data }) =&gt; {
        this.heavyDutyResult = data;
      };
      worker.postMessage(this. </span><span class="koboSpan" id="kobo.559.2">heavyDutyInput);
    } else { // Fall back }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.560.1">As you can see in the </span><a id="_idIndexMarker895"/><span class="koboSpan" id="kobo.561.1">preceding code, you use </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">worker.postMessage</span></strong><span class="koboSpan" id="kobo.563.1"> to send a message to the web worker. </span><span class="koboSpan" id="kobo.563.2">This is received inside the event listener of the web worker. </span><span class="koboSpan" id="kobo.563.3">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">postMessage()</span></strong><span class="koboSpan" id="kobo.565.1"> function is called in the web worker, it will be received in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">worker.onmessage()</span></strong><span class="koboSpan" id="kobo.567.1"> callback function inside the component. </span><span class="koboSpan" id="kobo.567.2">Now, you </span><a id="_idIndexMarker896"/><span class="koboSpan" id="kobo.568.1">only need to update the web worker file to perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">heavy-duty logic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.570.1">
addEventListener('message', ({ data }) =&gt; {
  const response = heavyDutyFunction(data);
  postMessage(response);
});</span></pre> <p><span class="koboSpan" id="kobo.571.1">As you can see in the preceding code, we perform some logic – in this example, an imaginary </span><strong class="source-inline"><span class="koboSpan" id="kobo.572.1">heavyDutyFunction()</span></strong><span class="koboSpan" id="kobo.573.1"> – and send the response back to the component using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">postMessage()</span></strong><span class="koboSpan" id="kobo.575.1"> function. </span><span class="koboSpan" id="kobo.575.2">Now the circle is complete. </span><span class="koboSpan" id="kobo.575.3">You can send some data from the component to the web worker and the web worker will receive this data, perform the heavy-duty logic with the data, and returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">response</span></strong><span class="koboSpan" id="kobo.577.1"> constant to the </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">component class.</span></span></p>
<p><span class="koboSpan" id="kobo.579.1">Now you know how to use a web worker to create multithreading and run resource-intensive code without blocking your main threat. </span><span class="koboSpan" id="kobo.579.2">To wrap up the section, I will mention some other methods you can use to improve the performance of your </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">Angular applications:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.581.1">Lazy loading</span></strong><span class="koboSpan" id="kobo.582.1">: Lazy loading</span><a id="_idIndexMarker897"/><span class="koboSpan" id="kobo.583.1"> routes help to only load sections of your app that </span><a id="_idIndexMarker898"/><span class="koboSpan" id="kobo.584.1">the user actually reaches. </span><span class="koboSpan" id="kobo.584.2">We already showcased this in </span><a href="B21625_02.xhtml#_idTextAnchor033"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.585.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.586.1">, but it’s worth mentioning as a </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">performance optimalization.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.588.1">Pre-loading routes</span></strong><span class="koboSpan" id="kobo.589.1">: Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">preloadingStrategy</span></strong><span class="koboSpan" id="kobo.591.1"> on your routes, you can also pre-load </span><a id="_idIndexMarker899"/><span class="koboSpan" id="kobo.592.1">routes you</span><a id="_idIndexMarker900"/><span class="koboSpan" id="kobo.593.1"> anticipate the user </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">will navigate.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.595.1">Caching</span></strong><span class="koboSpan" id="kobo.596.1">: You should cache your API requests and the results of heavy tasks you</span><a id="_idIndexMarker901"/><span class="koboSpan" id="kobo.597.1"> regularly perform. </span><span class="koboSpan" id="kobo.597.2">You can build your own caching</span><a id="_idIndexMarker902"/><span class="koboSpan" id="kobo.598.1"> system by utilizing </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">Record</span></strong><span class="koboSpan" id="kobo.600.1"> classes, for example. </span><span class="koboSpan" id="kobo.600.2">For API requests, I can recommend </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">ts-cachable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.604.1">Using pure pipes</span></strong><span class="koboSpan" id="kobo.605.1">: We already </span><a id="_idIndexMarker903"/><span class="koboSpan" id="kobo.606.1">explained the usage of pipes and what </span><a id="_idIndexMarker904"/><span class="koboSpan" id="kobo.607.1">pure pipes are in </span><a href="B21625_03.xhtml#_idTextAnchor058"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.608.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.609.1">, but they are worth mentioning as a </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">performance optimalization.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.611.1">Using canMatch</span></strong><span class="koboSpan" id="kobo.612.1">: Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">canMatch</span></strong><span class="koboSpan" id="kobo.614.1"> route guard</span><a id="_idIndexMarker905"/><span class="koboSpan" id="kobo.615.1"> combined with</span><a id="_idIndexMarker906"/><span class="koboSpan" id="kobo.616.1"> lazy-loaded routes prevents you from loading modules and components the user is not allowed </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">to access.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.618.1">Using RxJS effectively</span></strong><span class="koboSpan" id="kobo.619.1">: Running </span><a id="_idIndexMarker907"/><span class="koboSpan" id="kobo.620.1">code asynchronously doesn’t block your threat </span><a id="_idIndexMarker908"/><span class="koboSpan" id="kobo.621.1">and can help to improve the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">your application.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.623.1">Server-side rendering</span></strong><span class="koboSpan" id="kobo.624.1">: By </span><a id="_idIndexMarker909"/><span class="koboSpan" id="kobo.625.1">running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">ng add @angular/ssr</span></strong><span class="koboSpan" id="kobo.627.1"> command, you can enable</span><a id="_idIndexMarker910"/><span class="koboSpan" id="kobo.628.1"> server-side rendering, greatly improving the performance of your application. </span><span class="koboSpan" id="kobo.628.2">We will not cover server-side rendering in further detail, but as of Angular 17, you can also include page hydration when using server-side rendering, further enhancing </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">the performance.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.630.1">Virtual scrolling</span></strong><span class="koboSpan" id="kobo.631.1">: Virtual scrolling</span><a id="_idIndexMarker911"/><span class="koboSpan" id="kobo.632.1"> is a feature in the Angular Material CDK </span><a id="_idIndexMarker912"/><span class="koboSpan" id="kobo.633.1">that enables you to effectively render large lists. </span><span class="koboSpan" id="kobo.633.2">The virtual scroll will ensure that only items within the viewport </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">are rendered.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.635.1">You now know how to improve the performance of your Angular applications using </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">OnPush</span></strong><span class="koboSpan" id="kobo.637.1"> and Signals, run code outside the NgZone or create multithreading using web workers, optimize images using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.639.1"> directive, and render lists in a performant way by utilizing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">trackBy</span></strong><span class="koboSpan" id="kobo.641.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">track</span></strong><span class="koboSpan" id="kobo.643.1"> functions. </span><span class="koboSpan" id="kobo.643.2">You also learned about other tools and tips to further enhance the performance of your Angular applications. </span><span class="koboSpan" id="kobo.643.3">Next, we will learn how you can improve the security of your </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">Angular applications.</span></span></p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.645.1">Building secure Angular applications</span></h1>
<p><span class="koboSpan" id="kobo.646.1">In a world where hacks and exploits are more frequent than ever, you are also responsible for developing secure applications. </span><span class="koboSpan" id="kobo.646.2">In this section, we’ll delve into the various security risks that Angular applications may face and explore strategies to mitigate </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">them effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.648.1">When it comes to securing frontend applications, you want to ensure that the users can’t reach parts of your application they are not intended to go to and that they can’t perform malicious actions that will compromise your application. </span><span class="koboSpan" id="kobo.648.2">We will first look at the first scenario and ensure that users can’t reach sections of your applications they are not intended </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">to reach.</span></span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.650.1">Setting up route guards</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.651.1">Route guards</span></strong><span class="koboSpan" id="kobo.652.1"> are used</span><a id="_idIndexMarker913"/><span class="koboSpan" id="kobo.653.1"> to guard specific routes within your Angular application. </span><span class="koboSpan" id="kobo.653.2">They prevent unauthorized users from accessing certain parts of your application. </span><span class="koboSpan" id="kobo.653.3">For example, most parts of your application should only be accessible to users who are logged in; other routes might be restricted based on user roles or other factors. </span><span class="koboSpan" id="kobo.653.4">Within Angular, there are four different types of </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">route guards:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.655.1">canActivate</span></strong><span class="koboSpan" id="kobo.656.1">: Determines</span><a id="_idIndexMarker914"/><span class="koboSpan" id="kobo.657.1"> whether the user can activate a </span><a id="_idIndexMarker915"/><span class="No-Break"><span class="koboSpan" id="kobo.658.1">specific route.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.659.1">canActivateChild</span></strong><span class="koboSpan" id="kobo.660.1">: Determines </span><a id="_idIndexMarker916"/><span class="koboSpan" id="kobo.661.1">whether the user can activate the</span><a id="_idIndexMarker917"/><span class="koboSpan" id="kobo.662.1"> child routes of a </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">specific route.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.664.1">canDeactivate</span></strong><span class="koboSpan" id="kobo.665.1">: Determines </span><a id="_idIndexMarker918"/><span class="koboSpan" id="kobo.666.1">whether a user can deactivate a </span><a id="_idIndexMarker919"/><span class="No-Break"><span class="koboSpan" id="kobo.667.1">specific route.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.668.1">canMatch</span></strong><span class="koboSpan" id="kobo.669.1">: Determines</span><a id="_idIndexMarker920"/><span class="koboSpan" id="kobo.670.1"> whether a user can load a specific route. </span><span class="koboSpan" id="kobo.670.2">The </span><a id="_idIndexMarker921"/><span class="koboSpan" id="kobo.671.1">difference from </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">canActivate</span></strong><span class="koboSpan" id="kobo.673.1"> is that if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">canMatch</span></strong><span class="koboSpan" id="kobo.675.1"> guard fails, the module or standalone component related to the route is not loaded at all. </span><span class="koboSpan" id="kobo.675.2">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">canMatch</span></strong><span class="koboSpan" id="kobo.677.1"> offers some performance benefits when combined with </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">lazy-loaded routes.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.679.1">Since Angular 15, route guards</span><a id="_idIndexMarker922"/><span class="koboSpan" id="kobo.680.1"> have been implemented using a functional approach; in earlier versions, a class-based approach was used. </span><span class="koboSpan" id="kobo.680.2">The class-based approach is currently deprecated, so we will only cover the functional approach. </span><span class="koboSpan" id="kobo.680.3">You can declare each guard type you want to use in your route configuration, </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.682.1">
{
  path: ‹…',
  loadComponent: () =&gt; import(‹……'),
  canMatch: [],
  canActivate: [],
}</span></pre> <p><span class="koboSpan" id="kobo.683.1">As you can see, you define the guards in the route configuration object. </span><span class="koboSpan" id="kobo.683.2">Each guard type is assigned an array containing the guard function that it should resolve before the user can access the route. </span><span class="koboSpan" id="kobo.683.3">Each guard function returns a Boolean: </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">true</span></strong><span class="koboSpan" id="kobo.685.1"> if the guard passes and the user can access the route, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">false</span></strong><span class="koboSpan" id="kobo.687.1"> if the guard fails and the user can’t access </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">the route.</span></span></p>
<p><span class="koboSpan" id="kobo.689.1">In its simplest form, you can define the guard function directly inside the array assigned to the guard </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">type property:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.691.1">
canMatch: [() =&gt; inject(UserService).loggedIn],</span></pre> <p><span class="koboSpan" id="kobo.692.1">In the preceding example, we </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">inject</span></strong><span class="koboSpan" id="kobo.694.1"> a service and check whether the user is logged in (we did not create the service in this book; this is just an example). </span><span class="koboSpan" id="kobo.694.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">loggedIn</span></strong><span class="koboSpan" id="kobo.696.1"> property is </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">true</span></strong><span class="koboSpan" id="kobo.698.1">, the user can access the route. </span><span class="koboSpan" id="kobo.698.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">loggedIn</span></strong><span class="koboSpan" id="kobo.700.1"> property is </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">false</span></strong><span class="koboSpan" id="kobo.702.1">, the user can’t access </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">the route.</span></span></p>
<p><span class="koboSpan" id="kobo.704.1">In some scenarios, you </span><a id="_idIndexMarker923"/><span class="koboSpan" id="kobo.705.1">might need access to route properties or the current component. </span><span class="koboSpan" id="kobo.705.2">If this is the case, you create a function that implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">CanActivateFn</span></strong><span class="koboSpan" id="kobo.707.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">CanActivateChildFn</span></strong><span class="koboSpan" id="kobo.709.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">CanDeactivateFn</span></strong><span class="koboSpan" id="kobo.711.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">CanMatchFn</span></strong><span class="koboSpan" id="kobo.713.1"> type aliases. </span><span class="koboSpan" id="kobo.713.2">When using these type aliases, Angular provides the function with some function parameters you can use inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">guard logic:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.715.1">CanActivateFn</span></strong><span class="koboSpan" id="kobo.716.1">: Contains the function parameters: route of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">ActivatedRouteSnapshot</span></strong><span class="koboSpan" id="kobo.718.1"> and state of </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">RouterStateSnapshot</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.722.1">CanActivateChildFn</span></strong><span class="koboSpan" id="kobo.723.1">: Contains the same function parameters as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">CanActivateFn</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.725.1">type alias.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.726.1">CanDeactivateFn</span></strong><span class="koboSpan" id="kobo.727.1">: Contains the function parameters: component with a dynamic type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">currentRoute</span></strong><span class="koboSpan" id="kobo.729.1"> of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">ActivatedRouteSnapshot</span></strong><span class="koboSpan" id="kobo.731.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">currentState</span></strong><span class="koboSpan" id="kobo.733.1"> of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">RouterStateSnapshot</span></strong><span class="koboSpan" id="kobo.735.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">nextState</span></strong><span class="koboSpan" id="kobo.737.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">RouterStateSnapshot</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.741.1">CanMatchFn</span></strong><span class="koboSpan" id="kobo.742.1">: Contains the function parameters: </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">route</span></strong><span class="koboSpan" id="kobo.744.1"> of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">Route</span></strong><span class="koboSpan" id="kobo.746.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">segments</span></strong><span class="koboSpan" id="kobo.748.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">type </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">UrlSegment[]</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.752.1">You use the type aliases by defining a function that resolves in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">Boolean</span></strong><span class="koboSpan" id="kobo.754.1">. </span><span class="koboSpan" id="kobo.754.2">You type the function with the type alias and include the function parameters inside the function brackets. </span><span class="koboSpan" id="kobo.754.3">Here is an example implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">CanMatchFn</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.756.1">type alias:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.757.1">
export const hasRouteSegements: CanMatchFn = (route: Route, segments: UrlSegment[]) =&gt; {
return inject(UserService).loggedIn &amp;&amp; segments.length &gt; 1;
};</span></pre> <p><span class="koboSpan" id="kobo.758.1">In the preceding </span><a id="_idIndexMarker924"/><span class="koboSpan" id="kobo.759.1">example, we check whether the user is logged in and whether there is more than one route segment. </span><span class="koboSpan" id="kobo.759.2">To use this guard, you add it to the array of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">canMatch</span></strong><span class="koboSpan" id="kobo.761.1"> property inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">route configuration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.763.1">
canMatch: [hasRouteSegements]</span></pre> <p><span class="koboSpan" id="kobo.764.1">You can also directly implement the type alias inside the array without defining the </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">function elsewhere:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.766.1">
canDeactivate: [(component: UserComponent) =&gt; !component.hasUnsavedChanges]</span></pre> <p><span class="koboSpan" id="kobo.767.1">Now you know how to define functional route guards and prevent unauthorized users from accessing routes they aren’t allowed </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">to access.</span></span></p>
<p><span class="koboSpan" id="kobo.769.1">Although this already makes your application more secure, there are other risks when building Angular applications whereby users can perform malicious activities. </span><span class="koboSpan" id="kobo.769.2">So, let’s outline some attack surfaces and learn how you can </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">mitigate them.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.771.1">Angular attack surfaces and how to mitigate them</span></h2>
<p><span class="koboSpan" id="kobo.772.1">Before</span><a id="_idIndexMarker925"/><span class="koboSpan" id="kobo.773.1"> delving into </span><a id="_idIndexMarker926"/><span class="koboSpan" id="kobo.774.1">+Angular-specific security measures, it’s essential to understand the common threats that web applications face. </span><span class="koboSpan" id="kobo.774.2">These threats include </span><strong class="bold"><span class="koboSpan" id="kobo.775.1">cross-site scripting</span></strong><span class="koboSpan" id="kobo.776.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.777.1">XSS</span></strong><span class="koboSpan" id="kobo.778.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.779.1">cross-site request forgery</span></strong><span class="koboSpan" id="kobo.780.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.781.1">CSRF</span></strong><span class="koboSpan" id="kobo.782.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.783.1">XSRF</span></strong><span class="koboSpan" id="kobo.784.1">), injection attacks, and HTTP-level vulnerabilities </span><a id="_idIndexMarker927"/><span class="koboSpan" id="kobo.785.1">such as </span><strong class="bold"><span class="koboSpan" id="kobo.786.1">cross-site script </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.787.1">inclusion</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.788.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.789.1">XSSI</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.791.1">Angular has some built-in tools to reduce the security risks of these attacks for you and there are some preventive measures you can take yourself when developing your Angular application. </span><span class="koboSpan" id="kobo.791.2">Let’s start with the most prevalent risk when developing frontend applications: </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">XSS attacks.</span></span></p>
<h3><span class="koboSpan" id="kobo.793.1">Mitigating XSS attacks</span></h3>
<p><span class="koboSpan" id="kobo.794.1">In simple terms, you block</span><a id="_idIndexMarker928"/><span class="koboSpan" id="kobo.795.1"> XSS attacks by preventing malicious code from entering the </span><strong class="bold"><span class="koboSpan" id="kobo.796.1">Document Object Model</span></strong><span class="koboSpan" id="kobo.797.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.798.1">DOM</span></strong><span class="koboSpan" id="kobo.799.1">). </span><span class="koboSpan" id="kobo.799.2">For example, XSS attacks can run malicious code on your website if they can </span><a id="_idIndexMarker929"/><span class="koboSpan" id="kobo.800.1">trick you into injecting a </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.802.1"> tag into the DOM. </span><span class="koboSpan" id="kobo.802.2">Other HTML elements that allow code exaction and can be used by attackers include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">&lt;img&gt;</span></strong><span class="koboSpan" id="kobo.804.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">&lt;a&gt;</span></strong><span class="koboSpan" id="kobo.806.1"> tags. </span><span class="koboSpan" id="kobo.806.2">An attacker can use an XSS attack to hijack user sessions, steal sensitive data, or </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">deface websites.</span></span></p>
<p><span class="koboSpan" id="kobo.808.1">Angular takes a</span><a id="_idIndexMarker930"/><span class="koboSpan" id="kobo.809.1"> proactive approach to security, treating all values as untrusted by default. </span><span class="koboSpan" id="kobo.809.2">This means that when values are inserted into the DOM via template binding or interpolation, Angular automatically sanitizes and escapes untrusted values. </span><span class="koboSpan" id="kobo.809.3">This approach significantly reduces the risk of XSS attacks, a prevalent security vulnerability. </span><span class="koboSpan" id="kobo.809.4">Even though Angular proactively sanitizes and escapes untrusted values, there are still some actions you can take to make your applications even safer and protect them from </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">security vulnerabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.811.1">Values inserted into the DOM via template binding or interpolation are automatically sanitized and escaped if the values are not trusted. </span><span class="koboSpan" id="kobo.811.2">On the other hand, Angular trusts HTML templates by default, because of which you should treat HTML templates as executable code. </span><span class="koboSpan" id="kobo.811.3">Never directly concatenate user input and template syntax because this would enable an attacker to inject harmful code into your application. </span><span class="koboSpan" id="kobo.811.4">Here is an example of what you </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">should avoid:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.813.1">
&lt;div&gt;{{ data }}&lt;/div&gt; + userInput</span></pre> <p><span class="koboSpan" id="kobo.814.1">One way to reduce the template risks is by using the</span><a id="_idIndexMarker931"/><span class="koboSpan" id="kobo.815.1"> default </span><strong class="bold"><span class="koboSpan" id="kobo.816.1">ahead-of-time</span></strong><span class="koboSpan" id="kobo.817.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.818.1">AOT</span></strong><span class="koboSpan" id="kobo.819.1">) template compiler when creating production builds. </span><span class="koboSpan" id="kobo.819.2">Because the AOT compiler is the default, you don’t have to do anything unless you change the default </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">compile settings.</span></span></p>
<p><span class="koboSpan" id="kobo.821.1">Other possible attack surfaces for an XSS attack are </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">style</span></strong><span class="koboSpan" id="kobo.823.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">innerHTML</span></strong><span class="koboSpan" id="kobo.825.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">href</span></strong><span class="koboSpan" id="kobo.827.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">src</span></strong><span class="koboSpan" id="kobo.829.1"> bindings where the bound value is provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">the user:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.831.1">
&lt;div [innerHTML]="htmlSnippet"&gt;&lt;/div&gt;
&lt;div [style]="userProvidedStyles"&gt;...&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.832.1">Attackers can use unsafe binding to inject harmful code or URLs into your application. </span><span class="koboSpan" id="kobo.832.2">Besides unsafe bindings, you also should avoid direct interaction with the DOM. </span><span class="koboSpan" id="kobo.832.3">If you bind an unsafe value, Angular will recognize it in most cases and sanitize it by removing the unsafe value. </span><span class="koboSpan" id="kobo.832.4">It’s good to be aware of this because it can lead to broken functionality in your application. </span><span class="koboSpan" id="kobo.832.5">Also, some attackers might be able to circumvent the sanitation, so be careful when using unsafe binding options. </span><span class="koboSpan" id="kobo.832.6">If you want to bind a URL, script, or other value that Angular will sanitize and you know the value is safe, you can bypass the sanitation using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">DomSanitizer</span></strong><span class="koboSpan" id="kobo.834.1"> service provided </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">by Angular.</span></span></p>
<p><span class="koboSpan" id="kobo.836.1">If you want to bypass sanitation, you start by injecting the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">DomSanitizer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.838.1"> service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.839.1">
protected readonly sanitizer = inject(</span><strong class="bold"><span class="koboSpan" id="kobo.840.1">DomSanitizer</span></strong><span class="koboSpan" id="kobo.841.1">);</span></pre> <p><span class="koboSpan" id="kobo.842.1">Next, you can </span><a id="_idIndexMarker932"/><span class="koboSpan" id="kobo.843.1">use the bypass methods exposed by the service to </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">bypass sanitation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.845.1">
this.trustedUrl = this.sanitizer.bypassSecurityTrustUrl(this.dangerousUrl);</span></pre> <p><span class="koboSpan" id="kobo.846.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">DomSanitizer</span></strong><span class="koboSpan" id="kobo.848.1"> service exposes five different options to </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">bypass sanitation:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">bypassSecurityTrustHtml</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">bypassSecurityTrustScript</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">bypassSecurityTrustStyle</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">bypassSecurityTrustUrl</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">bypassSecurityTrustResourceUrl</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.855.1">Depending on what value you are bypassing, you use the corresponding </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">bypassSecurity</span></strong><span class="koboSpan" id="kobo.857.1"> method, so to bypass the sanitation of a piece of HTML, you would use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">bypassSecurityTrustHtml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.859.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.860.1">Besides binding unsafe values, another possible attack surface is direct manipulation of the DOM. </span><span class="koboSpan" id="kobo.860.2">The built-in browser DOM APIs don’t protect you from security vulnerabilities unless </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">Trusted Types</span></strong><span class="koboSpan" id="kobo.862.1"> are configured. </span><span class="koboSpan" id="kobo.862.2">For example, elements accessed through </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">ElementRef</span></strong><span class="koboSpan" id="kobo.864.1"> instances, the browser document, and many third-party APIs contain unsafe methods. </span><span class="koboSpan" id="kobo.864.2">You should avoid interacting with the DOM directly and instead use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">Renderer2</span></strong><span class="koboSpan" id="kobo.866.1"> service when you need to manipulate </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">DOM nodes.</span></span></p>
<p><span class="koboSpan" id="kobo.868.1">Lastly, you </span><a id="_idIndexMarker933"/><span class="koboSpan" id="kobo.869.1">can configure a </span><strong class="bold"><span class="koboSpan" id="kobo.870.1">Content Security Policy</span></strong><span class="koboSpan" id="kobo.871.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.872.1">CSP</span></strong><span class="koboSpan" id="kobo.873.1">) to prevent XSS attacks. </span><span class="koboSpan" id="kobo.873.2">A CSP can be enabled </span><a id="_idIndexMarker934"/><span class="koboSpan" id="kobo.874.1">on the web server and falls out of scope for </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.876.1">You now know what XSS attacks are, what Angular does to prevent them, and what measures you can take to prevent them. </span><span class="koboSpan" id="kobo.876.2">Next, you will learn what vulnerabilities there are when making HTTP requests and what you can do in your Angular applications to </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">prevent them.</span></span></p>
<h3><span class="koboSpan" id="kobo.878.1">Mitigating HTTP-related security risks</span></h3>
<p><span class="koboSpan" id="kobo.879.1">Ensuring </span><a id="_idIndexMarker935"/><span class="koboSpan" id="kobo.880.1">robust security measures against HTTP-related risks is paramount to safeguarding your application and its users. </span><span class="koboSpan" id="kobo.880.2">Two significant threats to consider are CSRF (or XSRF) and XSSI. </span><span class="koboSpan" id="kobo.880.3">In this section, we will dive deeper into CSRF and XSSI and explain what they are, how they can affect your applications and users, and what measures you can take to prevent CSRF and </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">XSSI exploits.</span></span></p>
<p><span class="koboSpan" id="kobo.882.1">While CSRF and XSSI predominantly have to be mitigated on the server side, Angular does provide some tools to make the integration with the client side a bit easier. </span><span class="koboSpan" id="kobo.882.2">We will start by explaining what CSRF is and what you need to do on the client side to </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">prevent it.</span></span></p>
<h3><span class="koboSpan" id="kobo.884.1">What CSRF/XSRF attacks are and how to prevent them</span></h3>
<p><span class="koboSpan" id="kobo.885.1">Imagine you’re logged</span><a id="_idIndexMarker936"/><span class="koboSpan" id="kobo.886.1"> into your online banking account in one tab of your browser. </span><span class="koboSpan" id="kobo.886.2">Now, if you visit a malicious website in another tab, that site can secretly make requests to your banking website without your knowledge. </span><span class="koboSpan" id="kobo.886.3">These requests could transfer money, change your password, or perform any action that your banking website allows – all without </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">your consent.</span></span></p>
<p><span class="koboSpan" id="kobo.888.1">CSRF/XSRF attacks can have serious consequences. </span><span class="koboSpan" id="kobo.888.2">They can lead to unauthorized transactions, data manipulation, and even account takeovers. </span><span class="koboSpan" id="kobo.888.3">Since the attacker doesn’t need to know your login credentials, these attacks can bypass traditional </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">authentication mechanisms.</span></span></p>
<p><span class="koboSpan" id="kobo.890.1">To protect against CSRF/XSRF attacks, websites </span><a id="_idIndexMarker937"/><span class="koboSpan" id="kobo.891.1">typically use techniques such as CSRF tokens. </span><span class="koboSpan" id="kobo.891.2">These tokens are unique identifiers generated by the server and sent to the frontend. </span><span class="koboSpan" id="kobo.891.3">The frontend includes these random tokens with each request so the server can verify the token, ensuring that the request originated from a legitimate source and not from a malicious website. </span><span class="koboSpan" id="kobo.891.4">Commonly, the token is sent to the frontend using a cookie flagged with </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">SameSite</span></strong><span class="koboSpan" id="kobo.893.1">. </span><span class="koboSpan" id="kobo.893.2">If the cookie also includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">httpOnly</span></strong><span class="koboSpan" id="kobo.895.1"> flag, you don’t have to do anything on the frontend and everything will be handled on the backend, but this isn’t always the case; often, you must include the token in the </span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">request headers.</span></span></p>
<p><span class="koboSpan" id="kobo.897.1">Using a CSRF token is an effective measure because all browsers have the same-origin policy. </span><span class="koboSpan" id="kobo.897.2">The same-origin policy ensures that only the code of the website where a cookie is set can read the cookie. </span><span class="koboSpan" id="kobo.897.3">The same-origin policy also ensures that a custom request header can be set by the code of the application making the request. </span><span class="koboSpan" id="kobo.897.4">That means that malicious code from the website the attacker tricked you into using cannot read the cookie or set the headers for your request. </span><span class="koboSpan" id="kobo.897.5">Only the code of your own application can </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">do this.</span></span></p>
<p><span class="koboSpan" id="kobo.899.1">If the cookie with the </span><a id="_idIndexMarker938"/><span class="koboSpan" id="kobo.900.1">CSFR token is not an </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">httpOnly</span></strong><span class="koboSpan" id="kobo.902.1"> cookie and the client is required to add the cookie in the request header, you can create an HTTP interceptor for this purpose. </span><span class="koboSpan" id="kobo.902.2">Here is an example of how the interceptor could </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">be implemented:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.904.1">
export const MockInterceptor: HttpInterceptorFn = (
  req: HttpRequest&lt;unknown&gt;,
  next: HttpHandlerFn,
) =&gt; {
  const csrfToken = inject(AuthService).getCsrfToken();
  const csrfReq = req.clone({
    setHeaders: {
      ‹X-XSRF-TOKEN›: csrfToken,
    },
  });
  return next(csrfReq);
};</span></pre> <p><span class="koboSpan" id="kobo.905.1">Besides adding a CSRF token, there isn’t anything you can do on the frontend to protect your application from CSRF attacks. </span><span class="koboSpan" id="kobo.905.2">If you need to add the token, it depends on how the server side implements the cookie, so consult with the backend team about </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">this topic.</span></span></p>
<p><span class="koboSpan" id="kobo.907.1">Now that you know what CSRF/XSRF attacks are, let’s learn about </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">XSSI attacks.</span></span></p>
<h3><span class="koboSpan" id="kobo.909.1">What XSSI attacks are and how to prevent them</span></h3>
<p><span class="koboSpan" id="kobo.910.1">XSSI attacks occur</span><a id="_idIndexMarker939"/><span class="koboSpan" id="kobo.911.1"> when an attacker injects malicious scripts into a web page from an external domain. </span><span class="koboSpan" id="kobo.911.2">These scripts are executed in the context of the victim’s session, potentially compromising sensitive information and performing unauthorized actions. </span><span class="koboSpan" id="kobo.911.3">XSSI attacks can lead to data theft, session hijacking, and unauthorized manipulation of </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">user interactions.</span></span></p>
<p><span class="koboSpan" id="kobo.913.1">XSSI attacks </span><a id="_idIndexMarker940"/><span class="koboSpan" id="kobo.914.1">are also known as the </span><strong class="bold"><span class="koboSpan" id="kobo.915.1">JSON vulnerability</span></strong><span class="koboSpan" id="kobo.916.1"> because this vulnerability exploits weaknesses in older browser versions by</span><a id="_idIndexMarker941"/><span class="koboSpan" id="kobo.917.1"> manipulating native JavaScript object constructors. </span><span class="koboSpan" id="kobo.917.2">By overriding these constructors and embedding an API URL within a </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.919.1"> tag, malicious actors can execute unauthorized requests and retrieve sensitive information from the targeted </span><span class="No-Break"><span class="koboSpan" id="kobo.920.1">JSON API.</span></span></p>
<p><span class="koboSpan" id="kobo.921.1">The success of this exploit hinges on the JSON data being executable as JavaScript. </span><span class="koboSpan" id="kobo.921.2">To prevent XSSI attacks, servers can adopt a preventive measure by prefixing all JSON responses, rendering them non-executable. </span><span class="koboSpan" id="kobo.921.3">Conventionally, this is achieved by appending the widely recognized </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">)]}',\</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">n</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.924.1"> string.</span></span></p>
<p><span class="koboSpan" id="kobo.925.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">HttpClient</span></strong><span class="koboSpan" id="kobo.927.1"> of the Angular framework is equipped to handle this security measure seamlessly. </span><span class="koboSpan" id="kobo.927.2">It detects and removes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">)]}',\n</span></strong><span class="koboSpan" id="kobo.929.1"> string from incoming responses automatically before proceeding with further parsing, thus fortifying the application against potential exploits. </span><span class="koboSpan" id="kobo.929.2">Because Angular automatically detects the </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">)]}',\n</span></strong><span class="koboSpan" id="kobo.931.1"> string and removes it for you, you don’t have to do anything for XSSI prevention in the frontend, but it’s always good to be aware of the attack and how it actually can be prevented. </span><span class="koboSpan" id="kobo.931.2">If your backend team uses a different prevention measure, align with it to see whether you need to do anything in </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">the frontend.</span></span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.933.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.934.1">In this chapter, you learned about performance and security. </span><span class="koboSpan" id="kobo.934.2">You took a deep dive into Angular change detection, giving you a better understanding of how Angular detects changes and how you can reduce the number of components and bindings that Angular has to check when performing </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">change detection.</span></span></p>
<p><span class="koboSpan" id="kobo.936.1">You also learned about other measures you can take to ensure your Angular applications remain performant. </span><span class="koboSpan" id="kobo.936.2">You learned how to run code outside of the Angular zone, you learned about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">NgOptimizedImage</span></strong><span class="koboSpan" id="kobo.938.1"> directive, you learned about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">trackBy</span></strong><span class="koboSpan" id="kobo.940.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">track</span></strong><span class="koboSpan" id="kobo.942.1"> functions, and you’ve created your own web worker to run code in a separate threat. </span><span class="koboSpan" id="kobo.942.2">Furthermore, you learned that you can use lazy loading, </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">canMatch</span></strong><span class="koboSpan" id="kobo.944.1">, server-side rendering, and other tools provided by the Angular framework to enhance application performance </span><span class="No-Break"><span class="koboSpan" id="kobo.945.1">even more.</span></span></p>
<p><span class="koboSpan" id="kobo.946.1">After taking a deep dive into Angular application performance, you learned how you can develop secure frontend applications using the Angular framework. </span><span class="koboSpan" id="kobo.946.2">You learned how to prevent users from accessing pages they aren’t intended to reach. </span><span class="koboSpan" id="kobo.946.3">You also learned about common exploits, what measures Angular takes to prevent these attacks, and what steps you can take to make your application even </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">more secure.</span></span></p>
<p><span class="koboSpan" id="kobo.948.1">In the next chapter, you will learn how to make your applications more accessible and tailored to the users visiting them. </span><span class="koboSpan" id="kobo.948.2">You will learn about translatable content, using the correct formatting and symbols for each user, and making your website accessible to people of </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">all abilities.</span></span></p>
</div>
</body></html>