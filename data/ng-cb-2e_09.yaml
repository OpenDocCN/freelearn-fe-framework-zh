- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Angular and the Angular CDK
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 和 Angular CDK
- en: Angular has an amazing ecosystem of tools and libraries, including Angular Material,
    the **Angular command-line interface** (**Angular CLI**), and the beloved **Angular
    Component Dev Kit** (**Angular CDK**). I call it “beloved” because if you are
    to implement your own custom interactions and behaviors in Angular apps without
    having to rely on an entire set of libraries, the Angular CDK is going to be your
    best friend. In this chapter, you’ll learn what an amazing combination of Angular
    and the Angular CDK is. You’ll learn about some neat components built into the
    CDK and will also use some CDK **APIs** to create amazing and optimized content.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 拥有一个令人惊叹的工具和库生态系统，包括 Angular Material、**Angular 命令行界面**（**Angular CLI**）以及备受喜爱的
    **Angular 组件开发工具包**（**Angular CDK**）。我称之为“备受喜爱”，因为如果你想在 Angular 应用中实现自己的自定义交互和行为，而不必依赖于整个库集，Angular
    CDK 将成为你的最佳拍档。在本章中，你将了解 Angular 和 Angular CDK 的惊人组合。你将了解 CDK 中内置的一些巧妙组件，并使用一些
    CDK **API** 创建令人惊叹且优化的内容。
- en: 'Here are the recipes we’re going to cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Using virtual scroll for huge lists
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用虚拟滚动处理大量列表
- en: Keyboard navigation for lists
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表的键盘导航
- en: Pointy little popovers with the Overlay API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Overlay API 的尖角小弹出框
- en: Input coercion utilities from the Angular CDK
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular CDK 的输入强制转换实用工具
- en: Using the CDK drag and drop API to move items from one list to another
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CDK 拖放 API 将项目从一个列表移动到另一个列表
- en: Creating a multi-step game with the CDK stepper API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CDK 步进器 API 创建多步游戏
- en: Accessible Listbox interactions using CDK listbox directives
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CDK 列表框指令进行可访问的列表框交互
- en: Working with nested menus using the Angular CDK menu API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular CDK 菜单 API 处理嵌套菜单
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For the recipes in this chapter, ensure your setup is complete as per the ''Technical
    Requirements'' in the ''Angular-Cookbook-2E'' GitHub repository. For setup details,
    visit: [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md).
    The starter code for this chapter is located at [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter09](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter09).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的食谱，请确保你的设置已按照 'Angular-Cookbook-2E' GitHub 仓库中的 '技术要求' 完成。有关设置详情，请访问：[https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md)。本章的起始代码位于
    [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter09](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter09)。
- en: Using virtual scroll for huge lists
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用虚拟滚动处理大量列表
- en: There might be certain scenarios in your application where you might have to
    show a huge set of items. This could be from either your backend API or the browser’s
    local storage. In either case, rendering a lot of items at once causes performance
    issues because the **Document Object Model** (**DOM**) struggles, and also because
    of the fact that the JS thread gets blocked, and the page becomes unresponsive.
    In this recipe, we’ll render a list of 270,000 users and use the `virtual scroll`
    functionality from the Angular CDK to improve the rendering performance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用中可能存在某些场景，你可能需要显示大量项目。这可能来自你的后端 API 或浏览器的本地存储。在任一情况下，一次性渲染大量项目会导致性能问题，因为
    **文档对象模型**（**DOM**）会挣扎，也因为 JS 线程被阻塞，页面变得无响应。在本食谱中，我们将渲染一个包含 270,000 个用户的列表，并使用
    Angular CDK 的 `虚拟滚动` 功能来提高渲染性能。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter09/ng-cdk-virtual-scroll`
    inside the cloned repository:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的 `start/apps/chapter09/ng-cdk-virtual-scroll`：
- en: Open the code repository in your code editor.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should open the app in a new browser tab. When you click the **Get Data**
    button, you should see the following:'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会在新浏览器标签页中打开应用。当你点击 **获取数据** 按钮时，你应该看到以下内容：
- en: '![](img/B18469_09_01.png)'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![img/B18469_09_01.png](img/B18469_09_01.png)'
- en: 'Figure 9.1: The ng-cdk-virtual-scroll app running on http://localhost:4200'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.1：运行在 http://localhost:4200 的 ng-cdk-virtual-scroll 应用
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地上运行了应用，让我们在下一节中查看食谱的步骤。
- en: How to do it…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We have a pretty simple Angular app, but with a lot of data. Right now, it
    shows a loader (button) for about a couple of seconds and then is supposed to
    show the data. However, you’ll notice that right after the **Tap me** button disappears,
    the loader keeps showing, the button is unresponsive, and we see a blank screen,
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个相当简单的 Angular 应用，但数据量很大。目前，它显示一个加载器（按钮），大约持续几秒钟，然后应该显示数据。然而，你会注意到在 **Tap
    me** 按钮消失后，加载器仍然显示，按钮无响应，我们看到一个空白屏幕，如下所示：
- en: '![](img/B18469_09_02.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18469_09_02.png)'
- en: 'Figure 9.2: App stuck with a blank screen while rendering list items'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：渲染列表项时应用卡在空白屏幕
- en: 'In fact, our entire application becomes unresponsive. If you scroll through—or
    even hover over—the items, you’ll see that the hover animation on the list items
    is not smooth and is a bit laggy. Let’s see the steps to use the Angular CDK virtual
    scroll to improve the rendering performance, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们的整个应用变得无响应。如果你滚动通过项目，或者甚至悬停在项目上，你会看到列表项上的悬停动画不流畅，有点卡顿。让我们看看使用 Angular
    CDK 虚拟滚动来提高渲染性能的步骤，如下所示：
- en: 'We already have the Angular CDK installed in the workspace. However, if you
    needed to install it, you would run the following command from the project’s root:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经在工作区中安装了 Angular CDK。然而，如果你需要安装它，你将需要在项目的根目录中运行以下命令：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You may have to restart your Angular server if you reinstall the package, so
    rerun the `npm run serve ng-cdk-virtual-scroll` command again.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你重新安装了包，可能需要重新启动你的 Angular 服务器，所以再次运行 `npm run serve ng-cdk-virtual-scroll`
    命令。
- en: 'Add the `ScrollingModule` class from the `@angular/cdk` package into the `users-list.component.ts`
    file, as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ScrollingModule` 类从 `@angular/cdk` 包导入到 `users-list.component.ts` 文件中，如下所示：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We now must implement the virtual scroll, modify the `users-list-item.component.html`
    file to use the `*cdkVirtualFor` directive instead of the `*ngFor directive`,
    and wrap the `<li>` element inside a `<cdk-virtual-scroll-viewport>` element,
    as follows:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在必须实现虚拟滚动，修改 `users-list-item.component.html` 文件以使用 `*cdkVirtualFor` 指令而不是
    `*ngFor` 指令，并将 `<li>` 元素包裹在 `<cdk-virtual-scroll-viewport>` 元素内，如下所示：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that we have moved the CSS classes `"``list list-group p-2"` from the
    `<ul>` element to the `<cdk-virtual-scroll-viewport>` element.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们将 CSS 类 `"list list-group p-2"` 从 `<ul>` 元素移动到了 `<cdk-virtual-scroll-viewport>`
    元素。
- en: Boom! Within a few steps, and by using the Angular CDK virtual scroll, we were
    able to fix a huge performance rendering issue within our Angular app. See the
    next section to understand how it works.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 咚！只需几步，通过使用 Angular CDK 虚拟滚动，我们就能够在我们的 Angular 应用中修复一个巨大的性能渲染问题。参见下一节了解它是如何工作的。
- en: How it works…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The Angular CDK provides the Scrolling APIs, which include the `*cdkVirtualFor`
    directive and the `<cdk-virtual-scroll-viewport>` element. It is necessary to
    have `<cdk-virtual-scroll-viewport>` wrapping the element that has the `*cdkVirtualFor`
    directive being applied to it. Notice that we have an attribute on the `cdk-virtual-scroll-viewport`
    element named `[itemSize]`, having its value set to `"``120"`. The reason for
    this is that each list item has a height of approximately 120 pixels, as shown
    in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CDK 提供了滚动 API，包括 `*cdkVirtualFor` 指令和 `<cdk-virtual-scroll-viewport>`
    元素。必须将 `<cdk-virtual-scroll-viewport>` 包裹应用于具有 `*cdkVirtualFor` 指令的元素。注意，我们在 `cdk-virtual-scroll-viewport`
    元素上有一个名为 `[itemSize]` 的属性，其值设置为 `"120"`。这是因为每个列表项的高度大约为 120 像素，如下面的截图所示：
- en: '![](img/B18469_09_03.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18469_09_03.png)'
- en: 'Figure 9.3: Each list item has a height of approximately 120 pixels'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：每个列表项的高度大约为 120 像素
- en: But how does it improve the rendering performance? Glad you asked! In the original
    code for this recipe, when we loaded the 270,000 users, it would create a separate
    `<li>` element with the `class="list__item list-group-item"` attribute for each
    user, thus creating 270,000 DOM elements all being rendered at once. With the
    virtual scroll in place, the CDK only creates a few `<li>` elements, renders them,
    and just replaces the content of those few `<li>` elements as we scroll through
    items.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但它是如何提高渲染性能的呢？很高兴你问了！在这个菜谱的原始代码中，当我们加载 270,000 个用户时，它会为每个用户创建一个具有 `class="list__item
    list-group-item"` 属性的单独 `<li>` 元素，从而一次性创建了 270,000 个 DOM 元素。有了虚拟滚动，CDK 只创建几个 `<li>`
    元素，渲染它们，然后在我们滚动通过项目时，只替换这些几个 `<li>` 元素的 内容。
- en: 'For our example, it creates 6 `<li>` elements, as shown in the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，它创建了 6 个 `<li>` 元素，如下面的截图所示：
- en: '![](img/B18469_09_04.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18469_09_04.png)'
- en: 'Figure 9.4: Showing only a few <div> elements rendered on DOM due to virtual
    scroll'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：由于虚拟滚动，仅显示 DOM 上渲染的几个 <div> 元素
- en: Since we only have a few elements rendered on the DOM, we don’t have performance
    issues anymore, and the hover animation also seems super-smooth now.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只渲染了少量元素在 DOM 上，我们不再有性能问题，并且悬停动画现在看起来也非常平滑。
- en: When implementing virtual scroll in your own applications, make sure that you
    set a specific height to the `<cdk-virtual-scroll viewport>` element, and also
    set the `[itemSize]` attribute equal to the expected list-item height in pixels,
    otherwise the list won’t show.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在您自己的应用程序中实现虚拟滚动时，请确保为 `<cdk-virtual-scroll viewport>` 元素设置一个特定的高度，并将 `[itemSize]`
    属性设置为像素中预期的列表项高度，否则列表将不会显示。
- en: See also
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular CDK scrolling examples: [https://material.angular.io/cdk/scrolling/examples](https://material.angular.io/cdk/scrolling/examples)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular CDK 滚动示例：[https://material.angular.io/cdk/scrolling/examples](https://material.angular.io/cdk/scrolling/examples)
- en: Keyboard navigation for lists
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表的键盘导航
- en: Accessibility is one of the most important aspects of building apps with a great
    user experience. The apps should not only be fast and performant but also accessible.
    While there are a lot of things to consider when it comes to accessibility, in
    this recipe, we’re going to make lists and list items more accessible by providing
    keyboard navigation for the items. With the Angular CDK, it is super simple. We’re
    going to use the `ListKeyManager` service from the Angular CDK to implement keyboard
    navigation for the users list in our target application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问性是构建具有良好用户体验的应用程序最重要的方面之一。应用程序不仅应该快速且性能出色，还应该易于访问。虽然涉及到可访问性有很多事情需要考虑，但在本食谱中，我们将通过提供键盘导航来使列表和列表项更加易于访问。使用
    Angular CDK，这非常简单。我们将使用 Angular CDK 中的 `ListKeyManager` 服务来实现目标应用程序中用户列表的键盘导航。
- en: Getting ready
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter09/ng-cdk-lkm`
    inside the cloned repository:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的仓库中的 `start/apps/chapter09/ng-cdk-lkm` 内：
- en: Open the code repository in your code editor.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，您应该看到以下内容：
- en: '![](img/B18469_09_05.png)'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 B18469_09_05.png](img/B18469_09_05.png)'
- en: 'Figure 9.5: The ng-cdk-lkm app running on http://localhost:4200'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.5：在 http://localhost:4200 上运行的 ng-cdk-lkm 应用
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，让我们在下一节中查看食谱的步骤。
- en: How to do it…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现
- en: 'We have an app that already has some of the goodness of the Angular CDK—that
    is, it has virtual scroll implemented from the previous recipe. We’ll now start
    making changes to the app to implement keyboard navigation, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个已经拥有一些 Angular CDK 优点（即，它已经实现了从先前食谱中的虚拟滚动）的应用程序。我们现在将开始修改应用程序以实现键盘导航，如下所示：
- en: 'First, we’ll implement the `FocusableOption` interface and some accessibility
    factors to our `UsersListItemComponent` class, as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将实现 `FocusableOption` 接口和一些可访问性因素到我们的 `UsersListItemComponent` 类中，如下所示：
- en: '[PRE5]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We now need to implement what happens in the `focus` method. We’ll use the
    `ElementRef` service to get the `nativeElement` and will set focus on the `nativeElement`,
    as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要实现 `focus` 方法中发生的事情。我们将使用 `ElementRef` 服务来获取 `nativeElement` 并将焦点设置在 `nativeElement`
    上，如下所示：
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will now add some accessibility to the list itself. Update the file `users-list.component.ts`
    as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将添加一些列表本身的可访问性。按照以下方式更新文件 `users-list.component.ts`：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We now need to implement the `FocusKeyManager` class in our `UsersListComponent`
    class. We’ll have to query our list items in the component to create an instance
    of the `FocusKeyManager` class. Update the `users-list.component.ts` file, as
    follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要在我们的 `UsersListComponent` 类中实现 `FocusKeyManager` 类。我们将在组件中查询我们的列表项以创建
    `FocusKeyManager` 类的实例。按照以下方式更新 `users-list.component.ts` 文件：
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We’ll now initiate the `FocusKeyManager` instance in the `AfterViewInit` hook
    in the same file. Update the `users-list.component.ts` file as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将在同一文件中的 `AfterViewInit` 钩子中初始化 `FocusKeyManager` 实例。按照以下方式更新 `users-list.component.ts`
    文件：
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we need to listen to the keyboard events. For this, you could either
    use a `keydown` event or a `window:keydown` event. For simplicity of the recipe,
    we’ll go with the `window:keydown` event as pressing any key will bubble up the
    event to the `window` object. Update the file as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要监听键盘事件。为此，你可以使用`keydown`事件或`window:keydown`事件。为了简化配方，我们将使用`window:keydown`事件，因为按下任何键都会将事件冒泡到`window`对象。按照以下方式更新文件：
- en: '[PRE10]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you go to the app, and press the down arrow key, you should see the first
    item being focused on the list and you can navigate to next and previous items
    and focusing them using the arrow keys.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你进入应用并按下向下箭头键，你应该看到列表中第一个项被聚焦，你可以使用箭头键导航到下一个和上一个项并将它们聚焦。
- en: 'To add a bit more fun to the recipe, let’s also implement an event listener
    for when the user presses the *Enter* key on a particular item. We will just show
    an alert with the item’s details. Let’s use a `HostListener` decorator in the
    `users-list-item.component.ts` file as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让配方更有趣，让我们也实现一个事件监听器，用于当用户在特定项上按下*Enter*键时。我们只需显示一个带有项详细信息的警告框。让我们在`users-list-item.component.ts`文件中使用`HostListener`装饰器，如下所示：
- en: '[PRE11]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With the above change, you should be able to see the selected item as shown
    in the following figure:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过上述更改，你应该能够看到所选项，如下面的图所示：
- en: '![](img/B18469_09_06.png)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_09_06.png)'
- en: 'Figure 9.6: Selected item JSON being shown in an alert'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.6：所选项JSON在警告框中显示
- en: Awesomesauce! You have just learned how to implement keyboard navigation using
    the Angular CDK. See the next section to understand how it works.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你已经学会了如何使用Angular CDK实现键盘导航。参见下一节了解它是如何工作的。
- en: How it works…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The Angular CDK provides the `ListKeyManager` class, which allows you to implement
    keyboard navigation. There are a bunch of techniques we can use with the `ListKeyManager`
    class, and for this recipe, we chose the `FocusKeyManager` class. To make it work
    for a list of items, we needed to do the following things:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CDK提供了`ListKeyManager`类，它允许你实现键盘导航。我们可以使用`ListKeyManager`类的一组技术，并且在这个配方中，我们选择了`FocusKeyManager`类。为了使其适用于项目列表，我们需要做以下几件事情：
- en: We made sure that we had a component for each item in the list.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们确保列表中的每一项都有一个组件。
- en: We used `ViewChildren` with `QueryList` in the list component to query all the
    list item components. `ViewChildren` is a property decorator that retrieves all
    the `UsersListItemComponent` elements from the DOM using `QueryList`, which gets
    updated automatically if an item is added, removed, or updated in the list.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表组件中使用了`ViewChildren`与`QueryList`来查询所有列表项组件。`ViewChildren`是一个属性装饰器，它使用`QueryList`从DOM中检索所有的`UsersListItemComponent`元素。如果列表中的项被添加、删除或更新，`QueryList`会自动更新。
- en: We then created an instance of the `FocusKeyManager` class in the list component
    so we can initiate the list item component elements.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在列表组件中创建了一个`FocusKeyManager`类的实例，这样我们就可以初始化列表项组件元素。
- en: Added a keyboard listener to the list component and passed the event to the
    instance of the `FocusKeyManager` class.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表组件中添加了一个键盘监听器，并将事件传递给`FocusKeyManager`类的实例。
- en: When we defined the `listKeyManager` property in the `UsersListComponent` class,
    we also defined its type as well by specifying it as `FocusKeyManager<UsersListItemComponent>`.
    This made it easier to understand that our `FocusKeyManager` class is supposed
    to work with an array of `UsersListItemComponent` elements. Therefore, in the
    `ngAfterViewInit` method, we specified `this.listKeyManager = new FocusKeyManager(this.listItemsElements);`,
    which provided a queried list of `UsersListItemComponent` elements.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`UsersListComponent`类中定义`listKeyManager`属性时，我们还通过指定它为`FocusKeyManager<UsersListItemComponent>`来定义其类型。这使得更容易理解我们的`FocusKeyManager`类应该与`UsersListItemComponent`元素数组一起工作。因此，在`ngAfterViewInit`方法中，我们指定`this.listKeyManager
    = new FocusKeyManager(this.listItemsElements);`，这提供了一个查询到的`UsersListItemComponent`元素列表。
- en: Finally, when we listened to the `window:keydown` event, we took the `keydown`
    event received in the handler and provided it to the instance of our `FocusKeyManager`
    class as `this.listKeyManager.onKeydown(event);`. This told our `FocusKeyManager`
    instance which key was pressed and what it must do.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们监听`window:keydown`事件时，我们在处理程序中接收到的`keydown`事件，并将其提供给我们的`FocusKeyManager`类实例作为`this.listKeyManager.onKeydown(event);`。这告诉我们的`FocusKeyManager`实例哪个键被按下以及它必须做什么。
- en: Notice that our `UsersListItemComponent` class implements the `FocusableOption`
    interface, and it also has the `focus` method, which the `FocusKeyManager` class
    uses behind the scenes when we press the keyboard arrow-down or arrow-up keys.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的 `UsersListItemComponent` 类实现了 `FocusableOption` 接口，并且它还有一个 `focus` 方法，当按下键盘上的向下或向上箭头键时，`FocusKeyManager`
    类会在幕后使用这个方法。
- en: 'Finally, we also used two properties with the `HostBinding` decorator. Let’s
    analyze them one by one:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还使用了两个带有 `HostBinding` 装饰器的属性。让我们逐一分析它们：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `HostBinding` decorator is used here to bind a class property (`tabIndex`)
    to a host element’s attribute `(tabIndex).` This effectively sets the `tabIndex`
    of the component’s host element to `-1`, making it programmatically focusable
    but not reachable via sequential keyboard navigation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用 `HostBinding` 装饰器将一个类属性（`tabIndex`）绑定到一个宿主元素的属性（`tabIndex`）。这实际上将组件宿主元素的
    `tabIndex` 设置为 `-1`，使其可以通过编程方式聚焦，但不能通过顺序键盘导航访问。
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Similarly, the above binds the role property of the class to the role attribute
    of the component’s host element. It assigns the ARIA role list item to the host
    element, providing a hint to assistive technologies about how they should interpret
    this element.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，上面的代码将类的角色属性绑定到组件宿主元素的 `role` 属性。它将 ARIA 角色列表项分配给宿主元素，为辅助技术提供有关如何解释此元素的提示。
- en: Now that you know how the recipe works, see the next section for some relevant
    links.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了食谱的工作原理，请查看下一节中的相关链接。
- en: See also
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: 'Angular CDK accessibility documentation: [https://material.angular.io/cdk/a11y/overview](https://material.angular.io/cdk/a11y/overview)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular CDK 可访问性文档：[https://material.angular.io/cdk/a11y/overview](https://material.angular.io/cdk/a11y/overview)
- en: '`ViewChildren` official documentation: [https://angular.io/api/core/ViewChildren](https://angular.io/api/core/ViewChildren
    )'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewChildren` 官方文档：[https://angular.io/api/core/ViewChildren](https://angular.io/api/core/ViewChildren)'
- en: Pointy little popovers with the Overlay API
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Overlay API 的尖锐小弹出框
- en: This is one of the advanced recipes in this book, especially for those of you
    who have already been working with Angular for a while. In this recipe, we’ll
    not only create some **popovers** using the **CDK Overlay API**, but we’ll also
    make them pointy, just like tooltips, and that’s where the fun lies.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中的高级食谱之一，特别是对于那些已经使用 Angular 工作了相当一段时间的人来说。在这个食谱中，我们不仅将使用 **CDK Overlay API**
    创建一些 **弹出框**，而且还会使它们尖锐，就像工具提示一样，这就是其中的乐趣所在。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter09/ng-cdk-popover`
    inside the cloned repository:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的 `start/apps/chapter09/ng-cdk-popover`：
- en: Open the code repository in your code editor.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE14]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，你应该看到以下内容：
- en: '![](img/B18469_09_07.png)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_09_07.png)'
- en: 'Figure 9.7: The ng-cdk-popover app running on http://localhost:4200'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.7：运行在 http://localhost:4200 上的 ng-cdk-popover 应用
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地上运行了应用，让我们在下一节中查看食谱的步骤。
- en: How to do it…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Our app has a list of users that we can scroll through on the page. We’ll add
    a popover menu to each item so that a drop-down menu is shown with some actions.
    We already have the `@angular/cdk` package installed, so we don’t need to worry
    about that. Let’s start with the recipe, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用有一个用户列表，我们可以在页面上滚动浏览。我们将在每个项目上添加一个弹出菜单，以便显示一个包含一些操作的下拉菜单。我们已安装了 `@angular/cdk`
    包，因此我们不需要担心这一点。让我们从以下食谱开始：
- en: 'We’ll first add the Overlay’s default styles so that when the overlay is displayed,
    it is positioned correctly. Open the `src/styles.scss` file and update it as per
    the following snippet:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先添加 Overlay 的默认样式，以便当 Overlay 显示时，它能够正确定位。打开 `src/styles.scss` 文件，并按照以下片段更新它：
- en: '[https://ng-cookbook.com/s/cdk-pane-styles](https://ng-cookbook.com/s/cdk-pane-styles
    )'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://ng-cookbook.com/s/cdk-pane-styles](https://ng-cookbook.com/s/cdk-pane-styles)'
- en: 'Now, we’ll create variables to hold the overlay origin (for the origin of the
    positions of the opened overlay) and the actual relative position’s settings.
    Open the `users-list.component.ts` file and update it, as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建变量来保存 Overlay 的原点（用于打开的 Overlay 的位置原点）和实际相对位置设置。打开 `users-list.component.ts`
    文件，并按照以下方式更新它：
- en: '[PRE15]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, open the `users-list.component.html` file and add the `cdkOverlayOrigin`
    directive to the `<app-users-list-item>` selector so that we can have each list
    item as an origin for the pop-up menu, as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`users-list.component.html`文件，并将`cdkOverlayOrigin`指令添加到`<app-users-list-item>`选择器中，以便我们可以将每个列表项作为弹出菜单的起点，如下所示：
- en: '[PRE16]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need to somehow pass the `#menuTrigger` variable from the template to assign
    its value to the `popoverMenuOrigin` property in the `UsersListComponent` class.
    To do so, create a method named `openMenu` in the `users-list.component.ts` file,
    as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以某种方式将模板中的`#menuTrigger`变量传递到`UsersListComponent`类中，以将其值分配给`popoverMenuOrigin`属性。为此，在`users-list.component.ts`文件中创建一个名为`openMenu`的方法，如下所示：
- en: '[PRE17]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We also need a property to show/hide the popover menu. Let’s create it and
    set it to `true` in the `openMenu` method as well. Update the `users-list.component.ts`
    file, as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个属性来显示/隐藏弹出菜单。让我们创建它，并在`openMenu`方法中将它设置为`true`。按照以下方式更新`users-list.component.ts`文件：
- en: '[PRE18]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We’ll now create an actual overlay. To do so, we’ll create an `<ng-template>`
    element with the `cdkConnectedOverlay` directive. At the bottom of the `users-list.component.html`
    file, add the code `(<ng-template>` `element)` from the following link:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建一个实际的覆盖层。为此，我们将创建一个带有`cdkConnectedOverlay`指令的`<ng-template>`元素。在`users-list.component.html`文件的底部，添加以下链接中的代码`(<ng-template>`
    `element)`：
- en: '[https://ng-cookbook.com/s/ng-popover-overlay](https://ng-cookbook.com/s/ng-popover-overlay
    )'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://ng-cookbook.com/s/ng-popover-overlay](https://ng-cookbook.com/s/ng-popover-overlay)'
- en: 'We need to pass the `#menuTrigger` variable that we have on each list item
    to the `openMenu` method on a click of the list item. Update the file, as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将每个列表项上的`#menuTrigger`变量传递给点击列表项时的`openMenu`方法。按照以下方式更新文件：
- en: '[PRE19]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you refresh the app now and click on any of the list items, you should see
    a drop-down menu, as follows:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在刷新应用程序并点击任何列表项，你应该会看到一个下拉菜单，如下所示：
- en: '![](img/B18469_09_08.png)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_09_08.png)'
- en: 'Figure 9.8: Working drop-down menu for each list item'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.8：每个列表项的工作下拉菜单
- en: 'We now have to implement the part where we show a pointy little arrow with
    the drop-down menu so that we can correlate the drop-down menu with the list item.
    First, add the following styles to the `menu-popover` class in the `src/styles.scss`
    file:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要实现显示带有下拉菜单的尖锐小箭头的部分，以便我们可以将下拉菜单与列表项关联起来。首先，将以下样式添加到`src/styles.scss`文件中的`menu-popover`类中：
- en: '[PRE20]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should now be able to see a pointy arrow on the top right of the drop-down
    menu, but if you try clicking the last item on the screen, you’ll see that the
    drop-down menu opens upward but still shows the pointer at the top, as follows:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在应该能够在下拉菜单的右上角看到一个尖锐的箭头，但如果你尝试点击屏幕上的最后一个项，你会看到下拉菜单向上打开，但仍然显示指针在顶部，如下所示：
- en: '![](img/B18469_09_09.png)'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_09_09.png)'
- en: 'Figure 9.9: Drop-down arrow pointing at the wrong list item'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.9：指向错误列表项的下拉箭头
- en: 'To point to the actual origin of the popover/drop-down menu, we need to implement
    a custom directive that applies a custom class to the popover. Let’s start by
    creating a directive, as follows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要指向弹出/下拉菜单的实际起点，我们需要实现一个自定义指令，将自定义类应用于弹出。让我们首先创建一个指令，如下所示：
- en: '[PRE21]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Update the code in the `popover-positional-class.directive.ts` generated file
    as per the following snippet:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下代码片段更新`popover-positional-class.directive.ts`生成的文件：
- en: '[https://ng-cookbook.com/s/popover-pc-directive](https://ng-cookbook.com/s/popover-pc-directive)'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://ng-cookbook.com/s/popover-pc-directive](https://ng-cookbook.com/s/popover-pc-directive)'
- en: 'Let’s import the `PopoverPositionalClassDirective` class in the file `users-list.component.ts`
    so we can use it in the template later. Update the code as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`users-list.component.ts`文件中导入`PopoverPositionalClassDirective`类，以便我们可以在模板中稍后使用它。按照以下方式更新代码：
- en: '[PRE22]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, open the `users-list.component.html` file to apply our directive to the
    `<ng-template>` element. Update the file as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`users-list.component.html`文件，将我们的指令应用到`<ng-template>`元素上。按照以下方式更新文件：
- en: '[PRE23]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We now need to create a `popoverMenuPosition` property and a `popoverPositionChanged`
    method in our `users-list.component.ts` file to track which list item is for opening
    the menu (for positioning) and which is for when the position of the menu changes
    due to resizing of the window or a change in content. Update the file further
    as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要在`users-list.component.ts`文件中创建一个`popoverMenuPosition`属性和一个`popoverPositionChanged`方法，以跟踪哪个列表项用于打开菜单（用于定位）以及当菜单由于窗口调整大小或内容更改而位置改变时的情况。进一步更新文件如下：
- en: '[PRE24]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And voilà! If you now refresh the page and tap each of the list items, you’ll
    see the arrows point in the correct direction. See the following screenshot to
    view the popover arrow pointing downward for the last item, due to the popover
    being shown above the item:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 哇！如果你现在刷新页面并点击每个列表项，你会看到箭头指向正确的方向。查看以下截图以查看最后一个项目的弹出箭头向下指，因为弹出菜单在项目上方显示：
- en: '![](img/B18469_09_10.png)'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_09_10.png)'
- en: 'Figure 9.10: Drop-down arrow pointing at the correct list item (pointing downward)'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.10：指向正确列表项的下拉箭头（向下指）
- en: Great! You now know how to use the Angular CDK to work with overlays to create
    custom pop-up/drop-down menus. Moreover, you now know how to quickly implement
    the pointy arrows on the menu using a custom directive. See the next section to
    understand how it all works.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！你现在知道如何使用Angular CDK与覆盖层一起创建自定义弹出/下拉菜单。此外，你现在知道如何快速使用自定义指令在菜单上实现尖锐的箭头。查看下一节以了解这一切是如何工作的。
- en: How it works…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Implementing an overlay using the Angular CDK Overlay API includes a couple
    of pieces to work with. We first have to import the `OverlayModule` class in our
    `UserListComponent` class’s imports. We do this because the `OverlayModule` contains
    the directives we are using in the application: for example, the `CdkConnectedOverlay`
    directive and the `CdkOverlayOrigin` directive. After importing the module for
    creating an overlay, we need to have both an overlay (the menu in our case) and
    an overlay origin (which opens/shows the menu). In this recipe, since we’re using
    the overlay to create a popover menu for each list item, we use the `cdkOverlayOrigin`
    directive on the `<app-users-list-item>` elements. Notice that the `<app-users-list-item>`
    elements are being rendered through the `*ngFor` directive.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular CDK Overlay API实现覆盖层包括几个需要处理的组件。我们首先必须在`UserListComponent`类的导入中导入`OverlayModule`类。我们这样做是因为`OverlayModule`包含我们在应用程序中使用的指令：例如，`CdkConnectedOverlay`指令和`CdkOverlayOrigin`指令。在导入创建覆盖层的模块之后，我们需要有一个覆盖层（在我们的例子中是菜单）和一个覆盖层源（用于打开/显示菜单）。在这个菜谱中，因为我们使用覆盖层为每个列表项创建弹出菜单，所以我们使用`cdkOverlayOrigin`指令在`<app-users-list-item>`元素上。注意，`<app-users-list-item>`元素是通过`*ngFor`指令渲染的。
- en: Therefore, in order to know which item was clicked or precisely which item we
    need to show the popover for, we create a `#menuTrigger` template variable on
    each list item element, and you’ll notice that we also bind the `(click)` event
    on the list items to call the `openMenu` method, passing this `menuTrigger` template
    variable into it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了知道哪个项目被点击或确切地知道我们需要为哪个项目显示弹出菜单，我们在每个列表项元素上创建一个`#menuTrigger`模板变量，并且你会注意到我们还绑定了列表项上的`(click)`事件来调用`openMenu`方法，并将这个`menuTrigger`模板变量传递给它。
- en: 'Now, if you have noticed the `openMenu` method in the `users-list.component.ts`
    file, it looks like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你已经注意到了`users-list.component.ts`文件中的`openMenu`方法，它看起来是这样的：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that we assign the `itemTrigger` property to our class’s `popoverMenuOrigin`
    property. This is because this `popoverMenuOrigin` property is being bound with
    the actual overlay in our template. You can also see that we set the `menuShown`
    property to `true`, and this is because it will decide whether the overlay should
    be shown or hidden.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将`itemTrigger`属性分配给我们的类的`popoverMenuOrigin`属性。这是因为这个`popoverMenuOrigin`属性正在与我们的模板中的实际覆盖层绑定。你还可以看到我们设置了`menuShown`属性为`true`，这是因为这将决定覆盖层是否应该显示或隐藏。
- en: 'Now, let’s see the code for the actual overlay, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看实际覆盖层的代码，如下所示：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s discuss each of the `cdkConnectedOverlay` directive’s attributes, one
    by one:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一讨论`cdkConnectedOverlay`指令的属性：
- en: 'The `cdkConnectedOverlay` attribute: This is the actual overlay directive that
    makes the `<ng-template>` element an Angular CDK overlay.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cdkConnectedOverlay`属性：这是实际的覆盖层指令，它使`<ng-template>`元素成为Angular CDK覆盖层。'
- en: 'The `[cdkConnectedOverlayOrigin]` attribute: This tells the Overlay API what
    the origin of this overlay is. This is to help the CDK decide where to position
    the overlay when opened.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[cdkConnectedOverlayOrigin]`属性：这告诉覆盖层API这个覆盖层的来源。这是为了帮助CDK在打开时决定覆盖层的位置。'
- en: 'The `[cdkConnectedOverlayOpen]` attribute: This decides whether the overlay
    should be shown or not.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[cdkConnectedOverlayOpen]`属性：这决定了覆盖层是否应该显示。'
- en: 'The `[cdkConnectedOverlayHasBackdrop]` attribute: This decides whether the
    overlay should have a backdrop or not—that is, if it has a backdrop, the user
    shouldn’t be able to click anything else apart from the overlay when it is open.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[cdkConnectedOverlayHasBackdrop]`属性：这决定了覆盖层是否应有背景——也就是说，如果它有背景，当它打开时，用户不应该能够点击除覆盖层之外的其他任何东西。'
- en: 'The `(backdropClick)` attribute: This is the event handler for when we click
    the backdrop. In this case, we’re setting the `menuShown` property to `false`,
    which hides/closes the overlay.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(backdropClick)`属性：这是当点击背景时的事件处理器。在这种情况下，我们将`menuShown`属性设置为`false`，这将隐藏/关闭覆盖层。'
- en: 'The `[cdkConnectedOverlayPositions]` attribute: This provides the positioning
    configuration to the Overlay API. It is an array of preferred positions that defines
    whether the overlay should be shown below the origin, on top of the origin, on
    the left, on the right, how far from the origin, and so on using properties such
    as `originX`, `originY`, `overlayX`, and `overlayY`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[cdkConnectedOverlayPositions]`属性：为覆盖API提供定位配置。它是一个首选位置数组，定义了覆盖层是否应显示在原点下方、原点上方、左侧、右侧、距离原点有多远等，使用`originX`、`originY`、`overlayX`和`overlayY`等属性。'
- en: 'The `[cdkConnectedOverlayPanelClass]` attribute: A **CSS** class to be applied
    to the generated overlay. This is used for styling.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[cdkConnectedOverlayPanelClass]`属性：应用于生成的覆盖层的CSS类。这用于样式化。'
- en: With all of the attributes set correctly, we are able to see the overlay working
    when tapping the list items. *“But what about the pointy arrows, Ahsan?”* Well,
    hold on! We’ll discuss them too.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有属性都设置正确的情况下，我们能够在轻触列表项时看到覆盖层的工作。*“但是，Ahsan，关于尖锐的箭头怎么办？”* 好吧，等等！我们也会讨论它们。
- en: 'So, the Angular CDK Overlay API already has a lot of things covered, including
    where to position the overlay based on the available space, and since we want
    to show the pointy arrows, we’ll have to analyze whether the overlay is being
    shown above the item or below the item. By default, we have the following styles
    set in the `src/styles.scss` file to show the pointy arrow below the popover:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Angular CDK覆盖API已经涵盖了众多功能，包括基于可用空间定位覆盖层的位置，而且我们想要显示尖锐的箭头，所以我们必须分析覆盖层是显示在项目上方还是下方。默认情况下，我们在`src/styles.scss`文件中设置了以下样式，以显示尖锐的箭头在弹出层下方：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And then, we have the `--up` modifier class, as follows, to show the overlay
    *above* the popover:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个`--up`修饰符类，如下所示，用于显示在弹出层之上的覆盖层：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let’s talk about how and when this `--up` modifier class is applied. We
    have created a custom directive named `appPopoverPositionalClass`. This directive
    is also applied to the `<ng-template>` element we have for the overlay—that is,
    this directive is applied with the `cdkConnectedOverlay` directive and expects
    the following input attributes:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈如何以及何时应用这个`--up`修饰符类。我们创建了一个名为`appPopoverPositionalClass`的自定义指令。这个指令也应用于我们为覆盖层准备的`<ng-template>`元素——也就是说，这个指令与`cdkConnectedOverlay`指令一起应用，并期望以下输入属性：
- en: 'The `appPopoverPositionalClass` attribute: The actual directive selector.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appPopoverPositionalClass`属性：实际的指令选择器。'
- en: 'The `targetSelector` attribute: The query selector for the element that is
    generated by the Angular CDK Overlay API. Ideally, this should be the same as
    what we use in `cdkConnectedOverlayPanelClass`.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`targetSelector`属性：由Angular CDK覆盖API生成的元素的查询选择器。理想情况下，这应该与我们用于`cdkConnectedOverlayPanelClass`的相同。'
- en: 'The `inverseClass` attribute: The class to be applied when the vertical position
    (`originY`) of the overlay is changed—that is, from `"top"` to `"bottom"`, and
    vice versa.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inverseClass`属性：当覆盖层的垂直位置（`originY`）改变时应用的类——也就是说，从`"top"`到`"bottom"`，反之亦然。'
- en: 'The `originY` attribute: The `originY` position of the overlay at the moment.
    The value is either `"top"` or `"bottom"`, based on the overlay position.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`originY`属性：覆盖层此时的`originY`位置。值是`"top"`或`"bottom"`，基于覆盖层的位置。'
- en: We have a `(positionChange)` listener on the CDK Overlay `<ng-template>` element
    that triggers the `popoverPositionChanged` method as soon as the overlay position
    changes. Notice that inside the `popoverPositionChanged` method, upon getting
    a new position, we update the `popover.originY` property that is updating `menuPopoverOrigin.originY`,
    and then we’re also passing `menuPopoverOrigin.originY` as the `[originY]` attribute
    to our `appPopoverPositionalClass` directive. Since we’re passing it to the directive,
    the directive knows if the overlay position is `"top"` or `"bottom"` at any particular
    time. How? Because we’re using the `ngOnChanges` life cycle hook in the directive
    to listen to the `originY` attribute/input, and as soon as we get a different
    value for `originY`, we either add the value of `inverseClass` as a CSS class
    to the `Overlay` element or remove it based on the value of the `originY` attribute.
    Also, based on the applied CSS classes, the direction of the popover arrow is
    decided for the overlay.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在CDK Overlay `<ng-template>` 元素上有一个 `(positionChange)` 监听器，当覆盖层位置改变时立即触发 `popoverPositionChanged`
    方法。注意，在 `popoverPositionChanged` 方法中，获取新位置后，我们更新 `popover.originY` 属性，该属性正在更新
    `menuPopoverOrigin.originY`，然后我们还将 `menuPopoverOrigin.originY` 作为 `[originY]`
    属性传递给我们的 `appPopoverPositionalClass` 指令。由于我们将其传递给指令，指令知道覆盖层位置在任何特定时间是否为 `"top"`
    或 `"bottom"`。如何做到的？因为我们使用指令中的 `ngOnChanges` 生命周期钩子来监听 `originY` 属性/输入，一旦我们得到 `originY`
    的不同值，我们就会根据 `originY` 属性的值将 `inverseClass` 的值作为CSS类添加到 `Overlay` 元素上，或者根据 `originY`
    属性的值将其移除。此外，根据应用的CSS类，覆盖层的箭头方向也会被确定。
- en: See also
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular CDK Overlay API: [https://material.angular.io/cdk/overlay/overview](https://material.angular.io/cdk/overlay/overview)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular CDK Overlay API：[https://material.angular.io/cdk/overlay/overview](https://material.angular.io/cdk/overlay/overview)
- en: '`CdkOverlayOrigin` directive documentation: [https://material.angular.io/cdk/overlay/api#CdkOverlayOrigin](https://material.angular.io/cdk/overlay/api#CdkOverlayOrigin)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CdkOverlayOrigin` 指令文档：[https://material.angular.io/cdk/overlay/api#CdkOverlayOrigin](https://material.angular.io/cdk/overlay/api#CdkOverlayOrigin)'
- en: Input coercion utilities from the Angular CDK
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular CDK输入强制转换工具
- en: This is one of those cool things that you see and think, “Oh, that could’ve
    been handy if I knew about this before.” I absolutely thought that about these
    coercion utilities from the Angular CDK. There have been many times when you have
    a number value as an input in an Angular component and you are forced to use the
    square bracket notation `([myNumberInput]="numberValue")` because if you use `"``myNumberInput="numberValue"`,
    it is interpreted as a literal string `"numberValue"` instead of a variable. The
    coercion utilities from the Angular CDK are exactly what we need here.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是那种你看到后觉得，“哦，如果我知道这个就好了。” 我确实对Angular CDK中的这些强制转换工具有了这样的想法。有很多次，你在Angular组件中有一个数值输入，被迫使用方括号表示法
    `([myNumberInput]="numberValue")`，因为如果你使用 `"myNumberInput=numberValue"`，它会被解释为字面字符串
    `"numberValue"`，而不是变量。Angular CDK中的强制转换工具正是我们需要的。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter09/ng-cdk-coercion`inside
    the cloned repository:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的仓库中的 `start/apps/chapter09/ng-cdk-coercion`：
- en: Open the code repository in your code editor.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE29]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会在新浏览器标签页中打开应用程序，你应该会看到以下内容：
- en: '![](img/B18469_09_11.png)'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_09_11.png)'
- en: 'Figure 9.11: using-cdk-coercion running on http://localhost:4200'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.11：使用-cdk-coercion在http://localhost:4200上运行
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，让我们在下一节中查看食谱的步骤。
- en: How to do it…
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We have a rating component that takes a few inputs, including “value” and “disabled.”
    However, we can’t really use them like usual attributes and have to use square
    brackets notation for the Angular attribute bindings for both of them. We’ll fix
    that in the recipe. Let’s begin:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个评分组件，它接受一些输入，包括“value”和“disabled”。然而，我们实际上不能像通常的属性那样使用它们，必须使用方括号表示法为这两个属性进行Angular属性绑定。我们将在食谱中修复这个问题。让我们开始吧：
- en: 'First of all, let’s say we want to add a new feature to the ratings component—that
    is, having a max number for the rating. Right now, it defaults to `5`. So we’ll
    create a new input in the `rating.component.ts` file as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们假设我们想要向评分组件添加一个新功能——那就是为评分设置一个最大数字。目前，它默认为 `5`。因此，我们将在 `rating.component.ts`
    文件中创建一个新的输入，如下所示：
- en: '[PRE30]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we’ll provide the max input to the rating component from the home component.
    We’ll set its value to `8`. But we’ll use the usual HTML notation to supply the
    value. Update the usage of the `<app-rating-component>` in the `home.component.html`
    file, as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从主组件向评分组件提供最大输入。我们将其值设置为 `8`。但我们将使用常规的 HTML 表示法来提供值。更新 `home.component.html`
    文件中 `<app-rating-component>` 的使用，如下所示：
- en: '[PRE31]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You’ll notice immediately that the IDE throws an error as we can’t assign a
    string value to a number input.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会立即注意到 IDE 抛出错误，因为我们不能将字符串值赋给数字输入。
- en: 'We’ll now use the coercion utilities from the Angular CDK to solve this issue.
    Update the `rating.component.ts` file to use the `NumberInput` type and the `coerceNumberProperty`
    method as follows:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用 Angular CDK 的强制转换实用工具来解决这个问题。更新 `rating.component.ts` 文件以使用 `NumberInput`
    类型以及 `coerceNumberProperty` 方法，如下所示：
- en: '[PRE32]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you check the `home.component.html` file again, you’ll see that the error
    is gone and the app compiles without any issues.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你再次检查 `home.component.html` 文件，你会看到错误已经消失，并且应用程序可以无错误地编译。
- en: 'Let’s make the `disabled` property coerced as well. We’ll try to use the double-curly-braces
    `{{}}` notation for this input. Update the usage of the `<app-rating>` element
    in the `home.component.html` file as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将 `disabled` 属性也进行强制转换。我们将尝试使用双大括号 `{{}}` 表示法来处理这个输入。更新 `home.component.html`
    文件中 `<app-rating>` 元素的使用，如下所示：
- en: '[PRE33]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You’ll see an error in both the IDE and the compilation: `Type ''string'' is
    not assignable to type ''boolean''`.'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将在 IDE 和编译过程中看到错误：`Type 'string' is not assignable to type 'boolean'`。
- en: 'To fix the issue, let’s use the `BooleanInput` and `coerceBooleanProperty`
    method in the `rating.component.ts` file as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们在 `rating.component.ts` 文件中使用 `BooleanInput` 和 `coerceBooleanProperty`
    方法，如下所示：
- en: '[PRE34]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And voilà! Your code should be compiled without errors, and you should be able
    to provide values without the forced square-bracket attribute binding notation.
    What’s great is that even if you just add the `disabled` attribute to the `<app-rating>`
    element, it will disable the component, which is what happens when we apply the
    `disabled` attribute to a regular `input` element or `textarea`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！你的代码应该可以无错误地编译，你应该能够提供值而不需要强制使用方括号属性绑定表示法。很棒的是，即使你只是将 `disabled` 属性添加到 `<app-rating>`
    元素中，它也会禁用组件，这就是当我们将 `disabled` 属性应用于常规 `input` 元素或 `textarea` 元素时发生的情况。
- en: How it works…
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the recipe, we used two different methods from the Angular CDK’s coercion
    utilities. The `coerceNumberProperty` method and the `coerceBooleanProperty` method.
    Let’s first have a look at the `coerceNumberProperty` method along with the `NumberInput`
    type.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用了 Angular CDK 的强制转换实用工具中的两种不同方法。`coerceNumberProperty` 方法以及 `coerceBooleanProperty`
    方法。让我们首先看看 `coerceNumberProperty` 方法以及 `NumberInput` 类型。
- en: The `NumberInput`type resolves to being `string | number | null | undefined`,
    which makes it possible for us to provide the values as any of those types. And
    when we don’t use the square-bracket notation for attribute binding, the value
    is considered as a **string**. This seems to be covered by the `NumberInput` type.
    The `coerceNumberProperty` method takes any value and converts it into a number.
    The function also takes a second optional argument as the fallback value.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`NumberInput` 类型解析为 `string | number | null | undefined`，这使得我们可以以任何这些类型提供值。而且当我们不使用方括号表示法进行属性绑定时，值被视为
    **字符串**。这似乎被 `NumberInput` 类型所涵盖。`coerceNumberProperty` 方法接受任何值并将其转换为数字。该函数还接受一个可选的第二个参数作为回退值。'
- en: 'The usages of the `BooleanInput` type and the `coerceBooleanProperty` method
    are very similar to the `NumberInput` type and `coerceNumberProperty` respectively.
    The difference, however, is that the `coerceBooleanProperty` method takes any
    value and converts it into a boolean. The logic behind this method is a bit different
    as it looks for the following condition:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`BooleanInput` 类型和使用 `coerceBooleanProperty` 方法的用法与 `NumberInput` 类型和使用 `coerceNumberProperty`
    方法非常相似。然而，不同之处在于 `coerceBooleanProperty` 方法接受任何值并将其转换为布尔值。此方法的逻辑略有不同，因为它寻找以下条件：'
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Which means if the attribute is provided without a value, it is going to be
    an empty string. And even though empty string is a falsy value, with the coerceBooleanProperty,
    an attribute without a value (empty string) will resolve as a truthy value.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果属性没有提供值，它将是一个空字符串。即使空字符串是一个假值，使用 `coerceBooleanProperty`，没有值（空字符串）的属性将解析为真值。
- en: See also
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'CDK coercion documentation: [https://material.angular.io/cdk/coercion/overview](https://material.angular.io/cdk/coercion/overview)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDK 强制转换文档：[https://material.angular.io/cdk/coercion/overview](https://material.angular.io/cdk/coercion/overview)
- en: Using the CDK Drag and Drop API to move items from one list to another
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CDK 拖放 API 将项目从一个列表移动到另一个列表
- en: Have you ever used the Trello board app, or maybe other apps that also allow
    you to drag and drop list items from one list to another? Well, you can do this
    easily using the Angular CDK, and in this recipe, you’ll learn about using the
    **Angular CDK Drag and Drop API** to move items from one list to another. You’ll
    also learn how to reorder lists.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经使用过 Trello 板应用，或者可能是其他也允许你将列表项从一个列表拖放到另一个列表的应用？嗯，你可以很容易地使用 Angular CDK
    做到这一点，在这个食谱中，你将学习如何使用 **Angular CDK 拖放 API** 将项目从一个列表移动到另一个列表。你还将学习如何重新排序列表。
- en: Getting ready
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter09/ng-cdk-drag-drop`
    inside the cloned repository:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的 `start/apps/chapter09/ng-cdk-drag-drop` 目录内：
- en: Open the code repository in your code editor.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以运行项目：
- en: '[PRE36]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，你应该能看到以下内容：
- en: '![](img/B18469_09_12.png)'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_09_12.png)'
- en: 'Figure 9.12: The ng-cdk-drag-drop app running on http://localhost:4200'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.12：运行在 http://localhost:4200 的 ng-cdk-drag-drop 应用
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地上运行了应用，让我们看看下一节中食谱的步骤。
- en: How to do it…
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: For this recipe, we have an interesting app that has some folders and files.
    We’re going to implement the drag-and-drop functionality for the files to be dragged
    to other folders, which should update the folder’s file count instantly, and we
    should be able to see the file in the new folder as well. Let’s get started.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们有一个有趣的包含一些文件夹和文件的应用。我们将实现拖放功能，以便文件可以被拖放到其他文件夹中，这将立即更新文件夹的文件计数，并且我们能够在新的文件夹中看到该文件。让我们开始吧。
- en: 'First of all, we need to import `DragDropModule` because we use the `CdkDrag`
    and the `CdkDropList` directives in our app which belong to it. We will import
    the module into the `imports` array of our `FoldersListComponent` class. Modify
    the `folders-list.component.ts` file, as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入 `DragDropModule`，因为我们使用的是属于它的 `CdkDrag` 和 `CdkDropList` 指令。我们将把模块导入到
    `FoldersListComponent` 类的 `imports` 数组中。修改 `folders-list.component.ts` 文件，如下所示：
- en: '[PRE37]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we’ll apply the `cdkDrag` directive to each of our files and will apply
    the `cdkDropList` directive to each of the folders. Update the `folders-list.component.html`
    file, as follows:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将把 `cdkDrag` 指令应用到我们每个文件上，并将 `cdkDropList` 指令应用到每个文件夹上。更新 `folders-list.component.html`
    文件，如下所示：
- en: '[PRE38]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We’ll also enable reordering of the files within a folder by adding the `cdkDropList`
    directive to the container elements for the files, as follows:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将通过向文件的容器元素添加 `cdkDropList` 指令来启用文件夹内文件的重新排序，如下所示：
- en: '[PRE39]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We’ll now define the origin of the drag-and-drop interaction by specifying
    the `[cdkDragData]` attribute on each `<app-file>` element and the `[cdkDropListData]`
    attribute on each `<app-folder>` element, and on the files container as well.
    Update the template again, as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将通过指定每个 `<app-file>` 元素上的 `[cdkDragData]` 属性和每个 `<app-folder>` 元素上的 `[cdkDropListData]`
    属性，以及文件容器上的属性来定义拖放交互的起点。再次更新模板，如下所示：
- en: '[PRE40]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We now need to implement what happens when the file is dropped. To do so, we’ll
    use the `(cdkDropListDropped)` event handler. Update the template, as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要实现文件被放下时会发生什么。为此，我们将使用 `(cdkDropListDropped)` 事件处理器。更新模板，如下所示：
- en: '[PRE41]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we need to implement the `onFileDrop` method. Update the `folders-list.component.ts`
    file, as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要实现 `onFileDrop` 方法。更新 `folders-list.component.ts` 文件，如下所示：
- en: '[PRE42]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `moveItemInArray` method and the `transferArrayItem` method are built-in
    from the Angular CDK. This makes our implementation a breeze.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`moveItemInArray`方法和`transferArrayItem`方法是Angular CDK内置的。这使得我们的实现变得非常简单。'
- en: 'In order to implement drag-and-drop previews, we need to enclose the droplists
    and the draggable items into an element with the `cdkDropListGroup` directive.
    Update the `folders-list.component.html` file and apply the directive to the element
    with the `folders` class (i.e., at the top level), as follows:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现拖拽预览，我们需要将droplists和可拖拽项包裹在一个带有`cdkDropListGroup`指令的元素中。更新`folders-list.component.html`文件，并将指令应用于具有`folders`类的元素（即顶级），如下所示：
- en: '[PRE43]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To apply a custom drag preview, we use a custom element with the `*cdkDragPreview`
    directive applied to it. Update the `folders-list.component.html` file, as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了应用自定义拖拽预览，我们使用一个带有`*cdkDragPreview`指令的自定义元素。更新`folders-list.component.html`文件，如下所示：
- en: '[PRE44]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For the `fa-icon` component to work, we also need to import the `FontAwesomeModule`
    in the `FoldersListComponent` class. Update the file below as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使`fa-icon`组件正常工作，我们还需要在`FoldersListComponent`类中导入`FontAwesomeModule`模块。更新以下文件，如下所示：
- en: '[PRE45]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We’ll also need some styles for the drag-and-drop previews. Update the `folders-list.component.scss`
    file, as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要为拖拽预览添加一些样式。更新`folders-list.component.scss`文件，如下所示：
- en: '[PRE46]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let’s also add some styles to make sure the other list items move smoothly
    when reordering the items within a folder. Since we need to style the elements
    from the Angular CDK, and they have styles encapsulation, we need to add the styles
    in our global `scss` file. Update the `folders-list.component.scss` file further,
    as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再添加一些样式，以确保在文件夹内重新排序项目时，其他列表项能够平滑移动。由于我们需要为Angular CDK中的元素添加样式，并且它们有样式封装，因此我们需要在我们的全局`scss`文件中添加样式。进一步更新`folders-list.component.scss`文件，如下所示：
- en: '[PRE47]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we need to create a drop preview (a placeholder that appears until we
    release the dragged file) template as well. For this, we use the `*cdkDragPlaceholder`
    directive on the `preview` element. Update the `folders-list.component.html` file,
    as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们还需要创建一个下拉预览（一个在我们释放拖拽文件之前出现的占位符）模板。为此，我们在`preview`元素上使用`*cdkDragPlaceholder`指令。更新`folders-list.component.html`文件，如下所示：
- en: '[PRE48]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, let’s create an `upArrow` property using the `faArrowAltCircleUp`
    icon from the `@fortawesome` package. Update the `folders-list.component.ts` file,
    as follows:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们使用`@fortawesome`包中的`faArrowAltCircleUp`图标创建一个`upArrow`属性。更新`folders-list.component.ts`文件，如下所示：
- en: '[PRE49]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: And boom! We now have a seamless **User Experience** (**UX**) for the entire
    drag-and-drop flow. Like it? Make sure that you share a snapshot on your X (Twitter)
    and tag me at **@codewith_ahsan**.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 咚！现在，我们为整个拖拽流程提供了一个无缝的**用户体验**（**UX**）。喜欢吗？请确保在您的X（Twitter）上分享一个快照，并@我**@codewith_ahsan**。
- en: Now that we’ve finished the recipe, let’s see in the next section how it all
    works.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了配方，让我们在下一节中看看它是如何工作的。
- en: How it works…
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There were a couple of interesting directives in this recipe, and we’ll go through
    them all one by one. First of all, as good Angular developers, we import the `DragDropModule`
    class into the `imports` array of our `standalone component`named `FoldersListComponent`,
    just to make sure we don’t end up with errors. Then, we start making the files
    draggable. We do this by adding the `cdkDrag` directive to each file element by
    applying the `*ngFor` directive to it. This tells the Angular CDK that this element
    will be dragged and, therefore, the Angular CDK binds different handlers to each
    element to be dragged.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，有几个有趣的指令，我们将逐一介绍。首先，作为优秀的Angular开发者，我们将`DragDropModule`类导入到名为`FoldersListComponent`的`standalone
    component`的`imports`数组中，以确保我们不会出错。然后，我们开始使文件可拖拽。我们通过在每个文件元素上添加`cdkDrag`指令并应用`*ngFor`指令来实现这一点。这告诉Angular
    CDK该元素将被拖拽，因此Angular CDK为每个要拖拽的元素绑定不同的处理器。
- en: IMPORTANT NOTE
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Angular components by default are not block elements. Therefore, when applying
    the `cdkDrag` directive to an Angular component such as the `<app-file>` component,
    it might restrict the animations from the CDK being applied when we’re dragging
    the elements. In order to fix this, we need to set a `display: block;` for our
    component elements. Notice that we’re applying the required styles in the `folders-list.component.scss`
    file (line 25) for the `.folders__selected-folder-files__file` class.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，Angular组件不是块级元素。因此，当我们将`cdkDrag`指令应用于Angular组件，如`<app-file>`组件时，它可能会限制CDK在拖拽元素时应用的动画。为了解决这个问题，我们需要为我们的组件元素设置`display:
    block;`。请注意，我们在`folders-list.component.scss`文件（第25行）中为`.folders__selected-folder-files__file`类应用了所需的样式。'
- en: After configuring the drag elements, we use the `cdkDropList` directive for
    each container DOM element where we’re supposed to drop the file. In our recipe,
    that is each folder that we see on the screen, and we can also reorder the files
    within a folder. Therefore, we apply the `cdkDropList` directive to the wrapper
    element of the currently displayed files, as well as to each `<app-folder>` item
    with the `*ngFor` looping over the `folders` array.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置拖拽元素后，我们为每个我们打算放下文件的容器DOM元素使用`cdkDropList`指令。在我们的菜谱中，这是屏幕上我们看到的每个文件夹，我们还可以重新排列文件夹内的文件。因此，我们将`cdkDropList`指令应用于当前显示文件的包装元素，以及每个通过`*ngFor`循环遍历`folders`数组的`<app-folder>`项目。
- en: Then, we specify the **data** that we’re dragging by specifying `[cdkDragData]="file"`
    for each draggable file. This helps us identify it in the later process when we
    drop it either within the current folder or within other folders. We also specify
    in which array this dragged item will be added when dropped upon the particular
    list, and we do this by specifying `[cdkDropListData]="ARRAY"` statements for
    the elements that we’ve applied the `cdkDropList` directive to. When the Angular
    CDK combines the information from the `cdkDragData` and the `cdkDropListData`
    attributes, it can easily identify if the item was dragged and then dropped within
    the same list or in another list.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过为每个可拖拽文件指定`[cdkDragData]="file"`来指定我们正在拖拽的数据。这有助于我们在稍后过程中识别它，无论是将其放下在当前文件夹内还是其他文件夹内。我们还指定了当拖拽到特定列表上时，这个拖拽项目将被添加到哪个数组中，我们通过为应用了`cdkDropList`指令的元素指定`[cdkDropListData]="ARRAY"`语句来完成这项工作。当Angular
    CDK结合`cdkDragData`和`cdkDropListData`属性的信息时，它可以轻松地识别项目是否被拖拽并在同一列表或另一个列表内放下。
- en: To handle what happens when we drop the dragged file, we use the `(cdkDropListDropped)`
    method from the Angular CDK on the element with the `cdkDropList` directive. We
    take the `$event` emitted from the CDK and pass it to our `onFileDrop` method.
    What’s great is that within the `onFileDrop` method, we use the `moveItemInArray`
    and `transferArrayItem` helper methods from the Angular CDK, with a really simple
    bit of logic to compare the containers. That is, the Angular CDK provides us with
    enough information that we can get away with the whole functionality really easily.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理拖拽文件时可能发生的情况，我们在带有`cdkDropList`指令的元素上使用Angular CDK的`(cdkDropListDropped)`方法。我们接收CDK发出的`$event`并将其传递给我们的`onFileDrop`方法。令人兴奋的是，在`onFileDrop`方法中，我们使用Angular
    CDK的`moveItemInArray`和`transferArrayItem`辅助方法，通过一段非常简单的逻辑来比较容器。也就是说，Angular CDK为我们提供了足够的信息，使我们能够非常容易地实现整个功能。
- en: Toward the end of the recipe, we customize how our drag preview should look
    when we are dragging a file using a custom template, by using the `*cdkDragPreview`
    directive on it. This tells the Angular CDK to not render it right away but to
    show it with the mouse when we start dragging a file. For our recipe, we only
    show the icon of the file as the drag preview. And finally, we also customize
    the drop preview (or drag placeholder) usingthe `*cdkDragPlaceholder` directive,
    which shows a transparent rectangle with an upward-arrow icon to reflect where
    the item is going to be added when dropped. Of course, we had to add some custom
    styles for both the drag preview and the drop preview.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在菜谱的末尾，我们通过在元素上使用自定义模板的`*cdkDragPreview`指令来自定义拖拽文件时的预览外观。这告诉Angular CDK不要立即渲染它，而是在我们开始拖拽文件时用鼠标显示它。在我们的菜谱中，我们只显示文件的图标作为拖拽预览。最后，我们还使用`*cdkDragPlaceholder`指令自定义了放下预览（或拖拽占位符），它显示一个带有向上箭头图标的透明矩形，以反映当放下时项目将被添加的位置。当然，我们必须为拖拽预览和放下预览添加一些自定义样式。
- en: See also
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular CDK Drag and Drop documentation: [https://material.angular.io/cdk/drag-drop/overview](https://material.angular.io/cdk/drag-drop/overview)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular CDK Drag and Drop文档：[https://material.angular.io/cdk/drag-drop/overview](https://material.angular.io/cdk/drag-drop/overview)
- en: Creating a multi-step game with the CDK Stepper API
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CDK Stepper API创建一个多步游戏
- en: If you try finding examples of the CDK Stepper API over the internet, you’ll
    find a bunch of articles revolving around creating multi-step forms using the
    CDK Stepper API, but since it is a stepper at its base, it can be used for various
    use cases. In this recipe, we’re going to build a guessing game using the Angular
    CDK Stepper API, in which the user will guess what the output of a rolled dice
    will be.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在互联网上尝试寻找CDK Stepper API的示例，你会找到许多围绕使用CDK Stepper API创建多步表单的文章，但鉴于它本质上是一个步骤器，它可以用于各种用例。在这个菜谱中，我们将使用Angular
    CDK Stepper API构建一个猜谜游戏，用户将猜测掷骰子的输出结果。
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter09/ng-cdk-stepper`
    inside the cloned repository:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的仓库中的`start/apps/chapter09/ng-cdk-stepper`目录内：
- en: Open the code repository in your code editor.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以运行项目：
- en: '[PRE50]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，你应该会看到以下内容：
- en: '![](img/B18469_09_13.png)'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![img/B18469_09_13.png](img/B18469_09_13.png)'
- en: 'Figure 9.13: The ng-cdk-stepper app running on http://localhost:4200'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.13：运行在http://localhost:4200的ng-cdk-stepper应用程序
- en: Now, let’s look at how to create a multi-step game with the CDK Stepper API
    in the next section.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一节中看看如何使用CDK Stepper API创建一个多步游戏。
- en: How to do it…
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We have a really simple yet interesting application at hand that has a couple
    of components built already, including the `dice component`, the `value-guess
    component`, and the `leaderboard component`. We’ll create this game as a multi-step
    game using the **Stepper API**. Proceed as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们手头有一个非常简单但有趣的应用程序，已经构建了一些组件，包括`dice component`、`value-guess component`和`leaderboard
    component`。我们将使用**Stepper API**将这个游戏作为一个多步游戏来创建。按照以下步骤进行：
- en: 'First, import the `CdkStepperModule` class from the `@angular/cdk` package
    in the `game.component.ts` file, as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`game.component.ts`文件中从`@angular/cdk`包导入`CdkStepperModule`类，如下所示：
- en: '[PRE51]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let’s create our stepper component now. Run the following command in the workspace
    root folder:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的步骤器组件。在项目根目录下运行以下命令：
- en: '[PRE52]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Choose the `@nx/angular:component` schematic when asked and select the “As provided”
    option.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当被询问时，选择`@nx/angular:component`脚本来创建组件，并选择“按提供”选项。
- en: 'To make our component a `CdkStepper`, we need to provide it using the `CdkStepper`
    token and have to extend our component class from `CdkStepper` as well. We can
    remove the `constructor`, the `OnInit` implementation, and the `ngOnInit` method.
    Modify the `game-stepper.component.ts` file, as follows:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使我们的组件成为`CdkStepper`，我们需要使用`CdkStepper`令牌提供它，并且还需要从`CdkStepper`扩展我们的组件类。我们可以移除`constructor`、`OnInit`实现和`ngOnInit`方法。修改`game-stepper.component.ts`文件，如下所示：
- en: '[PRE53]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `CDKStepper` provides us helpful methods like `next`, `previous`, and `reset`
    to navigate between the steps, and the `selectedIndexChange`event emitter to identify
    when a step is changed.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CDKStepper`为我们提供了有用的方法，如`next`、`previous`和`reset`，用于在步骤之间导航，以及`selectedIndexChange`事件发射器，用于识别何时更改了步骤。'
- en: 'Let’s add the template for our `<game-stepper>` component. We’ll start by adding
    the header that will show the step label. Update your `game-stepper.component.html`
    file, as follows:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加`<game-stepper>`组件的模板。我们将首先添加将显示步骤标签的标题。更新你的`game-stepper.component.html`文件，如下所示：
- en: '[PRE54]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, we’ll add the template to show our main content for the selected step—this
    is pretty simple to do. We need to add a `div` with the `[ngTemplateOutlet]` attribute,
    where we’ll show the content. Update the `game-stepper.component.html` file, as
    follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加模板以显示所选步骤的主要内容——这很简单。我们需要添加一个带有`[ngTemplateOutlet]`属性的`div`，我们将在这里显示内容。更新`game-stepper.component.html`文件，如下所示：
- en: '[PRE55]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we’ll add a footer element that’ll contain the navigation buttons
    for our stepper— that is, we should be able to jump to the next and the previous
    step using those navigation buttons. Update the `game-stepper.component.html`
    file further, as follows:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加一个包含步骤器导航按钮的页脚元素——也就是说，我们应该能够使用这些导航按钮跳转到下一个和上一个步骤。进一步更新`game-stepper.component.html`文件，如下所示：
- en: '[PRE56]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let’s add some styles to our `game-stepper` component. Modify the `game-stepper.component.scss`
    file, as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为我们的`game-stepper`组件添加一些样式。修改`game-stepper.component.scss`文件，如下所示：
- en: '[PRE57]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now we want to use the `game stepper` component inside the `game` component.
    To do this, first import it in the `GameComponent` class’s `imports` array as
    follows:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想在`game`组件内部使用`game stepper`组件。为此，首先在`GameComponent`类的`imports`数组中导入它，如下所示：
- en: '[PRE58]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We’ll now wrap our entire template in the `game.component.html` file with the
    `<app-game-stepper>` component. Update the file, as follows:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用`<app-game-stepper>`组件将整个模板包裹在`game.component.html`文件中。更新文件，如下所示：
- en: '[PRE59]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We’ll now modify our `game.component.html` file to break down the inner template
    into steps. For that, we’ll use the `<cdk-step>` element to wrap around the content
    for each step. Update the file, as follows:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将修改`game.component.html`文件，将内部模板分解为步骤。为此，我们将使用`<cdk-step>`元素来包裹每个步骤的内容。更新文件，如下所示：
- en: '[PRE60]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, we’ll add a label for each step. We need to add an `<ng-template>` element
    inside each `<cdk-step>` element. Update the `game.component.html` file, as follows:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为每个步骤添加一个标签。我们需要在每个`<cdk-step>`元素内部添加一个`<ng-template>`元素。更新`game.component.html`文件，如下所示：
- en: '[PRE61]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If you refresh the app, you should see the first step as the visible step,
    as well as the bottom navigation button, as follows:'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你刷新应用程序，你应该看到第一个步骤作为可见步骤，以及底部的导航按钮，如下所示：
- en: '![](img/B18469_09_14.png)'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_09_14.png)'
- en: 'Figure 9.14: The first step and the navigation button using CDKStepper'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.14：使用CDKStepper的第一步和导航按钮
- en: 'Now, we need to make sure that we can only move forward to the second step
    once we have entered a name in the first step. Make the following changes to the
    `game.component.html` file:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要确保只有在第一步输入了姓名后，我们才能向前移动到第二步。对`game.component.html`文件进行以下更改：
- en: '[PRE62]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We also need to disable the next button on the first step until we have entered
    a value for the player’s name. To do so, update the `game-stepper.component.html`
    file—specifically, the element with the `cdkStepperNext` attribute—as follows:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在第一步输入玩家姓名之前禁用第一个步骤的“下一步”按钮。为此，更新`game-stepper.component.html`文件——特别是具有`cdkStepperNext`属性的元素——如下所示：
- en: '[PRE63]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To handle the case when the user provides the name and hits the *Enter* key,
    resulting in the form submission, we can move to the next step using a `@ViewChild()`
    in the `GameComponent` class. Modify the `game.component.ts` file as follows,
    and try entering the name and then pressing the *Enter* key:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要处理用户提供姓名并按下*Enter*键的情况，导致表单提交，我们可以在`GameComponent`类中使用`@ViewChild()`跳到下一个步骤。修改`game.component.ts`文件如下，然后尝试输入姓名并按下*Enter*键：
- en: '[PRE64]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, let’s write the flow for guessing the number. Update the `game.component.ts`
    file, as follows:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写猜测数字的流程。更新`game.component.ts`文件，如下所示：
- en: '[PRE65]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now that we have the functions in place, let’s update the template to listen
    to the event listeners from the `<app-value-guesser>` and `<app-dice>` components
    and act accordingly. We’ll also add elements with class alerts to show messages
    in case of a successful or wrong guess. Update the `game.component.html` file,
    as follows:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置了函数，让我们更新模板以监听`<app-value-guesser>`和`<app-dice>`组件的事件监听器并相应地执行。我们还将添加具有class
    alerts的元素以显示成功或错误猜测的消息。更新`game.component.html`文件，如下所示：
- en: '[PRE66]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, we need to populate the leaderboards. Update the `game.component.ts`
    file to use the `LeaderboardService` class, as follows:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要填充排行榜。更新`game.component.ts`文件以使用`LeaderboardService`类，如下所示：
- en: '[PRE67]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, update the `game.component.html` file to pass the scores as an attribute
    to the `<app-leader-board>` component, as follows:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新`game.component.html`文件，将分数作为属性传递给`<app-leader-board>`组件，如下所示：
- en: '[PRE68]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If you refresh the app now and play the game, you should be able to see the
    leaderboard, as follows:'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在刷新应用程序并玩游戏，你应该能看到排行榜，如下所示：
- en: '![](img/B18469_09_15.png)'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_09_15.png)'
- en: 'Figure 9.15: Displaying results in the leaderboard at Step 3'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.15：在步骤3显示排行榜结果
- en: Phew! That was a *long* recipe! Well, perfection requires time and dedication.
    Feel free to use this game yourself or even with your friends, and if you improve
    it, do let me know on my socials.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！这是一个*长*的配方！好吧，完美需要时间和奉献。请随意使用这个游戏，甚至和你的朋友一起玩，如果你改进了它，请通过我的社交媒体告诉我。
- en: Now that you’ve finished the recipe, see the next section on how this works.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了配方，请查看下一节了解其工作原理。
- en: How it works…
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: There are a lot of moving parts in this recipe, but they’re super easy. First,
    we import the `CdkStepperModule` class into the `imports` array of our `GameComponent`
    class. Then, we create a component that extends the `CdkStepper` class. The reason
    for extending the `CdkStepper` class is to be able to create this `GameStepperComponent`
    component so that we can create a reusable template with some styles, and even
    some custom functionality.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方中有许多动态部分，但它们非常简单。首先，我们将`CdkStepperModule`类导入到`GameComponent`类的`imports`数组中。然后，我们创建一个扩展`CdkStepper`类的组件。扩展`CdkStepper`类的原因是能够创建这个`GameStepperComponent`组件，这样我们就可以创建一个具有一些样式和自定义功能的可重用模板。
- en: To start using the `GameStepperComponent` component, we wrap the entire template
    within the `<app-game-stepper>` element in the `game.component.html` file. Since
    the component extends the `CdkStepper` API, we can use all the functionality of
    the `CdkStepper` component here. For each step, we use the `<cdk-step>` element
    from the CDK and wrap the template of the step inside it. Notice that in the `game-stepper.component.html`
    file, we use the `[ngTemplateOutlet]` attribute for both the step’s label and
    the step’s actual content. This is a reflection of how amazing the CDK Stepper
    API is. Since our `GameStepperComponent` class extends the `CDKStepper` class,
    it automatically generates a `label` property and the `content` property for each
    step based on the values/template we provide for each `<cdk-step>` element in
    the `game.component.html` file. Since we provide an `<ng-template cdkStepLabel>`
    inside each `<cdk-step>` element in the `game.component.html` file, the CDK generates
    a `step.stepLabel.template` automatically for each step, which we then use inside
    the `game-stepper.component.html` file, to show the label of each `<cdk-step>`
    element respectively. If we didn’t provide the `<ng-template cdkStepLabel>` for
    a step and rather just used `<cdk-step label="someValue">`, it would then use
    the `step.label` property as per our code written in the `game-stepper.component.html`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用`GameStepperComponent`组件，我们在`game.component.html`文件中将整个模板包裹在`<app-game-stepper>`元素中。由于该组件扩展了`CdkStepper`
    API，我们在这里可以使用`CdkStepper`组件的所有功能。对于每个步骤，我们使用CDK中的`<cdk-step>`元素，并将步骤的模板包裹在其中。请注意，在`game-stepper.component.html`文件中，我们使用`[ngTemplateOutlet]`属性来显示步骤的标签和实际内容。这反映了CDK
    Stepper API的出色之处。由于我们的`GameStepperComponent`类扩展了`CDKStepper`类，它将自动为每个步骤生成一个`label`属性和`content`属性，这些属性基于我们在`game.component.html`文件中为每个`<cdk-step>`元素提供的值/模板。由于我们在`game.component.html`文件中的每个`<cdk-step>`元素内部提供了`<ng-template
    cdkStepLabel>`，CDK会自动为每个步骤生成一个`step.stepLabel.template`，我们随后在`game-stepper.component.html`文件中使用它，分别显示每个`<cdk-step>`元素的标签。如果我们没有为某个步骤提供`<ng-template
    cdkStepLabel>`，而是直接使用了`<cdk-step label="someValue">`，那么它将使用我们根据代码在`game-stepper.component.html`中编写的`step.label`属性。
- en: For the bottom navigation buttons, you notice that we use `<button>` elements
    with the `cdkStepperPrevious` and `cdkStepperNext` directives for going to the
    previous step and the next step respectively. We also show/hide the next and previous
    buttons based on the conditions to check if there is a step to go to. To prevent
    the navigation button from being rendered in the DOM when the provided condition
    is false, we utilize the `*ngIf` binding to dynamically hide or show it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 对于底部导航按钮，您会注意到我们使用了带有`cdkStepperPrevious`和`cdkStepperNext`指令的`<button>`元素，分别用于跳转到上一步和下一步。我们还会根据条件显示/隐藏下一步和上一步按钮，以检查是否有可跳转的步骤。为了防止在提供的条件为假时在DOM中渲染导航按钮，我们利用`*ngIf`绑定动态地隐藏或显示它。
- en: One interesting thing about the CDK Stepper API is that we can tell whether
    the user should be able to go to the next steps and backward, regardless of the
    state of the current step, or whether the user should first do something in the
    current step to go to the next one. The way we do it is by using the `[linear]`
    attribute on our `<app-game-stepper>` element, setting its value to `true`. This
    tells the CDK Stepper API to not move to the next step using the `cdkStepperNext`
    button, until the current step’s `completed` property is `true`. While just providing
    `[linear]="true"` is enough to handle the functionality, we improve the UX by
    disabling the **Next** button—in this case, by using `[disabled]="!selected!.completed"`
    on the `cdkStepperNext` button, as it makes more sense to just disable the button
    if it isn’t going to do anything on click.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 CDK Stepper API 的一个有趣之处在于，我们可以判断用户是否应该能够前往下一步或返回上一步，这不受当前步骤状态的影响，或者用户是否需要首先在当前步骤中完成某些操作才能前往下一步。我们实现这一点的做法是在
    `<app-game-stepper>` 元素上使用 `[linear]` 属性，将其值设置为 `true`。这告诉 CDK Stepper API 不要使用
    `cdkStepperNext` 按钮移动到下一步，直到当前步骤的 `completed` 属性为 `true`。虽然仅仅提供 `[linear]="true"`
    就足以处理功能，但我们通过禁用 **下一步** 按钮来提升用户体验——在这种情况下，我们在 `cdkStepperNext` 按钮上使用 `[disabled]="!selected!.completed"`，因为如果点击按钮不会执行任何操作，禁用按钮更有意义。
- en: Also, we needed to decide when a step is considered complete. For the first
    step, it is obvious that we should have a name entered in the input to consider
    the step completed—or, in other words, the `FormControl` for the `'name'` property
    in the `nameForm` Form Group should have a value. For the second step, it is bound
    to the condition `isCorrectGuess !== null`. This ensures that the user has guessed
    a number; regardless of whether the guess is correct or not, we mark the step
    as completed and let the user go to the next step (the leaderboard) if the user
    wants to. And that’s pretty much about it. You could go beyond the recipe to add
    an option of restarting the game from the leaderboard (last) step.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要决定何时认为一个步骤已完成。对于第一步，很明显，我们应该在输入中输入一个名称，才能认为步骤已完成——换句话说，`nameForm` 表单组中
    `'name'` 属性的 `FormControl` 应该有一个值。对于第二步，它与条件 `isCorrectGuess !== null` 相关联。这确保了用户已经猜了一个数字；无论猜测是否正确，我们都标记步骤为已完成，并允许用户如果想要的话前往下一步（排行榜）。这就是全部内容。您还可以超越这个食谱，添加一个从排行榜（最后）步骤重新开始游戏的功能。
- en: See also
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular CDK Stepper examples: [https://material.angular.io/cdk/stepper/examples](https://material.angular.io/cdk/stepper/examples)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular CDK Stepper 示例：[https://material.angular.io/cdk/stepper/examples](https://material.angular.io/cdk/stepper/examples)
- en: Accessible listbox interactions using CDK Listbox directives
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CDK Listbox 指令进行可访问的列表框交互
- en: Accessibility is one of the key aspects to focus on when you’re thinking about
    your end users using your applications. One of the major use cases for the users
    is to make a selection in apps, whether that’s selecting the color or size of
    a product or selecting multiple labels for a post. It makes it such a good experience
    if the experience is accessible. In this recipe, we’re going to replace a color
    selection feature for products with an accessible alternative using the **Angular
    CDK Listbox APIs**.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问性是您在考虑最终用户使用您的应用时需要关注的重点方面之一。用户的主要用例之一是在应用中进行选择，无论是选择产品的颜色或尺寸，还是选择多个标签。如果体验是可访问的，这将是一种非常好的体验。在这个食谱中，我们将使用
    **Angular CDK Listbox API** 替换产品的颜色选择功能，以实现可访问的替代方案。
- en: Getting ready
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter09/ng-cdk-listbox`
    inside the cloned repository:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的 `start/apps/chapter09/ng-cdk-listbox` 目录内：
- en: Open the code repository in your code editor.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE69]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，您应该看到以下内容：
- en: '![](img/B18469_09_16.png)'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_09_16.png)'
- en: 'Figure 9.16: The ng-cdk-listbox app running on http://localhost:4200'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.16：运行在 http://localhost:4200 的 ng-cdk-listbox 应用
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用，让我们在下一节中查看食谱的步骤。
- en: How to do it…
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In *Figure 9.16*, you will notice that we have options for selecting the product
    color—and if you click one of them, you can see the selected color on the right
    side. Even though they are somewhat accessible, they do not completely follow
    any of the WAI ARIA patterns. Let’s use the CDK Listbox module by following these
    steps:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.16*中，你会注意到我们有选择产品颜色的选项——如果你点击其中一个，你可以在右侧看到所选的颜色。尽管它们在一定程度上是可访问的，但它们并不完全遵循任何WAI
    ARIA模式。让我们按照以下步骤使用CDK Listbox模块：
- en: 'Now, we need to import the `CdkListboxModule` class into the `imports` array
    of our `ProductCardComponent` class so we can use the `cdkListbox` and `cdkOptions`
    directives. Modify the `product-card.component.ts` file, as follows:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将`CdkListboxModule`类导入到`ProductCardComponent`类的`imports`数组中，这样我们就可以使用`cdkListbox`和`cdkOptions`指令。按照以下方式修改`product-card.component.ts`文件：
- en: '[PRE70]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we’ll replace the HTML template to use the `cdkListbox` and `cdkOption`
    directives. We will be using an unordered list (`ul`) and list items (`li` elements)
    to render a similar color list. Update the `product-card.component.html` file
    between the mentioned HTML comments as follows:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将替换HTML模板以使用`cdkListbox`和`cdkOption`指令。我们将使用无序列表（`ul`）和列表项（`li`元素）来渲染类似的颜色列表。按照以下方式更新`product-card.component.html`文件在提到的HTML注释之间：
- en: '[PRE71]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You’ll notice that the options still look the same (because of the CSS classes);
    however, the functionality is gone now.
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到选项看起来仍然一样（因为CSS类的原因）；然而，现在功能已经消失了。
- en: 'Let’s also add some styles to highlight the selected color. Update the `color-options.scss`
    file inside the `src/styles` folder as follows:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再添加一些样式来突出显示所选颜色。更新`src/styles`文件夹内的`color-options.scss`文件，如下所示：
- en: '[PRE72]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Since Angular CDK Listbox works with both template-driven and reactive forms,
    let’s add the `formControlName` attribute to bind it with the `color` form control
    from the `productForm` form group. Update the template further as follows:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Angular CDK Listbox与模板驱动和响应式表单都兼容，让我们将`formControlName`属性添加到绑定`productForm`表单组中的`color`表单控件。按照以下方式更新模板：
- en: '[PRE73]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Great! With this change, when you refresh the page and pick a color, you should
    be able to see the desired result as before.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太好了！通过这个更改，当你刷新页面并选择颜色时，你应该能够看到之前的结果。
- en: 'Angular CDK implements WAI ARIA and, therefore, it is also possible to use
    the `typeahead` feature in the listbox. Let’s modify the template further to make
    it work:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Angular CDK实现了WAI ARIA，因此，在列表框中也可以使用`typeahead`功能。让我们进一步修改模板以使其工作：
- en: '[PRE74]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If you select any color and focus on the list box, you can type the name of
    the color here to jump directly to the option.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你选择任何颜色并聚焦到列表框上，你可以在这里输入颜色的名称以直接跳转到该选项。
- en: Awesome!! You’ve finished the recipe. Now you can see the next section to understand
    how it works.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！！你已经完成了配方。现在你可以看到下一部分来了解它是如何工作的。
- en: How it works…
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In the recipe, we’ve used the CDK Listbox API. And it is super cool that it
    completely implements the WAI ARIA pattern for the listbox. Kudos to the Angular
    team. To start, we import the `CdkListboxModule` in our standalone component (`ProductCardComponent`
    class) in its `imports` array. Then we use an unordered list, `<ul>`, in the template
    along with the `cdkListbox` directive. This applies the CDK Listbox features to
    the `<ul>` element. You’ll notice that we’re using the `aria-labelledby` attribute
    on the `<ul>` according to the WAI ARIA pattern for the listbox. Finally, we have
    the `cdkListboxOrientation` attribute set to `"horizontal"`, which tells the CDK
    Listbox API to allow horizontal navigation for this listbox; i.e., we can navigate
    with the left and right arrow keys. I would encourage you to read the Listbox
    specification at [https://www.w3.org/WAI/ARIA/apg/patterns/listbox/](https://www.w3.org/WAI/ARIA/apg/patterns/listbox/)
    to see the cool accessibility features it proposes. And what’s amazing is that
    the Angular CDK Listbox APIs follow all of them.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方中，我们使用了CDK Listbox API。而且它完全实现了列表框的WAI ARIA模式，非常酷。向Angular团队表示敬意。首先，我们在独立组件（`ProductCardComponent`类）的`imports`数组中导入`CdkListboxModule`。然后在模板中使用无序列表`<ul>`，并使用`cdkListbox`指令。这将为`<ul>`元素应用CDK
    Listbox功能。你会注意到我们正在根据列表框的WAI ARIA模式在`<ul>`上使用`aria-labelledby`属性。最后，我们将`cdkListboxOrientation`属性设置为`"horizontal"`，这告诉CDK
    Listbox API允许此列表框进行水平导航；即，我们可以使用左右箭头键进行导航。我鼓励你阅读[https://www.w3.org/WAI/ARIA/apg/patterns/listbox/](https://www.w3.org/WAI/ARIA/apg/patterns/listbox/)上的列表框规范，看看它提出的酷炫无障碍功能。而且令人惊讶的是，Angular
    CDK Listbox API遵循了所有这些规范。
- en: On top of following the WAI ARIA pattern for listboxes, the listbox itself works
    seamlessly with Angular forms (both template-driven and reactive). And since we
    were already using a reactive form in the template of the `product-card` component,
    we could easily use the `formControlName` binding with the `<ul>` element. Notice
    that each list item `(<li>)` element has the `cdkOption` binding, which tells
    the CDK Listbox module about the value of each option. At the end of the recipe,
    we also introduced the `cdkOptionTypeaheadLabel`, which helps the CDK Listbox
    API follow the `typeahead` feature of the WAI ARIA pattern recommendation. If
    we don’t use this attribute, the CDK Listbox module uses the list item’s text
    content as the default `typeahead`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 除了遵循 WAI ARIA 列表框模式外，列表框本身与 Angular 表单（无论是模板驱动还是响应式）无缝协作。由于我们已经在 `product-card`
    组件的模板中使用了响应式表单，我们可以轻松地使用 `<ul>` 元素上的 `formControlName` 绑定。请注意，每个列表项 `(<li>)` 元素都有
    `cdkOption` 绑定，这告诉 CDK 列表框模块每个选项的值。在菜谱的最后，我们还介绍了 `cdkOptionTypeaheadLabel`，这有助于
    CDK 列表框 API 遵循 WAI ARIA 模式推荐的 `typeahead` 功能。如果我们不使用此属性，CDK 列表框模块将使用列表项的文本内容作为默认的
    `typeahead`。
- en: You might have noticed that we also added another CSS selector in the `color-options.scss`
    file, i.e., `&[aria-selected=true]`, to highlight the selected color. That’s because
    the CDK Listbox API automatically sets that attribute to `true` or `false` based
    on which item is selected. And this too, is a part of the WAI ARIA pattern for
    listbox.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们在 `color-options.scss` 文件中添加了另一个 CSS 选择器，即 `&[aria-selected=true]`，以突出显示选中的颜色。这是因为
    CDK 列表框 API 会根据哪个项目被选中自动将此属性设置为 `true` 或 `false`。这也是 WAI ARIA 列表框模式的一部分。
- en: See also
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'CDK Listbox documentation: [https://material.angular.io/cdk/listbox/overview](https://material.angular.io/cdk/listbox/overview)'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDK 列表框文档：[https://material.angular.io/cdk/listbox/overview](https://material.angular.io/cdk/listbox/overview)
- en: 'WAI ARIA pattern for listboxes: [https://www.w3.org/WAI/ARIA/apg/patterns/listbox/](https://www.w3.org/WAI/ARIA/apg/patterns/listbox/)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WAI ARIA 列表框模式：[https://www.w3.org/WAI/ARIA/apg/patterns/listbox/](https://www.w3.org/WAI/ARIA/apg/patterns/listbox/)
- en: Working with nested menus using the Angular CDK Menu API
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Angular CDK 菜单 API 处理嵌套菜单
- en: Menus are vital for so many applications we use today. The pattern of having
    a menu itself allows us to have experiences that don’t take up space in the DOM
    all the time and can be shown relative to their triggers **on demand**. In this
    recipe, you’ll learn how to create nested menus using the Angular CDK APIs.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单对于今天我们使用的许多应用程序至关重要。拥有菜单的模式本身允许我们拥有不总是占用 DOM 空间的体验，并且可以根据需要相对于它们的触发器显示。在本菜谱中，你将学习如何使用
    Angular CDK API 创建嵌套菜单。
- en: Getting ready
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter09/ng-cdk-menu`
    inside the cloned repository:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的存储库中的 `start/apps/chapter09/ng-cdk-menu`：
- en: Open the code repository in your code editor.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码存储库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码存储库目录，并运行以下命令以提供项目：
- en: '[PRE75]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，你应该看到以下内容：
- en: '![](img/B18469_09_17.png)'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_09_17.png)'
- en: 'Figure 9.17: The ng-cdk-menu app running on http://localhost:4200'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9.17：运行在 http://localhost:4200 上的 ng-cdk-menu 应用程序
- en: Now that we have the app running locally, let’s see the steps of the recipe
    in the next section.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，让我们在下一节中查看菜谱的步骤。
- en: How to do it…
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We have an application that has a product card that needs an actions menu so
    we can perform some actions. We’ll start using the Angular CDK Menu APIs to implement
    a nested menu. Let’s take the following steps:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个应用程序，它有一个产品卡片需要操作菜单，以便我们可以执行一些操作。我们将开始使用 Angular CDK 菜单 API 来实现嵌套菜单。让我们采取以下步骤：
- en: Copy the styles from [https://ng-cookbook.com/s/cdk-pane-styles](https://ng-cookbook.com/s/cdk-pane-styles)
    into the `styles.scss` file in the project. Make sure to keep the existing styles
    in your file and just add the ones you copied.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 [https://ng-cookbook.com/s/cdk-pane-styles](https://ng-cookbook.com/s/cdk-pane-styles)
    中的样式复制到项目的 `styles.scss` 文件中。确保保留文件中的现有样式，只需添加你复制的样式即可。
- en: 'Import the components from the Angular CDK Menu APIs in the `product-card.component.ts`
    file as follows:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `product-card.component.ts` 文件中按照以下方式导入 Angular CDK 菜单 API 的组件：
- en: '[PRE76]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let’s use some directives in the template to create a menu. We’ll be using
    an `<ng-template>` element for our menu and will assign it to a template variable.
    Update the `product-card.component.html` file as follows:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在模板中使用一些指令来创建一个菜单。我们将使用`<ng-template>`元素作为我们的菜单，并将其分配给一个模板变量。按照以下方式更新`product-card.component.html`文件：
- en: '[PRE77]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If you click the More button (three vertical dots icon) on the product card
    now, you should be able to see the menu as follows:'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在点击产品卡片上的更多按钮（三个垂直点图标），你应该能看到以下菜单：
- en: '![](img/B18469_09_18.png)'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_09_18.png)'
- en: 'Figure 9.18: Menu implementation using Angular CDK Menu APIs'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.18：使用Angular CDK菜单API实现的菜单
- en: You’ll notice that the menu starts from the bottom-left position of the trigger.
    This is the default menu position set by the Angular CDK Menu API. We can override
    it using connected positions.
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到菜单从触发器的左下角位置开始。这是由Angular CDK菜单API设置的默认菜单位置。我们可以使用连接位置来覆盖它。
- en: 'Let’s use some preferred connected positions so the menu is shown on the left
    side of the trigger by default. Update the `product-card.component.ts` file as
    follows:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用一些首选的连接位置，以便菜单默认显示在触发器的左侧。按照以下方式更新`product-card.component.ts`文件：
- en: '[PRE78]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Let’s use the `menuPositions` variable in the template to use the preferred
    positions. Update the `product-card.component.html` file as follows:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在模板中使用`menuPositions`变量来使用首选位置。按照以下方式更新`product-card.component.html`文件：
- en: '[PRE79]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If you now refresh the app and click the More button (three vertical dots icon)
    on the product card, you should see the menu appearing on the left side of the
    button as follows:'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在刷新应用并点击产品卡片上的更多按钮（三个垂直点图标），你应该能看到菜单如下出现在按钮的左侧：
- en: '![](img/B18469_09_19.png)'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_09_19.png)'
- en: 'Figure 9.19: Menu with preferred positions'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.19：具有首选位置的菜单
- en: 'Let’s implement the nested menu now. We’ll create the `<ng-template>` element
    for the nested menu and connect it with the `"Manage"` menu item. Update the `product-card.component.html`
    file as follows:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来实现嵌套菜单。我们将为嵌套菜单创建`<ng-template>`元素，并将其与`"Manage"`菜单项连接起来。按照以下方式更新`product-card.component.html`文件：
- en: '[PRE80]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'With this change, you should be able to see the nested menu as follows:'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这个更改，你应该能看到以下嵌套菜单：
- en: '![](img/B18469_09_20.png)'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_09_20.png)'
- en: 'Figure 9.20: Nested menu implementation'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图9.20：嵌套菜单实现
- en: Kaboom! We were able to implement a nested menu in this application within a
    few steps by using the Angular CDK. Trust me, if we had to do this on our own,
    this would’ve taken hours, or maybe days.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Kaboom！我们通过使用Angular CDK，在几个步骤内就能在这个应用程序中实现嵌套菜单。相信我，如果我们自己来做这件事，可能需要几个小时，甚至可能需要几天。
- en: How it works…
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Angular CDK provides the CDK Menu APIs, which include the `cdkMenuTriggerFor`
    directive. This directive ideally points to a template variable for an `<ng-template>`
    element. And then behind the scenes, the Angular CDK connects that menu with the
    trigger. Even though the menu item itself is appended to the `<body>` element
    inside an overlay, the position of the overlay is calculated accurately for the
    menu and is correct across screen resizes as well. However, the Angular CDK Menu
    API **does not** contain the CSS styles for the overlay. Therefore, in this recipe,
    we have a link to the relevant styles for both the overlay and the menu itself.
    You’ll also notice that we use the directives `cdkMenu` on the menu list `(<ul>)`
    items, and we use the `cdkMenuItem`on the menu `(<li>)` items. Since we use these
    three directives and nothing else from the Angular CDK Menu package, you’ll notice
    that we don’t import `CdkMenuModule` from `'@angular/cdk/menu'`. That’s because
    all these directives are `standalone` directives. So they can be imported without
    the module.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CDK提供了CDK菜单API，其中包括`cdkMenuTriggerFor`指令。这个指令理想地指向一个`<ng-template>`元素的模板变量。然后，在幕后，Angular
    CDK将这个菜单与触发器连接起来。尽管菜单项本身被附加到覆盖层内的`<body>`元素中，但覆盖层的位置对于菜单计算得非常准确，并且在屏幕大小调整时也是正确的。然而，Angular
    CDK菜单API**不包含**覆盖层的CSS样式。因此，在这个菜谱中，我们提供了覆盖层和菜单本身的相应样式链接。你也会注意到我们在菜单列表（`<ul>`）项上使用了`cdkMenu`指令，在菜单（`<li>`）项上使用了`cdkMenuItem`指令。由于我们使用了这三个指令而没有使用Angular
    CDK菜单包中的其他任何东西，你会注意到我们没有从`'@angular/cdk/menu'`导入`CdkMenuModule`。这是因为所有这些指令都是`standalone`指令。所以它们可以不导入模块而导入。
- en: 'In this recipe, we also modified the default positioning for the menu. By default,
    the overlay starts from the *bottom-left* point of the trigger, toward the right
    side. We used a `ConnectionPosition` array with the `[cdkMenuPosition]` binding
    to the **More** button (the trigger element) to use our preferred position. The
    first (preferred) position is that the overlay’s **top-right** corner aligns with
    the trigger element’s **bottom-right** corner. That is, the overlay shows below
    the **More** button and expands toward the left side, as per the following object:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们还修改了菜单的默认定位。默认情况下，覆盖层从触发器的*左下角*开始，向右侧扩展。我们使用了一个带有 `[cdkMenuPosition]`
    绑定的 `ConnectionPosition` 数组，将其绑定到**更多**按钮（触发元素）以使用我们首选的位置。第一个（首选）位置是覆盖层的**右上角**与触发元素的**右下角**对齐。也就是说，覆盖层显示在**更多**按钮下方，并继续向左侧扩展，如下所示：
- en: '[PRE81]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The second position is that the overlay shows above More button (three vertical
    dots icon) and still expands toward the left side based on the following options:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个位置是，覆盖层显示在“更多”按钮（三个垂直点图标）上方，并且根据以下选项继续向左侧扩展：
- en: '[PRE82]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Finally, we implemented the nested menu. This was pretty simple. We created
    another menu with the same technique as the first one, creating an `<ng-template>`
    with a template variable, a `cdkMenu` inside it, and `cdkMenuItems` inside the
    menu. Then we set the trigger of this nested menu to the `Manage` menu item in
    the primary menu. The Angular CDK is smart enough to understand if the trigger
    is a `cdkMenuItem`. If it is, it opens the nested menu automatically on the mouse-over
    event on the trigger menu item. And when the mouse-leave event triggers from the
    nested menu, it hides. I must give kudos to the Angular CDK team for making things
    this easy.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了嵌套菜单。这相当简单。我们使用与第一个菜单相同的技术创建了另一个菜单，创建了一个带有模板变量的 `<ng-template>`，其中包含一个
    `cdkMenu` 和菜单内的 `cdkMenuItems`。然后我们将这个嵌套菜单的触发器设置为一级菜单中的“管理”菜单项。Angular CDK 足够智能，能够理解触发器是否是
    `cdkMenuItem`。如果是，它会在触发菜单项的鼠标悬停事件上自动打开嵌套菜单。当从嵌套菜单触发鼠标离开事件时，它会隐藏。我必须向 Angular CDK
    团队表示敬意，因为他们使事情变得如此简单。
- en: See also
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular CDK Menu: [https://material.angular.io/cdk/menu/overview](https://material.angular.io/cdk/menu/overview)'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular CDK 菜单：[https://material.angular.io/cdk/menu/overview](https://material.angular.io/cdk/menu/overview)
- en: Learn more on Discord
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里您可以分享反馈、向作者提问，并了解新发布的内容——请扫描下面的二维码：
- en: '[https://packt.link/AngularCookbook2e](Chapter_9.xhtml)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/AngularCookbook2e](Chapter_9.xhtml)'
- en: '![](img/QR_Code1388317275422265.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1388317275422265.png)'
