<html><head></head><body>
<div id="_idContainer054">
<h1 class="chapter-number" id="_idParaDest-113"><a id="_idTextAnchor225"/><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-114"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.2.1">Improving Backend Integrations: the Interceptor Pattern</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In a </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">single-page application</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">SPA</span></strong><span class="koboSpan" id="kobo.7.1">), communication </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.8.1">with the backend is one of the most common tasks. </span><span class="koboSpan" id="kobo.8.2">In </span><a href="B19562_05.xhtml#_idTextAnchor163"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Angular Services and the Singleton Pattern</span></em><span class="koboSpan" id="kobo.12.1">, we learned that the Angular component that makes this communication is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.13.1">Service</span></strong><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">However, many side tasks are common to all communications with the backend, such as header processing, authentication, </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">and loading.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">We could do this sides task on a service-by-service basis, but in addition to being an unproductive activity, the team might not be able to implement some control on the request due to the carelessness or ignorance of a new member of </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">the team.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">In order to simplify the development of side tasks for communicating with the backend, the Angular framework implements the interceptor design pattern, which we will explore in this chapter. </span><span class="koboSpan" id="kobo.18.2">Here, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.20.1">Attaching the token to the request with </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">an interceptor</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Changing the </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">request route</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">a loader</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.26.1">Notifying success</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Measuring the performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">a request</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.29.1">By the end of this chapter, you will be able to create interceptors capable of implicitly performing tasks necessary for your </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">backend communication.</span></span><a id="_idTextAnchor228"/></p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.31.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.32.1">To follow the instructions in this chapter, you’ll need </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.34.1">Visual Studio </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">Code (</span></span><a href="https://code.visualstudio.com/Download"><span class="No-Break"><span class="koboSpan" id="kobo.36.1">https://code.visualstudio.com/Download</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.37.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">Node.js 18 or </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">higher (</span></span><a href="https://nodejs.org/en/download/"><span class="No-Break"><span class="koboSpan" id="kobo.40.1">https://nodejs.org/en/download/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.41.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.42.1">The code files for this chapter are available </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">at </span></span><a href="https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch8"><span class="No-Break"><span class="koboSpan" id="kobo.44.1">https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch8</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.45.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">While following this chapter, remember to run the backend of the application found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">gym-diary-backend</span></strong><span class="koboSpan" id="kobo.48.1"> folder with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">npm </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">start</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.51.1"> command.</span></span><a id="_idTextAnchor230"/></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.52.1">Attaching the token to the request with an interceptor</span></h1>
<p><span class="koboSpan" id="kobo.53.1">So far, our </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.54.1">backend doesn’t have any kind of authentication</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.55.1"> control, which doesn’t happen (or at least it shouldn’t happen) in the real world. </span><span class="koboSpan" id="kobo.55.2">The backend was modified to perform authentication, but this was reflected in the frontend because, if we tried to log in, the following error </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">would occur:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.57.1">
ERROR Error: Uncaught (in promise): HttpErrorResponse:
{"headers":{"normalizedNames":{},"lazyUpdate":null},"status":401,"statusText":"Unauthorized","url":"http://localhost:3000/diary","ok":false,"name":"HttpErrorResponse","message":"Http failure response for http://localhost:3000/diary: 401 Unauthorized","error":{"message":"Unauthorized","statusCode":401}}</span></pre> <p><span class="koboSpan" id="kobo.58.1">This error means that our request was rejected by the server because it was not authorized. </span><span class="koboSpan" id="kobo.58.2">That’s because our server implements a very common form of security that consists of asking for an authorization token in </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">every request.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">This token is created when the user logs in to the application and it must be passed in the header of the </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">HTTP request.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">We’ll fix this problem first by making a change to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">AuthService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.64.1"> service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.65.1">
export class AuthService {
  private httpClient = inject(HttpClient);
  private url = 'http://localhost:3000/auth/login';
</span><strong class="bold"><span class="koboSpan" id="kobo.66.1">  #token?: Token;</span></strong><span class="koboSpan" id="kobo.67.1">
  login(loginForm: Partial&lt;LoginForm&gt;): Observable&lt;Token&gt; {
    return this.httpClient
      .post&lt;Token&gt;(this.url, loginForm)
      .pipe(tap((token) =&gt; (this.#token = token)));
  }
  get isLogged() {
    return this.#token ? </span><span class="koboSpan" id="kobo.67.2">true : false;
  }
  logout() {
    this.#token = undefined;
  }
  get token() {
    return this.#token?.access_token;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.68.1">First, we </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.69.1">change the access mode of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">token</span></strong><span class="koboSpan" id="kobo.71.1"> attribute. </span><span class="koboSpan" id="kobo.71.2">We are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">#</span></strong><span class="koboSpan" id="kobo.73.1"> symbol, which is the way to declare a </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">private</span></strong><span class="koboSpan" id="kobo.75.1"> attribute in standard JavaScript. </span><span class="koboSpan" id="kobo.75.2">We want the token to be read by the other </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">component</span></strong><span class="koboSpan" id="kobo.77.1"> but never overwritten, and using the token ensures that this happens even if the consumer </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.78.1">class </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">forces manipulation.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">We change the class to the new attribute name and, at the end, we create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">token()</span></strong><span class="koboSpan" id="kobo.82.1"> accessor method to return the token stored by </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">the service.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">We’ll refactor the </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">ExerciseSetsService</span></strong><span class="koboSpan" id="kobo.86.1"> service to send the token in the request that returns the </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">diary items:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.88.1">
. </span><span class="koboSpan" id="kobo.88.2">. </span><span class="koboSpan" id="kobo.88.3">.
</span><span class="koboSpan" id="kobo.88.4">private authService = inject(AuthService);
private url = 'http://localhost:3000/diary';
getInitialList(): Observable&lt;ExerciseSetListAPI&gt; {
  const headers = new HttpHeaders({
    Authorization: `Bearer ${this.authService.token}`,
  });
  return this.httpClient.get&lt;ExerciseSetListAPI&gt;(this.url, { headers });
}
. </span><span class="koboSpan" id="kobo.88.5">. </span><span class="koboSpan" id="kobo.88.6">.</span></pre> <p><span class="koboSpan" id="kobo.89.1">Here, we create </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.90.1">a header using the accessory class of </span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.91.1">Angular, </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">HttpHeaders</span></strong><span class="koboSpan" id="kobo.93.1">, passing the token in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">Authorization</span></strong><span class="koboSpan" id="kobo.95.1"> attribute. </span><span class="koboSpan" id="kobo.95.2">Then, we pass this header in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">get</span></strong><span class="koboSpan" id="kobo.97.1"> method of Angular’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">HttpClient</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.99.1"> service.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">When we run our application again, it works again (</span><strong class="bold"><span class="koboSpan" id="kobo.101.1">Username</span></strong><span class="koboSpan" id="kobo.102.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">mario</span></strong><span class="koboSpan" id="kobo.104.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">Password</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.106.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">1234</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.109.1"><img alt="Figure 8.1 – Gym diary home page" src="image/B19562_08_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.110.1">Figure 8.1 – Gym diary home page</span></p>
<p><span class="koboSpan" id="kobo.111.1">This approach</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.112.1"> has a problem, as we would need to</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.113.1"> replicate this operation for all of the service’s methods, and as our application grows, we would need to remember to do this </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">token handling.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">A good software architecture should think about new team members with different backgrounds and even the creation of new teams as the project grows. </span><span class="koboSpan" id="kobo.115.2">Therefore, this type of transversal requirement of our system must be treated in a more </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">intelligent way.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">Enter </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">Angular Interceptor</span></strong><span class="koboSpan" id="kobo.119.1">, which is a service of a specific type to handle the HTTP request flow. </span><span class="koboSpan" id="kobo.119.2">This component is based on the design pattern of the same name, which aims to change a </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">processing cycle.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">Let’s illustrate this pattern with the </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.123.1"><img alt="" role="presentation" src="image/B19562_08_2.jpg"/></span>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.124.1"><img alt="Figure 8.2 – Interceptor design pattern" src="image/B19562_08_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.125.1">Figure 8.2 – Interceptor design pattern</span></p>
<p><span class="koboSpan" id="kobo.126.1">In this diagram, we have the Angular application that makes an HTTP request to the backend; in the interceptor pattern, we have an Angular service in the middle of the request that can change both the request and the return from </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">the backend.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">We will refactor our </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.129.1">previous solution to see this pattern in </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.130.1">practice. </span><span class="koboSpan" id="kobo.130.2">We’ll clean up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">ExerciseSetsService</span></strong><span class="koboSpan" id="kobo.132.1"> service by removing the handling from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">Authorization</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.134.1"> header:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.135.1">
export class ExerciseSetsService {
  private httpClient = inject(HttpClient);
  private url = 'http://localhost:3000/diary';
  getInitialList(): Observable&lt;ExerciseSetListAPI&gt; {
    return this.httpClient.get&lt;ExerciseSetListAPI&gt;(this.url);
  }
 . </span><span class="koboSpan" id="kobo.135.2">. </span><span class="koboSpan" id="kobo.135.3">.
</span><span class="koboSpan" id="kobo.135.4">}</span></pre> <p><span class="koboSpan" id="kobo.136.1">To create</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.137.1"> the interceptor, we are going to use the Angular</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.138.1"> CLI for Angular to create the entire boilerplate of </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">the service:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.140.1">
ng g interceptor login/auth</span></pre> <p><span class="koboSpan" id="kobo.141.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">AuthInterceptor</span></strong><span class="koboSpan" id="kobo.143.1"> service created, let’s create our logic to attach the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">Authorization</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.145.1"> header:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.146.1">
@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  private authService = inject(AuthService);
  intercept(
    request: HttpRequest&lt;unknown&gt;,
    next: HttpHandler
  ): Observable&lt;HttpEvent&lt;unknown&gt;&gt; {
    const token = this.authService.token;
    if (request.url.includes('auth')) {
      return next.handle(request);
    }
    if (token) {
      const reqAuth = request.clone({
        headers: request.headers.set(`Authorization`, `Bearer ${token}`),
      });
      return next.handle(reqAuth);
    }
    return next.handle(request);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.147.1">The first thing we can </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.148.1">notice is that the interceptor is a common </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.149.1">Angular service, so it has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">@Injectable</span></strong><span class="koboSpan" id="kobo.151.1"> notation; for more details about Angular services, see </span><a href="B19562_05.xhtml#_idTextAnchor163"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.152.1">Chapter 5</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.153.1">,</span></em> <em class="italic"><span class="koboSpan" id="kobo.154.1">Angular Services and the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.155.1">Singleton Pattern</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">This service implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">HttpInterceptor</span></strong><span class="koboSpan" id="kobo.159.1"> interface, which requires the class to have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">inject</span></strong><span class="koboSpan" id="kobo.161.1"> method. </span><span class="koboSpan" id="kobo.161.2">This method receives the request we want to handle and expects an observable as a return. </span><span class="koboSpan" id="kobo.161.3">This signature indicates the characteristic of the interceptor because this class is always in the middle of a flow between the component making the request and </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">the backend.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">Therefore, the service receives information from the flow and must return the flow represented by the observable. </span><span class="koboSpan" id="kobo.163.2">In our case, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">AuthService</span></strong><span class="koboSpan" id="kobo.165.1"> service to get the token. </span><span class="koboSpan" id="kobo.165.2">The service cannot attach the token to the login endpoint because that is where we will get the token, so we make an </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">if</span></strong><span class="koboSpan" id="kobo.167.1"> statement by analyzing which URL the request </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">is using.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">If we have a token, we clone the request, but this time, we inform the header with the token. </span><span class="koboSpan" id="kobo.169.2">The reason we need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">clone</span></strong><span class="koboSpan" id="kobo.171.1"> method to get a new object is that the request object is immutable – that is, it is not possible to change it; we need to create a new one, identical to the old one, but this time, we put </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">the header.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">Finally, the flow is </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.174.1">returned but, this time, with the new request </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.175.1">object. </span><span class="koboSpan" id="kobo.175.2">To configure the interceptor, we need to change the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">AppModule</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.177.1"> module:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.178.1">
@NgModule({
  declarations: [AppComponent, ErrorPageComponent],
  imports: [BrowserModule, AppRoutingModule, HttpClientModule],
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },
  ],
  bootstrap: [AppComponent],
})
export class AppModule {}</span></pre> <p><span class="koboSpan" id="kobo.179.1">We’re including the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">AuthInterceptor</span></strong><span class="koboSpan" id="kobo.181.1"> service in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">HTTP_INTERCEPTORS</span></strong><span class="koboSpan" id="kobo.183.1"> token. </span><span class="koboSpan" id="kobo.183.2">This tells the framework to call the service whenever a component uses Angular’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">HttpClient</span></strong><span class="koboSpan" id="kobo.185.1"> service. </span><span class="koboSpan" id="kobo.185.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">multi</span></strong><span class="koboSpan" id="kobo.187.1"> attribute informs the framework that we can have more than one interceptor because, by default, Angular adds </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">only one.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">Running the</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.190.1"> application again, we can see that it is working </span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.191.1">now with the addition that all the resources are attaching the header, but implicitly, without the need to change each </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">HttpClient</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.193.1"> call.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">Let’s explore this feature further with a very common task in our project, which is URL routing in the </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">API call.</span></span></p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.196.1">Changing the request route</span></h1>
<p><span class="koboSpan" id="kobo.197.1">In our project so far, we have</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.198.1"> two services that make requests to the backend. </span><span class="koboSpan" id="kobo.198.2">If </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.199.1">we analyze them, we see that they both point directly to the backend URL. </span><span class="koboSpan" id="kobo.199.2">This is not a good practice since, as the project scales and grows in complexity, errors can occur by pointing to the wrong URL. </span><span class="koboSpan" id="kobo.199.3">In addition to the need to change the host, we will need to change </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">numerous files.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">There are a few ways to handle this problem, but a very useful tool for this is the Angular interceptor. </span><span class="koboSpan" id="kobo.201.2">Let’s see it in practice starting with the Angular CLI, where we are going to create the </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">new interceptor:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.203.1">
ng g interceptor shared/host</span></pre> <p><span class="koboSpan" id="kobo.204.1">With the generated file, let’s </span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.205.1">create the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">intercept</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.207.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.208.1">
@Injectable()
export class HostInterceptor implements HttpInterceptor {
  intercept(
    request: HttpRequest&lt;unknown&gt;,
    next: HttpHandler
  ): Observable&lt;HttpEvent&lt;unknown&gt;&gt; {
    const url = 'http://localhost:3000';
    const resource = request.url;
    if (request.url.includes('http')) {
      return next.handle(request);
    }
    const urlsReq = request.clone({
      url: `${url}/${resource}`,
    });
    return next.handle(urlsReq);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.209.1">In this function, we have the URL of the backend and, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">resource</span></strong><span class="koboSpan" id="kobo.211.1"> variable, we receive the original URL of the request that we want to intercept and modify. </span><span class="koboSpan" id="kobo.211.2">We use an </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">if</span></strong><span class="koboSpan" id="kobo.213.1"> statement next because we want to avoid errors in case some service needs to call another </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">API directly.</span></span></p>
<p><span class="koboSpan" id="kobo.215.1">Finally, we create a</span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.216.1"> new request object (this time, with the URL changed) and we pass this new object to the request flow. </span><span class="koboSpan" id="kobo.216.2">For this interceptor to be triggered by Angular, we need to add it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">providers</span></strong><span class="koboSpan" id="kobo.218.1"> array of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">AppModule</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.220.1"> module:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.221.1">
@NgModule({
  declarations: [AppComponent, ErrorPageComponent],
  imports: [BrowserModule, AppRoutingModule, HttpClientModule],
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },
    { provide: HTTP_INTERCEPTORS, useClass: HostInterceptor, multi: true },
  ],
  bootstrap: [AppComponent],
})
export class AppModule {}</span></pre> <p><span class="koboSpan" id="kobo.222.1">We will </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.223.1">refactor our service to only care about the features they need, starting </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.224.1">with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">ExerciseSetsService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.226.1"> service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
export class ExerciseSetsService {
  private httpClient = inject(HttpClient);
  private url = 'diary';
 . </span><span class="koboSpan" id="kobo.227.2">. </span><span class="koboSpan" id="kobo.227.3">.
</span><span class="koboSpan" id="kobo.227.4">}</span></pre> <p><span class="koboSpan" id="kobo.228.1">We follow this with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">Authentication</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.230.1"> service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.231.1">
export class AuthService {
  private httpClient = inject(HttpClient);
  private url = 'auth/login';
. </span><span class="koboSpan" id="kobo.231.2">. </span><span class="koboSpan" id="kobo.231.3">.
</span><span class="koboSpan" id="kobo.231.4">}</span></pre> <p><span class="koboSpan" id="kobo.232.1">We can see that if</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.233.1"> we needed new services or changed the URL, the HTTP requests </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.234.1">would not need to be refactored, as we created an interceptor to work </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">on that.</span></span></p>
<p><span class="koboSpan" id="kobo.236.1">Next, we’ll learn how to give our users a better experience if a </span><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.237.1">request takes </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">too long.</span></span></p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.239.1">Creating a loader</span></h1>
<p><span class="koboSpan" id="kobo.240.1">In a frontend </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.241.1">project, performance is not only about having faster requests but also improving the user’s perception of the application. </span><span class="koboSpan" id="kobo.241.2">A blank screen without any feedback signals </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.242.1">to the user that the page did not load, that their internet is having a problem, or any other type of </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">negative perception.</span></span></p>
<p><span class="koboSpan" id="kobo.244.1">That’s why we always need to signal that the action the user expects is being performed. </span><span class="koboSpan" id="kobo.244.2">One way to show this is a loading indicator, and that’s what we’re going to do in this session. </span><span class="koboSpan" id="kobo.244.3">In the command line of our operating system, we will use the </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">Angular CLI:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.246.1">
 ng generate component loading-overlay
 ng generate service loading-overlay/load
 ng generate interceptor loading-overlay/load</span></pre> <p><span class="koboSpan" id="kobo.247.1">With that, we created the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">overlay</span></strong><span class="koboSpan" id="kobo.249.1"> component, the service that will control the loading state, and the interceptor that will control the beginning and end of the loading based on </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">HTTP requests.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">Let’s create the loading overlay screen in the HTML template of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">LoadingOverlayComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.253.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.254.1">
&lt;div class="fixed inset-0 flex items-center justify-center bg-gray-800 bg-opacity-75 z-50"&gt;
  &lt;div class="text-white text-xl"&gt;
    Loading...
</span><span class="koboSpan" id="kobo.254.2">  &lt;/div&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.255.1">We will </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.256.1">implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">LoadService</span></strong><span class="koboSpan" id="kobo.258.1"> service, which will maintain and control the </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">loading</span></span><span class="No-Break"><a id="_idIndexMarker379"/></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1"> state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.261.1">
@Injectable({
  providedIn: 'root',
})
export class LoadService {
  #showLoader = false;
  showLoader() {
    this.#showLoader = true;
  }
  hideLoader() {
    this.#showLoader = false;
  }
  get isLoading() {
    return this.#showLoader;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.262.1">We create two methods to turn the loading state on and off and a property to expose </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">this state.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">In the load interceptor, we will implement </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.266.1">
@Injectable()
export class LoadInterceptor implements HttpInterceptor {
  private loadService = inject(LoadService);
  intercept(
    request: HttpRequest&lt;unknown&gt;,
    next: HttpHandler
  ): Observable&lt;HttpEvent&lt;unknown&gt;&gt; {
    if (request.headers.get('X-LOADING') === 'false') {
      return next.handle(request);
    }
    this.loadService.showLoader();
    return next
      .handle(request)
      .pipe(finalize(() =&gt; this.loadService.hideLoader()));
  }
}</span></pre> <p><span class="koboSpan" id="kobo.267.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">intercept</span></strong><span class="koboSpan" id="kobo.269.1"> method</span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.270.1"> starts by turning on the loading state and returning requests without</span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.271.1"> modifying anything </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">in them.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">However, in the flow of the request, we placed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">finalize</span></strong><span class="koboSpan" id="kobo.275.1"> operator from RxJs, which has the characteristic of executing a function when an observable arrives in the complete state – here, turning off the loading state. </span><span class="koboSpan" id="kobo.275.2">For more details about RxJS, read </span><a href="B19562_09.xhtml#_idTextAnchor242"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.276.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.277.1">, </span><em class="italic"><span class="koboSpan" id="kobo.278.1">Exploring Reactivity </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.279.1">with RxJS</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">To activate the interceptor, we will add it </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">AppModule</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
@NgModule({
  declarations: [AppComponent, ErrorPageComponent, LoadingOverlayComponent],
  imports: [BrowserModule, AppRoutingModule, HttpClientModule],
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },
    { provide: HTTP_INTERCEPTORS, useClass: HostInterceptor, multi: true },
    { provide: HTTP_INTERCEPTORS, useClass: LoadInterceptor, multi: true },
  ],
  bootstrap: [AppComponent],
})
export class AppModule {}</span></pre> <p><span class="koboSpan" id="kobo.286.1">We want the overlay </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.287.1">to be executed in the application as a whole, so we will </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.288.1">include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">overlay</span></strong><span class="koboSpan" id="kobo.290.1"> component in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">AppComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.292.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.293.1">
export class AppComponent {
  loadService = inject(LoadService);
  title = 'gym-diary';
}</span></pre> <p><span class="koboSpan" id="kobo.294.1">We just need to inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">LoadService</span></strong><span class="koboSpan" id="kobo.296.1"> service because that’s where we’ll have the </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">loading state.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">Finally, let’s place the </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">overlay</span></strong><span class="koboSpan" id="kobo.300.1"> component in the </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">HTML template:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.302.1">
&lt;app-loading-overlay *ngIf="loadService.isLoading"&gt;&lt;/app-loading-overlay&gt;
&lt;router-outlet&gt;&lt;/router-outlet&gt;</span></pre> <p><span class="koboSpan" id="kobo.303.1">Running our application, as we are running it with a backend on our machine, we may not notice the loading screen. </span><span class="koboSpan" id="kobo.303.2">However, for these cases, we can use a Chrome feature that simulates a slow </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">3G network.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">Open </span><strong class="bold"><span class="koboSpan" id="kobo.306.1">Chrome DevTools</span></strong><span class="koboSpan" id="kobo.307.1"> and, in the </span><strong class="bold"><span class="koboSpan" id="kobo.308.1">Network</span></strong><span class="koboSpan" id="kobo.309.1"> tab, use the throttling option, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.311.1"><img alt="Figure 8.3 – Simulation of a slow 3G network to notice the loading screen" src="image/B19562_08_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.312.1">Figure 8.3 – Simulation of a slow 3G network to notice the loading screen</span></p>
<p><span class="koboSpan" id="kobo.313.1">In the next section, we will learn how to notify the success of </span><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.314.1">a backend request to </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">the user.</span></span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.316.1">Notifying success</span></h1>
<p><span class="koboSpan" id="kobo.317.1">In addition to the </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.318.1">loading screen to inform the user that the system is looking for the information they want, it is important to notify the user after processing an item. </span><span class="koboSpan" id="kobo.318.2">We can handle this notification directly from the service or component, but we can also implement it generically and implicitly </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">using interceptors.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">We will refactor our application to add this treatment. </span><span class="koboSpan" id="kobo.320.2">But first, let’s install a library to show the </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">toaster</span></strong><span class="koboSpan" id="kobo.322.1"> component on the screen with an animation. </span><span class="koboSpan" id="kobo.322.2">In the command line of our operating system, we will use the following command in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">main</span></strong><span class="koboSpan" id="kobo.324.1"> folder of our </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">frontend project:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.326.1">
 npm install ngx-toastr</span></pre> <p><span class="koboSpan" id="kobo.327.1">In order for the package to work, we need to add our CSS to our project by editing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">angular.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.329.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.330.1">
. </span><span class="koboSpan" id="kobo.330.2">. </span><span class="koboSpan" id="kobo.330.3">.
</span><span class="koboSpan" id="kobo.330.4">  "build": {
    . </span><span class="koboSpan" id="kobo.330.5">. </span><span class="koboSpan" id="kobo.330.6">.
</span><span class="koboSpan" id="kobo.330.7">      "assets": [
      "src/favicon.ico",
      "src/assets"
      ],
      "styles": ["src/styles.css", </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">"node_modules/ngx-toastr/toastr.css"</span></strong><span class="koboSpan" id="kobo.332.1">],
    . </span><span class="koboSpan" id="kobo.332.2">. </span><span class="koboSpan" id="kobo.332.3">.
</span><span class="koboSpan" id="kobo.332.4">  },</span></pre> <p><span class="koboSpan" id="kobo.333.1">For the toaster animations to work, we need to change the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">AppModule</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.335.1"> module:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.336.1">
imports: [
  BrowserAnimationsModule,
  AppRoutingModule,
  HttpClientModule,
  ToastrModule.forRoot(),
],</span></pre> <p><span class="koboSpan" id="kobo.337.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">main</span></strong><span class="koboSpan" id="kobo.339.1"> module of </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.340.1">our application, we are adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">ToastrModule</span></strong><span class="koboSpan" id="kobo.342.1"> module from the library and changing </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">BrowserModule</span></strong><span class="koboSpan" id="kobo.344.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">BrowserAnimationsModule</span></strong><span class="koboSpan" id="kobo.346.1">, which adds Angular animation services used by </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">the library.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">With the new package configured, we can proceed with creating the new interceptor using the </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">Angular CLI:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.350.1">
ng interceptor notification/notification</span></pre> <p><span class="koboSpan" id="kobo.351.1">With the interceptor created, we will change the file with the treatment for </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">the notification:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.353.1">
. </span><span class="koboSpan" id="kobo.353.2">. </span><span class="koboSpan" id="kobo.353.3">.
</span><span class="koboSpan" id="kobo.353.4">import { ToastrService } from 'ngx-toastr';
@Injectable()
export class NotificationInterceptor implements HttpInterceptor {
  private toaster = inject(ToastrService);
  intercept(
    request: HttpRequest&lt;unknown&gt;,
    next: HttpHandler
  ): Observable&lt;HttpEvent&lt;unknown&gt;&gt; {
    return next.handle(request).pipe(
      tap((event: HttpEvent&lt;any&gt;) =&gt; {
        if (event instanceof HttpResponse &amp;&amp; event.status === 201) {
          this.toaster.success('Item Created!');
        }
      })
    );
  }
}</span></pre> <p><span class="koboSpan" id="kobo.354.1">As in the </span><em class="italic"><span class="koboSpan" id="kobo.355.1">Creating a loader</span></em><span class="koboSpan" id="kobo.356.1"> section, we </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.357.1">are using the fact that the request is treated as a flow to use RxJS and its observables to verify the request’s characteristics. </span><span class="koboSpan" id="kobo.357.2">We are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">tap</span></strong><span class="koboSpan" id="kobo.359.1"> operator, which aims to perform side effects on the request without </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">changing it.</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">This operator will execute an anonymous function that will check the HTTP event, which brings us to an interesting point. </span><span class="koboSpan" id="kobo.361.2">As we are interested in the return of the request, we only select the event of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">HttpResponse</span></strong><span class="koboSpan" id="kobo.363.1"> and the event code </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">201-Created</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">When we develop an interceptor, we have to remember that it is called in the request and the response, so it is important to use conditionals to execute what we need when we </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">need it.</span></span></p>
<p><span class="koboSpan" id="kobo.369.1">The last point we need to</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.370.1"> configure is the main </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">AppModule</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.372.1"> module:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.373.1">
 providers: [
. </span><span class="koboSpan" id="kobo.373.2">. </span><span class="koboSpan" id="kobo.373.3">.
</span><span class="koboSpan" id="kobo.373.4">   {
     provide: HTTP_INTERCEPTORS,
     useClass: NotificationInterceptor,
     multi: true,
   },
. </span><span class="koboSpan" id="kobo.373.5">. </span><span class="koboSpan" id="kobo.373.6">.
 </span><span class="koboSpan" id="kobo.373.7">]</span></pre> <p><span class="koboSpan" id="kobo.374.1">Running our project and creating an entry, we notice that the toast appears on the screen with the </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">configured message.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.376.1"><img alt="Figure 8.4 – Success notification" src="image/B19562_08_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.377.1">Figure 8.4 – Success notification</span></p>
<p><span class="koboSpan" id="kobo.378.1">Another use for interceptors is to instrument our application to measure performance and stability, which we’ll</span><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.379.1"> learn about in the </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">next section.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.381.1">Measuring the performance of a request</span></h1>
<p><span class="koboSpan" id="kobo.382.1">As a</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.383.1"> development team, we must always seek to offer the best experience for our users, and, in addition to developing quality products, we must allow the application to be monitored to maintain quality </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">during production.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">There are several tools available on the market, and many of them need some level of instrumentation to accurately measure the user experience. </span><span class="koboSpan" id="kobo.385.2">We will develop a simpler telemetry example, but it can be applied to the monitoring tool your </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">team uses.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">Using the Angular CLI, we will create a </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">new interceptor:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.389.1">
ng g interceptor telemetry/telemetry</span></pre> <p><span class="koboSpan" id="kobo.390.1">In the file generated by the Angular CLI, we will develop </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">our interceptor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.392.1">
@Injectable()
export class TelemetryInterceptor implements HttpInterceptor {
  intercept(
    request: HttpRequest&lt;unknown&gt;,
    next: HttpHandler
  ): Observable&lt;HttpEvent&lt;unknown&gt;&gt; {
    if (request.headers.get('X-TELEMETRY') !== 'true') {
      return next.handle(request);
    }
    const started = Date.now();
    return next.handle(request).pipe(
      finalize(() =&gt; {
        const elapsed = Date.now() - started;
        const message = `${request.method} "${request.urlWithParams}" in ${elapsed} ms.`;
        console.log(message);
      })
    );
  }
}</span></pre> <p><span class="koboSpan" id="kobo.393.1">To illustrate the ability to customize an interceptor, we agree that telemetry will only be used if the request made has a custom header called </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">X-TELEMETRY</span></strong><span class="koboSpan" id="kobo.395.1">, and right at the beginning of the function, we do </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">this verification.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">As we did in the loader example, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">finalize</span></strong><span class="koboSpan" id="kobo.399.1"> operator to measure the performance of the request in a simplified way and presented it in </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">console.log</span></strong><span class="koboSpan" id="kobo.401.1">. </span><span class="koboSpan" id="kobo.401.2">You could put your telemetry provider call or even your custom </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">backend here.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">To exemplify, we </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.404.1">use </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">console.log</span></strong><span class="koboSpan" id="kobo.406.1"> to show the information. </span><span class="koboSpan" id="kobo.406.2">As in the other sections, we need to configure the interceptor in the main </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">AppModule</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.408.1"> module:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.409.1">
. </span><span class="koboSpan" id="kobo.409.2">. </span><span class="koboSpan" id="kobo.409.3">.
</span><span class="koboSpan" id="kobo.409.4">providers: [
. </span><span class="koboSpan" id="kobo.409.5">. </span><span class="koboSpan" id="kobo.409.6">.
</span><span class="koboSpan" id="kobo.409.7">   {
     provide: HTTP_INTERCEPTORS,
     useClass: TelemetryInterceptor,
     multi: true,
   },
 ],
. </span><span class="koboSpan" id="kobo.409.8">. </span><span class="koboSpan" id="kobo.409.9">.</span></pre> <p><span class="koboSpan" id="kobo.410.1">Finally, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">ExerciseSetsService</span></strong><span class="koboSpan" id="kobo.412.1"> service, we will send the customized header to carry out the telemetry of this </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">request only:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.414.1">
. </span><span class="koboSpan" id="kobo.414.2">. </span><span class="koboSpan" id="kobo.414.3">.
</span><span class="koboSpan" id="kobo.414.4">getInitialList(): Observable&lt;ExerciseSetListAPI&gt; {
  const headers = new HttpHeaders().set('X-TELEMETRY', 'true');
  return this.httpClient.get&lt;ExerciseSetListAPI&gt;(this.url, { headers });
}
. </span><span class="koboSpan" id="kobo.414.5">. </span><span class="koboSpan" id="kobo.414.6">.</span></pre> <p><span class="koboSpan" id="kobo.415.1">Header passing is a way to configure an interceptor to behave differently depending on </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">the situation.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">Running our project, we can see the messages in the </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">browser log:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.419.1">
GET "http://localhost:3000/diary" in 5 ms. </span><span class="koboSpan" id="kobo.419.2">telemetry.interceptor.ts:25:16</span></pre> <p><span class="koboSpan" id="kobo.420.1">With this development, HTTP</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.421.1"> requests with the configured header will be logged in </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">console.log</span></strong><span class="koboSpan" id="kobo.423.1">. </span><span class="koboSpan" id="kobo.423.2">You can replace this interceptor with an integration to a telemetry service, improving</span><a id="_idTextAnchor239"/><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.424.1"> the monitoring of </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">your application.</span></span></p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.426.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.427.1">In this chapter, we explored the interceptor feature in Angular and the possibilities that this feature can give our team. </span><span class="koboSpan" id="kobo.427.2">We learned how to attach the authentication token to the requests without having to change all the services in our project. </span><span class="koboSpan" id="kobo.427.3">We also worked on changing the URL of the request, making our project more flexible to its </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">execution environment.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">We also improved our users’ experience by creating a loader in case their internet is slow and notifying them on the screen when a new entry is registered in their gym diary. </span><span class="koboSpan" id="kobo.429.2">Finally, we created a simple example of telemetry using a custom header to give the team the ability to select which requests are </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">telemetry capable.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">In the next chapter, we’ll explore RxJS, the most powerful library in the Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">utility belt.</span></span></p>
</div>
</body></html>