<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Testing Components"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Testing Components</h1></div></div></div><p>In the last chapter, we looked at ways of making our components friendly for plugin developers. We saw a few of the benefits of dependency injection and how AdonisJS Fold can help us achieve it with minimal effort.</p><p>In this chapter, we will learn about testing—automated testing, effective testing, before-you-make-a-mess-of-your-code testing. We will learn about the benefits of testing and the different kinds of tests.</p><div class="section" title="Eat your vegetables"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec56"/>Eat your vegetables</h1></div></div></div><p>Is there something you really don't like to eat? Perhaps it's a kind of vegetable or fruit. When I was a kid, there were many things I didn't like to eat. I couldn't even remember what many of them tasted like, and they didn't hurt me. I just made up my mind that they were bad, and I didn't like them.</p><p>Some developers have similar habits. Are there things you don't like to do as a developer? Not because they're difficult or bad, but just because...</p><p>For me, testing was one of those things. I learned <a id="id251" class="indexterm"/>about testing many years after I started programming, and it's still something I need to actively work on. I know why it's good, and why the common arguments against testing are bad. Still, I need to convince myself to continually test my work well.</p><p>I had to learn that it's not enough just to click through an interface, that testing isn't really testing unless it can be run automatically, that testing isn't really useful unless it happens continuously, and that testing is often very useful as part of a design phase before any implementation happens.</p><p>Here are some reasons why I believe these things. Perhaps you'll find them useful as you learn about testing or even as you try to convince people why they should plan and budget for testing.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note60"/>Note</h3><p>I can't stress enough on the importance of testing. The concepts we look at here are just the tip of the iceberg. If you really want to learn about testing and writing testable code, I highly recommend that you read <span class="emphasis"><em>Clean Code</em></span> (by Robert C. Martin).</p></div></div><div class="section" title="Design by testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec25"/>Design by testing</h2></div></div></div><p>Testing can be a <a id="id252" class="indexterm"/>powerful design tool for code as much as wireframes can be for interactive interfaces. Sometimes, it's good to make a rapid prototype of the code you think can work for you. But once you know how you want your code to behave, it's useful to write some assertions for this behavior.</p><p>Put the prototype to one side and start creating a checklist of the behavior you now know your code should have. Perhaps this is a good time to involve the product owners, as you essentially create a contract of functionality you have yet to implement.</p><p>This kind of a<a id="id253" class="indexterm"/> testing-first approach is often referred to as <span class="strong"><strong>test-driven development</strong></span> (<span class="strong"><strong>TDD</strong></span>). Tests are useful whether or not you write them first. But if you do write them first, they can help you shape the behavior of your code at a critical stage of a project.</p></div><div class="section" title="Documentation by testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec26"/>Documentation by testing</h2></div></div></div><p>Unless you have a folder <a id="id254" class="indexterm"/>of examples or extensive documentation, tests may be the only way for you to demonstrate what your code is supposed to do and how it is supposed to do it.</p><p>You (or the developers who work with your code) may know little of what your code is supposed to do, but if you write good tests, they can learn interesting things about it. Tests can reveal the parameters of functions, the ways in which functions break, and even what code is unused.</p></div><div class="section" title="Sleep by testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec27"/>Sleep by testing</h2></div></div></div><p>Few things set me on edge quite like deploying critical code changes to large production systems. Does your team follow the "never deploy on a Friday" rule? If you had a good suite of tests, you could deploy fearlessly.</p><p>Tests are an excellent <a id="id255" class="indexterm"/>way to discover regressions in code. Want to know if a change you're making will affect other parts of the application? If the application is well tested, you'll know the moment it does.</p><p>In summary, a good test suite will help you keep your code doing what it should and let you know when you've broken it. Tests are great.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note61"/>Note</h3><p>Whether you write tests before or after the rest of your application code, having any tests is usually better than having no tests. You don't have to follow TDD principles, but they<a id="id256" class="indexterm"/> have been known to improve the design of code. And grown-ups know to try broccoli before dismissing it.</p></div></div></div></div></div>
<div class="section" title="Types of tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec57"/>Types of tests</h1></div></div></div><p>Many books can (and have been) filled with the intricacies of testing. There's a lot of jargon and we could go on for <a id="id257" class="indexterm"/>quite some time. Instead, I want to focus on a handful of terms, which I think will be most useful to us. There are two common kinds of tests we can write.</p><div class="section" title="Unit tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec28"/>Unit tests</h2></div></div></div><p>Unit tests are tests that<a id="id258" class="indexterm"/> focus on one small, practical unit of work at a time. Given a<a id="id259" class="indexterm"/> non-trivial class or component, a unit test will focus on just one method or even just a single part of that method (if the method does many things).</p><p>To illustrate this, consider the following example code:</p><div class="informalexample"><pre class="programlisting">class Page extends React.Component {
    render() {
        return (
            &lt;div className="page"&gt;
                &lt;h1&gt;{this.props.title}&lt;/h1&gt;
                {this.props.content}
            &lt;/div&gt;
        );
    }
}

class Pages extends React.Component {
    render() {
        return (
            &lt;div className="pages"&gt;
                {this.getPageComponents()}
            &lt;/div&gt;
        );
    }

    getPageComponents() {
        return this.props.pages.map((page, key) =&gt; {
            return this.getPageComponent(page, key);
        });
    }

    getPageComponent(page, key) {
        return (
            &lt;li key={key}&gt;
                &lt;Page {...page} /&gt;
            &lt;/li&gt;
        );
    }
}

let pages = [
    {"title": "Home", "content": "A welcome message"},
    {"title": "Products", "content": "Some products"},
];

let component = &lt;Pages pages={pages} /&gt;;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note62"/>Note</h3><p>In previous chapters, we created a workflow for being able to run the ES6 code through Node.js. I<a id="id260" class="indexterm"/> recommend that you recreate this setup for some of the code in this chapter, or use a site such as <a class="ulink" href="http://jsbin.com/">http://jsbin.com/</a>.</p></div></div><p>A unit test for the <code class="literal">Page</code> component could be something like this: given an instance of this component, and an <a id="id261" class="indexterm"/>object with a title <code class="literal">"Home"</code> and content <code class="literal">"A welcome message"</code>, when I call something such as <code class="literal">ReactDOMServer.render</code>, I see markup containing an <code class="literal">h1</code> element with the same title and a few <code class="literal">data-reactid</code> attributes.</p><p>We test a small, practical <a id="id262" class="indexterm"/>unit of work. In this case, <code class="literal">Page</code> has a single method with a small focus. We can test the whole component at once, assured that we're testing something small and focused.</p><p>On the other hand, a unit test for <code class="literal">Pages</code> can be something like this: given an instance of this component with the <code class="literal">pages</code> property containing an array of well-formed page objects, when I call <code class="literal">getPageComponents</code>, the <code class="literal">getPageComponent</code> method is called once for each page object with the correct properties each time.</p><p>We would write separate<a id="id263" class="indexterm"/> tests for each method since they have different focuses and <a id="id264" class="indexterm"/>produce different results. We wouldn't test all of the pages together in a unit test.</p></div><div class="section" title="Functional tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec29"/>Functional tests</h2></div></div></div><p>As compared to unit tests, functional tests are less concerned with such a narrow focus. Functional tests still test more areas, but they don't require as much unit isolation as unit tests. We can test the <a id="id265" class="indexterm"/>whole <code class="literal">Pages</code> component in a single functional test, perhaps, as follows: given an instance of this component with the <code class="literal">pages</code> property containing an array of well-formed page objects, when I call something such as <code class="literal">ReactDOMServer.render</code>, I see markup containing all pages and their correct properties.</p><p>We can test a lot<a id="id266" class="indexterm"/> more in a shorter period of time using functional tests. The downside to this is that the causes of errors are harder to pinpoint. Unit tests immediately point to the causes of smaller errors, while functional tests often only show that the group of functionality isn't working as expected.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note63"/>Note</h3><p>All of this is to say—the more accurately and granularly you test your code, the easier it will be to pinpoint the causes of errors. You can write a single functional test or 20 unit tests for the same code. So you need to balance the available time with the importance of detailed testing.</p></div></div></div></div>
<div class="section" title="Testing with assertions"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec58"/>Testing with assertions</h1></div></div></div><p>Assertions are the <a id="id267" class="indexterm"/>spoken/written language constructs made in the code. They look and function similar to how I've been speaking about them. In fact, most tests are <a id="id268" class="indexterm"/>structured in the same way we've been describing tests:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Given some pre-conditions</li><li class="listitem" style="list-style-type: disc">When something happens</li><li class="listitem" style="list-style-type: disc">We see some post-conditions</li></ul></div><p>The first two points happen as we create objects and components and call their various methods. Assertions happen in the third point. Node.js ships with a few basic assertion methods, which we can use to write our first tests:</p><div class="informalexample"><pre class="programlisting">import assert from "assert";

<span class="strong"><strong>assert(</strong></span>
    <span class="strong"><strong>rendered.match(/&lt;h1 data-reactid=".*"&gt;Home&lt;\/h1&gt;/g)</strong></span>
<span class="strong"><strong>);</strong></span>
</pre></div><p>There are quite a<a id="id269" class="indexterm"/> few assertion methods we can use:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">assert(condition), assert.ok(condition)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assert.equal(actual, expected)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assert.notEqual(actual, expected)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assert.strictEqual(actual, expected)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assert.notStrictEqual(actual, expected)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assert.deepEqual(actual, expected)</code>…</li><li class="listitem" style="list-style-type: disc"><code class="literal">assert.notDeepStrictEqual(actual, expected)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">assert.throws(function, type)</code></li></ul></div><p>You can add an <a id="id270" class="indexterm"/>optional custom message string to the parameters for any of these methods. The custom message will be displayed in place of the default error messages for each of these.</p><p>We can write these quite simply—creating a <code class="literal">tests.js</code> file, importing classes and components, and making assertions against their methods and markup.</p><p>If you prefer a more expressive syntax, consider installing the <code class="literal">assertthat</code> library:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save-dev assertthat</strong></span>
</pre></div><p>You can then write tests similar to the following:</p><div class="informalexample"><pre class="programlisting">import assert from "assertthat";

<span class="strong"><strong>assert.that(actual).is.equals.to(expected);</strong></span>
<span class="strong"><strong>assert.that(actual).is.between(expectedLow, expectedHigh);</strong></span>
<span class="strong"><strong>assert.that(actual).is.not.undefined();</strong></span>
</pre></div><p>The example code for this chapter includes tests that you can inspect and run. I've also created a BabelJS-powered way to use ES6 and JSX in the tests. You can run the tests with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm test</strong></span>
</pre></div><p>This runs the NPM script defined as follows:</p><div class="informalexample"><pre class="programlisting">"scripts": {
  <span class="strong"><strong>"test": "node_modules/.bin/babel-node index.js"</strong></span>
}</pre></div><p>Don't be alarmed if you <a id="id271" class="indexterm"/>see nothing after running that. The tests are set<a id="id272" class="indexterm"/> up in such a way that you'll only see errors if the tests fail. If you see no errors, everything is OK!</p><div class="section" title="Testing for immutability and idempotence"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec30"/>Testing for immutability and idempotence</h2></div></div></div><p>When we <a id="id273" class="indexterm"/>looked at Flux and Redux, one of the interesting things we saw is<a id="id274" class="indexterm"/> that they recommend immutable types and idempotent functionality (like in reducers). If we were to test for these qualities, we can! Let's install a helper library:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install --save-dev deep-freeze</strong></span>
</pre></div><p>Then, let's consider the following example:</p><div class="informalexample"><pre class="programlisting">import { createStore } from "redux";

const defaultState = {
    "pages": [],
};

const reducer = (state = defaultState, action) =&gt; {
    if (action.type === "ADD_PAGE") {
        state.pages.push(action.payload);
    }

    return state;
};

let store = createStore(reducer);

store.dispatch({
    "type": "ADD_PAGE",
    "payload": {
        "title": "Home",
        "content": "A welcome message",
    },
});

let state = store.getState();

<span class="strong"><strong>assert(</strong></span>
    <span class="strong"><strong>state.pages.filter(page =&gt; page.title == "Home").length &gt; 0</strong></span>
<span class="strong"><strong>);</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note64"/>Note</h3><p>If this is unfamiliar to you, refer back to the chapter on design patterns (<a class="link" href="ch08.html" title="Chapter 8. React Design Patterns">Chapter 8</a>, <span class="emphasis"><em>React Design Patterns</em></span>).</p></div></div><p>Here, we have an<a id="id275" class="indexterm"/> example reducer, store, and assertion. The reducer handles a single action—adding new pages. When we dispatch an <code class="literal">ADD_PAGE</code> action to the store, the<a id="id276" class="indexterm"/> reducer adds a new page to the <code class="literal">pages</code> state array. This reducer is not idempotent—it cannot be run with the same input and always produce the same output.</p><p>We can see this by freezing the default state:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import freeze from "deep-freeze";</strong></span>

const defaultState = <span class="strong"><strong>freeze({</strong></span>
    "pages": [],
<span class="strong"><strong>});</strong></span>
</pre></div><p>When we run this, we should see an error such as <code class="literal">Can't add property 0, object is not extensible</code>. Remember that we can fix this problem by returning a new, modified state object from our reducer:</p><div class="informalexample"><pre class="programlisting">const reducer = (state = defaultState, action) =&gt; {
    if (action.type === "ADD_PAGE") {
        <span class="strong"><strong>let pages = state.pages;</strong></span>

        <span class="strong"><strong>pages = [</strong></span>
            <span class="strong"><strong>...pages,</strong></span>
            <span class="strong"><strong>action.payload,</strong></span>
        <span class="strong"><strong>];</strong></span>
    }

    <span class="strong"><strong>return {</strong></span>
        <span class="strong"><strong>"pages": pages,</strong></span>
    <span class="strong"><strong>};</strong></span>
};</pre></div><p>Now, we can dispatch the same actions and always get the same results. We're no longer modifying the state in-place, but rather returning a new, modified state. The particulars of idempotence and<a id="id277" class="indexterm"/> immutability are better explained elsewhere; but the important thing to note is how we test<a id="id278" class="indexterm"/> for idempotence.</p><p>We can freeze the objects/arrays we want to remain idempotent and be assured that we're not modifying the things we don't want to modify.</p></div><div class="section" title="Connecting to Travis"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec31"/>Connecting to Travis</h2></div></div></div><p>Having tests is a <a id="id279" class="indexterm"/>great first step toward better code, but it's also important to run them often. There are many ways to do this (such as Git hooks or build steps), but the way I prefer is to connect my projects to <span class="emphasis"><em>Travis</em></span>.</p><p>Travis is a continuous<a id="id280" class="indexterm"/> integration service, meaning that Travis watches for<a id="id281" class="indexterm"/> changes in a GitHub repository (<a class="ulink" href="https://github.com">https://github.com</a>) and triggers tests for those changes.</p><div class="mediaobject"><img src="graphics/5268_10_01.jpg" alt="Connecting to Travis"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note65"/>Note</h3><p>We will look at how to <a id="id282" class="indexterm"/>connect Travis to a GitHub repository, which means<a id="id283" class="indexterm"/> we need a GitHub repository already set up. I will not go into detail about how to use GitHub, but you can find an excellent tutorial at <a class="ulink" href="https://guides.github.com/activities/hello-world">https://guides.github.com/activities/hello-world</a>.</p></div></div><p>You can sign in to <a id="id284" class="indexterm"/>Travis by logging into your GitHub account and clicking on one of the <span class="strong"><strong>Sign in with GitHub</strong></span> buttons. Hover over your profile and click on <span class="strong"><strong>Accounts</strong></span>:</p><div class="mediaobject"><img src="graphics/5268_10_02.jpg" alt="Connecting to Travis"/></div><p>Enable the<a id="id285" class="indexterm"/> repositories you would like Travis to check. In addition, you need to create a configuration file called <code class="literal">.travis.yml</code>:</p><div class="informalexample"><pre class="programlisting">language: node_js

node_js:
  - "5.5"</pre></div><p>This tells Travis to test<a id="id286" class="indexterm"/> this project as a Node.js project and to test it against version 5.5. By default, Travis will run <code class="literal">npm install</code> before any tests. It will also run <code class="literal">npm test</code> to run the actual tests. We can enable this command by adding the following to <code class="literal">package.json</code>:</p><div class="informalexample"><pre class="programlisting">"scripts": {
  "test": "node run.js"
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note66"/>Note</h3><p>If you've put your tests in another file, you'll need to adjust that command to reflect what you type to run your tests. It's nothing more than a common alias.</p></div></div><p>After you commit <a id="id287" class="indexterm"/>code to your repository, Travis should test that code for you.</p><div class="mediaobject"><img src="graphics/5268_10_03.jpg" alt="Connecting to Travis"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note67"/>Note</h3><p>You<a id="id288" class="indexterm"/> can learn more<a id="id289" class="indexterm"/> about Travis at <a class="ulink" href="https://docs.travis-ci.com/user/for-beginners">https://docs.travis-ci.com/user/for-beginners</a>.</p></div></div></div><div class="section" title="End-to-end testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec32"/>End-to-end testing</h2></div></div></div><p>You may also want to try testing your application as a normal user would. You already do this as you click through the application you're developing to check whether things you just typed work as you expect. Why not automate the process?</p><p>There are quite a few<a id="id290" class="indexterm"/> tools for this. The one I've enjoyed using is called <span class="emphasis"><em>Protractor</em></span>. It can be a little tricky to set up, but there's an excellent tutorial on the <a id="id291" class="indexterm"/>subject at <a class="ulink" href="http://www.joelotter.com/2015/04/18/protractor-reactjs.html">http://www.joelotter.com/2015/04/18/protractor-reactjs.html</a>.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec59"/>Summary</h1></div></div></div><p>In this chapter, you learned about the benefits of writing tests and running them often. We created a few tests for our classes and components and made assertions about their behavior.</p><p>We've now covered all the topics I want to share with you. Hopefully, they've given you all the tools to start creating interfaces with confidence. We've learned so much together; covering topics such as single component designs and states, how components talk to each other (through things such as context), how to structure and decorate the whole system, and even how to test it.</p><p>The React community is just beginning, and you can join it and influence it. All it will take is for you to spend a bit of time building things with React and talking to others about your experiences doing so.</p></div></body></html>