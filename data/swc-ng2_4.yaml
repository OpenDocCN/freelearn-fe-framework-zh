- en: Chapter 4. Getting Started with Angular 2 Components and Directives
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。开始使用Angular 2组件和指令
- en: By this point, you're already familiar with the core building blocks that Angular
    2 provides for the development of single-page applications and the relations between
    them. However, we've touched only the surface by introducing the general idea
    behind Angular's concepts and the basic syntax used for their definition. In this
    chapter, we'll take a deep dive into Angular 2's components and directives.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经熟悉了Angular 2为单页应用程序开发提供的核心构建块以及它们之间的关系。然而，我们只是介绍了Angular概念背后的一般思想和用于定义它们的基本语法。在本章中，我们将深入研究Angular
    2的组件和指令。
- en: 'In the following sections, we will cover these topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将涵盖以下主题：
- en: Enforced separation of concerns of the building blocks that Angular 2 provides
    for developing applications.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制分离Angular 2为开发应用程序提供的构建块的关注点。
- en: The appropriate use of directives or components when interacting with the DOM.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与DOM交互时指令或组件的适当使用。
- en: Built-in directives and developing custom ones.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置指令和开发自定义指令。
- en: An in-depth look at components and their templates.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解组件及其模板。
- en: Content projection.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容投影。
- en: View children versus content children.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图子代与内容子代。
- en: The component's life cycle.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件的生命周期。
- en: Using template references.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板引用。
- en: Configuring Angular's change detection.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Angular的变更检测。
- en: The Hello world! application in Angular 2
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 2中的Hello world！应用程序
- en: 'Now, let''s build our first "Hello world!" app in Angular 2! In order to get
    everything up and running as easy and quickly as possible, for our first application,
    we will use the ECMAScript 5 syntax with the transpiled bundle of Angular 2\.
    First, create the `index.html` file with the following content:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在Angular 2中构建我们的第一个“Hello world！”应用程序！为了尽可能轻松快速地启动和运行一切，对于我们的第一个应用程序，我们将使用ECMAScript
    5语法与Angular 2的转译捆绑包。首先，创建带有以下内容的`index.html`文件：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding HTML file defines the basic structure of our page. Just before
    closing the `body` tag, we have references to four script files: the `polyfills`
    required by the framework (including ES2015 `shim`, `zone.js`, and others), `RxJS`,
    the ES5 bundle of Angular 2, and the file that contains the application we''re
    going to build.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的HTML文件定义了我们页面的基本结构。在关闭`body`标签之前，我们引用了四个脚本文件：框架所需的`polyfills`（包括ES2015 `shim`，`zone.js`等），`RxJS`，Angular
    2的ES5捆绑包，以及包含我们将要构建的应用程序的文件。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`RxJS` is used by Angular''s core in order to allow us to empower the reactive
    programming paradigm in our applications. In the following content, we will take
    only a shallow look at how we can take advantage of observables. For further information,
    you can visit the `RxJS` GitHub repository at [https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`RxJS`被Angular的核心使用，以便让我们在应用程序中实现响应式编程范式。在接下来的内容中，我们将浅显地了解如何利用可观察对象。有关更多信息，您可以访问`RxJS`的GitHub存储库[https://github.com/Reactive-Extensions/RxJS](https://github.com/Reactive-Extensions/RxJS)。'
- en: 'In the same directory where your `index.html` resides, create a file called
    `app.js` and enter the following content inside it:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`index.html`所在的同一目录中，创建一个名为`app.js`的文件，并在其中输入以下内容：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding snippet, we define a component called `App` with an `app`
    selector. This selector will match all the app elements inside our templates that
    are in the scope of the application. The component has the following template:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们定义了一个名为`App`的组件，带有一个`app`选择器。此选择器将匹配应用程序范围内模板中的所有应用程序元素。组件具有以下模板：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This syntax should already be familiar to you from AngularJS 1.x. When compiled
    in the context of the given component, the preceding snippet will interpolate
    the template with the result of the expression inside the curly brackets. In our
    case, the expression is simply the `target` variable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法在 AngularJS 1.x 中应该已经很熟悉了。在给定组件的上下文中编译时，前面的片段将使用花括号内表达式的结果插值模板。在我们的例子中，表达式只是
    `target` 变量。
- en: To `Class`, we pass an object literal, which has a single method called `constructor`.
    This DSL provides an alternative way to define classes in ECMAScript 5\. In the
    body of the `constructor` function, we add a property called `target` with a value
    of the `"world"` string. In the last line of the snippet, we invoke the `bootstrap`
    method in order to initialize our application with `App` as a root component.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Class`，我们传递了一个对象字面量，其中包含一个名为 `constructor` 的方法。这个 DSL 提供了在 ECMAScript 5
    中定义类的另一种方式。在 `constructor` 函数的主体中，我们添加了一个名为 `target` 的属性，其值为字符串 `"world"`。在片段的最后一行，我们调用
    `bootstrap` 方法来使用 `App` 作为根组件初始化我们的应用程序。
- en: Note that `bootstrap` is located under `ng.platform.browser`. This is due to
    the fact that the framework is built for different platforms in mind, such as
    a browser, NativeScript, and so on. By placing the `bootstrap` methods used by
    the different platforms under a separate namespace, Angular 2 can implement different
    logic to initialize the application and also include different sets of providers
    and directives that are platform specific.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`bootstrap` 位于 `ng.platform.browser` 下。这是因为该框架是针对不同平台构建的，比如浏览器、NativeScript
    等。通过将不同平台使用的 `bootstrap` 方法放在单独的命名空间下，Angular 2 可以实现不同的逻辑来初始化应用程序，并包含特定于平台的不同提供者和指令集。
- en: 'Now, if you open `index.html` with your browser, you should see some errors,
    as shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您用浏览器打开 `index.html`，您应该会看到一些错误，如下面的截图所示：
- en: '![The Hello world! application in Angular 2](../images/00010.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Angular 2 中的 Hello world! 应用程序](../images/00010.jpeg)'
- en: 'This happened because we missed something quite important. We didn''t use the
    root component anywhere inside `index.html`. In order to finish the application,
    add the following HTML element after the open tag of the body element:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们错过了一些非常重要的东西。我们没有在 `index.html` 中的任何地方使用根组件。为了完成应用程序，在 body 元素的开放标签之后添加以下
    HTML 元素：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, you can refresh your browser to see the following result:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以刷新浏览器以查看以下结果：
- en: '![The Hello world! application in Angular 2](../images/00011.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Angular 2 中的 Hello world! 应用程序](../images/00011.jpeg)'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Using TypeScript**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 TypeScript**'
- en: Although we already have an Angular 2 application running, we can do much better!
    We didn't use any package manager or module loader. We spent all of [Chapter 3](part0027_split_000.html#PNV61-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 3. TypeScript Crash Course"), *TypeScript Crash Course*, talking about
    TypeScript; however, we didn't write a single line of it in the preceding application.
    Although it is not required that you use TypeScript with Angular 2, it's much
    convenient to take advantage of all the bonuses that static typing provides.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经运行了一个 Angular 2 应用程序，但我们可以做得更好！我们没有使用任何包管理器或模块加载器。在 [第 3 章](part0027_split_000.html#PNV61-a118c4c18dd64e8ab73e171b466b6582
    "第 3 章. TypeScript Crash Course") 中，*TypeScript Crash Course*，我们讨论了 TypeScript；然而，在前面的应用程序中我们没有写一行
    TypeScript 代码。虽然不要求您在 Angular 2 中使用 TypeScript，但利用静态类型提供的所有奖励会更方便。
- en: Setting up our environment
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的环境
- en: The core team of Angular developed a brand new CLI tool for Angular 2, which
    allows us to `bootstrap` our applications with a few commands. Although we are
    going to introduce it in the last chapter, by then, in order to boost our learning
    experience, we are going to use the code located at [https://github.com/mgechev/switching-to-angular2](https://github.com/mgechev/switching-to-angular2).
    It includes all the examples in this book and allows us to quickly `bootstrap`
    our Angular 2 application (you can know more on how to quickly start developing
    web applications with Angular 2 in [Chapter 5](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 5. Dependency Injection in Angular 2"), *Dependency Injection in Angular
    2.*). It has all the required dependencies declared in `package.json`, the definition
    of basic gulp tasks, such as the development server, the transpilation of your
    TypeScript code to ECMAScript 5, live-reload, and so on. Our upcoming examples
    are going to be based on it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的核心团队为Angular 2开发了一个全新的CLI工具，允许我们通过几个命令来“引导”我们的应用程序。尽管我们将在最后一章介绍它，但为了加快我们的学习体验，我们将使用位于[https://github.com/mgechev/switching-to-angular2](https://github.com/mgechev/switching-to-angular2)的代码。它包括本书中的所有示例，并允许我们快速“引导”我们的Angular
    2应用程序（您可以在[第5章](part0056_split_000.html#1LCVG1-a118c4c18dd64e8ab73e171b466b6582
    "第5章。Angular 2中的依赖注入")中了解如何快速开始使用Angular 2开发Web应用程序，*Angular 2中的依赖注入*）。它在`package.json`中声明了所有必需的依赖项，定义了基本的gulp任务，如开发服务器、将您的TypeScript代码转译为ECMAScript
    5、实时重新加载等。我们即将介绍的示例将基于它。
- en: In order to set up the `switching-to-angular2` project, you'll need Git, Node.js
    v5.x.x, and npm up and running on your computer. If you have a different version
    of the Node.js installed, I recommend that you take a look at nvm (the Node.js
    version manager, which is available at [https://www.npmjs.com/package/nvm](https://www.npmjs.com/package/nvm))
    or n ([https://www.npmjs.com/package/n](https://www.npmjs.com/package/n)). Using
    these tools, you'll be able to have multiple versions of Node.js on your machine
    and switch between them with a single command via the command line.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置`switching-to-angular2`项目，您需要在计算机上安装Git、Node.js v5.x.x和npm。如果您安装了不同版本的Node.js，我建议您查看nvm（Node.js版本管理器，可在[https://www.npmjs.com/package/nvm](https://www.npmjs.com/package/nvm)上找到）或n（[https://www.npmjs.com/package/n](https://www.npmjs.com/package/n)）。使用这些工具，您可以在计算机上拥有多个Node.js版本，并通过命令行轻松切换它们。
- en: Installing our project repository
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装我们的项目存储库
- en: 'Let''s start by setting up the `switching-to-angular2` project. Open your terminal
    and enter the following commands:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置`switching-to-angular2`项目开始。打开您的终端并输入以下命令：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first line will clone the `switching-to-angular2` project into a directory
    called `switching-to-angular2`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将把`switching-to-angular2`项目克隆到一个名为`switching-to-angular2`的目录中。
- en: The last step before being able to run the seed project is to install all the
    required dependencies using npm. This step may take a while depending on your
    Internet connection, so be patient and do not interrupt it. If you encounter any
    problems, do not hesitate to raise the issues at [https://github.com/mgechev/switching-to-angular2/issues](https://github.com/mgechev/switching-to-angular2/issues).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够运行种子项目之前的最后一步是使用npm安装所有必需的依赖项。这一步可能需要一些时间，取决于您的互联网连接速度，所以请耐心等待，不要中断它。如果遇到任何问题，请毫不犹豫地在[https://github.com/mgechev/switching-to-angular2/issues](https://github.com/mgechev/switching-to-angular2/issues)上提出问题。
- en: 'The last step left is to start the development server:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是启动开发服务器：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the process of the transpilation is completed, your browser will automatically
    open with this URL: `http://localhost:5555/dist/dev`. You should now see a view
    similar to what is shown in the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当转译过程完成时，您的浏览器将自动打开此URL：`http://localhost:5555/dist/dev`。现在，您应该看到与以下截图中显示的类似的视图：
- en: '![Installing our project repository](../images/00012.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![安装我们的项目存储库](../images/00012.jpeg)'
- en: Playing with Angular 2 and TypeScript
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转Angular 2和TypeScript
- en: 'Now, let''s play around with the files we already have! Navigate to the `app/ch4/ts/hello-world`
    directory inside `switching-to-angular2`. Then, open `app.ts` and replace its
    content with the following snippet:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们玩弄一下我们已经拥有的文件！转到`switching-to-angular2`内的`app/ch4/ts/hello-world`目录。然后，打开`app.ts`并用以下片段替换其内容：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s take a look at the code line by line:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看代码：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Initially, we import the `@Component` decorator from the `angular2/core` module
    and the `bootstrap` function from `angular2/platform/browser`. Later, we use `@Component`
    to decorate the `App` class. To the `@Component` decorator, we pass almost the
    same object literal that we used in the ECMAScript 5 version of the application,
    and this way, we define the CSS selector for the component.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们从`angular2/core`模块中导入`@Component`装饰器和从`angular2/platform/browser`中导入`bootstrap`函数。稍后，我们使用`@Component`来装饰`App`类。对于`@Component`装饰器，我们传递了几乎与应用程序的ECMAScript
    5版本中使用的相同的对象文字，通过这种方式，我们定义了组件的CSS选择器。
- en: As a next step, we define the view of the component. However, note that in this
    case, we use `templateUrl` instead of simply inlining the component's template.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，我们定义组件的视图。但是，请注意，在这种情况下，我们使用`templateUrl`而不是简单地内联组件的模板。
- en: Open `app.html` and replace the file's content with `<h1>Hello {{target}}!</h1>`.
    The content of `app.html` should be the same as the inlined template we used previously.
    Since we can use a template by both inlining it (with `template`) and setting
    its URL (`templateUrl`), the component's API is quite similar to the AngularJS
    1.x directives API.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app.html`，并用`<h1>Hello {{target}}!</h1>`替换文件的内容。`app.html`的内容应与我们先前使用的内联模板相同。由于我们可以通过内联（使用`template`）和设置其URL（`templateUrl`）来使用模板，因此组件的API与AngularJS
    1.x指令API非常相似。
- en: In the last line of the snippet, we `bootstrap` the application by providing
    the root component.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段的最后一行，我们通过提供根组件来`bootstrap`应用程序。
- en: Digging into the index
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入了解索引
- en: 'Now, let''s take a look at `index.html` in order to get a sense of what goes
    on when we start the application:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`index.html`，以便了解启动应用程序时发生了什么：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that inside the body of the page, we use the `app` element with the content
    of the text node, `"Loading…"`, inside. The `"Loading…"` label will be visible
    until the application gets bootstrapped and the main component gets rendered.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在页面的主体中，我们使用`app`元素，并在其中使用文本节点的内容`"Loading…"`。`"Loading…"`标签将在应用程序启动并渲染主组件之前可见。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are template placeholders `<%= INIT %> and <-- inject:js…` that inject
    content that is specific to individual demos. They are not Angular specific but
    instead aim to prevent code duplications in the code samples attached to the book
    because of the shared structure between them. In order to see how this specific
    HTML file has been transformed, open `/dist/dev/ch4/ts/hello-world/index.html`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有模板占位符`<%= INIT %>和<!-- inject:js…`，它们注入了特定于各个演示的内容。它们不是Angular特定的，而是旨在防止由于它们之间的共享结构而在附有书籍的代码示例中重复代码。为了查看此特定HTML文件已被转换的方式，请打开`/dist/dev/ch4/ts/hello-world/index.html`。
- en: Using Angular 2 directives
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular 2指令
- en: We already built our simple "Hello world!" app. Now, let's start building something
    that is closer to a real-life application. By the end of this section, we'll have
    a simple application that lists a number of items we need to do and greets us
    at the header of the page.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了简单的“Hello world!”应用程序。现在，让我们开始构建更接近真实应用程序的东西。在本节结束时，我们将拥有一个简单的应用程序，列出我们需要做的一些项目，并在页面的标题处向我们问候。
- en: 'Let''s start by developing our `app` component. The two modifications from
    the previous example that we need to make are to rename the `target` property
    to `name` and add a list of `todos` to the component''s controller definition:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从开发我们的`app`组件开始。我们需要对上一个示例进行两个修改，将`target`属性重命名为`name`，并在组件的控制器定义中添加一个`todos`列表：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The only thing left is to change the template in order to consume the provided
    data. We're already familiar with the `ng-repeat` directive from AngularJS 1.x.
    It allows us to loop a list of items using a microsyntax, which is later interpreted
    by AngularJS 1.x. However, the directive doesn't carry enough semantics, so it
    is hard to build tools that perform static code analysis and help us improve our
    development experience. Since the `ng-repeat` directive is quite useful, Angular
    2 took the idea and improved it further in order to allow more sophisticated tooling
    by introducing further semantics on top of it. It allows better static code analysis
    to be performed by IDEs and text editors. Such support will prevent us from making
    typos in the code we write and allow us to have smoother development experience.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的事情就是改变模板以消耗提供的数据。我们已经熟悉了AngularJS 1.x中的`ng-repeat`指令。它允许我们使用微语法循环列表项，稍后由AngularJS
    1.x解释。然而，该指令没有足够的语义，因此很难构建执行静态代码分析并帮助我们改进开发体验的工具。由于`ng-repeat`指令非常有用，Angular 2进一步改进了这个想法，以允许更复杂的工具通过引入更多的语义来进行更好的静态代码分析。这种支持将防止我们在编写代码时出现拼写错误，并允许我们拥有更流畅的开发体验。
- en: 'In `app.html`, add the following content:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.html`中，添加以下内容：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `template` element is a place where we can hold markup and make sure that
    it won't be rendered by the browser. This is quite useful if we need to embed
    the templates of our application directly into the markup of the page and let
    the template engine we're using to process them later. In the current example,
    this means that if the Angular 2 DOM compiler doesn't process the DOM tree, all
    we're going to see on the screen are the `h1`, `p` elements and the `ul` element
    without any list items.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`template`元素是一个我们可以放置标记的地方，并确保它不会被浏览器渲染。如果我们需要直接嵌入应用程序模板到页面标记中，并让我们使用的模板引擎稍后处理它们，这是非常有用的。在当前的例子中，这意味着如果Angular
    2 DOM编译器不处理DOM树，我们在屏幕上看到的只有`h1`、`p`元素和`ul`元素，没有任何列表项。'
- en: 'Now, after you refresh your browser, you should see the following result:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在刷新浏览器后，您应该看到以下结果：
- en: '![Using Angular 2 directives](../images/00013.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![使用Angular 2指令](../images/00013.jpeg)'
- en: So far, so good! The only new things left in the preceding snippets are the
    attributes of the `template` element that we're not familiar with, such as `ngFor`,
    `var-todo`, and `[ngForOf]`. Let's take a look at them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好！在前面的片段中，唯一剩下的新事物是我们不熟悉的`template`元素的属性，如`ngFor`、`var-todo`和`[ngForOf]`。让我们来看看它们。
- en: The ngFor directive
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ngFor指令
- en: The `ngFor` directive is a directive that allows us to loop over a collection
    of items and does exactly what `ng-repeat` does in AngularJS 1.x, but it brings
    some extra semantics. Note that the `ngForOf` attribute is surrounded by brackets.
    At first, these brackets might seem like invalid HTML. However, according to the
    HTML specification, their use is permitted in attribute names. The only thing
    the W3C validator is going to complain about is the fact that the `template` element
    doesn't own such attributes; however, browsers won't have problems processing
    the markup.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor` 指令是一个允许我们循环遍历项目集合的指令，它与 AngularJS 1.x 中的 `ng-repeat` 做的事情完全一样，但它带来了一些额外的语义。请注意，`ngForOf`
    属性被括号括起来。起初，这些括号可能看起来像无效的 HTML。然而，根据 HTML 规范，它们在属性名称中是允许使用的。唯一会引起 W3C 验证器抱怨的是
    `template` 元素不拥有这样的属性；然而，浏览器不会在处理标记时出现问题。'
- en: The semantics behind these brackets is that the value of the attribute surrounded
    by them is an expression, which needs to be evaluated.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些括号背后的语义是，它们括起来的属性的值是一个表达式，需要进行评估。
- en: Improved semantics of the directives syntax
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令语法的改进语义
- en: 'In [Chapter 1](part0015_split_000.html#E9OE1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 1. Getting Started with Angular 2"), *Getting Started with Angular 2*,
    we mentioned the opportunity for improved tooling in Angular 2\. A big issue in
    AngularJS 1.x is the different ways in which we can use directives. This requires
    an understanding of the attribute values, which can be literals, expressions,
    callbacks, or a microsyntax. Angular 2 eliminates this problem by introducing
    a few simple conventions that are built into the framework:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0015_split_000.html#E9OE1-a118c4c18dd64e8ab73e171b466b6582 "第1章。开始使用
    Angular 2")中，*开始使用 Angular 2*，我们提到了 Angular 2 中改进工具的机会。在 AngularJS 1.x 中存在的一个大问题是我们可以使用指令的不同方式。这需要理解属性值，它可以是文字，表达式，回调或微语法。Angular
    2 通过引入一些内置到框架中的简单约定来消除这个问题：
- en: '`propertyName="value"`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`propertyName="value"`'
- en: '`[propertyName]="expression"`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[propertyName]="expression"`'
- en: '`(eventName)="handler()"`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(eventName)="handler()"`'
- en: In the first line, the `propertyName` attribute accepts a string literal as
    a value. Angular will not process the attribute's value any further; it will use
    it the way it is set in the template.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，`propertyName` 属性接受一个字符串文字作为值。Angular 不会进一步处理属性的值；它将使用模板中设置的方式。
- en: The second syntax, `[propertyName]="expression"`, gives a hint to Angular 2
    that the value of the attributes should be handled as an expression. When Angular
    2 finds an attribute surrounded by brackets, it will interpret the expression
    in the context of the component associated to the template. In short, if we want
    to set a non-string value or result of an expression as value of given property
    we need to use this syntax.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种语法 `[propertyName]="expression"` 给 Angular 2 提供了一个提示，即属性的值应该被处理为表达式。当 Angular
    2 发现一个被括号括起来的属性时，它将在与模板相关联的组件的上下文中解释表达式。简而言之，如果我们想要将非字符串值或表达式的结果作为给定属性的值设置，我们需要使用这种语法。
- en: The last example shows how we can bind to events. The semantics behind `(eventName)="handler()"`
    is that we want to handle all events called `eventName` that are triggered by
    the given component with the `handler()` expression.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子展示了我们如何绑定事件。 `(eventName)="handler()"` 背后的语义是，我们想要处理由给定组件触发的名为 `eventName`
    的所有事件，并使用 `handler()` 表达式。
- en: We're going to discuss more examples later in this chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论更多例子。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Angular provides alternative canonical syntax, which allows us to define the
    bindings of the elements without using brackets. For instance, the property binding
    can be expressed using the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供了另一种规范的替代语法，允许我们定义元素的绑定而不使用括号。例如，可以使用以下代码表示属性绑定：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It can also be expressed using this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以用这种方式表达：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Similarly, we can express the event bindings with the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以用以下代码表达事件绑定：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'They can also be expressed using this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以用这种方式表达：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Declaring variables inside a template
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模板中声明变量
- en: The last thing left from the preceding template is the `var-todo` attribute.
    What we are telling Angular using this syntax is that we want to declare a new
    variable called `todo` and bind it to the individual items from the collection
    we get from the evaluation of the expression set as a value of `[ngForOf]`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的模板中剩下的最后一件事是`var-todo`属性。使用这种语法告诉Angular的是，我们想要声明一个名为`todo`的新变量，并将其绑定到从评估设置为`[ngForOf]`值的表达式的个别项目。
- en: Using syntax sugar in templates
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模板中使用语法糖
- en: Although the template syntax is awesome and provides much more meaning of the
    code to the IDEs or text editors we use, it is quite verbose. Angular 2 provides
    an alternative syntax, which will be desugared to the one shown in the preceding.
    Instead of using `var-todo`, for example, we can use `#todo`, which has the same
    semantics.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管模板语法很棒，并且为我们使用的IDE或文本编辑器提供了更多的代码含义，但它相当冗长。Angular 2提供了一种替代语法，它将被解糖为前面显示的语法。例如，我们可以使用`#todo`来代替`var-todo`，它具有相同的语义。
- en: 'There are a few Angular 2 directives that require the usage of a template element,
    for example, `ngForOf`, `ngIf`, and `ngSwitch`. Since such directives are used
    often, there''s an alternative syntax for them. Instead of typing down the entire
    template element explicitly, we can simply prefix the directive with `*`. This
    will allow us to turn our `ngForOf` directive syntax usage into the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些Angular 2指令需要使用模板元素，例如`ngForOf`，`ngIf`和`ngSwitch`。由于这些指令经常被使用，因此有一种替代语法。我们可以简单地在指令前加上`*`，而不是明确地输入整个模板元素。这将允许我们将`ngForOf`指令语法的使用转换为以下形式：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Later, this template will be desugared by Angular 2 to the more verbose syntax
    described earlier. Since the less verbose syntax is easier to read and write,
    its use is considered as best practice.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，此模板将被Angular 2解糖为之前描述的更冗长的语法。由于较少冗长的语法更容易阅读和编写，因此其使用被视为最佳实践。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `*` character allows you to remove the `template` element and put the directive
    directly on the root of the `template` element (in the preceding example, the
    list item, `li`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`字符允许您删除`template`元素，并直接将指令放在`template`元素的根上（在前面的示例中，列表项`li`）。'
- en: Defining Angular 2 directives
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义Angular 2指令
- en: Now that we've built a simple Angular 2 component, let's continue our journey
    by understanding the Angular 2 directives.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了一个简单的Angular 2组件，让我们继续通过理解Angular 2指令来继续我们的旅程。
- en: Using Angular 2 directives, we can apply different behavioral or structural
    changes over the DOM. In this example, we're going to build a simple tooltip directive.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular 2指令，我们可以在DOM上应用不同的行为或结构变化。在这个例子中，我们将构建一个简单的工具提示指令。
- en: In contrast to components, directives do not have views and templates, respectively.
    Another core difference between these two concepts is that the given HTML element
    may have only a single component but multiple directives on it. In other words,
    directives augment the elements compared to components that are the actual elements
    in our views.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与组件相比，指令没有视图和模板。这两个概念之间的另一个核心区别是，给定的HTML元素可能只有一个组件，但可以有多个指令。换句话说，指令增强了元素，而组件是视图中的实际元素。
- en: 'Angular''s core team''s recommendation is to use directives as attributes,
    prefixed with a namespace. Keeping this in mind, we will use the tooltip directive
    in the following way:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Angular核心团队的建议是将指令作为带有命名空间前缀的属性使用。记住这一点，我们将以以下方式使用工具提示指令：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding snippet, we use the tooltip directive over the `div` element.
    As a namespace, its selector uses the `sa` string.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，我们在`div`元素上使用了tooltip指令。作为命名空间，它的选择器使用了`sa`字符串。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For simplicity, in the rest of the book we may not prefix all the selectors
    of our components and directives. However, for production applications following
    best practices is essential. You can find an Angular 2 style guide which points
    out such practices at [https://github.com/mgechev/angular2-style-guide](https://github.com/mgechev/angular2-style-guide).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，在本书的其余部分中，我们可能不会给我们的组件和指令的所有选择器加前缀。然而，对于生产应用程序来说，遵循最佳实践是必不可少的。您可以在[https://github.com/mgechev/angular2-style-guide](https://github.com/mgechev/angular2-style-guide)找到一个指出这些实践的Angular
    2风格指南。
- en: 'Before implementing our tooltip, we need to import a couple of things from
    `angular2/core`. Open a new TypeScript file called `app.ts` and enter the following
    content; we''ll fill the placeholders later:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现我们的tooltip之前，我们需要从`angular2/core`中导入一些东西。打开一个名为`app.ts`的新的TypeScript文件，并输入以下内容；稍后我们将填写占位符：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding line, we import the following definitions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的行中，我们导入了以下定义：
- en: '`ElementRef`: This allows us to inject the element reference (we''re not limited
    to the DOM only) to the host element. In the sample usage of the preceding tooltip,
    we get an Angular wrapper of the `div` element, which holds the tooltip attribute.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ElementRef`：这允许我们将元素引用（我们不仅限于DOM）注入到宿主元素中。在上面tooltip的示例用法中，我们得到了一个`div`元素的Angular包装器，其中包含了tooltip属性。'
- en: '`Directive`: This decorator allows us to add the metadata required for the
    new directives we define.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Directive`：这个装饰器允许我们为我们定义的新指令添加所需的元数据。'
- en: '`HostListener(eventname)`: This is a method decorator that accepts an event
    name as an argument. During initialization of the directive, Angular 2 will add
    the decorated method as an event handler for the `eventname` event of the host
    element.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HostListener(eventname)`：这是一个方法装饰器，接受一个事件名称作为参数。在指令初始化期间，Angular 2将把装饰的方法添加为宿主元素的`eventname`事件的事件处理程序。'
- en: 'Let''s look at our implementation; this is what the directive''s definition
    looks like:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的实现；这是指令的定义看起来像什么：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Setting the directive's inputs
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置指令的输入
- en: 'In the preceding example, we declare a directive with the `saTooltip` selector.
    Note that Angular''s HTML compiler is case sensitive, which means that it will
    distinguish the `[satooltip]` and `[saTooltip]` selectors. Later, we will declare
    the input of the directive using the `@Input` decorator over the `saTooltip` property.
    The semantics behind this code is: declare a property called `saTooltip` and bind
    it to the value of the result that we got from the evaluation of the expression
    passed to the `saTooltip` attribute.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们使用了`saTooltip`选择器声明了一个指令。请注意，Angular的HTML编译器是区分大小写的，这意味着它将区分`[satooltip]`和`[saTooltip]`选择器。稍后，我们将使用`@Input`装饰器声明指令的输入，放在`saTooltip`属性上。这段代码背后的语义是：声明一个名为`saTooltip`的属性，并将其绑定到我们从传递给`saTooltip`属性的表达式的评估结果的值。
- en: The `@Input` decorator accepts a single argument—the name of the attribute we
    want to bind to. In case we don't pass an argument, Angular will create a binding
    between the attribute with the same name as the property itself. We will explain
    the concept of input and output in detail later in this chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input`装饰器接受一个参数——我们想要绑定的属性的名称。如果我们不传递参数，Angular将创建一个属性名称与属性本身相同的属性之间的绑定。我们将在本章后面详细解释输入和输出的概念。'
- en: Understanding the directive's constructor
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解指令的构造函数
- en: 'The constructor declares two private properties: `el` of the `ElementRef` type
    and `overlay` of the `Overlay` type. The `Overlay` class implements logic to manage
    the tooltips'' overlays and is going to be injected using the DI mechanism of
    Angular. In order to declare it as available for injection, we need to declare
    the top-level component in the following way:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数声明了两个私有属性：`el`是`ElementRef`类型的，`overlay`是`Overlay`类型的。`Overlay`类实现了管理工具提示覆盖层的逻辑，并将使用Angular的DI机制进行注入。为了声明它可以用于注入，我们需要以以下方式声明顶层组件：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We're going to take a look at the dependency injection mechanism of Angular
    2 in the next chapter, where we will explain the way in which we can declare the
    dependencies of our services, directives, and components.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下Angular 2的依赖注入机制，我们将解释如何声明我们的服务、指令和组件的依赖关系。
- en: 'The implementation of the `Overlay` class is not important for the purpose
    of this chapter. However, if you''re interested in it, you can find the implementation
    in: `ch4/ts/tooltip/app.ts`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Overlay`类的实现对本章的目的并不重要。然而，如果你对此感兴趣，你可以在`ch4/ts/tooltip/app.ts`中找到实现。'
- en: Better encapsulation of directives
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指令更好的封装
- en: 'In order to make the tooltip directive available to the Angular''s compiler,
    we need to explicitly declare where we intend to use it. For instance, take a
    look at the `App` class at `ch4/ts/tooltip/app.ts`; there, you can notice the
    following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使工具提示指令可用于Angular的编译器，我们需要明确声明我们打算在哪里使用它。例如，看一下`ch4/ts/tooltip/app.ts`中的`App`类；在那里，你可以注意到以下内容：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To the `@Component` decorator, we pass an object literal that has the `directives`
    property. This property contains a list of all the directives that should be available
    in the entire component subtree with the root of the given component.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`@Component`装饰器，我们传递了一个具有`directives`属性的对象字面量。该属性包含了整个组件子树中应该可用的所有指令的列表，根据给定组件的根。
- en: At first, it might seem annoying that you should explicitly declare all the
    directives that your component uses; however, this enforces better encapsulation.
    In AngularJS 1.x, all directives are in a global namespace. This means that all
    the directives defined in the application are accessible in all the templates.
    This brings in some problems, for example, name collision. In order to deal with
    this issue, we've introduced naming conventions, for instance, the "`ng-`" prefix
    of all the directives defined by AngularJS 1.x and "`ui-`" for all directives
    coming with the Angular UI.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，你可能会觉得很烦人，因为你需要明确声明你的组件使用的所有指令；然而，这强化了更好的封装。在AngularJS 1.x中，所有指令都在全局命名空间中。这意味着应用程序中定义的所有指令都可以在所有模板中访问。这带来了一些问题，例如名称冲突。为了解决这个问题，我们引入了命名约定，例如，AngularJS
    1.x定义的所有指令都带有"`ng-`"前缀，Angular UI中的所有指令都带有"`ui-`"前缀。
- en: This way, by explicitly declaring all the directives, the given component uses
    in Angular 2, we create a namespace specific to the individual components' subtrees
    (that is, the directives will be visible to the given root component and all of
    its successor components). Preventing name collisions is not the only benefit
    we get; it also helps us with better semantics of the code that we produce, since
    we're always aware of the directives accessible by the given component. We can
    find all the accessible directives of the given component by following the path
    from the component to the top of the component tree and taking the union of all
    the values of `directives` arrays set in the `@Component` decorators. Given that
    components are extended from directives, we need to explicitly declare all the
    used components as well.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过显式声明组件在Angular 2中使用的所有指令，我们创建了一个特定于各个组件子树的命名空间（即，指令将对给定根组件及其所有后继组件可见）。防止名称冲突不是我们得到的唯一好处；它还有助于我们更好地语义化我们生成的代码，因为我们始终知道给定组件可访问的指令。我们可以通过从组件到组件树顶部的路径，并取`@Component`装饰器中设置的`directives`数组的所有值的并集来找到给定组件的所有可访问指令。鉴于组件是从指令扩展而来，我们还需要显式声明所有使用的组件。
- en: Since Angular 2 defines a set of built-in directives, the `bootstrap` method
    passes them in a similar way in order to make them available in the entire application
    in order to prevent us from code duplications. This list of predefined directives
    includes `NgClass`, `NgFor`, `NgIf`, `NgStyle`, `NgSwitch`, `NgSwitchWhen`, and
    `NgSwitchDefault`. Their names are quite self-explanatory; we'll take a look at
    how we can use some of them later in this chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Angular 2定义了一组内置指令，`bootstrap`方法以类似的方式传递它们，以使它们在整个应用程序中可用，以防止我们重复编码。这些预定义指令的列表包括`NgClass`、`NgFor`、`NgIf`、`NgStyle`、`NgSwitch`、`NgSwitchWhen`和`NgSwitchDefault`。它们的名称相当自明；我们将在本章后面看看如何使用其中一些。
- en: Using Angular 2's built-in directives
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular 2的内置指令
- en: Now, let's build a simple to-do application in order to demonstrate the syntax
    to define components further!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个简单的待办事项应用程序，以便进一步演示定义组件的语法！
- en: 'Our to-do items will have the following format:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的待办事项将具有以下格式：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s start by importing everything we are going to need:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入我们将需要的一切开始：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s declare the component and the metadata associated with it:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们声明与组件相关的元数据：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we specify that the selector of the `Todo` component will be the `todo-app`
    element. Later, we add the template URL, which points to the `app.html` file.
    After that, we use the `styles` property; this is the first time we encounter
    it. As we can guess from its name, it is used to set the styles of the component.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定`Todo`组件的选择器将是`todo-app`元素。稍后，我们添加模板URL，指向`app.html`文件。之后，我们使用`styles`属性；这是我们第一次遇到它。从名称可以猜到，它用于设置组件的样式。
- en: Introducing the component's view encapsulation
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍组件的视图封装
- en: As we know, Angular 2 is inspired from Web Components, whose core feature is
    the shadow DOM. The shadow DOM allows us to encapsulate the styles of our Web
    Components without allowing them to leak outside the component's scope. Angular
    2 provides this feature. If we want Angular's renderer to use the shadow DOM,
    we can use `ViewEncapsulation.Native`. However, the shadow DOM is not supported
    by all browsers; if we want to have the same level of encapsulation without using
    the shadow DOM, we can use `ViewEncapsulation.Emulated`. If we don't want to have
    any encapsulation at all, we can use `ViewEncapsulation.None`. By default, the
    renderer uses encapsulation of the type `Emulated`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，Angular 2受到Web组件的启发，其核心功能是影子DOM。影子DOM允许我们封装我们的Web组件的样式，而不允许它们泄漏到组件范围之外。Angular
    2提供了这个功能。如果我们希望Angular的渲染器使用影子DOM，我们可以使用`ViewEncapsulation.Native`。然而，并非所有浏览器都支持影子DOM；如果我们希望在不使用影子DOM的情况下具有相同级别的封装，我们可以使用`ViewEncapsulation.Emulated`。如果我们根本不想有任何封装，我们可以使用`ViewEncapsulation.None`。默认情况下，渲染器使用`Emulated`类型的封装。
- en: Implementing the component's controllers
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现组件的控制器
- en: 'Now, let''s continue with the implementation of the application:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续实现应用程序：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here is part of the implementation of the controller associated with the template
    of the `Todo` application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与`Todo`应用程序模板相关的控制器实现的一部分。
- en: 'Inside the class declaration, we initialized the `todos` property to an array
    with two `todo` items:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在类声明内部，我们将`todos`属性初始化为一个包含两个`todo`项目的数组：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let''s update the template and render these items! Here''s how this is
    done:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新模板并渲染这些项目！这是如何完成的：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding template, we looped all the `todo` items inside the `todos`
    property of the controller. For each `todo` item, we created a checkbox that can
    `toggle` the item''s completion status; we also rendered the `todo` item''s label
    with the interpolation directive. Here, we can notice the syntax that was explained
    earlier:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板中，我们循环遍历了控制器的`todos`属性中的所有`todo`项目。对于每个`todo`项目，我们创建了一个复选框，可以`切换`项目的完成状态；我们还使用插值指令呈现了`todo`项目的标签。在这里，我们可以注意到之前解释过的语法：
- en: We bind to the change event of the checkbox using `(change)="statement"`.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`(change)="statement"`绑定到复选框的change事件。
- en: We bind to the property of the `todo` item using `[checked]="expr"`.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`[checked]="expr"`绑定到`todo`项目的属性。
- en: 'In order to have a line across the completed `todo` items, we bind to the `class.completed`
    property of the element. Since we want to apply the `completed` class to all the
    completed to-do items, we use `[class.completed]="todo.completed"`. This way,
    we declare that we want to apply the `completed` class depending on the value
    of the `todo.completed` expression. Here is how our application looks now:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在已完成的`todo`项目上画一条线，我们绑定到元素的`class.completed`属性。由于我们想要将`completed`类应用于所有已完成的待办事项，我们使用`[class.completed]="todo.completed"`。这样，我们声明了我们想要根据`todo.completed`表达式的值应用`completed`类。现在我们的应用程序是这样的：
- en: '![Implementing the component''s controllers](../images/00014.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![实现组件的控制器](../images/00014.jpeg)'
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Similar to the class binding syntax, Angular allows us to bind to the element''s
    styles and attributes. For instance, we can bind to the `td` element''s `colspan`
    attribute using the following line of code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与类绑定语法类似，Angular允许我们绑定元素的样式和属性。例如，我们可以使用以下代码绑定到`td`元素的`colspan`属性：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the same way, we can bind to any `style` property using this line of code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用这行代码绑定到任何`style`属性：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Handling user actions
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户操作
- en: 'So far, so good! Now, let''s implement the `toggleCompletion` method. This
    method accepts the index of the to-do item as a single argument:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利！现在，让我们实现`toggleCompletion`方法。这个方法接受待办事项的索引作为单个参数：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In `toggleCompletion`, we simply toggle the `completed` Boolean value associated
    with the current to-do item, which is specified by the index passed as an argument
    to the method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在`toggleCompletion`中，我们只是切换与当前待办事项相关联的`completed`布尔值，该值由传递给该方法的索引指定。
- en: 'Now, let''s add a text input to add the new to-do items:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个文本输入来添加新的待办事项：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The input here defines a new identifier called `newtodo`. We can reference the
    input using the `newtodo` identifier inside the template. Once the user clicks
    on the button, the `addTodo` method defined in the controller will be invoked
    with the value of the `newtodo` input as an argument. Inside the statement that
    is passed to the `(click)` attribute, we also reset the value of the `newtodo`
    input by setting it to the empty string.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的输入定义了一个名为`newtodo`的新标识符。我们可以在模板中使用`newtodo`标识符引用输入。一旦用户点击按钮，控制器中定义的`addTodo`方法将以`newtodo`输入的值作为参数被调用。在传递给`(click)`属性的语句中，我们还通过将其设置为空字符串来重置`newtodo`输入的值。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that directly manipulating DOM elements is not considered as best practice
    since it will prevent our component from running properly outside the browser
    environment. We will explain how we can migrate this application to Web Workers
    in [Chapter 8](part0075_split_000.html#27GQ62-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 8. Development Experience and Server-Side Rendering"), *Development Experience
    and Server-Side Rendering*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，直接操作DOM元素不被视为最佳实践，因为它会阻止我们的组件在浏览器环境之外正常运行。我们将解释如何将此应用程序迁移到Web Workers中，详见[第8章](part0075_split_000.html#27GQ62-a118c4c18dd64e8ab73e171b466b6582
    "第8章。开发体验和服务器端渲染"), *开发体验和服务器端渲染*。
- en: 'Now, let''s define the `addTodo` method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义`addTodo`方法：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Inside it, we create a new to-do item using the object literal syntax.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们使用对象字面量语法创建一个新的待办事项。
- en: The only thing left out of our application is to implement removal of existing
    to-do items. Since it is quite similar to the functionality used to toggle the
    completion of the to-do items, I'll leave its implementation as a simple exercise
    for the reader.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中唯一剩下的事情是实现删除现有待办事项。由于它与用于切换待办事项完成情况的功能非常相似，我将把它的实现作为读者的简单练习留下。
- en: Using a directives' inputs and outputs
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指令的输入和输出
- en: 'By refactoring our `todo` application, we are going to demonstrate how we can
    take advantage of the directives'' inputs and outputs:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重构我们的`todo`应用程序，我们将演示如何利用指令的输入和输出：
- en: '![Using a directives'' inputs and outputs](../images/00015.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![使用指令的输入和输出](../images/00015.jpeg)'
- en: We can think of the inputs as properties (or even arguments) that the given
    directive accepts. The outputs could be considered as events that it triggers.
    When we use a directive provided by a third-party library, mostly we care about
    is its inputs and outputs because they define its API.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将输入视为给定指令接受的属性（甚至参数）。输出可以被视为它触发的事件。当我们使用第三方库提供的指令时，我们主要关心的是它的输入和输出，因为它们定义了它的API。
- en: Inputs refers to values that parameterize the directive's behavior and/or view.
    On the other hand, outputs refers to events that the directive fires when something
    special happens.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是指参数化指令行为和/或视图的值。另一方面，输出是指指令在发生特殊事件时触发的事件。
- en: Finding out directives' inputs and outputs
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找指令的输入和输出
- en: 'Now, let''s divide our monolithic to-do application into separate components
    that communicate with each other. In the following screenshot, you can see the
    individual components that when composed together implement the functionality
    of the application:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的单体待办事项应用程序分成单独的组件，它们彼此通信。在下面的屏幕截图中，您可以看到单独的组件，当组合在一起时实现应用程序的功能：
- en: '![Finding out directives'' inputs and outputs](../images/00016.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![查找指令的输入和输出](../images/00016.jpeg)'
- en: The outer rectangle represents the entire `Todo` application. The first nested
    rectangle contains the component that is responsible for entering labels of the
    new to-do items, and the one below it lists the individual items that are stored
    in the root component.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 外部矩形代表整个`Todo`应用程序。第一个嵌套的矩形包含负责输入新待办事项标签的组件，下面的矩形列出了存储在根组件中的各个项目。
- en: 'Having said this, we can define these three components as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，我们可以将这三个组件定义如下：
- en: '`TodoApp`: Responsible for maintaining the list of to-do items (adding new
    items and toggling the completion status).'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoApp`：负责维护待办事项列表（添加新项目和切换完成状态）。'
- en: '`InputBox`: Responsible for entering the label of the new to-do item. It has
    the following inputs and outputs:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputBox`：负责输入新待办事项的标签。它具有以下输入和输出：'
- en: '`Input`: A placeholder for the textbox and a label for the submit button.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Input`：文本框的占位符和提交按钮的标签。'
- en: '`Output`: It should emit the content of the input once the submit button is
    clicked.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Output`：它应该在单击提交按钮时发出输入的内容。'
- en: '`TodoList`: This is responsible for rendering the individual to-do items. It
    has the following inputs and outputs:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TodoList`：负责呈现各个待办事项。它具有以下输入和输出：'
- en: '`Input`: The list of to-do items.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Input`：待办事项列表。'
- en: '`Output`: Once the completion status of any of the to-do items changes, the
    component should emit the change.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Output`：一旦任何待办事项的完成状态发生变化，该组件应该发出变化。'
- en: Now, let's begin with the implementation!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始实施！
- en: Defining the component's inputs and outputs
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义组件的输入和输出
- en: 'Let''s use a bottom-up approach and start with the `InputBox` component. Before
    that, we need a couple of imports from Angular''s `angular2/core` package:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们采用自下而上的方法，从`InputBox`组件开始。在此之前，我们需要从Angular的`angular2/core`包中导入一些内容：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, we imported the `@Component`, `@Input`, and `@Output`
    decorators and the `EventEmitter` class. As their names state, `@Input` and `@Output`
    are used for declaring the directive's inputs and outputs. `EventEmitter` is a
    generic class (that is, accepting type parameter) which combined with the `@Output`
    decorator helps us emit outputs.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入了`@Component`、`@Input`和`@Output`装饰器以及`EventEmitter`类。正如它们的名称所述，`@Input`和`@Output`用于声明指令的输入和输出。`EventEmitter`是一个通用类（即接受类型参数），它与`@Output`装饰器结合使用，帮助我们发出输出。
- en: 'As the next step, let''s take a look at the `InputBox` component''s declaration:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，让我们来看一下`InputBox`组件的声明：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Note that in the template, we declare a text input called `todoInput` and set
    its placeholder property to the value that we got from the evaluation of the `inputPlaceholder`
    expression. The value of the expression is the value of the `inputPlaceholder`
    property defined in the component''s controller. This is the first input that
    we need to define:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在模板中，我们声明了一个名为`todoInput`的文本输入，并将其占位符属性设置为我们从`inputPlaceholder`表达式的评估中获得的值。表达式的值是组件控制器中定义的`inputPlaceholder`属性的值。这是我们需要定义的第一个输入：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Similarly, we declare the other input of the `buttonLabel` component, which
    we use as a value of the label of the button:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们声明了`buttonLabel`组件的另一个输入，我们将其用作按钮标签的值：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding template, we bind the click event of the button to this expression:
    `emitText(todoInput.value); todoInput.value = '''';`. The `emitText` method is
    supposed to be defined in the component''s controller; once it is invoked, it
    should emit the value of the text input. Here is how we can implement this behavior:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板中，我们将按钮的点击事件绑定到这个表达式：`emitText(todoInput.value); todoInput.value = '';`。`emitText`方法应该在组件的控制器中定义；一旦调用它，它应该发出文本输入的值。以下是我们可以实现这种行为的方法：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Initially, we declare an output called `inputText`. As its value, we set a new
    instance of the type `EventEmitter<string>` that we create.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们声明了一个名为`inputText`的输出。我们将其值设置为我们创建的`EventEmitter<string>`类型的新实例。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that all the outputs of all the components need to be instances of `EventEmitter`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有组件的输出都需要是`EventEmitter`的实例。
- en: Inside the `emitText` method, we invoke the emit method of the `inputText` instance
    with the argument of the value of the text input.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在`emitText`方法内部，我们使用`inputText`实例的emit方法，并传入文本输入的值作为参数。
- en: 'Now, let''s define the `TodoList` component in the same fashion:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以相同的方式定义`TodoList`组件：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Since the value of the object literal passed to the `@Component` decorator is
    not essential for the purpose of this section, we've omitted it. The complete
    implementation of this example could be found at `ch4/ts/inputs-outputs/app.ts`.
    Let's take a look at the body of the `TodoList` class. Similarly, for the `InputBox`
    component, we define the `todos` input. We also define the `toggle` output by
    declaring the `toggle` property, setting its value to a new instance of the type
    `EventEmitter<Todo>` and decorating it with the `@Output` decorator.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于传递给`@Component`装饰器的对象文字的值对于本节的目的并不重要，我们已经省略了它。这个例子的完整实现可以在`ch4/ts/inputs-outputs/app.ts`中找到。让我们来看一下`TodoList`类的主体。同样，对于`InputBox`组件，我们定义了`todos`输入。我们还通过声明`toggle`属性，将其值设置为`EventEmitter<Todo>`类型的新实例，并用`@Output`装饰器装饰它，定义了`toggle`输出。
- en: Passing inputs and consuming the outputs
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递输入和消耗输出
- en: Now, let's combine the components we defined in the preceding section and implement
    our complete application!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们结合前面定义的组件并实现我们的完整应用程序！
- en: 'The last component we need to take a look at is `TodoApp`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要查看的最后一个组件是`TodoApp`：
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Initially, we define the `TodoApp` class and decorate it with the `@Component`
    decorator. Note that in the list of the directives used by the component, we include
    `InputBox` and `TodoList`. The magic of how these components collaborate together
    happens in the template:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了`TodoApp`类，并用`@Component`装饰器装饰它。请注意，在组件使用的指令列表中，我们包括了`InputBox`和`TodoList`。这些组件如何协同工作的魔法发生在模板中：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'First, we use the `InputBox` component and pass values to the inputs: `inputPlaceholder`
    and `buttonLabel`. Note that just like we saw earlier, if we want to pass an expression
    as a value to any of these inputs, we need to surround them with brackets (that
    is, `[inputPlaceholder]="expression"`). In this case, the expression will be evaluated
    in the context of the component that owns the template, and it will be passed
    as an input to the component that owns the given property.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`InputBox`组件并向输入传递值：`inputPlaceholder`和`buttonLabel`。请注意，就像我们之前看到的那样，如果我们想将表达式作为值传递给任何这些输入中的一个，我们需要用括号括起来（即`[inputPlaceholder]="expression"`）。在这种情况下，表达式将在拥有模板的组件的上下文中进行评估，并作为输入传递给拥有给定属性的组件。
- en: Right after we pass the value for the `buttonLabel` input, we consume the `inputText`
    output by setting the value of the `(inputText)` attribute to the `addTodo($event)`
    expression. The value of `$event` will equal the value we passed to the `emit`
    method of the `inputText` object inside the `emitText` method of `InputBox` (in
    case we bind to a native event, the value of the event object will be the native
    event object itself).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在为`buttonLabel`输入传递值后，我们通过将`(inputText)`属性的值设置为`addTodo($event)`表达式来消耗`inputText`输出。`$event`的值将等于我们传递给`InputBox`的`inputText`对象的`emitText`方法中的`emit`方法的值（如果我们绑定到原生事件，事件对象的值将是原生事件对象本身）。
- en: 'In the same way, we pass the input of the `TodoList` component and handle its
    toggle output. Now, let''s define the logic behind the `TodoApp` component:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们传递`TodoList`组件的输入并处理其切换输出。现在，让我们定义`TodoApp`组件的逻辑：
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the `addTodo` method, we simply push a new to-do item to the `todos` array.
    The implementation of `toggleCompletion` is even simpler—we toggle the value of
    the completed flag that is passed as an argument to the to-do item. Now, we are
    familiar with the basics of the components' inputs and outputs!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addTodo`方法中，我们只是将一个新的待办事项推送到`todos`数组中。`toggleCompletion`的实现甚至更简单——我们切换作为参数传递给待办事项的完成标志的值。现在，我们熟悉了组件输入和输出的基础知识！
- en: Event bubbling
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件冒泡
- en: 'In Angular, we have the same bubbling behavior we have in the DOM. For instance,
    if we have the following template:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，我们有与DOM中相同的冒泡行为。例如，如果我们有以下模板：
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The declaration of `input-box` looks like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`input-box`的声明如下：'
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Once the user clicks on the button defined within the template of the `input-box`
    component, the `handleClick($event)` expression will be evaluated.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 用户一旦点击了模板中定义的`input-box`组件内的按钮，`handleClick($event)`表达式就会被评估。
- en: Further, the `target` property of the first argument of `handleClick` will be
    the button itself, but the `currentTarget` property will be the `input-box` element.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`handleClick`的第一个参数的`target`属性将是按钮本身，但`currentTarget`属性将是`input-box`元素。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that unlike native events, ones triggered by `EventEmitter` will not bubble.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与原生事件不同，由`EventEmitter`触发的事件不会冒泡。
- en: Renaming the inputs and outputs of a directive
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重命名指令的输入和输出
- en: 'Now, we will explore how we can rename the directives'' inputs and outputs!
    Let''s suppose that we have the following definition of the `TodoList` component:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨如何重命名指令的输入和输出！假设我们有以下`TodoList`组件的定义：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output of the component is called `toggle`; the method that handles changes
    in the checkboxes responsible for toggling completion of the individual to-do
    items is called `toggle` as well. This code will not be compiled as in the `TodoList`
    controller, we have two identifiers named in the same way. We have two options
    here: we can either rename the method or the property. If we rename the property,
    this will change the name of the component''s output as well. So, the following
    line of code will no longer work:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的输出被称为`toggle`；负责切换个人待办事项完成状态的复选框的方法也被称为`toggle`。这段代码不会被编译，因为在`TodoList`控制器中，我们有两个同名的标识符。我们有两个选择：我们可以重命名方法或属性。如果我们重命名属性，这也会改变组件输出的名称。因此，以下代码将不再起作用：
- en: '[PRE44]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'What we can do instead is rename the `toggle` property and explicitly set the
    name of the output using the `@Output` decorator:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的是重命名`toggle`属性，并使用`@Output`装饰器显式设置输出的名称：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This way, we will be able to trigger the `toggle` output using the `toggleEvent`
    property.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们将能够使用`toggleEvent`属性触发`toggle`输出。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that such renames could be confusing and are not considered as best practices.
    For a complete set of best practices visit [https://github.com/mgechev/angular2-style-guide](https://github.com/mgechev/angular2-style-guide).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这样的重命名可能会令人困惑，并且不被视为最佳实践。有关最佳实践的完整集合，请访问[https://github.com/mgechev/angular2-style-guide](https://github.com/mgechev/angular2-style-guide)。
- en: 'Similarly, we can rename component''s inputs using the following code snippet:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用以下代码片段来重命名组件的输入：
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, no matter that we renamed the input and output properties of `TodoList`,
    it still has the same public interface:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论我们如何重命名`TodoList`的输入和输出属性，它仍然具有相同的公共接口：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: An alternative syntax to define inputs and outputs
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义输入和输出的另一种语法
- en: 'The `@Input` and `@Output` decorators are syntax sugar for easier declaration
    of the directive''s inputs and outputs. The original syntax for this purpose is
    as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input`和`@Output`装饰器是语法糖，用于更容易地声明指令的输入和输出。用于此目的的原始语法如下：'
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Using `@Input` and `@Output`, the preceding syntax is equivalent to this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Input`和`@Output`，前面的语法等同于这样：
- en: '[PRE49]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Although both have the same semantics, according to the best practices, we should
    use the latter one because it is easier to read and understand.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管两者语义相同，但根据最佳实践，我们应该使用后者，因为它更容易阅读和理解。
- en: Explaining Angular 2's content projection
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释Angular 2的内容投影
- en: Content projection is an important concept when developing user interfaces.
    It allows us to project pieces of content into different places of the user interface
    of our application. Web Components solve this problem with the `content` element.
    In AngularJS 1.x, it is implemented with the infamous transclusion.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 内容投影是开发用户界面时的一个重要概念。它允许我们将内容的片段投影到应用程序的用户界面的不同位置。Web组件使用`content`元素解决了这个问题。在AngularJS
    1.x中，它是通过臭名昭著的转置来实现的。
- en: Angular 2 is inspired by modern web standards, especially Web Components, which
    led to the adoption of some of the methods of content projection used there. In
    this section, we'll look at them in the context of Angular 2 using the `ng-content`
    directive.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2受到现代Web标准的启发，特别是Web组件，这导致了采用了一些在那里使用的内容投影方法。在本节中，我们将在Angular 2的上下文中使用`ng-content`指令来查看它们。
- en: Basic content projection in Angular 2
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular 2中的基本内容投影
- en: 'Let''s suppose we''re building a component called `fancy-button`. This component
    will use the standard HTML button element and add some extra behavior to it. Here
    is the definition of the `fancy-button` component:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在构建一个名为`fancy-button`的组件。该组件将使用标准的HTML按钮元素，并为其添加一些额外的行为。以下是`fancy-button`组件的定义：
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Inside of the `@Component` decorator, we set the inline template of the component
    together with its selector. Now, we can use the component with the following markup:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@Component`装饰器内部，我们设置了组件的内联模板以及其选择器。现在，我们可以使用以下标记使用组件：
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: On the screen, we are going to see a standard HTML button that has a label with
    the content **Click me**. This is not a very flexible way to define reusable UI
    components. Most likely, the users of the fancy button will need to change the
    content of the label to something, depending on their application.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上，我们将看到一个标准的HTML按钮，其标签中包含内容**Click me**。这不是一种定义可重用UI组件的非常灵活的方式。很可能，漂亮按钮的用户将需要根据他们的应用程序更改标签的内容。
- en: 'In AngularJS 1.x, we were able to achieve this result with `ng-transclude`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS 1.x中，我们可以使用`ng-transclude`来实现这个结果：
- en: '[PRE52]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In Angular 2, we have the `ng-content` element:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 2中，我们有`ng-content`元素：
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we can pass custom content to the fancy button by executing this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过执行以下操作将自定义内容传递给漂亮按钮：
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As a result, the content between the opening and the closing `fancy-button`
    tags will be placed where the `ng-content` directive resides.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`fancy-button`标签的开头和结尾之间的内容将放置在`ng-content`指令所在的位置。
- en: Projecting multiple content chunks
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 投影多个内容块
- en: Another typical use case of content projection is when we pass content to a
    custom Angular 2 component or AngularJS 1.x directive and we want different parts
    of this content to be projected to different locations in the template.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 内容投影的另一个典型用例是，当我们将内容传递给自定义的Angular 2组件或AngularJS 1.x指令时，我们希望将此内容的不同部分投影到模板中的不同位置。
- en: 'For instance, let''s suppose we have a `panel` component that has a title and
    a body:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个`panel`组件，它有一个标题和一个正文：
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'And we have the following template of our component:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件模板如下：
- en: '[PRE56]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In AngularJS 1.5, we are able to do this using multi-slot transclusion, which
    was implemented in order to allow us to have a smoother transition to Angular
    2\. Let''s take a look at how we can proceed in Angular 2 in order to define such
    a `panel` component:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS 1.5中，我们可以使用多槽传输来实现这一点，这是为了让我们能够更顺利地过渡到Angular 2而实施的。让我们看看我们如何可以在Angular
    2中进行，以定义这样一个`panel`组件：
- en: '[PRE57]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We have already described the `selector` and `styles` properties, so let''s
    take a look at the component''s template. We have a `div` element with the `panel`
    class, which wraps the two nested `div` elements, respectively: one for the title
    of `panel` and one for the content of `panel`. In order to grab the content from
    the `panel-title` element and project it where the title of the `panel` is supposed
    to be in the rendered panel, we need to use the `ng-content` element with the
    `selector` attribute, which has the `panel-title` value. The value of the `selector`
    attribute is a CSS selector, which in this case is going to match all the `panel-title`
    elements that reside inside the target `panel` element. After this, `ng-content`
    will grab their content and set them as its own content.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经描述了`selector`和`styles`属性，现在让我们来看一下组件的模板。我们有一个带有`panel`类的`div`元素，它包裹了两个嵌套的`div`元素，分别用于`panel`的标题和内容。为了从`panel-title`元素中获取内容，并将其投影到渲染面板中`panel`标题应该在的位置，我们需要使用带有`selector`属性的`ng-content`元素，该属性具有`panel-title`值。`selector`属性的值是一个CSS选择器，在这种情况下，它将匹配位于目标`panel`元素内的所有`panel-title`元素。之后，`ng-content`将获取它们的内容并将其设置为自己的内容。
- en: Nesting components
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套组件
- en: 'We''ve already built a few simple applications as a composition of components
    and directives. We saw that components are basically directives with views, so
    we can implement them by nesting/composing other directives and components. The
    following figure illustrates this with a structural diagram:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了一些简单的应用程序，作为组件和指令的组合。我们看到组件基本上是带有视图的指令，因此我们可以通过嵌套/组合其他指令和组件来实现它们。以下图示说明了这一点：
- en: '![Nesting components](../images/00017.jpeg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![嵌套组件](../images/00017.jpeg)'
- en: 'The composition could be achieved by nesting directives and components within
    the components'' templates, taking advantage of the nested nature of the used
    markup. For instance, let''s say we have a component with the `sample-component`
    selector, which has the following definition:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 组合可以通过在组件模板中嵌套指令和组件来实现，利用所使用标记的嵌套特性。例如，假设我们有一个带有`sample-component`选择器的组件，其定义如下：
- en: '[PRE58]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The template of the `sample-component` selector has a single child element with
    the tag name `view-child`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample-component`选择器的模板有一个带有标签名`view-child`的子元素。'
- en: 'On the other hand, we can use the `sample-component` selector inside the template
    of another component, and since it can be used as an element, we can nest other
    components or directives inside it:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以在另一个组件的模板中使用`sample-component`选择器，由于它可以作为一个元素使用，我们可以在其中嵌套其他组件或指令：
- en: '[PRE59]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This way, the `sample-component` component has two different types of successors:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`sample-component`组件有两种不同类型的后继：
- en: The successor defined within its template.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在它的模板中定义的后继。
- en: The successor that is passed as nested elements between its opening and closing
    tags.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为嵌套元素传递的后继。
- en: In the context of Angular 2, the direct children elements defined within the
    component's template are called **view children** and the ones nested between
    its opening and closing tags are called **content children**.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 2的上下文中，定义在组件模板中的直接子元素称为**视图子组件**，而在其开放和关闭标签之间嵌套的子元素称为**内容子组件**。
- en: Using ViewChildren and ContentChildren
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ViewChildren和ContentChildren
- en: 'Let''s take a look at the implementation of the `Tabs` component, which uses
    the following structure:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下使用以下结构的`Tabs`组件的实现：
- en: '[PRE60]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding structure is composed of three components:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结构由三个组件组成：
- en: The `Tab` component.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tab`组件。'
- en: The `TabTitle` component.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TabTitle`组件。'
- en: The `TabContent` component.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TabContent`组件。'
- en: 'Let''s look at the implementation of the `TabTitle` component:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`TabTitle`组件的实现：
- en: '[PRE61]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: There's nothing new in this implementation. We define a `TabTitle` component,
    which has a single property called `tabSelected`. It is of the type `EventEmitter`
    and will be triggered once the user clicks on the tab title.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中没有什么新的。我们定义了一个`TabTitle`组件，它有一个叫做`tabSelected`的属性。它是`EventEmitter`类型的，一旦用户点击标签标题，它就会被触发。
- en: 'Now, let''s take a look at the `TabContent` component:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`TabContent`组件：
- en: '[PRE62]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This has an even simpler implementation—all we do is project the DOM passed
    to the `tab-content` element inside `ng-content` and hide it once the value of
    the `isActive` property becomes `false`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现甚至更简单——我们所做的就是将传递给`tab-content`元素的DOM投影到`ng-content`中，并在`isActive`属性的值变为`false`时隐藏它。
- en: 'The interesting part of the implementation is the `Tabs` component itself:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 实现中有趣的部分是`Tabs`组件本身：
- en: '[PRE63]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this implementation, we have a decorator that we haven't used yet—the `@ContentChildren`
    decorator. The `@ContentChildren` property decorator fetches the content children
    of the given component. This means that we can get references to all `TabTitle`
    and `TabContent` instances from within the instance of the `Tabs` component and
    get them in the order in which they are declared in the markup. There's an alternative
    decorator called `@ViewChildren`, which fetches all the view children of the given
    element. Let's take a look at the difference between them before we explain the
    implementation further.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们有一个尚未使用的装饰器——`@ContentChildren`装饰器。`@ContentChildren`属性装饰器获取给定组件的内容子组件。这意味着我们可以从`Tabs`组件的实例中获取对所有`TabTitle`和`TabContent`实例的引用，并按照它们在标记中声明的顺序获取它们。还有一个叫做`@ViewChildren`的替代装饰器，它获取给定元素的所有视图子组件。在我们进一步解释实现之前，让我们看看它们之间的区别。
- en: ViewChild versus ContentChild
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ViewChild与ContentChild
- en: 'Although both concepts sound similar, they have quite different semantics.
    In order to understand them better, let''s take a look at the following example:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个概念听起来相似，但它们的语义有很大的不同。为了更好地理解它们，让我们来看一个例子：
- en: '[PRE64]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here, we''ve defined two components: `UserBadge` and `UserRating`. Let''s define
    a parent component, which comprises both the components:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个组件：`UserBadge`和`UserRating`。让我们定义一个包含这两个组件的父组件：
- en: '[PRE65]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Note that the template of the view of `UserPanel` contains only the `UserBadge`
    component''s selector. Now, let''s use the `UserPanel` component in our application:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，“UserPanel”视图的模板仅包含“UserBadge”组件的选择器。现在，让我们在我们的应用程序中使用“UserPanel”组件：
- en: '[PRE66]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The template of our main `App` component uses the `UserPanel` component and
    nests the `UserRating` component inside it. Now, let''s suppose we want to get
    a reference to the instance of the `UserRating` component that is used inside
    the `user-panel` element in the `App` component and a reference to the `UserBadge`
    component, which is used inside the `UserPanel` template. In order to do this,
    we can add two more properties to the `UserPanel` controller and add the `@ContentChild`
    and `@ViewChild` decorators to them with the appropriate arguments:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要的“App”组件的模板使用“UserPanel”组件，并嵌套了“UserRating”组件。现在，假设我们想要获取对“App”组件中“user-panel”元素内使用的“UserRating”组件实例的引用，以及对“UserPanel”模板内使用的“UserBadge”组件的引用。为了做到这一点，我们可以向“UserPanel”控制器添加两个属性，并为它们添加“@ContentChild”和“@ViewChild”装饰器，并使用适当的参数：
- en: '[PRE67]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The semantics of the `badge` property declaration is this: "get the instance
    of the first child component of the type `UserBadge`, which is used inside the
    `UserPanel` template". Accordingly, the semantics of the `rating` property''s
    declaration is this: "get the instance of the first child component of the type
    `UserRating`, which is nested inside the `UserPanel` host element".'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: “badge”属性声明的语义是：“获取在‘UserPanel’模板内使用的类型为‘UserBadge’的第一个子组件的实例”。相应地，“rating”属性声明的语义是：“获取在‘UserPanel’宿主元素内嵌套的类型为‘UserRating’的第一个子组件的实例”。
- en: Now, if you run this code, you'll note that the values of the `badge` and `rating`
    properties are still equal to the `undefined` value inside the controller's constructor.
    This is because they are still not initialized in this phase of the component's
    life cycle. The life cycle hooks that we can use in order to get a reference to
    these child components are `ngAfterViewInit` and `ngAfterContentInit`. We can
    use these hooks simply by adding definitions of the `ngAfterViewInit` and `ngAfterContentInit`
    methods to the component's controller. We will make a complete overview of the
    life cycle hooks that Angular 2 provides shortly.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您运行此代码，您会注意到在控制器的构造函数内，“badge”和“rating”的值仍然等于“undefined”。这是因为它们在组件生命周期的这个阶段仍然没有初始化。我们可以使用“ngAfterViewInit”和“ngAfterContentInit”生命周期钩子来获取对这些子组件的引用。我们可以通过向组件的控制器添加“ngAfterViewInit”和“ngAfterContentInit”方法的定义来简单地使用这些钩子。我们将很快对Angular
    2提供的生命周期钩子进行全面概述。
- en: To recap, we can say that the content children of the given components are the
    child elements that are nested within the component's host element. In contrast,
    the view children directives of the given component are the elements used within
    its template.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们可以说给定组件的内容子代是嵌套在组件宿主元素内的子元素。相反，给定组件的视图子代指令是其模板中使用的元素。
- en: Note
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In order to get platform independent reference to a DOM element, again, we
    can use `@ContentChildren` and `@ViewChildren`. For instance, if we have the following
    template: `<input #todo>` we can get a reference to the `input` by using: `@ViewChild(''todo'')`.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '为了获得对DOM元素的平台无关引用，我们可以再次使用“@ContentChildren”和“@ViewChildren”。例如，如果我们有以下模板：“<input
    #todo>”，我们可以通过使用“@ViewChild(''todo'')”来获取对“input”的引用。'
- en: Since we are already familiar with the core differences between view children
    and content children now, we can continue with our tabs implementation.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了视图子代和内容子代之间的核心区别，现在我们可以继续实现我们的选项卡。
- en: 'In the tabs component, instead of using the `@ContentChild` decorator, we use
    `@ContentChildren`. We do this because we have multiple content children and we
    want to get them all:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签组件中，我们使用的是`@ContentChildren`而不是`@ContentChild`装饰器。我们这样做是因为我们有多个内容子级，我们想要获取它们所有：
- en: '[PRE68]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Another main difference we can notice is that the types of the `tabTitles` and
    `tabContents` properties are `QueryList` with the respective type parameter and
    not the component's type itself. We can think of the `QueryList` data structure
    as a JavaScript array—we can apply the same high-order functions (`map`, `filter`,
    `reduce`, and so on) over it and loop over its elements; however, `QueryList`
    is also observable, that is, we can observe it for changes.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到的另一个主要区别是，“tabTitles”和“tabContents”属性的类型是带有相应类型参数的“QueryList”，而不是组件本身的类型。我们可以将“QueryList”数据结构视为JavaScript数组——我们可以对其应用相同的高阶函数（`map`、`filter`、`reduce`等），并循环遍历其元素；但是，“QueryList”也是可观察的，也就是说，我们可以观察它进行更改。
- en: 'As the final step of our `Tabs` definition, let''s take a peek at the implementation
    of the `ngAfterContentInit` and select methods:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们“标签”定义的最后一步，让我们来看一下“ngAfterContentInit”和“select”方法的实现：
- en: '[PRE69]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the first line of the method's implementation, we loop all `tabTitles` and
    take the observable's references. These objects have a method called `subscribe`,
    which accepts a callback as an argument. Once the `.emit()` method of the `EventEmitter`
    instance (that is, the `tabSelected` property of any tab) is called, the callback
    passed to the `subscribe` method will be invoked.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法实现的第一行，我们循环所有“tabTitles”并获取可观察的引用。这些对象有一个名为“subscribe”的方法，它接受一个回调作为参数。一旦调用了任何选项卡的“EventEmitter”实例（即任何选项卡的“tabSelected”属性）的`.emit()`方法，将调用传递给“subscribe”方法的回调。
- en: 'Now, let''s take a look at the `select` method''s implementation:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下“select”方法的实现：
- en: '[PRE70]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the first line, we get an array representation of `tabContents`, which is
    of the type `QueryList<TabContent>`. After that, we set the `isActive` flag of
    the current active tab to `false` and select the next active one. In the last
    line in the `select` method's implementation, we trigger the selected event of
    the `Tabs` component by invoking `this.tabChanged.emit` with the index of the
    currently selected tab.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法的第一行，我们获取了“tabContents”的数组表示形式，它的类型是“QueryList<TabContent>”。之后，我们将当前活动选项卡的“isActive”标志设置为“false”，并选择下一个活动选项卡。在“select”方法的实现的最后一行中，我们通过调用`this.tabChanged.emit`并传入当前选定选项卡的索引来触发“Tabs”组件的选定事件。
- en: Hooking into the component's life cycle
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂钩到组件的生命周期
- en: Components in Angular 2 have a well-defined life cycle, which allows us to hook
    into different phases of it and have further control over our application. We
    can do this by implementing specific methods in the component's controller. In
    order to be more explicit, thanks to the expressiveness of TypeScript, we can
    implement different interfaces associated with the life cycle's phases. Each of
    these interfaces has a single method, which is associated with the phase itself.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2中的组件具有明确定义的生命周期，这使我们能够挂钩到其不同阶段，并进一步控制我们的应用程序。我们可以通过在组件的控制器中实现特定方法来实现这一点。为了更加明确，由于TypeScript的表现力，我们可以实现与生命周期阶段相关的不同接口。这些接口中的每一个都有一个与阶段本身相关联的单个方法。
- en: Although code written with explicit interface implementation will have better
    semantics, since Angular 2 supports ES5 as well within the component, we can simply
    define methods with the same names as the life cycle hooks (but this time, prefixed
    with `ng`) and take advantage of duck typing.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用显式接口实现的代码语义更好，因为Angular 2也支持组件内的ES5，我们可以简单地定义与生命周期钩子相同名称的方法（但这次以“ng”为前缀），并利用鸭子类型。
- en: 'The following diagram shows all the phases we can hook into:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了我们可以挂钩的所有阶段：
- en: '![Hooking into the component''s life cycle](../images/00018.jpeg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![钩入组件的生命周期](../images/00018.jpeg)'
- en: 'Let''s take a look at the different life cycle hooks:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下不同的生命周期钩子：
- en: '`OnChanges`: This hook will be invoked once a change in the input properties
    of a given component has been detected. For instance, let''s take a look at the
    following component:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnChanges`：一旦检测到给定组件的输入属性发生变化，将调用此钩子。例如，让我们来看一下以下组件：'
- en: '[PRE71]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can use it like this:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用：
- en: '[PRE72]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Once the value of the expression associated with the `[title]` attribute has
    been changed, the `ngOnChanges` hook will be invoked. We can implement it using
    this code snippet:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦与`[title]`属性关联的表达式的值发生变化，将调用`ngOnChanges`钩子。我们可以使用以下代码片段来实现它：
- en: '[PRE73]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The preceding snippet will display all the changed bindings and their old values.
    In order to be more explicit in the implementation of the hook, we can use interfaces:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段将显示所有更改的绑定及其旧值。为了在钩子的实现中更加明确，我们可以使用接口：
- en: '[PRE74]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: All the interfaces representing the individual life cycle hooks define a single
    method with the name of the interface itself prefixed with `ng`. In the upcoming
    list, we'll use the term life cycle hook, both for interface and/or the method,
    except if we won't imply anything specifically for only one of them.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 代表各个生命周期钩子的所有接口都定义了一个以`ng`为前缀的接口名称的单个方法。在即将到来的列表中，我们将使用生命周期钩子这个术语，无论是接口还是方法，除非我们不会特别指代其中的一个。
- en: '`OnInit`: This hook will be invoked once the given component has been initialized.
    We can implement it using the `OnInit` interface with its `ngOnInit` method.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnInit`：一旦给定组件被初始化，将调用此钩子。我们可以使用`OnInit`接口及其`ngOnInit`方法来实现它。'
- en: '`DoCheck`: This will be invoked when the change detector of the given component
    is invoked. It allows us to implement our own change detection algorithm for the
    given component. Note that `DoCheck` and `OnChanges` should not be implemented
    together on the same directive.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoCheck`：当给定组件的变更检测器被调用时，将调用此方法。它允许我们为给定组件实现自己的变更检测算法。请注意，`DoCheck`和`OnChanges`不应该在同一个指令上同时实现。'
- en: '`OnDestroy`: If we implement the `OnDestroy` interface with its single `ngOnDestroy`
    method, we can hook into the destroy life cycle phase of a component. This method
    will be invoked once the component is detached from the component tree.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDestroy`：如果我们实现了`OnDestroy`接口及其单个`ngOnDestroy`方法，我们可以钩入组件销毁生命周期阶段。一旦组件从组件树中分离，将调用此方法。'
- en: 'Now, let''s take a look at the life cycle hooks associated with the component''s
    content and view children:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下与组件内容和视图子元素相关的生命周期钩子：
- en: '`AfterContentInit`: If we implement the `ngAfterContentInit` life cycle hook,
    we will be notified when the component''s content has been fully initialized.
    This is the phase when the properties decorated with `ContentChild` or `ContentChildren`
    will be initialized.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterContentInit`：如果我们实现了`ngAfterContentInit`生命周期钩子，那么当组件的内容完全初始化时，我们将收到通知。这是使用`ContentChild`或`ContentChildren`装饰的属性将被初始化的阶段。'
- en: '`AfterContentChecked`: By implementing this hook, we''ll get notified each
    time the content of the given component has been checked by the change detection
    mechanism of Angular 2.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterContentChecked`：通过实现此钩子，我们将在每次Angular 2的变更检测机制检查给定组件的内容时收到通知。'
- en: '`AfterViewInit`: If we implement the `ngAfterViewInit` life cycle hook, we
    will be notified when the component''s view has been fully initialized. This is
    the phase when the properties decorated with `ViewChild` or `ViewChildren` will
    be initialized.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterViewInit`：如果我们实现了`ngAfterViewInit`生命周期钩子，那么当组件的视图完全初始化时，我们将收到通知。这是使用`ViewChild`或`ViewChildren`装饰的属性将被初始化的阶段。'
- en: '`AfterViewChecked`: This is similar to `AfterContentChecked`. The `AfterViewChecked`
    hook will be invoked once the view of your component has been checked.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterViewChecked`：这类似于`AfterContentChecked`。一旦组件的视图被检查，`AfterViewChecked`钩子将被调用。'
- en: The order of execution
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行顺序
- en: 'In order to trace the order of execution of the callbacks associated with each
    hook, let''s take a peek at the `ch4/ts/life-cycle/app.ts` example:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 为了追踪与每个钩子相关的回调的执行顺序，让我们来看一下`ch4/ts/life-cycle/app.ts`示例：
- en: '[PRE75]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `Panel` component implements all the hooks without explicitly implementing
    the interfaces associated with them.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`Panel`组件实现了所有钩子，而没有显式实现与它们相关的接口。'
- en: 'We can use the component in the following template:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下模板中使用该组件：
- en: '[PRE76]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In the preceding example, we have a panel and a button. Upon each click on the
    button, the panel will be either removed or appended to the view by the `ngIf`
    directive.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们有一个面板和一个按钮。每次点击按钮时，面板将通过`ngIf`指令被移除或附加到视图中。
- en: During the application initialization, if the result of the `"counter % 2 ==
    0"` expression is evaluated to `true`, the `ngOnChanges` method will be invoked.
    This happens because the values of the title and caption properties are going
    to be set for the first time.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序初始化期间，如果`"counter % 2 == 0"`表达式的结果被评估为`true`，`ngOnChanges`方法将被调用。这是因为标题和说明属性的值将首次设置。
- en: Right after this, the `ngOnInit` method will be called, since the component
    has been initialized. Once the component's initialization is completed, the change
    detection will be triggered, which will lead to the invocation of the `ngDoCheck`
    method that allows us to hook custom logic for detecting changes in the state.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，`ngOnInit`方法将被调用，因为组件已经初始化。一旦组件的初始化完成，将触发变更检测，这将导致调用`ngDoCheck`方法，允许我们钩入自定义逻辑以检测状态的变化。
- en: Note
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that you are not supposed to implement both `ngDoCheck` and `ngOnChanges`
    methods for the same component, since they are mutually exclusive. The example
    here does this for learning purposes only.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您不应该为同一个组件同时实现`ngDoCheck`和`ngOnChanges`方法，因为它们是互斥的。这里的示例仅用于学习目的。
- en: After the `ngDoCheck` method, the component's content will be followed by performing
    a check on it (`ngAfterContentInit` and `ngAfterContentChecked` will be invoked
    in this order). Right after this, the same will happen for the component's view
    (`ngAfterViewInit` followed by `ngAfterViewChecked`).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ngDoCheck`方法之后，组件的内容将被检查（按顺序调用`ngAfterContentInit`和`ngAfterContentChecked`）。紧接着，组件的视图也将发生同样的情况（`ngAfterViewInit`后跟`ngAfterViewChecked`）。
- en: Once the expression of the `ngIf` directive is evaluated to `false`, the entire
    component will be detached from the view, which will lead to the invocation of
    the `ngOnDestroy` hook.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`ngIf`指令的表达式被评估为`false`，整个组件将从视图中分离，这将导致`ngOnDestroy`钩子的调用。
- en: On the next button click, if the value of the expression of `ngIf` is equal
    to `true`, the same sequence of calls of the life cycle hooks as the one during
    the initialization phase will be executed.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个按钮点击时，如果`ngIf`表达式的值等于`true`，则与初始化阶段相同的生命周期钩子调用顺序将被执行。
- en: Defining generic views with TemplateRef
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TemplateRef定义通用视图
- en: 'We are already familiar with the concepts of inputs, content, and view children,
    and we also know when we can get a reference to them in the component''s life
    cycle. Now, we will combine them and introduce a new concept: `TemplateRef`.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了输入、内容和视图子项的概念，也知道在组件的生命周期中何时可以获取对它们的引用。现在，我们将把它们结合起来，并引入一个新概念：`TemplateRef`。
- en: 'Let''s take a step back and take a look at the last to-do application we developed
    earlier in this chapter. In the following screenshot, you can see what its UI
    looks like:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，看一下本章早些时候开发的最后一个待办事项应用程序。在下面的屏幕截图中，你可以看到它的用户界面是什么样子的：
- en: '![Defining generic views with TemplateRef](../images/00019.jpeg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![使用TemplateRef定义通用视图](../images/00019.jpeg)'
- en: If we take a look at its implementation in `ch4/ts/inputs-outputs/app.ts`, we'll
    see that the template used to render the individual to-do items is defined inside
    the template of the entire to-do application.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下它在`ch4/ts/inputs-outputs/app.ts`中的实现，我们会看到用于渲染单个待办事项的模板是在整个待办事项应用程序的模板中定义的。
- en: What if we want to use a different layout to render the to-do items? We can
    do this by creating another component called `Todo`, which encapsulates the responsibility
    of rendering them. Then, we can define separate `Todo` components for the different
    layouts we want to support. This way, we need to have *n* different components
    for *n* different layouts, even though we use only their templates.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用不同的布局来渲染待办事项呢？我们可以通过创建另一个名为`Todo`的组件来实现这一点，该组件封装了渲染它们的责任。然后，我们可以为我们想要支持的不同布局定义单独的`Todo`组件。这样，即使我们只使用它们的模板，我们也需要为*n*个不同的布局定义*n*个不同的组件。
- en: Angular 2 comes with a more elegant solution. Earlier in this chapter, we already
    discussed the template element. We said that it allows us to define a chunk of
    HTML that will not be processed by the browser. Angular 2 allows us to reference
    such template elements and use them by passing them as content children!
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2提供了一个更加优雅的解决方案。在本章的早些时候，我们已经讨论了模板元素。我们说它允许我们定义一块不会被浏览器处理的HTML。Angular
    2允许我们引用这样的模板元素，并通过将它们作为内容子元素传递来使用它们！
- en: 'Here is how we can pass the custom layout to our refactored `todo-app` component:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何将自定义布局传递给我们重构后的`todo-app`组件：
- en: '[PRE77]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In the template, we declare a variable called `todo`. Later in the template,
    we can use it to specify the way in which we want to visualize the content.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们声明了一个名为`todo`的变量。稍后在模板中，我们可以使用它来指定我们希望可视化内容的方式。
- en: 'Now, let''s see how we can get a reference to this template in the controller
    of the `TodoApp` component:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在`TodoApp`组件的控制器中获取对这个模板的引用：
- en: '[PRE78]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: All we do here is define a property called `itemsTemplate` and decorate it with
    the `@ContentChild` decorator. During the component's life cycle (more accurately,
    in `ngAfterContentInit`), the value of `itemsTemplate` will be set as a reference
    of the template that we passed as the content of the `todo-app` element.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是定义一个名为`itemsTemplate`的属性，并用`@ContentChild`装饰它。在组件的生命周期中（更准确地说，在`ngAfterContentInit`中），`itemsTemplate`的值将被设置为我们作为`todo-app`元素的内容传递的模板的引用。
- en: 'There is one more problem though—we need the template in the `TodoList` component,
    since that''s the place where we render the individual to-do items. What we can
    do is define another input of the `TodoList` component and pass the template directly
    from `TodoApp`:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 不过还有一个问题——我们需要在`TodoList`组件中的模板中使用模板，因为那是我们渲染单个待办事项的地方。我们可以做的是在`TodoList`组件中定义另一个输入，并直接从`TodoApp`中传递模板：
- en: '[PRE79]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We need to pass it as an input from the template of `TodoApp`:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从`TodoApp`的模板中将其作为输入传递：
- en: '[PRE80]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The only thing left is to use this template reference in the template of the
    `TodoList` application:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下的事情就是在`TodoList`应用程序的模板中使用这个模板引用：
- en: '[PRE81]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We explained the extended syntax of the `ngForOf` directive in the previous
    sections of this chapter. This snippet shows one more property of this directive
    that we can set: the `ngForTemplate` property. By default, the template of the
    `ngForOf` directive is the element it is used on. By specifying a template reference
    to the `ngForTemplate` property, we can use the passed `TemplateRef` instead.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几节中，我们解释了`ngForOf`指令的扩展语法。这个片段展示了这个指令的另一个属性：`ngForTemplate`属性。默认情况下，`ngForOf`指令的模板是它所用的元素。通过将模板引用指定为`ngForTemplate`属性，我们可以使用传递的`TemplateRef`。
- en: Understanding and enhancing the change detection
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和增强变更检测
- en: We already briefly described the change detection mechanism of the framework.
    We said that compared to AngularJS 1.x, where it runs in the context of the scope,
    in Angular 2, it runs in the context of the individual components. Another concept
    we mentioned is the zones, which basically intercept all the asynchronous calls
    that we can make using the browser APIs and provide execution context for the
    change detection mechanism of the framework. Zones fix the annoying problem we
    have in AngularJS 1.x, where when we use APIs outside of Angular, we need to explicitly
    invoke the `digest` loop.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简要描述了框架的变更检测机制。我们说过，与AngularJS 1.x相比，在Angular 2中，它在各个组件的上下文中运行。我们提到的另一个概念是zone，它基本上拦截了我们使用浏览器API进行的所有异步调用，并为框架的变更检测机制提供执行上下文。Zone解决了我们在AngularJS
    1.x中遇到的烦人问题，即当我们在Angular之外使用API时，需要显式调用`digest`循环。
- en: 'In [Chapters 1](part0015_split_000.html#E9OE1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 1. Getting Started with Angular 2"), *Getting Started with Angular 2*
    and [Chapter 2](part0019_split_000.html#I3QM1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 2. The Building Blocks of an Angular 2 Application"), *The Building Blocks
    of an Angular 2 Application*, we discussed that there are two main implementations
    of the change detector: `DynamicChangeDetector` and `JitChangeDetector`. The first
    one works great for environments with strict **CSP** (**Content-Security-Policy**)
    because of the disabled dynamic evaluation of JavaScript. The second one takes
    great benefits from the inline-caching mechanism of the JavaScript virtual machine
    and therefore brings great performance!'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0015_split_000.html#E9OE1-a118c4c18dd64e8ab73e171b466b6582 "第1章。开始使用Angular
    2")和[第2章](part0019_split_000.html#I3QM1-a118c4c18dd64e8ab73e171b466b6582 "第2章。Angular
    2应用程序的构建块")中，我们讨论了变更检测的两种主要实现：`DynamicChangeDetector`和`JitChangeDetector`。第一种对于具有严格**CSP**（**内容安全策略**）的环境非常有效，因为它禁用了JavaScript的动态评估。第二种则充分利用了JavaScript虚拟机的内联缓存机制，因此带来了很好的性能！
- en: In this section, we'll explore another property of the `@Component` decorator's
    configuration object, which provides us further control over the change detection
    mechanism of the framework by changing its strategy. By explicitly setting the
    strategy, we are able to prevent the change detection mechanism from running over
    a component's subtrees, which in some cases can bring great performance benefits.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨`@Component`装饰器配置对象的另一个属性，它通过改变策略为我们提供了对框架的变更检测机制更进一步的控制。通过显式设置策略，我们能够阻止变更检测机制在组件的子树上运行，这在某些情况下可以带来很好的性能优势。
- en: The order of execution of the change detectors
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变更检测的执行顺序
- en: Now, let's briefly describe the order in which the change detectors are invoked
    in a given component tree.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要描述一下变更检测在给定组件树中被调用的顺序。
- en: 'For this purpose, we will use the last implementation of the to-do application
    we have, but this time, we''ll extract the logic to render the individual to-do
    items into a separate component called `TodoItem`. In the following figure, we
    can see the application''s structure:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用我们拥有的待办事项应用程序的最后一个实现，但这次，我们将提取渲染单独待办事项的逻辑到一个名为 `TodoItem` 的单独组件中。在下图中，我们可以看到应用程序的结构：
- en: '![The order of execution of the change detectors](../images/00020.jpeg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![变更检测器的执行顺序](../images/00020.jpeg)'
- en: 'At the top level is the `TodoApp` component, which has two children: `InputBox`
    and `TodoList`. The `TodoList` component renders the individual to-do items in
    `TodoItem` components. The implementation details are not important for our purpose,
    so we are going to ignore them.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层是 `TodoApp` 组件，它有两个子组件：`InputBox` 和 `TodoList`。`TodoList` 组件在 `TodoItem` 组件中呈现单独的待办事项。实现细节对我们的目的不重要，所以我们将忽略它们。
- en: 'Now, we need to realize that there is an implicit dependency between the state
    of the parent component and its children. For instance, the state of the `TodoList`
    component depends completely on the to-do items that are located at its parent:
    the `TodoApp` component. There''s a similar dependency between `TodoItem` and
    `TodoList`, since the `TodoList` component passes the individual to-do items to
    a separate instance of the `TodoItem` component.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要意识到父组件和其子组件之间存在隐含的依赖关系。例如，`TodoList` 组件的状态完全取决于其父级 `TodoApp` 组件中的待办事项。`TodoItem`
    和 `TodoList` 之间也存在类似的依赖关系，因为 `TodoList` 组件将单独的待办事项传递给 `TodoItem` 组件的单独实例。
- en: '![The order of execution of the change detectors](../images/00021.jpeg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![变更检测器的执行顺序](../images/00021.jpeg)'
- en: Because of our last observation, the order of execution of the change detectors
    attached to the individual components is like the one shown on the preceding figure.
    Once the change detection mechanism run, initially it will perform a check over
    the `TodoApp` component. Right after this, the `InputBox` component will be checked
    for changes, followed by the `TodoList` component. In the end, Angular will invoke
    the change detector of the `TodoItem` component.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的最后观察，附加到各个组件的变更检测器的执行顺序如前图所示。一旦变更检测机制运行，它将首先对 `TodoApp` 组件进行检查。紧接着，将检查
    `InputBox` 组件是否有变化，然后是 `TodoList` 组件。最后，Angular 将调用 `TodoItem` 组件的变更检测器。
- en: You can trace the order of execution in the `ch4/ts/change_detection_strategy_order/app.ts`
    example, where each individual component logs a message once its `ngDoCheck` method
    is invoked.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `ch4/ts/change_detection_strategy_order/app.ts` 示例中跟踪执行顺序，其中每个单独的组件在调用其
    `ngDoCheck` 方法时记录一条消息。
- en: Note
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that only the components have an instance of a change detector attached
    to them; directives use the change detector of their parent component.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只有组件才有一个附加的变更检测器实例；指令使用其父组件的变更检测器。
- en: Change detection strategies
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变更检测策略
- en: 'The change detection strategies that Angular 2 provides are: `CheckOnce`, `Checked`,
    `CheckAlways`, `Detached`, `Default`, and `OnPush`. We will describe how we can
    take advantage of `OnPush` in detail, since it is very powerful when working with
    immutable data. Before taking a deep dive into `OnPush`, let''s briefly describe
    the other strategies.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 2 提供的变更检测策略有：`CheckOnce`、`Checked`、`CheckAlways`、`Detached`、`Default`
    和 `OnPush`。我们将详细描述如何充分利用 `OnPush`，因为在使用不可变数据时非常强大。在深入研究 `OnPush` 之前，让我们简要描述其他策略。
- en: 'Now, let''s import the TypeScript `enum`, which can be used to configure the
    strategy used for the individual components:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们导入 TypeScript `enum`，它可以用于配置用于各个组件的策略：
- en: '[PRE82]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, we can configure the `TodoList` component to use the `Checked` strategy:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以配置`TodoList`组件以使用`Checked`策略：
- en: '[PRE83]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This way, the change detection will be skipped until its mode (strategy) changes
    to `CheckOnce`. But what does it mean to prevent the change detection from running?
    You can go to `http://localhost:5555/dist/dev/ch4/ts/change_detection_strategy_broken/`
    and see the inconsistent behavior of the `TodoList` component. When you add a
    new to-do item in the input and you click on the button, it won't immediately
    appear in the list.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，变更检测将被跳过，直到其模式（策略）更改为`CheckOnce`。但是，阻止变更检测运行意味着什么？您可以转到`http://localhost:5555/dist/dev/ch4/ts/change_detection_strategy_broken/`，并查看`TodoList`组件的不一致行为。当您在输入中添加一个新的待办事项并单击按钮时，它不会立即出现在列表中。
- en: Now, let's try `CheckOnce`! Inside `ch4/ts/change_detection_strategy_broken/app.ts`,
    change the change detection strategy of the `TodoList` component to `ChangeDetectionStrategy.CheckOnce`.
    After refreshing the browser, try to add a new to-do item. The change should not
    be immediately reflected because `CheckOnce` will instruct the change detector
    to perform the check only once (in this case, during initialization), and after
    that, nothing will happen.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试`CheckOnce`！在`ch4/ts/change_detection_strategy_broken/app.ts`中，将`TodoList`组件的变更检测策略更改为`ChangeDetectionStrategy.CheckOnce`。刷新浏览器后，尝试添加一个新的待办事项。变更不应立即反映出来，因为`CheckOnce`会指示变更检测器仅执行一次检查（在这种情况下，在初始化期间），之后将不会发生任何变化。
- en: By default, it is used in the `CheckAlways` mode, which as its name states,
    doesn't prevent the change detector from running.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它在`CheckAlways`模式下使用，正如其名称所示，不会阻止变更检测器运行。
- en: If we declare the strategy of a given component to `Detached`, the change detector
    subtree will not be considered as a part of the main tree and will be skipped.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将给定组件的策略声明为`Detached`，则变更检测器子树将不被视为主树的一部分，并将被跳过。
- en: Performance boosting with immutable data and OnPush
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用不可变数据和OnPush来提高性能
- en: The last change detection strategy that we are going to describe is `OnPush`.
    It is extremely useful when the result that the given component produces depends
    only on its inputs. In such cases, we can pass immutable data to the inputs in
    order to make sure that it will not be mutated by any other component. This way,
    by having a component that depends only on its immutable inputs, we can make sure
    that it produces different user interfaces only once it receives different inputs
    (that is, different reference).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要描述的最后一个变更检测策略是`OnPush`。当给定组件产生的结果仅取决于其输入时，它非常有用。在这种情况下，我们可以将不可变数据传递给输入，以确保它不会被任何其他组件改变。通过这种方式，通过具有仅依赖于其不可变输入的组件，我们可以确保它仅在接收到不同输入时（即不同引用）产生不同的用户界面。
- en: In this section, we are going to apply the `OnPush` strategy on the `TodoList`
    component. Since it depends only on its inputs (the `todos` input), we want to
    make sure that its change detection will be performed only once it receives a
    new reference of the `todos` collection.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在`TodoList`组件上应用`OnPush`策略。由于它仅依赖于其输入（`todos`输入），我们希望确保它的变更检测仅在收到`todos`集合的新引用时执行。
- en: The essence of immutable data is that it cannot change. This means that once
    we add a new to-do item to the `todos` collection, we cannot change it; instead,
    the `add` (or in our case, `push`) method will return a new collection—a copy
    of the initial collection with the new item included.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据的本质是它不能改变。这意味着一旦我们向`todos`集合添加新的待办事项，我们就不能改变它；相反，`add`（或在我们的情况下，`push`）方法将返回一个新的集合——包含新项目的初始集合的副本。
- en: 'This may seem like a huge overhead—to copy the entire collection on each change.
    In big applications, this may have a big performance impact. However, we don''t
    need to copy the entire collection. There are libraries that implement immutable
    data structure using smarter algorithms: persistent data structures. Persistent
    data structures are out of the scope of the current content. Further information
    about them can be found in most computer science textbooks for advanced data structures.
    The good thing is that we don''t have to understand their implementation in depth
    in order to use them! There is a library called `Immutable.js` that implements
    a few commonly used immutable data structures. In our case, we are going to use
    the immutable list. Generally, the immutable list behaves just like a normal list,
    but on each operation that is supposed to mutate it, it returns a new list.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一个巨大的开销-每次更改都要复制整个集合。在大型应用程序中，这可能会对性能产生很大影响。然而，我们不需要复制整个集合。有一些库使用更智能的算法来实现不可变数据结构：持久数据结构。持久数据结构超出了当前内容的范围。关于它们的更多信息可以在大多数计算机科学高级数据结构的教科书中找到。好消息是，我们不必深入了解它们的实现就可以使用它们！有一个名为`Immutable.js`的库，它实现了一些常用的不可变数据结构。在我们的情况下，我们将使用不可变列表。通常，不可变列表的行为就像普通列表一样，但在每个应该改变它的操作上，它会返回一个新的列表。
- en: 'This means that if we have a list called `foo`, which is immutable, and we
    append a new item to the list, we are going to get a new reference:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们有一个名为`foo`的不可变列表，并且向列表添加一个新项，我们将得到一个新的引用：
- en: '[PRE84]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In order to take advantage of immutability, we need to install `Immutable.js`
    using npm.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用不可变性，我们需要使用npm安装`Immutable.js`。
- en: We've already done this in `ch4/ts/change_detection_strategy/app.ts`. `Immutable.js`
    is already part of `package.json`, which is located at the root directory of the
    project.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`ch4/ts/change_detection_strategy/app.ts`中做过这个。`Immutable.js`已经是`package.json`的一部分，它位于项目的根目录。
- en: Now, it's time to refactor our to-do application and make it use immutable data!
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候重构我们的待办事项应用程序，并使其使用不可变数据了！
- en: Using immutable data structures in Angular
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Angular中使用不可变数据结构
- en: 'Let''s take a look at how we currently keep the to-do items in the `TodoApp`
    component:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们目前如何在`TodoApp`组件中保存待办事项。
- en: '[PRE85]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We use an array of `Todo` items. The JavaScript array is mutable, which means
    that if we pass it to a component that uses the `OnPush` strategy, it is not safe
    to skip the change detection in case we get the same input reference. For instance,
    we may have two components that use the same list of to-do items. Both components
    can modify the list since it is mutable. This will lead to an inconsistent state
    to any of the components in case their change detection is not performed. That''s
    why we need to make sure that the list that holds the items is immutable. All
    we need to do in the `TodoApp` component in order to make sure that it holds its
    data in an immutable data structure is this:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个`Todo`项目的数组。JavaScript数组是可变的，这意味着如果我们将其传递给使用`OnPush`策略的组件，如果我们得到相同的输入引用，跳过变更检测是不安全的。例如，我们可能有两个使用相同待办事项列表的组件。由于它是可变的，两个组件都可以修改列表。如果它们的变更检测没有执行，这将导致任何一个组件处于不一致的状态。这就是为什么我们需要确保保存项目的列表是不可变的。为了确保`TodoApp`组件将其数据保存在不可变数据结构中，我们需要做的就是这样：
- en: '[PRE86]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In this way, we construct the `todos` property as an immutable list. Since
    the mutation operations of the immutable list return a new list, we need to make
    a slight modification in `addTodo` and `toggleTodoCompletion`:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们将`todos`属性构造为不可变列表。由于不可变列表的变异操作会返回一个新列表，我们需要在`addTodo`和`toggleTodoCompletion`中进行轻微修改：
- en: '[PRE87]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `addTodo` function looks exactly the same as before except that we set the
    result of the `push` method as a value to the `todos` property.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`addTodo`函数看起来与以前完全相同，只是我们将`push`方法的结果设置为`todos`属性的值。'
- en: In `toggleTodoCompletion`, we use the `update` method of the immutable list.
    As the first argument, we pass the index of the to-do item we want to modify,
    and the second argument is a callback that does the actual modification. Note
    that since we are using immutable data in this case, we copy the modified to-do
    item. This is required because it tells the `update` method that the item with
    the given index has been changed (since it is immutable, it is considered as changed
    only when it has a new reference), which means that the entire list has been changed.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在`toggleTodoCompletion`中，我们使用不可变列表的`update`方法。作为第一个参数，我们传递要修改的待办事项的索引，第二个参数是执行实际修改的回调函数。请注意，由于在这种情况下我们使用的是不可变数据，所以我们复制了修改后的待办事项。这是必需的，因为它告诉`update`方法给定索引的项目已经更改（因为它是不可变的，只有当它具有新引用时才被认为已更改），这意味着整个列表已更改。
- en: 'That was the complex part! Now let''s take a look at the `TodoList` component''s
    definition:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是复杂的部分！现在让我们来看一下`TodoList`组件的定义：
- en: '[PRE88]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Inside the `@Component` decorator, we set the `changeDetection` property to
    the value of the `OnPush` strategy. This means that the component will run its
    change detector only when any of its inputs gets a new reference. The template
    of the component stays exactly the same since `ngForOf` internally uses ES2015
    iterators to loop the items in the provided collection. They are supported by
    `Immutable.js`, so the changes in the template are not required.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@Component`装饰器内，我们将`changeDetection`属性设置为`OnPush`策略的值。这意味着组件只有在其任何输入获得新引用时才会运行其变更检测器。组件的模板保持完全相同，因为`ngForOf`在内部使用ES2015迭代器来循环提供的集合中的项目。它们受`Immutable.js`支持，因此不需要更改模板。
- en: Since we need the index of the changed item (the one we use in the `update`
    method of the `todos` collection in `TodoApp`), we change the type of the output
    of the component to `EventEmitter<number>`. In `toggleCompletion`, we emit the
    index of the changed to-do item.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要改变项目的索引（我们在`TodoApp`中的`todos`集合的`update`方法中使用的索引），我们将组件的输出类型更改为`EventEmitter<number>`。在`toggleCompletion`中，我们发出了更改的待办事项的索引。
- en: This is how we optimized our simple to-do application by preventing the change
    detection mechanism from running in the entire right subtree in case the parent
    component hasn't pushed an input with a new reference.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们通过防止变更检测机制在父组件没有推送新引用的情况下运行整个右子树来优化我们的简单待办事项应用程序的方法。
- en: Summary
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we went through the core building blocks of an Angular 2 application:
    directives and components. We built a couple of sample components, which show
    us the syntax to be used for the definition of these fundamental concepts. We
    also described the life cycle of each directive and the core set of features the
    given directive and component have. As the next step, we saw how we can enhance
    the performance of our application by using the `OnPush` change detection strategy
    with immutable data.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Angular 2应用程序的核心构建模块：指令和组件。我们构建了一些示例组件，展示了用于定义这些基本概念的语法。我们还描述了每个指令的生命周期和给定指令和组件的核心功能集。作为下一步，我们看到了如何通过使用不可变数据和`OnPush`变更检测策略来增强应用程序的性能。
- en: The next chapter is completely dedicated to the Angular 2 services and the dependency
    injection mechanism of the framework. We are going to look at how we can define
    and instantiate custom injectors and how we can take advantage of the dependency
    injection mechanism in our directives and components.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章完全致力于Angular 2服务和框架的依赖注入机制。我们将看看如何定义和实例化自定义注入器，以及如何利用依赖注入机制在我们的指令和组件中。
