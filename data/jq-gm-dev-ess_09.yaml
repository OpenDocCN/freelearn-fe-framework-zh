- en: Chapter 9. Making Your Game Mobile
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章 制作您的游戏移动端
- en: Mobile devices are quickly becoming the go-to platform for gaming. The good
    news is that the web browsers in most of these devices are pretty good, and in
    most cases, you can make your mobile game run smoothly on them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备正在迅速成为游戏的首选平台。好消息是，大多数这些设备中的 Web 浏览器都相当不错，在大多数情况下，您可以使您的移动游戏在其上顺利运行。
- en: These devices have, however, some memory and power limitations. There are some
    games that simply won't work on a mobile browser at the moment. You cannot expect
    to have just as many sprites running smoothly on your smartphone that has one-tenth
    of the power of your desktop computer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这些设备具有一些内存和电源限制。目前有一些游戏在移动浏览器上根本无法运行。您不能指望在智能手机上运行和桌面计算机性能只有十分之一的设备上顺畅运行同样数量的精灵。
- en: 'On the plus side, a mobile device offers a few capabilities you typically don''t
    find on a desktop:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备的一个优点是，它提供了一些通常在桌面上找不到的功能：
- en: The multi-touch interface allows for new kinds of interaction with your game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多点触摸界面允许您以新的方式与您的游戏互动
- en: The device orientation API allows you to control your game or UI in interesting
    ways
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备方向 API 允许您以有趣的方式控制您的游戏或 UI。
- en: Most devices allow your game to be installed to the "springboard" just like
    a native app, blurring the line between browser games and native ones
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数设备允许您的游戏像原生应用一样安装到“springboard”，模糊了浏览器游戏和原生游戏之间的界线。
- en: An offline cache allows your game to work even without an Internet connection
    active on the device
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离线缓存允许您的游戏即使在设备上没有活动的互联网连接时也能工作。
- en: 'In this chapter, we will take our MMORP and make it work on an iOS device.
    Most of the APIs we will use are de facto standards and are supported on Android
    as well. Here is a short overview of the topics we will cover:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将采取我们的 MMORP 并使其在 iOS 设备上运行。我们将使用的大多数 API 都是事实上的标准，并且也支持 Android。以下是我们将要涵盖的主题的简要概述：
- en: Dealing with the performance limitations of mobile devices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理移动设备的性能限制
- en: Adding multi-touch control to our game
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的游戏添加多点触控控制
- en: Integrating our game with the springboard and other mobile-specific configuration
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的游戏与 springboard 和其他移动特定配置集成
- en: Using the device orientation API
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用设备方向 API
- en: Taking advantage of web storage and the offline application cache
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Web 存储和离线应用缓存
- en: 'We chose to only consider the iOS side of things for several reasons:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择只考虑 iOS 方面的原因有几个：
- en: iOS is still globally the most commonly used mobile OS even though Android has
    caught up recently (depending on the source and what exactly is considered a mobile
    device, you will find market share for iOS between 30 percent and 50 percent).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管安卓最近赶上了，但 iOS 仍然是全球使用最广泛的移动操作系统（根据来源和什么被认为是移动设备，您会发现 iOS 的市场份额在 30% 到 50%
    之间）。
- en: Even if the choice Apple made to forbid a third-party browser for its OS has
    been very controversial, it has the positive side effect of making web development
    much easier. Indeed, you don't have to deal with too much diversity on the browser
    side.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使苹果选择禁止第三方浏览器进入其操作系统在某种程度上引起了争议，但它具有积极的副作用，即使 Web 开发变得更加容易。实际上，您不必在浏览器端处理太多的差异。
- en: Most of the specific APIs available on mobile browsers have first been created
    or implemented by Apple on Webkit mobile.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动浏览器上可用的大多数特定 API 首先是由苹果在 Webkit 移动端上创建或实现的。
- en: Before we begin, I'd like to emphasize the fact that this is a field that evolves
    even faster than the rest of the web development world. New APIs are regularly
    added and the performance of each new device is significantly better than the
    one it replaces. If you are serious about making games that take full advantage
    of mobile devices, you should invest some time to keep yourself up-to-date with
    those changes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我想强调这一点，这是一个比 Web 开发世界其他领域发展得更快的领域。新的 API 定期添加，每个新设备的性能明显优于其替代品。如果您认真考虑制作充分利用移动设备的游戏，您应该投入一些时间来使自己了解这些变化。
- en: Making your game run well on mobile devices
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使您的游戏在移动设备上运行良好
- en: Performance issues are probably the single biggest problem you will encounter
    when developing a browser-based mobile game, the main reason being that a wide
    variety of devices is available, each with very different capabilities.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 性能问题可能是开发基于浏览器的移动游戏时会遇到的最大问题，主要原因是有各种各样的设备可用，每个设备的功能都非常不同。
- en: Even if you chose to support only iOS, which is probably the simplest ecosystem
    at the moment, you will still have very large differences in performance, screen
    resolution, and browser support.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你选择仅支持iOS，这可能是目前最简单的生态系统，你仍然会在性能、屏幕分辨率和浏览器支持方面有很大的差异。
- en: To get an idea of the complexity of the situation, take a look at the supported
    device for jQuery Mobile ([http://jquerymobile.com/gbs/](http://jquerymobile.com/gbs/)).
    For your game, you should probably have an approach similar to theirs; select
    a few device/software versions you will target. Your game should work flawlessly
    on those.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解情况的复杂性，可以查看jQuery Mobile支持的设备（[http://jquerymobile.com/gbs/](http://jquerymobile.com/gbs/)）。对于你的游戏，你可能应该有一个类似于他们的方法；选择几个设备/软件版本作为目标。你的游戏应该在这些设备上无缝运行。
- en: Then make sure that the game runs without errors on a broader selection of devices.
    On those devices, performance can be less than ideal. Finally, draw a clear line
    beyond which you won't even bother to test whether your game runs at all.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后确保游戏在更广泛的设备上无错误运行。在这些设备上，性能可能不理想。最后，明确划定一个线，超过这条线你甚至都不会去测试游戏是否能够运行。
- en: The size of each of these categories will depend on how much effort you want
    to invest in them. One problem is that you can't really use the emulators provided
    with each platform's SDK to investigate performance issues. This means that, in
    the end, you will have to test your game on actual devices.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类别的大小将取决于你想要投入多少精力。一个问题是你实际上不能使用每个平台SDK提供的模拟器来调查性能问题。这意味着最终你将不得不在实际设备上测试你的游戏。
- en: This is not a problem for large companies, but if you are a small indie game
    developer, you will probably find this to be a limiting factor on the number of
    devices you will support.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于大公司来说不是问题，但如果你是一个小型独立游戏开发者，你可能会发现这是一个限制你支持的设备数量的因素。
- en: Detecting mobile browsers
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测移动浏览器
- en: 'To cope with the differences between the desktop and the mobile device there
    are many possible approaches:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对桌面和移动设备之间的差异，有许多可能的方法：
- en: Design one game only with mobile devices in mind. It will run without any problem
    on desktops too but may not be as beautiful or as complex as it might have been
    had it been designed specifically for desktops. The good thing is that if players
    compete with one another in your game, they will all be on the same level.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只设计一个游戏，专注于移动设备。它也可以在桌面上毫无问题地运行，但可能不像专门为桌面设计的那样美观或复杂。好处是，如果玩家在你的游戏中相互竞争，他们都将处于同一水平。
- en: Design two games, one optimized for desktop and one for mobile. This is almost
    twice the work, but you will probably share a big part of the art, music, and
    server-side code (if any). This is the ideal solution in terms of performances,
    but if you have PvP (player versus player) in your game player on one platform,
    it could be advantageous compared to those in the other platforms.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计两个游戏，一个优化用于桌面，一个用于移动。这几乎是两倍的工作量，但你可能会共享大部分艺术、音乐和服务器端代码（如果有）。从性能上讲，这是理想的解决方案，但如果你的游戏中有PvP（玩家对玩家），那么在一个平台上的玩家与其他平台上的玩家相比可能更具优势。
- en: You could design only one game but add some purely cosmetic features if the
    game runs on a desktop browser. With this solution, you have only one code base,
    but it may be slightly more complex. The problem with the PvP game remains.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果游戏在桌面浏览器上运行，你可以只设计一个游戏，但是增加一些纯粹的装饰性功能。通过这种解决方案，你只需要一个代码库，但可能会稍微复杂一些。PvP游戏的问题仍然存在。
- en: The approach you will choose to follow will depend on your priorities, but for
    the second and third approaches, you will need to detect what kind of platform
    the player is running your game on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你将选择遵循的方法将取决于你的优先级，但对于第二和第三种方法，你需要检测玩家运行游戏的平台类型。
- en: 'Depending on how precise you want to be, this can be quite a complex task.
    There are basically two general methods you can use: client-side detecting and
    server-side detecting.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你想要多精确，这可能是一个相当复杂的任务。基本上有两种一般的方法可以使用：客户端检测和服务器端检测。
- en: Client-side browser detection
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端浏览器检测
- en: If what you want is to implement the third approach described previously, detecting
    the browser on the client side makes a lot of sense. The most common approach
    is to use the `navigator.userAgent` string (**UA** for short). This variable contains
    a very long and cryptic string that holds a lot of information.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要实现之前描述的第三种方法，即在客户端检测浏览器，那么这是非常合理的。最常见的方法是使用`navigator.userAgent`字符串（**UA**简称）。这个变量包含一个非常长和晦涩的字符串，其中包含了大量信息。
- en: It's important to keep in mind that the browser can fake this string (this is
    called **UA spoofing**). For example, in Safari, you can specify which browser
    it should imitate. The good thing is that mobile devices typically don't offer
    this without some hacking on the user part. Furthermore, some very different mobiles
    have the same UA such as the desktop and mobile versions of Internet Explorer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是浏览器可以伪造这个字符串（这被称为**UA伪装**）。例如，在 Safari 中，你可以指定它模仿哪个浏览器。好处是移动设备通常不会在用户部分进行某些黑客行为。此外，一些非常不同的移动设备具有相同的
    UA，例如桌面和移动版本的 Internet Explorer。
- en: 'A big part of it is here for legacy reasons, and you really shouldn''t bother
    with it, but by looking at the occurrence of a given string in this longer string,
    you can detect what kind of browser you''re dealing with. For example, if the
    `userAgent` string contains `iPhone`, you know that the browser is Safari mobile
    running on an iPhone. The corresponding JavaScript would be something like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 其中很大一部分是出于遗留原因，你真的不应该关心它，但通过查看这个更长字符串中特定字符串的出现，你可以检测到你正在处理的浏览器的类型。例如，如果`userAgent`字符串包含`iPhone`，你就知道浏览器是在
    iPhone 上运行的 Safari 移动版。相应的 JavaScript 代码可能如下所示：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now this will work for an iPhone, but if your user is using an iPad, it won''t
    be detected. You have to look for the string `iPad` to detect an iPad. The same
    goes for iPod Touch, where you would have to look for `iPod`. If you want to differentiate
    between iDevices and others, you could do something like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这对于 iPhone 可能有效，但如果你的用户使用的是 iPad，则不会被检测到。你必须查找字符串`iPad`来检测 iPad。对于 iPod Touch
    也是一样，你必须查找`iPod`。如果你想区分 iDevices 和其他设备，你可以这样做：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you want the granularity to detect individual devices, you should use the
    following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望精确检测各个设备，你应该使用以下代码：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can imagine, this list could quickly become quite long if you want to
    detect a large number of devices. Hopefully, there exist code snippets that do
    exactly what you are aiming to do. If you just want to detect mobile devices,
    you can use the script provided at [http://detectmobilebrowsers.com/](http://detectmobilebrowsers.com/).
    If you want more control of what exactly it is that you detect, you can use the
    script provided by the always excellent Peter-Paul Koch at [http://www.quirksmode.org/js/detect.html](http://www.quirksmode.org/js/detect.html).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的，如果你想要检测大量设备，这个列表可能很快变得相当长。希望存在着确切完成你目标的代码片段。如果你只想检测移动设备，你可以使用 [http://detectmobilebrowsers.com/](http://detectmobilebrowsers.com/)
    提供的脚本。如果你想更精确地控制你要检测的内容，你可以使用由总是出色的 Peter-Paul Koch 提供的脚本，网址为 [http://www.quirksmode.org/js/detect.html](http://www.quirksmode.org/js/detect.html)。
- en: Server-side detection
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器端检测
- en: If what you want is to implement the second approach (different versions of
    your game for mobile and desktop browsers), you will probably want to detect the
    player's browser on the server and redirect them to the right version of the game.
    As with client-side detection, the most common technique uses the browser's `userAgent`
    string.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要实现第二种方法（为移动和桌面浏览器提供不同版本的游戏），你可能会想要在服务器上检测玩家的浏览器，并将他们重定向到游戏的正确版本。与客户端检测一样，最常见的技术使用浏览器的`userAgent`字符串。
- en: 'If you use PHP, you will be happy to learn that it almost supports browser
    detection out of the box. Indeed, you can use the `get_browser` function in conjunction
    with an up-to-date `php_browscap.ini` file to get information about the browser
    (you can find various versions of this file at [http://tempdownloads.browserscap.com/](http://tempdownloads.browserscap.com/)).
    You will have to configure the `browscap` property in your `php.ini` file to point
    to your `php_browscap.ini` file for it to be recognized. The code to replicate
    the client-side detection we''ve implemented previously would look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 PHP，你会很高兴地了解到它几乎支持开箱即用的浏览器检测。实际上，你可以使用 `get_browser` 函数与一个最新的 `php_browscap.ini`
    文件结合使用，以获取有关浏览器的信息（你可以在 [http://tempdownloads.browserscap.com/](http://tempdownloads.browserscap.com/)
    找到各种版本的此文件）。你将不得不在你的 `php.ini` 文件中配置 `browscap` 属性，将其指向你的 `php_browscap.ini` 文件，以便它被识别。复制我们先前实现的客户端检测的代码将如下所示：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This has the same shortcoming as the client-side implementation: the browser
    can forge the `userAgent` string.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这与客户端实现具有相同的缺点：浏览器可以伪造 `userAgent` 字符串。
- en: Should you really detect the browser?
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你真的需要检测浏览器吗？
- en: It's not generally considered good practice to detect the browser. The preferred
    solution is generally to use feature detection. For example, this really makes
    sense if you want to use device orientation, then you will simply check if the
    corresponding API is available at runtime.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不建议检测浏览器。首选解决方案通常是使用功能检测。例如，如果你想使用设备方向，那么你只需在运行时检查相应的 API 是否可用，这样做真的很有意义。
- en: In this situation, it is a far more robust approach, but what we're talking
    about here is optimizing the game performance-wise. There is no feature that you
    can detect that will provide information about this. In this situation, I would
    argue that browser detection makes sense.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这是一种更为健壮的方法，但我们讨论的是对游戏性能的优化。没有可以检测的特性会提供有关这方面的信息。在这种情况下，我认为检测浏览器是有意义的。
- en: A more robust alternative would be to run a very quick benchmark before starting
    the game to extrapolate the performance of the device your game is running on.
    This would be a lot of work but can be worth the effort in situations where you
    can scale the performance of your game linearly. For example, you could define
    the number of trees you use to draw a forest in a very fine way, say, 80 percent
    of the maximum number of trees.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 更健壮的替代方案是在开始游戏之前运行一个非常快速的基准测试，以推断游戏运行的设备的性能。这将是很多工作，但在可以线性地扩展游戏性能的情况下，这样做可能是值得的。例如，你可以非常精细地定义绘制森林所使用的树的数量，比如，最大树数的
    80%。
- en: This is typically the case if you use a lot of particle effects. Then it's very
    easy to change the total number of particles you use to match the device performance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用了大量的粒子效果，通常就会出现这种情况。然后，非常容易调整你使用的粒子总数以匹配设备的性能。
- en: Performance limitation – memory
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能限制 - 内存
- en: Now that we're able to detect that the game runs on a mobile device, we will
    be able to adapt to the device's limitations. The first thing that probably pops
    up in your mind when talking about performance is the speed of the processor,
    but most of the time, memory is a bigger limitation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够检测到游戏在移动设备上运行，我们将能够适应设备的限制。谈论性能时，你脑海中可能首先浮现的是处理器的速度，但大多数情况下，内存是一个更大的限制。
- en: 'On the desktop, you don''t need to think about memory anymore, in most cases
    (except to avoid memory leaks). On mobile devices, memory is a much more limited
    resource, and sometimes, simply loading a big image is too much for the browser.
    For example, the maximum allowed size for an image is as follows for iDevices:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面上，你不再需要考虑内存，大多数情况下（除了避免内存泄漏）。在移动设备上，内存是一种更为有限的资源，有时，仅仅加载一个大图像对浏览器来说就太多了。例如，对于
    iDevices，允许的最大图像尺寸如下：
- en: '|   | **< 256 MB of RAM** | **> 256 MB of RAM** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|   | **< 256 MB 的 RAM** | **> 256 MB 的 RAM** |'
- en: '| **GIF, PNG, and TIFF images** | 3 megapixels | 5 megapixels |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **GIF、PNG 和 TIFF 图像** | 3 百万像素 | 5 百万像素 |'
- en: '| **JPEG** | 32 megapixels | 32 megapixels |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **JPEG** | 32 百万像素 | 32 百万像素 |'
- en: '| **Canvas DOM element** | 3 megapixels | 5 megapixels |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **Canvas DOM 元素** | 3 百万像素 | 5 百万像素 |'
- en: It's important to note that this has absolutely nothing to do with the compression
    of the image. Indeed, though it's important to compress your images to reduce
    the time it will take to download them for the memory imprint, the only thing
    that matters is the resolution.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这与图像的压缩毫无关系。事实上，尽管压缩图像以减少下载所需的时间对内存印记很重要，但唯一重要的是分辨率。
- en: So if compression isn't going to help, what can we do? Let's take the example
    of our multiplayer RPG. There, we used a very large image with all the tiles for
    our tile map. Many of those tiles are not actually used in the map we created
    for our game. So, a very simple way to reduce this very large image is to remove
    all the tiles we don't need.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果压缩不会有所帮助，我们该怎么办呢？让我们以我们的多人在线角色扮演游戏为例。在那里，我们使用了一个非常大的图像，其中包含我们瓦片地图的所有图块。实际上，我们游戏中创建的地图并未使用许多这些图块。因此，减少这个非常大的图像的一个非常简单的方法是删除我们不需要的所有图块。
- en: This means that instead of having one large image that you will use through
    the whole game, you will have a smaller image for each zone. This will increase
    the complexity of the code because it means managing the transition between zones,
    but it has the advantage of not degrading your level design at all.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，您不再拥有一个整个游戏都会使用的大图像，而是为每个区域都有一个较小的图像。这将增加代码的复杂性，因为它意味着管理区域之间的过渡，但它有一个优点，即完全不会降低您的级别设计。
- en: 'In some situations, even with this technique you will find it hard to reduce
    the size of the image enough. One easy solution is to have two versions of the
    level, one for the desktop and the other for mobile platforms. On the mobile version,
    you will reduce the variety of tiles. For example, in our game we use multiple
    tiles to render grass, as shown in the following figure:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，即使使用这种技术，您可能会发现很难将图像的大小减小到足够小。一个简单的解决方案是为桌面和移动平台分别设置两个版本的级别。在移动版本中，您将减少图块的种类。例如，在我们的游戏中，我们使用多个图块来渲染草地，如下图所示：
- en: '![Performance limitation – memory](img/5060OT_09_01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![性能限制 - 内存](img/5060OT_09_01.jpg)'
- en: Here, we could simply use a single tile instead. Sure, the resulting graphics
    will be less varied, but it will dramatically decrease the number of tiles you'll
    need. This has, however, the disadvantage of requiring you to maintain two separate
    versions of each level.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以简单地使用一个单一的图块。当然，生成的图形将会变得不那么多样化，但它将大大减少您所需的图块数量。然而，这种做法的缺点是需要您维护每个级别的两个单独版本。
- en: Performance limitation – speed
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能限制 - 速度
- en: The performance for mobile devices varies greatly, but even the fastest ones
    are still way slower than any desktop. This means that there are games that simply
    won't run on mobile devices, no matter how much effort you put into them. There
    are, however, many games that you can slightly transform to make them run at a
    reasonable speed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备的性能差异很大，但即使是最快的移动设备也比任何桌面设备都要慢得多。这意味着有些游戏根本无法在移动设备上运行，无论您付出多少努力。然而，有许多游戏可以稍加改造，使其以合理的速度运行。
- en: When making a DOM-based game, there are not many areas where you can speed things
    up. The first thing you should do is to try reducing the number of sprites or
    tiles.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 制作基于 DOM 的游戏时，您可以加快速度的地方并不多。您应该做的第一件事是尝试减少精灵或图块的数量。
- en: Specifying the page's visible area
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定页面的可见区域
- en: A very simple way to reduce the number of tiles is to make the game area smaller.
    You may think this is a very bad idea since what you really want is for the game
    area to fill up the entire screen, which means adapting to the device resolution.
    Well, yes...and no! Yes, you want the game area to fill the entire screen, but
    no, that doesn't necessarily mean using the full resolution.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 减少图块数量的一个非常简单的方法是使游戏区域更小。您可能会认为这是一个非常糟糕的主意，因为您真正想要的是游戏区域填满整个屏幕，这意味着要适应设备的分辨率。好吧，是的...也不是！是的，您希望游戏区域填满整个屏幕，但不，这并不一定意味着使用完整的分辨率。
- en: Mobile browsers offer a very handy `meta` property that allows you to specify
    how the browser should manage the page width. This will come in handy here since
    we can basically choose the size you want for the game area and then force the
    browser to display it in fullscreen mode.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 移动浏览器提供了一个非常方便的`meta`属性，允许您指定浏览器应该如何管理页面宽度。这在这里将非常有用，因为我们基本上可以选择游戏区域的大小，然后强制浏览器将其显示在全屏模式下。
- en: 'This property is called viewport, and to specify a given width for the screen
    you can simply write:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性称为视口，要为屏幕指定一个给定的宽度，您可以简单地写：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We configure two different behaviors here. First, we say to the browser that
    the original width of the page is 480 pixels. Let's say the device's native resolution
    is 960 pixels; this will mean that the page will be zoomed in to. Had the device
    resolution been 320 pixels, the page would have been zoomed out of.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里配置了两种不同的行为。首先，我们告诉浏览器页面的原始宽度为 480 像素。假设设备的原生分辨率为 960 像素；这意味着页面将被放大。如果设备分辨率为
    320 像素，页面将被缩小。
- en: The second thing we do here is to disable the zoom function for the user. This
    is not necessary if you want to use touch events later; to control the game, you
    want to be sure that the user won't zoom in or out while trying to manipulate
    the game.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的第二件事是禁用用户的缩放功能。如果你想后续使用触摸事件来控制游戏，这是不必要的；为了控制游戏，你要确保用户在尝试操作游戏时不会放大或缩小页面。
- en: Level of details
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 细节级别
- en: Reducing the number of sprites can be tricky. For example, you don't want to
    reduce the number of NPCs (Non Player Characters) or enemies in the game. Identifying
    the element that can be removed is a tedious task.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 减少精灵的数量可能会很棘手。例如，你不希望减少游戏中的 NPC（非玩家角色）或敌人的数量。识别可以移除的元素是一项繁琐的任务。
- en: The following figure is taken from [Chapter 5](ch05.html "Chapter 5. Putting
    Things into Perspective"), *Putting Things into Perspective*. It's a quick reminder
    of the structure of the tile map we used for our RPG.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片摘自 [第 5 章](ch05.html "第 5 章. 透视")，*透视*。这是我们为我们的 RPG 使用的瓦片地图的结构的快速提醒。
- en: '![Level of details](img/5060OT_09_02.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![细节级别](img/5060OT_09_02.jpg)'
- en: If you keep the purely decorative elements in the last two layers in this figure
    it becomes easy to reduce the number of sprites; if needed, just delete those
    two layers and you're done.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个图中最后两层中纯装饰性的元素保留下来，减少精灵的数量就变得很容易；如果需要，只需删除这两层，就完成了。
- en: It doesn't necessarily mean that you have to get rid of all those elements.
    What you could do is have two different versions of those layers, one with a lot
    of elements and one with way fewer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不一定意味着你必须摆脱所有这些元素。你可以做的是有两个不同版本的这些层，一个有很多元素，一个元素更少。
- en: If you really need to reduce the number of sprites even further, you will have
    to consider the impact it will have on the gameplay. There is no standard answer
    here; you will have to approach each game individually and find the right balance
    between keeping your gameplay like you originally intended the and speed of your
    game.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的需要进一步减少精灵的数量，你将不得不考虑这将对游戏玩法产生的影响。这里没有标准答案；你将需要针对每个游戏进行独立的处理，并在保持游戏玩法与游戏速度之间找到正确的平衡。
- en: Touch control
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触摸控制
- en: Until now we've only talked about the problematic parts of mobile devices, but
    there are also advantages that come with these devices. Touch screens allow for
    a very interesting game mechanism (and multi-touch screens even more so).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只谈到了移动设备的问题部分，但是这些设备也带来了一些优势。触摸屏允许非常有趣的游戏机制（而且多点触摸屏效果更好）。
- en: In this section, we will implement two different ways of controlling our game
    with touches, but it's really a field where you can be creative and find novel
    and engaging ways for the player to interact with your game. What is important
    to know is that the API for touch control is not standard, and mobile devices
    may implement it with some differences. Nevertheless, the code shown in the following
    section should work on iOS and on recent versions of Android.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将实现两种不同的触摸控制方式，但这确实是一个可以发挥创意、找到新颖而引人入胜的方式让玩家与你的游戏进行交互的领域。重要的是要知道触摸控制的
    API 不是标准的，而且移动设备可能会以一些不同的方式实现它。尽管如此，下一节中显示的代码应该可以在 iOS 和最新版本的 Android 上正常工作。
- en: 'Both interfaces we will implement are based on the same basic idea: the whole
    screen is a joypad, and no visible UI elements are used. The advantage of this
    is that the bigger the surface used for control, the more precise the control.
    The disadvantage is that you need to explain to the user how it works if he/she
    will not be able to discover it by himself/herself by simply looking at the screen.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现的两个界面都基于同样的基本思想：整个屏幕都是一个摇杆，没有可见的 UI 元素被使用。这样做的优势是，用于控制的表面越大，控制就越精确。缺点是，如果用户不是通过简单地看屏幕就能发现它是如何工作的，你就需要解释给用户听。
- en: The code we use can easily be adapted to work with smaller control placed at
    the bottom/side of the screen.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的代码可以很容易地调整为适用于放置在屏幕底部/侧边的较小控件。
- en: D-pad
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 十字键
- en: 'A d-pad (short for directional pad) is a kind of control that was used in old-school
    game consoles. It provides a few predefined directions the user can choose between
    (for example, up, down, left, and right). By contrast, joysticks provide an analogic
    interface, where the player can choose a precise direction (for example, a 30
    degree angle). The first control methods we will implement divide the screen into
    five zones as shown in the following figure:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 方向键（缩写为D-pad）是一种在老式游戏机上使用的控制方式。它提供了几个预定义的方向供用户选择（例如，上、下、左和右）。相比之下，摇杆提供了一个模拟接口，玩家可以选择精确的方向（例如，30度角度）。我们将要实现的第一个控制方法将屏幕划分为如下图所示的五个区域：
- en: '![D-pad](img/5060OT_09_03.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![方向键](img/5060OT_09_03.jpg)'
- en: The advantage is that this method has a one-to-one mapping with the keyboard
    control. If the player touches the **UP** zone, it will correspond to pressing
    the up arrow on the keyboard and so on for the other border zones. If the player
    touches the center zone, it will correspond to pressing the Space bar.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 优点在于此方法与键盘控制有一一对应关系。如果玩家触摸**上**区域，它将对应于按下键盘上的上箭头，其他边界区域类似。如果玩家触摸中心区域，它将对应于按下空格键。
- en: 'To implement this, we will create five virtual keys and expand the part of
    the code that checks for keyboard input to check for that as well. The following
    code extract is the definition of those virtual keys:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们将创建五个虚拟键，并扩展检查键盘输入的代码部分以进行检查。下面的代码摘录是定义这些虚拟键的部分：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, those keys have ID fields. This is necessary because we are
    dealing with multi-touch events, and we have to be able to identify which touch
    events ended to turn the `on` field back to `false` when the player lifts his/her
    finger.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些键具有ID字段。这是必要的，因为我们正在处理多点触摸事件，我们必须能够识别哪些触摸事件结束时将`on`字段切换回`false`，玩家抬起手指时。
- en: To detect that the player touches the screen, we will register a `touchstart`
    event handler. This event is similar to the `onmousedown` event, except that it
    contains a list of touches. This makes sense because we're dealing with multi-touch
    input and we cannot simply assume that only one finger is touching the screen.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测玩家触摸屏幕，我们将注册一个`touchstart`事件处理程序。这个事件类似于`onmousedown`事件，除了它包含一个触摸列表。这是有道理的，因为我们正在处理多点触摸输入，我们不能简单地假设只有一个手指触摸屏幕。
- en: 'All those touches are stored in the `event.changedTouches` array. In your event
    handler, you simply need to look at each of them. The following code extract is
    the whole event handler:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些触摸都存储在`event.changedTouches`数组中。在您的事件处理程序中，您只需查看每个触摸。下面的代码摘录是整个事件处理程序：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since "jQuery Core" doesn't support touch events, we use the standard way to
    register event handlers. Then we prevent the events from bubbling up to make sure
    they won't produce zooms, scroll, and so on. The last part of this event handler
    checks for each touch to find out what zone it's on, switches the `on` flag of
    the corresponding key to `true`, and sets the correct `id` value for tracking.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于"jQuery核心"不支持触摸事件，我们使用标准方法来注册事件处理程序。然后我们阻止事件冒泡，以确保它们不会产生缩放、滚动等。此事件处理程序的最后一部分检查每个触摸，以确定它在哪个区域，将相应按键的`on`标志切换为`true`，并设置正确的`id`值以进行跟踪。
- en: Now we need to be able to detect when the touch ends. This is done with `touchend`
    event. This event works in a similar way to the `touchstart` one, and the code
    of the event handler has the same structure. Here we don't need to worry about
    the position of the touch but only about its ID. We will then switch the `on`
    flag of the corresponding touch back to `false`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要能够检测触摸何时结束。这通过`touchend`事件完成。这个事件的工作方式类似于`touchstart`，事件处理程序的代码结构相同。在这里，我们不需要担心触摸的位置，而只需要关注其ID。然后，我们将相应触摸的`on`标志切换回`false`。
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that our virtual keys hold the correct value, we can use them in our code
    as we used the array that holds the state of the real keys. That''s exactly what
    the following code does; the modified parts have been highlighted:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的虚拟键持有正确的值，我们可以像使用保存真实键状态的数组一样在我们的代码中使用它们。下面的代码正是如此；修改部分已经突出显示：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With these simple modifications, we've implemented the first version of our
    touch control.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些简单的修改，我们已经实现了我们的触摸控制的第一个版本。
- en: Analog joystick
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟摇杆
- en: 'The previous control method was fine, but you may want to allow the player
    a more natural way to make the avatar move. This is where the following method
    comes in. Here, we only have two zones: a small one in the center that works like
    the Space bar and the rest of the screen. The following figure shows these two
    zones:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的控制方法不错，但您可能想要让玩家以更自然的方式移动角色。这就是下面的方法发挥作用的地方。这里，我们只有两个区域：中心的一个小区域，它的作用类似于空格键，以及屏幕的其余部分。下图显示了这两个区域：
- en: '![Analog joystick](img/5060OT_09_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![模拟摇杆](img/5060OT_09_04.jpg)'
- en: 'If the player touches this bigger zone, the avatar will move in the direction
    of the touch. If the fingers of the player change direction, the avatar''s movement
    will change accordingly, as shown in the following figure:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家触摸这个更大的区域，角色将朝触摸的方向移动。如果玩家的手指改变方向，角色的移动也会相应改变，如下图所示：
- en: '![Analog joystick](img/5060OT_09_05.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![模拟摇杆](img/5060OT_09_05.jpg)'
- en: 'To implement this means slightly changing the way the player is controlled,
    so we''ve added a new method to the `player` object: `direction`. This function
    takes an angle in degrees and extrapolates the most appropriate animation as well
    as the new position of the player. The following code shows this function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们稍微改变了玩家控制的方式，因此我们在`player`对象中添加了一个新方法：`direction`。该函数接受以度为单位的角度，并推断出最合适的动画，以及玩家的新位置。下面的代码显示了这个函数：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There is only one piece of code worth pointing out here, highlighted in the
    preceding snippet. To compute the vertical and horizontal movement from the angle,
    we use sine and cosine functions. Their meaning is explained in the following
    figure:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只有一小段代码值得指出，如前面的片段所示。要从角度计算垂直和水平移动，我们使用正弦和余弦函数。它们的含义在下图中解释：
- en: '![Analog joystick](img/5060OT_09_06.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![模拟摇杆](img/5060OT_09_06.jpg)'
- en: Those two functions will give us a number between -1 and 1 that represent how
    much the player should move along each axis. We then simply multiply this by the
    maximum movement (3, in our case) to get the real movement along each axis.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数将给我们一个介于-1和1之间的数字，表示玩家应该沿每个轴移动多少。然后我们简单地将这个数乘以最大移动量（在我们的例子中为3）来获得沿每个轴的实际移动。
- en: We do nothing to support the case where the player tries to control the game
    with the keyboard and the touch screen since this is very unlikely.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要支持玩家尝试使用键盘和触摸屏控制游戏的情况，因为这种情况是非常不可能发生的。
- en: Event handlers
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件处理程序
- en: 'Now we will use a pattern somewhat similar to what we used before with our
    virtual keys. Here we will have only two of them. One will be the same as before:
    the interaction key. The second one is a bit special since it will be used to
    store the angle at which the avatar should move.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用一种与之前使用的虚拟键类似的模式，这里我们只会有两个。一个将与以前相同：交互键。第二个有点特殊，因为它将用于存储角度，该角度是角色应该移动的方向。
- en: 'The `touchstart` event handler is almost the same as before, except that we
    compute the angle between the touch and the center of the screen:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`touchstart` 事件处理程序与之前几乎相同，只是我们计算了触摸点和屏幕中心之间的角度：'
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For this, we use another trigonometric function: cotangent. This function allows
    us to retrieve the angle between two segments of a right triangle as shown in
    the following figure:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们使用另一个三角函数：余切。这个函数允许我们检索右角三角形的两条边之间的角度，如下图所示：
- en: '![Event handlers](img/5060OT_09_07.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![事件处理程序](img/5060OT_09_07.jpg)'
- en: 'The `touchend` handler is identical to the previous one but for the two virtual
    keys:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`touchend` 处理程序与之前的处理程序相同，但适用于两个虚拟键。'
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will need a third event handler to track the movement of the fingers between
    the start of the touch and its end. This handler has a structure similar to that
    of `touchend` but updates the angle of the `MOVE` virtual key:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要第三个事件处理程序来跟踪手指在触摸开始和结束之间的移动。此处理程序的结构与`touchend`的结构类似，但更新了`MOVE`虚拟键的角度：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With those three event handlers, our new control interface is implemented. You
    really have to try them to see which one you prefer. Those methods are really
    only two among many others, and choosing the right one will have a big influence
    on the success of your game on mobile devices, so don't hesitate to try a lot
    of them before choosing the final one!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这三个事件处理程序，我们实现了新的控制界面。您真的必须尝试它们，看看哪种方法更适合您。这些方法实际上只是许多其他方法中的两种，选择合适的方法将对您的游戏在移动设备上的成功产生重大影响，因此在选择最终方法之前，请毫不犹豫地尝试很多方法！
- en: Integrating our game with the springboard
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的游戏与主屏幕集成
- en: 'There is a very elegant way to make your game run in fullscreen mode on iOS.
    With the proper configuration, we can make your game installable on the springboard.
    This will have several effects: the game will run without any browser UI element,
    and it will have an icon and a splash screen.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种非常优雅的方法可以使您的游戏在 iOS 上全屏运行。通过适当的配置，我们可以使您的游戏可安装到 SpringBoard 上。这将产生几个效果：游戏将在没有任何浏览器
    UI 元素的情况下运行，并且将具有一个图标和一个启动画面。
- en: All this is done through setting a series of `meta` tags in the document header.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是通过在文档标头中设置一系列`meta`标签来完成的。
- en: Making your game installable
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使您的游戏可安装
- en: 'To make your game installable you have to use the `apple-mobile-web-app-capable`
    `meta` tag in your document head with the value `yes`. Once this is done the player
    will be able to add the game to the springboard from Safari as shown in the following
    screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要使您的游戏可安装，您必须在文档头部使用`apple-mobile-web-app-capable` `meta`标签，并将值设置为`yes`。一旦完成这个步骤，玩家就可以从
    Safari 将游戏添加到 SpringBoard，如下面的截图所示：
- en: '![Making your game installable](img/5060OT_09_08.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![使您的游戏可安装](img/5060OT_09_08.jpg)'
- en: 'The code you should have in your header is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在标头中拥有的代码如下所示：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A web page installed this way will be run without any visible browser UI elements
    (also called Chrome). The following figure gives the name of all the UI elements:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式安装的网页将在没有任何可见浏览器 UI 元素（也称为 Chrome）的情况下运行。以下图列出了所有 UI 元素的名称：
- en: '![Making your game installable](img/5060OT_09_10.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![使您的游戏可安装](img/5060OT_09_10.jpg)'
- en: Sadly, at the time of writing, this property is not well supported by Android
    phones. Some of them will make the web page installable to the main screen with
    a custom icon but won't accept the chromeless mode. Others will simply ignore
    it entirely.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '遗憾的是，在撰写本文时，这个属性在安卓手机上的支持并不好。其中一些手机会将网页安装到主屏幕并使用自定义图标，但不接受无 Chrome 模式。其他手机将完全忽略它。 '
- en: Configuring the status bar
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置状态栏
- en: Once launched from the springboard, the only remaining UI element is the status
    bar. As shown in the preceding figure, it's the bar at the top of the screen that
    holds information such as network reception and name, and remaining battery.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从 SpringBoard 启动，唯一剩下的 UI 元素就是状态栏。如前面的图所示，它是屏幕顶部的栏，显示诸如网络接收和名称以及剩余电量等信息。
- en: You can choose how this status bar looks like to make it fit your application
    as much as possible. This is done with the `apple-mobile-web-app-status-bar-style`
    `meta` tag.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择状态栏的外观，使其尽可能地适合您的应用程序。这可以通过`apple-mobile-web-app-status-bar-style` `meta`标签完成。
- en: 'The following list holds the possible values you can give to this tag and their
    corresponding effects:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表列出了您可以为此标签指定的可能值及其相应的效果：
- en: '`default`: If you don''t use this `meta` tag or give it this value, you will
    leave the choice of the appearance of the status bar to the OS.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：如果您不使用这个`meta`标签或给它赋予这个值，则将状态栏的外观选择留给操作系统。'
- en: '`black`: With this value, the status bar will have a black background and white
    text.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`black`: 使用这个值，状态栏将具有黑色背景和白色文本。'
- en: '`black-translucent`: With this value, the status bar will have a slightly transparent
    black background with white text. This setting has the peculiarity that the web
    page will be rendered under the status bar. This has the advantage of giving the
    full device resolution to the game; whereas, with the other settings, the web
    page will lose a few pixels on top of the screen.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`black-translucent`: 使用这个值，状态栏将具有略带透明的黑色背景和白色文本。这个设置的特殊之处在于网页将被渲染在状态栏下面。这样做的好处是为游戏提供完整的设备分辨率；而使用其他设置，网页将在屏幕顶部丢失一些像素。'
- en: 'The code you should have in your header is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在标头中拥有的代码如下所示：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Specifying the application icon
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定应用程序图标
- en: 'If you don''t specify anything, iOS will use a screenshot of the web page as
    an icon. If you want to specify an icon to be used instead, you will need to use
    one or more `link` tags. The problem is that different iDevices need different
    icon sizes. The solution is to specify the size of the icon in the `link` tag
    like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有指定任何内容，iOS 将使用网页的屏幕截图作为图标。如果您想指定一个要替代使用的图标，则需要使用一个或多个`link`标签。问题在于不同的 iDevices
    需要不同大小的图标。解决方案是在`link`标签中指定图标的大小，如下所示：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The possible sizes are: 57 x 57, 72 x 72, 114 x 114, and 144 x 144\. The icon
    you specified with this tag will be overlaid with a sort of gloss effect. If you
    want your icon to be used as is, you can use the `rel` tag `apple-touch-icon-precomposed`
    instead.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的尺寸是：57 x 57、72 x 72、114 x 114和144 x 144。您使用此标签指定的图标将被覆盖上一种光泽效果。如果您希望您的图标原样使用，可以改用`rel`标签`apple-touch-icon-precomposed`。
- en: Specifying a splash screen
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定闪屏
- en: When the user launches the game, a screenshot will be displayed during the loading
    of the page. If you instead want to specify an image, you can use a `link` tag
    with the `rel` tag `apple-touch-startup-image`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户启动游戏时，页面加载期间将显示一个屏幕截图。如果您希望指定一张图像，可以使用一个带有`rel`标签`apple-touch-startup-image`的`link`标签。
- en: 'We will have the same problem as with the icon: each device has another screen
    resolution and should use a corresponding image. However, the way to specify the
    resolution of the image is different from that for the icon. Here, you will need
    to use the `media` attribute.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遇到与图标相同的问题：每个设备都有另一个屏幕分辨率，应该使用相应的图像。但是，用于指定图像分辨率的方法与图标的方法不同。在这里，您需要使用`media`属性。
- en: 'With the `media` attribute, you can specify the device width with `device-width`,
    the device orientation with `orientation`, and whether the device uses retina
    display with `-webkit-device-pixel-ratio`. A complete example would be as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`media`属性，您可以使用`device-width`指定设备宽度，使用`orientation`指定设备方向，使用`-webkit-device-pixel-ratio`指定设备是否使用视网膜显示。完整的示例如下：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using device orientation
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用设备方向
- en: 'In some situations, it can be useful to have access to the device orientation.
    For example, you can use it to control the avatar''s movement. To do this, you
    can simply register an event handler that will receive an event each time the
    device orientation changes. The following code does exactly that:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，访问设备方向可能很有用。例如，您可以使用它来控制角色的移动。要做到这一点，您可以简单地注册一个事件处理程序，每当设备方向更改时就会收到一个事件。以下代码正是如此：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first `if` statement is there to check whether the device supports the
    device orientation API. Then we register an event handler that accesses the orientation
    of the device. This orientation is provided by three angles: `alpha` is the rotation
    around the z axis, `beta` is the rotation around the x axis, and `gamma` is the
    rotation around the y axis.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`if`语句是用来检查设备是否支持设备方向API的。然后我们注册一个事件处理程序来访问设备的方向。这个方向由三个角度提供：`alpha`是绕z轴的旋转，`beta`是绕x轴的旋转，而`gamma`是绕y轴的旋转。
- en: You already know what the x and y axes are; they are the same that we used to
    position the elements of our games. The z axis is an axis that points out of the
    screen towards the player.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道x和y轴是什么；它们与我们用来定位游戏元素的轴相同。z轴是一个指向玩家的屏幕外的轴。
- en: 'The following figure shows those axes and their corresponding angles:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了这些轴及其相应的角度：
- en: '![Using device orientation](img/5060OT_09_09.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![使用设备方向](img/5060OT_09_09.jpg)'
- en: Using the offline application cache
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用离线应用程序缓存
- en: One very useful feature of mobile devices is the ability for the web pages to
    work offline. For a game like the platformer we created earlier, it means that,
    once installed, you won't ever need a network connection again to load the game
    assets.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备的一个非常有用的功能是网页可以脱机工作。对于我们之前创建的平台游戏，这意味着一旦安装，您就再也不需要网络连接来加载游戏资产了。
- en: To enable offline mode, you will need to create a file called a manifest. The
    manifest is a list of all the files required by the game. They will be stored
    locally on the device during game installation on the springboard.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用离线模式，您需要创建一个名为清单的文件。清单是游戏所需的所有文件的列表。它们将在春板上安装游戏时在设备上本地存储。
- en: 'The format of this manifest is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此清单的格式如下：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `CACHE` section lists all the files to be stored locally. The `NETWORK`
    section lists all the external resources that are accessible when the application
    is online. If you don't want to restrict the network access you may simply write
    `*` as in the preceding example.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`CACHE`部分列出了所有要本地存储的文件。`NETWORK`部分列出了当应用程序在线时可访问的所有外部资源。如果您不想限制网络访问，可以像前面的示例中一样简单地写`*`。'
- en: 'To link the manifest to your game, you will use the following attribute for
    your `html` tag:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要将清单链接到您的游戏中，您将使用以下属性为您的`html`标记：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The manifest has to be served by the server with the MIME type `text/cache-manifest`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 清单必须由服务器以MIME类型`text/cache-manifest`提供。
- en: You have to be aware that once the application is installed using such a manifest,
    the game's file will not be updated even if the application changed on the server.
    The only way to force the refreshing of the resources is to change the manifest
    itself. If you don't really need to change the manifest, you can simply write
    a version number or timestamp in a comment; this will be enough to trigger the
    refresh.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须意识到，一旦使用这样一个清单安装了应用程序，即使服务器上的应用程序发生了变化，游戏文件也不会被更新。强制刷新资源的唯一方法是更改清单本身。如果你不真的需要更改清单，你可以简单地在注释中写上版本号或时间戳；这就足够触发刷新。
- en: Another possibility is that of adding a version number on your static media.
    This will help avoiding some bugs in iOS where the static files are not refreshed
    correctly.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是在静态媒体中添加版本号。这将有助于避免iOS中静态文件未能正确刷新的一些错误。
- en: Using web storage
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Web存储
- en: There are, however, situations where your application needs to transmit information
    to the server, for example, when the player hits a high score. What should you
    do if the game is running in offline mode at this moment?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在一些情况下，你的应用程序需要将信息传输到服务器，例如，当玩家获得高分时。如果此刻游戏正在离线模式下运行，你该怎么办？
- en: The solution is to use web storage. We won't go into the details of all that
    you can do with web storage, but the basic idea here is to store all the information
    you want to send to the server in local storage and transmit it once the game
    is online again. This technology is part of the HTML5 specification and therefore
    supported only by modern browsers. The available space you have to save your data
    in is 5 MB, so you will have to use it wisely.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用Web存储。我们不会详细介绍你可以用Web存储做什么，但基本思想是在本地存储所有你想发送到服务器的信息，并在游戏再次在线时传输它。这项技术是HTML5规范的一部分，因此只有现代浏览器支持。你可以用它来保存数据的可用空间为5MB，所以你必须明智地使用它。
- en: To store any value you want on the client's side, you can simply use the `setItem`
    method of the `sessionStorage` object. To retrieve the value, you can use the
    `getItem` method.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要在客户端存储任何值，你可以简单地使用`sessionStorage`对象的`setItem`方法。要检索该值，你可以使用`getItem`方法。
- en: 'The following code shows exactly this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码正是显示这一点：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now if you want to check whether the game is online, you can use the `onLine`
    flag on the `navigator` object, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你想检查游戏是否在线，你可以使用`navigator`对象上的`onLine`标志，如下所示：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the case of our RPG, you may want to store the player position and the enemies
    he/she killed locally and push them to the server once the Internet connection
    is restored.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的RPG游戏来说，你可能希望在本地存储玩家位置和其击败的敌人，并在Internet连接恢复后将它们推送到服务器。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter you've learned a lot of specific APIs and techniques available
    only to the mobile device. Writing games for mobile devices using web technologies
    is often a challenge but will greatly increase the number of potential players
    for your game.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学习了许多仅适用于移动设备的特定API和技术。使用Web技术为移动设备编写游戏通常是一个挑战，但会极大地增加你的游戏潜在玩家数量。
- en: You can even distribute your game in the App Store by using PhoneGap (also known
    as Apache Cordova).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以通过使用PhoneGap（又名Apache Cordova）在App Store上分发你的游戏。
- en: In the next chapter we will see how to add sound and music to your game. This
    is a tricky thing to do with web technologies, but it's well worth the trouble!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何将声音和音乐添加到你的游戏中。使用Web技术来做这件事情可能有些麻烦，但它绝对是值得的！
