<html><head></head><body>
		<div>
			<div id="_idContainer164" class="Content">
			</div>
		</div>
		<div id="_idContainer165" class="Content">
			<h1 id="_idParaDest-109"><a id="_idTextAnchor161"/>5. Global Component Composition</h1>
		</div>
		<div id="_idContainer188" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, you will learn how to reduce duplication in your Vue.js application code using global abstractions, new composition models, and new types of components. You will experiment with Vue.js <strong class="bold">mixins</strong>, <strong class="bold">plugins</strong>, and new types of components and ways of composing them.</p>
			<p class="callout">By the end of this chapter, you will be able to identify situations where <strong class="bold">mixins</strong> and <strong class="bold">plugins</strong> can be used to achieve global composition and keep code <strong class="bold">DRY</strong> (<strong class="bold">don't repeat yourself</strong>) in a Vue.js application, as well as how to define global components, functional components, and components in non-Vue files. You will also be able to contrast the advantages and drawbacks of global composition and select the right abstraction to maximize component flexibility.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor162"/>Introduction</h1>
			<p>Component nesting is an approach to composition where the application is built up from smaller units (components). The application can be thought of as components fitting within each other. In this scenario, any shared functionality will be provided through components. Vue.js provides other methods of composition.</p>
			<p>Component-based composition can be very verbose and will mean we repeat imports wherever a certain piece of functionality is needed. This does not follow the DRY principle. To avoid this duplication and verbosity, we can globally register <strong class="bold">mixins</strong>, <strong class="bold">plugins</strong>, and <strong class="bold">components</strong> to inject the globally available resources to be used throughout the application. This can reduce friction and frustration at having to type out <strong class="source-inline">import MyComponent from ...</strong> in every consumer of <strong class="source-inline">MyComponent</strong>.</p>
			<p>Much in the same way, applications can be built from different types of primitives (mixins, plugins, and components). For maximum flexibility, components can be defined in different ways beyond Vue.js single-file component files (<strong class="source-inline">.vue</strong> files). In this category, we have the case of functional components, as well as components defined with <strong class="bold">JSX</strong>, string templates, and <strong class="source-inline">render</strong> functions. Each of these types of components has some advantages and drawbacks.</p>
			<p>To keep code DRY, a component should be easy to use and extend. This chapter will look at a few tips that we can follow to make a component more reusable, thereby making the application more DRY.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor163"/>Mixins </h1>
			<p>Mixins can add methods, properties, and default life cycle methods to components that consume them. In the following example, we are defining a mixin that adds a <strong class="source-inline">greet</strong> method and a <strong class="source-inline">greeting</strong> field to the component's <strong class="source-inline">data</strong> function:</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  methods: {</p>
			<p class="source-code">    greet(name) {</p>
			<p class="source-code">      return `${this.greeting} ${name}`</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      greeting: 'Hello'</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Mixins allow multiple components' shared functionality to be defined independently. They are used through a <strong class="source-inline">mixins</strong> component property, which accepts an array.</p>
			<p>In the <strong class="source-inline">App.vue</strong> file, we can consume the mixin by setting the component's <strong class="source-inline">mixins</strong> property.</p>
			<p>The properties and methods of the mixin are then available in the component (just as they would be if they were defined in the component itself):</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;{{ greet('World') }}&lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import greeter from './mixins/greeter.js'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  mixins: [greeter]</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>This displays the following message in the browser:</p>
			<div>
				<div id="_idContainer166" class="IMG---Figure">
					<img src="image/B15218_05_01.jpg" alt="Figure 5.1: Hello World using a greeter mixin&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1: Hello World using a greeter mixin</p>
			<p>When there is a conflict, in terms of instance properties or methods that are named the same, between the component and the mixin, the component wins. This can be thought of as the component adopting mixin behavior by default unless said component declares the same instance property or method. In this case, instance access that is defined in the mixin would access the component's instance.</p>
			<p>For example, let's add a <strong class="source-inline">data()</strong> initializer to our <strong class="source-inline">App</strong> component that has <strong class="source-inline">greeting</strong> set to <strong class="source-inline">Hi</strong>:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">// other imports</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  // other component properties</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      greeting: 'Hi'</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>The mixin defines a <strong class="source-inline">data</strong> method, but so does the component. In this case, the component <em class="italic">wins</em>, hence why the greeting displayed is <strong class="source-inline">Hi</strong> (as defined in the component) instead of <strong class="source-inline">Hello</strong> (as defined in the mixin), as displayed in the following screenshot:</p>
			<div>
				<div id="_idContainer167" class="IMG---Figure">
					<img src="image/B15218_05_02.jpg" alt="Figure 5.2: Hi World using a greeter mixin with overridden data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2: Hi World using a greeter mixin with overridden data</p>
			<p>Note that when the component does not define a <strong class="source-inline">data</strong> method, the mixin's implementation is used but the component "wins" if both the mixin and the component define it.</p>
			<p>Vue.js life cycle hooks are prime candidates to be extracted into mixins. The life cycle hooks we can use are (in order of execution) <strong class="source-inline">beforeCreated</strong>, <strong class="source-inline">created</strong>, <strong class="source-inline">beforeMount</strong>, <strong class="source-inline">mounted</strong>, <strong class="source-inline">beforeUpdate</strong>, <strong class="source-inline">updated</strong>, <strong class="source-inline">beforeDestroy</strong>, and <strong class="source-inline">destroyed</strong>.</p>
			<p>Life cycle hooks are an exception to the mixin/component conflict resolution rule mentioned previously. In the case of Vue.js life cycle hooks functions, for each mixin, component, and hook, the hook functions are all executed in the order of mixins first (in order of addition to the component), component last.</p>
			<p>We can see this in action in the following example. Let's create two mixins that implement the <strong class="source-inline">mounted</strong> life cycle hook and implement that hook in the component. This illustrates the case of life cycle hooks for mixin/component conflict resolution:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div ref="zone" /&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">const firstMixin = {</p>
			<p class="source-code">  mounted() {</p>
			<p class="source-code">    console.log('First mixin mounted hook')</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">const secondMixin = {</p>
			<p class="source-code">  mounted() {</p>
			<p class="source-code">    console.log('Second mixin mounted hook')</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  mixins: [firstMixin, secondMixin],</p>
			<p class="source-code">  mounted() {</p>
			<p class="source-code">    console.log('Component mounted hook')</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>The browser console output for this component will be (in order) <strong class="source-inline">First mixin mounted hook</strong>, <strong class="source-inline">Second mixin mounted hook</strong>, and <strong class="source-inline">Component mounted hook</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer168" class="IMG---Figure">
					<img src="image/B15218_05_03.jpg" alt="Figure 5.3: Browser console output showing the hooks defined in the mixins that were executed before the component hooks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3: Browser console output showing the hooks defined in the mixins that were executed before the component hooks</p>
			<p>All the examples we have seen have used mixins directly to inject functionality into components. Mixins can also be created globally by using a <strong class="source-inline">Vue.mixin</strong> function call.</p>
			<p>We can, for example, make our greeting function a global instance method:</p>
			<p class="source-code">Vue.mixin({</p>
			<p class="source-code">  methods: {</p>
			<p class="source-code">    $greet(greeting, name) {</p>
			<p class="source-code">      return `${greeting} ${name}`</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">})</p>
			<p><strong class="source-inline">this.$greet</strong> will now be available on all Vue instances declared after the <strong class="source-inline">Vue.mixin</strong> call. This use case, however, is better served by a plugin.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">$methodName</strong> convention is used in Vue.js for methods that are provided by the Vue.js application instance (as opposed to the current component instance).</p>
			<h2 id="_idParaDest-112">Exe<a id="_idTextAnchor164"/>rcise 5.01: Creating Your Own Mixin</h2>
			<p>In this exercise, we will create a mixin called <strong class="source-inline">debug</strong> that will return the JSON-stringified representation of the input it has been passed. <strong class="bold">JavaScript Object Notation</strong> or <strong class="bold">JSON</strong> is a subset of JavaScript that allows the annotations of objects and arrays to be put in a compact human and machine-readable format. This can be useful for printing data to the console or even onto the page. We will make <strong class="source-inline">debug</strong> do what is called pretty-printing so that we can read it more easily.</p>
			<p>This can also be useful for printing data inside HTML when debugging a Vue.js application in a situation where Vue.js DevTools are not available or reliable. To access the code files for this exercise, refer to <a href="https://packt.live/38ivgFq">https://packt.live/38ivgFq</a>.</p>
			<p>We will start with a clean Vue CLI project (this can be created with the <strong class="source-inline">vue new exercise5.01</strong> command). The application in the Vue CLI project can be started with <strong class="source-inline">npm run serve</strong>.</p>
			<p>Follow these steps to complete this exercise:</p>
			<ol>
				<li>Create a new <strong class="source-inline">src/mixins</strong> folder and a <strong class="source-inline">src/mixins/debug.js</strong> file where we will define the skeleton of our mixin:<p class="source-code">export default {}</p></li>
				<li>The mixin will add a <strong class="source-inline">debug</strong> method, which we should define under <strong class="source-inline">methods</strong>. The <strong class="source-inline">debug</strong> method will take an <strong class="source-inline">obj</strong> parameter and return the output of <strong class="source-inline">JSON.stringify</strong> for that data. We will use <strong class="source-inline">JSON.stringify(obj, null, 2)</strong> to output two-space pretty-printed JSON:<p class="source-code">export default {</p><p class="source-code">  methods: {</p><p class="source-code">    debug(obj) {</p><p class="source-code">      return JSON.stringify(obj, null, 2)</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>We are now able to import the <strong class="source-inline">debug</strong> mixin from <strong class="source-inline">src/App.vue</strong> and register it under the <strong class="source-inline">mixins</strong> property:<p class="source-code">&lt;script&gt;</p><p class="source-code">import debug from './mixins/debug.js'</p><p class="source-code">export default {</p><p class="source-code">  mixins: [debug],</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>To see the <strong class="source-inline">debug</strong> method in action, we will add a <strong class="source-inline">data</strong> method and a <strong class="source-inline">created</strong> hook (from which we can print the output of <strong class="source-inline">debug</strong>) in the <strong class="source-inline">src/App.vue</strong> file:<p class="source-code">&lt;script&gt;</p><p class="source-code">// imports</p><p class="source-code">export default {</p><p class="source-code">  // other component properties</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      myObj: {</p><p class="source-code">        some: 'data',</p><p class="source-code">        other: 'values'</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  created() {</p><p class="source-code">    console.log(this.debug(this.myObj))</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>You should get the following output:</p><div id="_idContainer169" class="IMG---Figure"><img src="image/B15218_05_04.jpg" alt="Figure 5.4: Browser console output due to the created hook&#13;&#10;"/></div><p class="figure-caption">Figure 5.4: Browser console output due to the created hook</p></li>
				<li><strong class="source-inline">debug</strong> is also available in the template; we can interpolate its output in a <strong class="source-inline">pre</strong> tag so that whitespace is respected:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;pre&gt;{{ debug(myObj) }}&lt;/pre&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p>The application, as well as this template, will look as follows:</p><div id="_idContainer170" class="IMG---Figure"><img src="image/B15218_05_05.jpg" alt="Figure 5.5: Browser printing myObj using the debug method from the mixin&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.5: Browser printing myObj using the debug method from the mixin</p>
			<p>With that, we have learned how mixins can be used to inject shared functionality into multiple components in a manner that is quite explicit (a <strong class="source-inline">mixins</strong> property). We also got a chance to see what happens when a component's implementation overwrites properties and methods provided by the mixin (the component usually wins).</p>
			<p>We will now look at how to inject instance and global functionality and distribute it through plugins.</p>
			<h1 id="_idParaDest-113">Plugi<a id="_idTextAnchor165"/>ns</h1>
			<p>Vue.js plugins are a way to add custom functionality to Vue.js globally. Good candidates for plugins are core to the application and used widely. Classic examples of plugin candidates are translation/internationalization libraries (such as <strong class="source-inline">i18n-next</strong>) and HTTP clients (such as the <strong class="source-inline">axios</strong>, <strong class="source-inline">fetch</strong>, and <strong class="source-inline">GraphQL</strong> clients). The plugin initializer has access to the <strong class="source-inline">Vue</strong> instance, so it can be a good way to wrap global directive, mixin, component, and filter definitions.</p>
			<p>Plugins can inject functionality by registering directives and filters. They can also add <strong class="source-inline">global</strong> and <strong class="source-inline">instance</strong> Vue.js methods, as well as defining global component mixins.</p>
			<p>A Vue.js plugin is an object that exposes an <strong class="source-inline">install</strong> method. The <strong class="source-inline">install</strong> function is called with <strong class="source-inline">Vue</strong> and <strong class="source-inline">options</strong>:</p>
			<p class="source-code">const plugin = {</p>
			<p class="source-code">  install(Vue, options) {}</p>
			<p class="source-code">}</p>
			<p>Within the <strong class="source-inline">install</strong> method, we can register directives, filters, and mixins and add global and instance properties and methods:</p>
			<p class="source-code">const plugin = {</p>
			<p class="source-code">  install(Vue, options) {</p>
			<p class="source-code">    Vue.directive('fade', { bind() {} })</p>
			<p class="source-code">    Vue.filter('truncate', str =&gt; str.slice(0, 140))</p>
			<p class="source-code">    Vue.mixin({</p>
			<p class="source-code">      data() { return { empty: true } }</p>
			<p class="source-code">    })</p>
			<p class="source-code">    Vue.globalProperty = 'very-global-value'</p>
			<p class="source-code">    Vue.prototype.$myInstanceMethod = function() {}</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Plugins are registered using the <strong class="source-inline">Vue.use</strong> method:</p>
			<p class="source-code">import plugin from './plugin'</p>
			<p class="source-code">Vue.use(plugin)</p>
			<p><strong class="source-inline">Vue.use</strong> can also be passed options as the second argument. These options are passed to the plugin:</p>
			<p class="source-code">Vue.use(plugin, { optionProperty: true })</p>
			<p>One of the features of <strong class="source-inline">Vue.use</strong> is that it does not allow you to register the same plugin twice. This is a nice feature that avoids edge case behavior when attempting to instantiate or install the same plugin multiple times.</p>
			<p>A popular HTTP client to use in combination with Vue.js is <strong class="source-inline">axios</strong>. It is common to configure <strong class="source-inline">axios</strong> with interceptors or <strong class="source-inline">axios</strong> options to achieve things such as retries, passing cookies, or following redirects.</p>
			<p><strong class="source-inline">axios</strong> can be installed using: <strong class="source-inline">npm install –save axios</strong>.</p>
			<h2 id="_idParaDest-114">Exerc<a id="_idTextAnchor166"/>ise 5.02: Creating a Custom Axios Plugin </h2>
			<p>In order to avoid having to add <strong class="source-inline">import axios from 'axios'</strong> or having to wrap our custom <strong class="source-inline">axios</strong> instance under an <strong class="source-inline">http</strong> or <strong class="source-inline">transport</strong> internal module, we'll inject our custom <strong class="source-inline">axios</strong> instance into the Vue object and Vue component instances under <strong class="source-inline">Vue.axios</strong> and <strong class="source-inline">this.axios</strong>. This will make it easier and more ergonomic to use in our application, which needs to call out to an API using <strong class="source-inline">axios</strong> as the HTTP client. To access the code files for this exercise, refer to <a href="https://packt.live/36po08b">https://packt.live/36po08b</a>.</p>
			<p>We will start with a clean Vue CLI project (this can be created with the <strong class="source-inline">vue new exercise5.02</strong> command). The application in the Vue CLI project can be started with <strong class="source-inline">npm run serve</strong>.</p>
			<p>Follow these steps to complete this exercise:</p>
			<ol>
				<li value="1">To organize our code properly, we will create a new folder in <strong class="source-inline">src/plugins</strong> and a new file for our <strong class="source-inline">axios</strong> plugin at <strong class="source-inline">src/plugins/axios.js</strong>. In the new file, we will scaffold the <strong class="source-inline">axios</strong> plugin:<p class="source-code">import axios from 'axios'</p><p class="source-code">export default {</p><p class="source-code">  install(Vue, options) {}</p><p class="source-code">}</p></li>
				<li>We will now register our <strong class="source-inline">axios</strong> plugin on the Vue.js instance in <strong class="source-inline">src/main.js</strong>:<p class="source-code">// other imports</p><p class="source-code">import axiosPlugin from './plugins/axios.js'</p><p class="source-code">// other code</p><p class="source-code">Vue.use(axiosPlugin)</p><p class="source-code">// Vue instantiation code</p></li>
				<li>We will now install <strong class="source-inline">axios</strong> through <strong class="source-inline">npm</strong> using the following command. This will allow us to import <strong class="source-inline">axios</strong> and expose it on Vue through a plugin:<p class="source-code">npm install --save axios</p></li>
				<li>We will now add <strong class="source-inline">axios</strong> to Vue as a global property in <strong class="source-inline">src/plugins/axios.js</strong>:<p class="source-code">import axios from 'axios'</p><p class="source-code">export default {</p><p class="source-code">  install(Vue) {</p><p class="source-code">    Vue.axios = axios</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">axios</strong> is now available on <strong class="source-inline">Vue</strong>. In <strong class="source-inline">src/App.vue</strong>, we can make a request to an API that will populate a list of <strong class="source-inline">todos</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;div v-for="todo in todos" :key="todo.id"&gt;</p><p class="source-code">      &lt;ul&gt;</p><p class="source-code">        &lt;li&gt;Title: {{ todo.title }}&lt;/li&gt;</p><p class="source-code">        &lt;li&gt;Status: {{ todo.completed ? "Completed" :           "Not Completed" }}&lt;/li&gt;</p><p class="source-code">      &lt;/ul&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import Vue from 'vue'</p><p class="source-code">export default {</p><p class="source-code">  async mounted() {</p><p class="source-code">    const { data: todos } = await       Vue.axios('https://jsonplaceholder.typicode.com/todos')</p><p class="source-code">    this.todos = todos</p><p class="source-code">  },</p><p class="source-code">  data() {</p><p class="source-code">    return { todos: [] }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>The following is the expected output:</p><div id="_idContainer171" class="IMG---Figure"><img src="image/B15218_05_06.jpg" alt="Figure 5.6: Global Vue.axios todo display sample&#13;&#10;"/></div><p class="figure-caption">Figure 5.6: Global Vue.axios todo display sample</p></li>
				<li>Having to add <strong class="source-inline">import Vue from 'vue'</strong> is a bit odd in our case. The whole point of injecting <strong class="source-inline">axios</strong> through a plugin was to get rid of the <strong class="source-inline">import</strong> boilerplate. The better way to expose <strong class="source-inline">axios</strong> is through the component instance; that is, <strong class="source-inline">this.axios</strong>. To do so, we need to update the install step in the <strong class="source-inline">src/plugins/axios.js</strong> file and add <strong class="source-inline">axios</strong> to the <strong class="source-inline">Vue.prototype</strong> so that any <strong class="source-inline">new Vue()</strong> component will have it as a property:<p class="source-code">// imports</p><p class="source-code">export default {</p><p class="source-code">  install(Vue, options) {</p><p class="source-code">    // other plugin code</p><p class="source-code">    Vue.prototype.axios = axios</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>We can now remove the <strong class="source-inline">import Vue from 'vue'</strong> line and access <strong class="source-inline">axios</strong> through <strong class="source-inline">this.axios</strong> in <strong class="source-inline">src/App.vue</strong>:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  async mounted() {</p><p class="source-code">    const { data: todos } = await       this.axios('https://jsonplaceholder.typicode.com/todos')</p><p class="source-code">    this.todos = todos</p><p class="source-code">  },</p><p class="source-code">  data() {</p><p class="source-code">    return { todos: [] }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>The following is the output:</p><div id="_idContainer172" class="IMG---Figure"><img src="image/B15218_05_07.jpg" alt="Figure 5.7: Vue instance axios todo display sample&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.7: Vue instance axios todo display sample</p>
			<p>With that, we have used a plugin to inject both global and instance-level properties and methods, as well as having learned how they can be used to create directives and other Vue constructs in a format that is easy to distribute.</p>
			<p>We will now look at how globally registering components can help reduce boilerplate for high usage components in a code base.</p>
			<h1 id="_idParaDest-115">Globall<a id="_idTextAnchor167"/>y Registering Components</h1>
			<p>A reason for using plugins is to reduce boilerplate in all Vue application files by removing <strong class="source-inline">imports</strong> and replacing them with access to <strong class="source-inline">this</strong> and/or <strong class="source-inline">Vue</strong>.</p>
			<p>Vue.js components are usually defined in a single-file component and imported explicitly. Much for the same reasons as we define global methods and properties, we might want to register components globally. This will allow us to use these components in all our other component templates without having to import them and register them under the <strong class="source-inline">components</strong> property.</p>
			<p>A situation where this can be very useful is when using a design system or when a component is used across the code base.</p>
			<p>Globally registering a component helps with some types of updates, such as if the filename is not exposed to the consumer so that when changing the filename, there is only one path to update as opposed to one per user.</p>
			<p>Let's assume we have a <strong class="source-inline">CustomButton</strong> component in the <strong class="source-inline">CustomButton.vue</strong> file that looks as follows:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;button @click="$emit('click', $event)"&gt;</p>
			<p class="source-code">    &lt;slot /&gt;</p>
			<p class="source-code">  &lt;/button&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>We can register <strong class="source-inline">CustomButton</strong> globally as follows (this is usually done in the <strong class="source-inline">main.js</strong> file):</p>
			<p class="source-code">// other imports</p>
			<p class="source-code">import CustomButton from './components/CustomButton.vue'</p>
			<p class="source-code">Vue.component('CustomButton', CustomButton)</p>
			<p class="source-code">// other global instance setup</p>
			<p>We can now use it in the <strong class="source-inline">App.vue</strong> file without locally registering it or importing it:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;CustomButton&gt;Click Me&lt;/CustomButton&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>This renders as expected, with a button called <strong class="source-inline">Click Me</strong>:</p>
			<div>
				<div id="_idContainer173" class="IMG---Figure">
					<img src="image/B15218_05_08.jpg" alt="Figure 5.8: CustomButton rendering with a Click Me button&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8: CustomButton rendering with a Click Me button</p>
			<p>With that, we have explored how globally registering components can cut down on boilerplate when components are used often across a code base.</p>
			<p>Next, we will look at some tips on how to increase component flexibility in Vue.js.</p>
			<h1 id="_idParaDest-116">Maximizi<a id="_idTextAnchor168"/>ng Component Flexibility</h1>
			<p>Vue.js components take props and slots as input; their output is rendered as HTML and emitted events.</p>
			<p>To maximize component flexibility, it always makes sense to leverage slots and props.</p>
			<p>Leveraging props and default values judiciously means a component can be reused and extended. For example, instead of hardcoding a value in the component, we could set it as a default prop. In this case, <strong class="source-inline">date</strong> defaults to the current date, <strong class="source-inline">new Date()</strong>. We then extract the epoch using a computed property:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;Date as epoch: {{ epoch }}&lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: {</p>
			<p class="source-code">    date: {</p>
			<p class="source-code">      type: Date,</p>
			<p class="source-code">      default() {</p>
			<p class="source-code">        return new Date()</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  computed: {</p>
			<p class="source-code">    epoch() {</p>
			<p class="source-code">      return Number(this.date)</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>When registered and used, this renders as follows:</p>
			<p class="source-code">Date as epoch: 1574289255348</p>
			<p>Slots can be thought of as a way for a component to delegate rendering back to its consumers. Delegating parts of the template to the parent component helps with reusability.</p>
			<p>A specific example of slots used to maximize reusability is the <strong class="bold">renderless component</strong> pattern. For example, in the epoch display example, we could leverage scoped slots and remove any rendering logic from the component:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;slot :epoch="epoch" /&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>In the parent component, the rendering can be defined using a scoped slot:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;Epoch&gt;</p>
			<p class="source-code">      &lt;template v-slot:default="{ epoch }"&gt;</p>
			<p class="source-code">        Epoch as rendered with parent template {{ epoch }}</p>
			<p class="source-code">      &lt;/template&gt;</p>
			<p class="source-code">    &lt;/Epoch&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>This means that the delegation of the component is delegated to the parent and displays the following:</p>
			<p class="source-code">Epoch as rendered with parent template 1574289270190</p>
			<p>The next set of practices maximize the reuse of components by making their API predictable. In many ways, forwarding attributes, leveraging the <strong class="source-inline">style</strong> and <strong class="source-inline">class</strong> attributes being merged, and implementing a <strong class="source-inline">v-model</strong> interface is another way of making Vue.js custom components behave more like HTML elements.</p>
			<p>Forwarding attributes can be interesting. For example, a <strong class="source-inline">CustomInput</strong> component (in the <strong class="source-inline">CustomInput.vue</strong> file) might need to pass the <strong class="source-inline">type</strong> attribute, as well as a <strong class="source-inline">required</strong> attribute:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;input v-bind="$attrs"&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>The <strong class="source-inline">CustomInput</strong> component can be used to render any type of component (<strong class="source-inline">src/App.vue</strong>):</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;fieldset&gt;</p>
			<p class="source-code">      &lt;label for="textinput"&gt;</p>
			<p class="source-code">        Text Input</p>
			<p class="source-code">      &lt;/label&gt;</p>
			<p class="source-code">      &lt;CustomInput</p>
			<p class="source-code">      type="text"</p>
			<p class="source-code">      name="textinput"</p>
			<p class="source-code">      id="textinput"</p>
			<p class="source-code">      /&gt;</p>
			<p class="source-code">    &lt;/fieldset&gt;</p>
			<p class="source-code">    &lt;fieldset&gt;</p>
			<p class="source-code">      &lt;label for="dateinput"&gt;</p>
			<p class="source-code">        Date Input</p>
			<p class="source-code">      &lt;/label&gt;</p>
			<p class="source-code">      &lt;CustomInput</p>
			<p class="source-code">        type="date"</p>
			<p class="source-code">        name="dateinput"</p>
			<p class="source-code">        id="dateinput"</p>
			<p class="source-code">      /&gt;</p>
			<p class="source-code">    &lt;/fieldset&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import CustomInput from './components/CustomInput.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    CustomInput</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>This renders the text and date inputs correctly:</p>
			<div>
				<div id="_idContainer174" class="IMG---Figure">
					<img src="image/B15218_05_09.jpg" alt="Figure 5.9: CustomInput with text and date as types&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9: CustomInput with text and date as types</p>
			<p>Vue.js does a lot of the heavy lifting around classes/inline styles since it merges the <strong class="source-inline">style</strong> and <strong class="source-inline">class</strong> objects defined on a component with the <strong class="source-inline">style</strong> and <strong class="source-inline">class</strong> objects of the root element in said component. As per the documentation, "<em class="italic">the class and style attributes are a little smarter, so both values are merged</em>" (<em class="italic">Vue.js Component Props guide</em>: <a href="https://vuejs.org/v2/guide/components-props.html#Replacing-Merging-with-Existing-Attributes">https://vuejs.org/v2/guide/components-props.html#Replacing-Merging-with-Existing-Attributes</a>).</p>
			<p>In Vue.js, the tendency is for input elements and components to be controlled through <strong class="source-inline">v-model</strong>, a two-way reactive Vue.js binding. <strong class="source-inline">v-model</strong> is shorthand for using <strong class="source-inline">v-bind:value</strong> and <strong class="source-inline">v-on:input</strong> to provide a value and keep it in sync with the output from the child component or element.</p>
			<p>The <strong class="bold">controlled</strong> denomination is the opposite of <strong class="bold">uncontrolled</strong>. In an uncontrolled scenario, the <strong class="source-inline">value</strong> that is passed is only used as the starting value; <strong class="source-inline">input</strong> events are emitted when the input is done being captured (for example, typing is done).</p>
			<p>If a component implements the <strong class="source-inline">v-model</strong> shape, it works as a direct replacement for form elements.</p>
			<p>For example, a <strong class="source-inline">TextInput</strong> that implements the <strong class="source-inline">v-model</strong> interface can be used interchangeably with <strong class="source-inline">input</strong> and <strong class="source-inline">textarea</strong>:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;textarea</p>
			<p class="source-code">      v-if="type === 'long'"</p>
			<p class="source-code">      :value="value"</p>
			<p class="source-code">      @input="$emit('input', $event.target.value)"</p>
			<p class="source-code">    &gt;</p>
			<p class="source-code">    &lt;/textarea&gt;</p>
			<p class="source-code">    &lt;input</p>
			<p class="source-code">      v-else</p>
			<p class="source-code">      :value="value"</p>
			<p class="source-code">      @input="$emit('input', $event.target.value)"</p>
			<p class="source-code">      type="text"</p>
			<p class="source-code">    /&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: ['value', 'type']</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>This can then be used as follows in <strong class="source-inline">src/App.vue</strong>:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;label&gt;Short Text: {{ shortText }}&lt;/label&gt;</p>
			<p class="source-code">    &lt;TextInput v-model="shortText" type="short" /&gt;</p>
			<p class="source-code">    &lt;label&gt;Long Text: {{ longText }}&lt;/label&gt;</p>
			<p class="source-code">    &lt;TextInput v-model="longText" type="long" /&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import TextInput from './components/TextInput.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    TextInput</p>
			<p class="source-code">  },</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      shortText: '',</p>
			<p class="source-code">      longText: ''</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>The application renders as follows:</p>
			<div>
				<div id="_idContainer175" class="IMG---Figure">
					<img src="image/B15218_05_10.jpg" alt="Figure 5.10: Custom component implementing v-model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10: Custom component implementing v-model</p>
			<p>With that, we have looked at how to leverage props and slots, inherit attributes, and implement well-known Vue.js interfaces to help maximize component flexibility.</p>
			<p>The next section is dedicated to deepening our understanding of Vue.js components by learning how to use them without <strong class="source-inline">.vue</strong> files.</p>
			<h1 id="_idParaDest-117">Using Vue.<a id="_idTextAnchor169"/>js Components without a .vue Single-File Component</h1>
			<p>Most of the examples we have seen of Vue.js components have leveraged <strong class="source-inline">.vue</strong> single-file components.</p>
			<p>This is not the only way to define a Vue.js component. In this section, we will look at four different ways to define Vue.js components without using a <strong class="source-inline">.vue</strong> file.</p>
			<p>Evaluating these options will help us understand what a Vue.js component is at its core.</p>
			<h2 id="_idParaDest-118">Runtime De<a id="_idTextAnchor170"/>finition with a String Template</h2>
			<p>A component can use a <strong class="source-inline">template</strong> property that accepts a string value. This is commonly called a <strong class="bold">string template</strong>. This template is evaluated at runtime (in the browser).</p>
			<p>We can define a component in the <strong class="source-inline">StringTemplate.js</strong> file by defining an object with a <strong class="source-inline">template</strong> property:</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  template: `&lt;div&gt;String Template Component&lt;/div&gt;`</p>
			<p class="source-code">}</p>
			<p>This can then be consumed from the <strong class="source-inline">App.vue</strong> file, as follows:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;StringTemplate /&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import StringTemplate from './components/StringTemplate.js'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    StringTemplate</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>Unfortunately, this crashes on load and displays the following Vue warning in the console:</p>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="image/B15218_05_11.jpg" alt="Figure 5.11: Vue runtime compiler missing warning&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11: Vue runtime compiler missing warning</p>
			<p>As per the Vue warning, for this component to work when imported, we need to include the Vue.js compiler in the runtime build. To do so, in a Vue CLI project, we can set the <strong class="source-inline">runtimeCompiler</strong> option to <strong class="source-inline">true</strong> in <strong class="source-inline">vue.config.js</strong> (the Vue CLI configuration file).</p>
			<p>Your <strong class="source-inline">vue.config.js</strong> should look like the following:</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">  runtimeCompiler: true</p>
			<p class="source-code">};</p>
			<p>After setting this option and restarting the development server, a message from the <strong class="source-inline">StringTemplate</strong> component appears in the browser:</p>
			<p class="source-code">String Template Component</p>
			<p>Props and other component instance properties can be defined with <strong class="source-inline">.vue</strong> component objects.</p>
			<h2 id="_idParaDest-119">The render <a id="_idTextAnchor171"/>Function</h2>
			<p>A Vue.js single-file component <strong class="source-inline">template</strong> section gets compiled into a <strong class="source-inline">render</strong> function at build time.</p>
			<p>A <strong class="source-inline">render</strong> function tends to be used in the <strong class="source-inline">main.js</strong> file of a Vue CLI project – specifically, the <strong class="source-inline">new Vue()</strong> call:</p>
			<p class="source-code">new Vue({</p>
			<p class="source-code">  render: h =&gt; h(App),</p>
			<p class="source-code">}).$mount('#app')</p>
			<p>A <strong class="source-inline">render</strong> function takes a <strong class="source-inline">createElement</strong> parameter and returns a virtual DOM node. This is done by calling the <strong class="source-inline">createElement</strong> function (in the preceding example, this is <strong class="source-inline">h</strong>).</p>
			<p><strong class="source-inline">h</strong> is often used as shorthand for <strong class="source-inline">createElement</strong> due to its compactness.</p>
			<p>We can define a component in a JavaScript file (<strong class="source-inline">RenderFunction.js</strong>) with a <strong class="source-inline">render</strong> property like so:</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  render(createElement) {</p>
			<p class="source-code">    return createElement(</p>
			<p class="source-code">      'h2',</p>
			<p class="source-code">      'Render Function Component'</p>
			<p class="source-code">    )</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>This can be rendered in the <strong class="source-inline">App.vue</strong> file as follows:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;RenderFunction /&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import RenderFunction from './components/RenderFunction.js'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    RenderFunction</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>This component displays a <strong class="source-inline">h2</strong> with <strong class="bold">Render Function Component</strong> as its content in the browser:</p>
			<p class="source-code">Render Function Component</p>
			<p>Beyond writing components in non <strong class="source-inline">.vue</strong> files, <strong class="source-inline">render</strong> functions can be useful for highly dynamic components.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor172"/>JSX</h2>
			<p>JSX has<a id="_idTextAnchor173"/> been popularized by React. As per the React documentation, <em class="italic">JSX is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like</em> (<a href="https://reactjs.org/docs/introducing-jsx.html">https://reactjs.org/docs/introducing-jsx.html</a>). JSX is a superset of JavaScript that allows <strong class="source-inline">HTML-style</strong> tags and interpolation using braces.</p>
			<p>React, like Vue.js, does not render JSX to the DOM. Like Vue.js templates, React application build tools compile JSX to <strong class="source-inline">render</strong> functions that are used at runtime so that they can be rendered to the Virtual DOM. The Virtual DOM is then <em class="italic">reconciled</em> (synced) with the real DOM.</p>
			<p>JSX compiles to <strong class="source-inline">render</strong> functions and Vue.js supports component definitions with <strong class="source-inline">render</strong> functions. Moreover, <strong class="bold">Vue CLI 3+</strong> compiles JSX out of the box.</p>
			<p>This means we can write the following, which is the equivalent of the <strong class="source-inline">RenderFunction</strong> component, <strong class="source-inline">JSXRender.js</strong> file:</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  render() {</p>
			<p class="source-code">    return &lt;h2&gt;JSX Render Function Component&lt;/h2&gt;</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The equivalent <strong class="source-inline">render</strong> function without JSX looks as follows (based on the example from the previous section):</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  render(createElement) {</p>
			<p class="source-code">    return createElement(</p>
			<p class="source-code">      'h2',</p>
			<p class="source-code">      'JSX Render Function Component'</p>
			<p class="source-code">    )</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The following <strong class="source-inline">App.vue</strong> file renders <strong class="source-inline">JSXRender</strong> to the browser:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;JSXRender /&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import JSXRender from './components/JSXRender.js'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    JSXRender</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>Now, we can see the <strong class="source-inline">h2</strong> from <strong class="source-inline">JSXRender</strong> on the screen with the expected content:</p>
			<p class="source-code">JSX Render Function Component</p>
			<p>With that, we have learned that Vue.js components are just objects with a <strong class="source-inline">render</strong> or <strong class="source-inline">template</strong> function. <strong class="source-inline">.vue</strong> component <strong class="source-inline">template</strong> sections are compiled to <strong class="source-inline">render</strong> functions at build time, which means that to use string templates, we need to include the Vue.js compiler in the application runtime. We have also learned how to use <strong class="source-inline">render</strong> functions, as well as JSX, to define components and pointed out some things React and Vue.js have in common from an implementation point of view. When choosing to use JSX or <strong class="source-inline">render</strong> functions, JSX can be easier to read with the full flexibility of <strong class="source-inline">render</strong> functions (which regular templates do not always have).</p>
			<p>We will now look at how components can be rendered dynamically from runtime data using the Vue.js <strong class="source-inline">component</strong> tag.</p>
			<h1 id="_idParaDest-121">The Vue com<a id="_idTextAnchor174"/>ponent Tag</h1>
			<p>JSX and <strong class="source-inline">render</strong> functions are great for situations where the component being rendered needs to be very dynamic.</p>
			<p>The way to achieve this within regular Vue.js templates is by using the <strong class="source-inline">component</strong> tag.</p>
			<p>The <strong class="source-inline">component</strong> tag uses the <strong class="source-inline">is</strong> prop to dynamically select which component will be rendered.</p>
			<p>To render a dynamic component, we use a <strong class="source-inline">component</strong> tag with a bound <strong class="source-inline">is</strong> property (here, we are using the shorthand <strong class="source-inline">:is</strong>, which is equivalent to <strong class="source-inline">v-bind:is</strong>):</p>
			<p class="source-code">&lt;component :is="componentName" /&gt;</p>
			<p>We will now learn how to render dynamic components using a name or component reference.</p>
			<h2 id="_idParaDest-122">Rendering D<a id="_idTextAnchor175"/>ynamic Components by Name or Component Reference</h2>
			<p>Let's say we have a grid that contains items whose display can be toggled between a card display (a design element with an image and text) or an image-only view.</p>
			<p>First, we need to import the relevant components and register them as components. We will also set some fixture data to loop through for the grid:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;div class="grid"&gt;</p>
			<p class="source-code">      &lt;component</p>
			<p class="source-code">        class="grid-item"</p>
			<p class="source-code">        v-for="item in items"</p>
			<p class="source-code">        :key="item.id"</p>
			<p class="source-code">      /&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import Card from './components/Card.vue';</p>
			<p class="source-code">import ImageEntry from './components/ImageEntry.vue';</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    Card,</p>
			<p class="source-code">    ImageEntry</p>
			<p class="source-code">  },</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      items: [</p>
			<p class="source-code">        {</p>
			<p class="source-code">          id: '10',</p>
			<p class="source-code">          title: 'Forest Shot',</p>
			<p class="source-code">          url: 'https://picsum.photos/id/10/1000/750.jpg',</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          id: '1000',</p>
			<p class="source-code">          title: 'Cold cross',</p>
			<p class="source-code">          url: 'https://picsum.photos/id/1000/1000/750.jpg',</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          id: '1002',</p>
			<p class="source-code">          title: 'NASA shot',</p>
			<p class="source-code">          url: 'https://picsum.photos/id/1002/1000/750.jpg',</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          id: '866',</p>
			<p class="source-code">          title: 'Peak',</p>
			<p class="source-code">          url: 'https://picsum.photos/id/866/1000/750.jpg'</p>
			<p class="source-code">        },</p>
			<p class="source-code">      ]</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>We can then reference the components by name – that is, <strong class="source-inline">card</strong> and <strong class="source-inline">image-entry</strong> – and set <strong class="source-inline">itemComponent</strong> as the value for <strong class="source-inline">is</strong>:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">    &lt;!-- rest of template --&gt;</p>
			<p class="source-code">    &lt;component</p>
			<p class="source-code">      :is="itemComponent"</p>
			<p class="source-code">      class="grid-item"</p>
			<p class="source-code">      v-for="item in items"</p>
			<p class="source-code">      :key="item.id"</p>
			<p class="source-code">    /&gt;</p>
			<p class="source-code">    &lt;!-- rest of template --&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">// rest of script</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  // other component properties</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      itemComponent: 'card',</p>
			<p class="source-code">      // other data properties eg. `items`</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>In this case, the <strong class="source-inline">Card</strong> component will render since we are passing its lowercased name (<strong class="source-inline">card</strong>) to the <strong class="source-inline">component</strong> tag.</p>
			<p>If we turned <strong class="source-inline">itemComponent</strong> into <strong class="source-inline">image-entry</strong>, the <strong class="source-inline">ImageEntry</strong> component would render. This switch can be made as follows using <strong class="source-inline">v-model</strong>:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;!-- rest of template --&gt;</p>
			<p class="source-code">  Display mode:</p>
			<p class="source-code">  &lt;input</p>
			<p class="source-code">    type="radio"</p>
			<p class="source-code">    name="style"</p>
			<p class="source-code">    value="card"</p>
			<p class="source-code">    v-model="itemComponent"</p>
			<p class="source-code">    id="card-radio"</p>
			<p class="source-code">  /&gt;</p>
			<p class="source-code">  &lt;label for="card-radio"&gt;Card&lt;/label&gt;</p>
			<p class="source-code">  &lt;input</p>
			<p class="source-code">    type="radio"</p>
			<p class="source-code">    name="style"</p>
			<p class="source-code">    value="image-entry"</p>
			<p class="source-code">    v-model="itemComponent"</p>
			<p class="source-code">    id="image-radio"</p>
			<p class="source-code">  /&gt;</p>
			<p class="source-code">  &lt;label for="image-radio"&gt;Image&lt;/label&gt;</p>
			<p class="source-code">  &lt;!-- rest of template --&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>We can also pass components to <strong class="source-inline">is</strong> using the component reference itself (instead of the name). For example, we could set <strong class="source-inline">itemComponent</strong> to <strong class="source-inline">Card</strong>:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">// rest of script</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  // other component properties</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      itemComponent: Card,</p>
			<p class="source-code">      // other data properties eg. `items`</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>In this case, switching between card and image views would be more difficult since we would need to use component references instead of using names.</p>
			<p>We can pass props to components that have been dynamically rendered with <strong class="source-inline">component</strong> as we would pass regular props either with <strong class="source-inline">v-bind:prop-name</strong> or the <strong class="source-inline">:prop-name</strong> shorthand:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">    &lt;!-- rest of template --&gt;</p>
			<p class="source-code">    &lt;component</p>
			<p class="source-code">      class="grid-item"</p>
			<p class="source-code">      v-for="item in items"</p>
			<p class="source-code">      :key="item.id"</p>
			<p class="source-code">      :is="itemComponent"</p>
			<p class="source-code">    </p>
			<p class="source-code">      :url="item.url"</p>
			<p class="source-code">      :title="item.title"</p>
			<p class="source-code">    /&gt;</p>
			<p class="source-code">    &lt;!-- rest of template --&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>Given the following <strong class="source-inline">Card</strong> and <strong class="source-inline">ImageEntry</strong> components, we get an application that has toggleable views for grid items.</p>
			<p><strong class="source-inline">Card.vue</strong> renders the image and the title and has a <strong class="source-inline">150px</strong> maximum width:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div class="card"&gt;</p>
			<p class="source-code">    &lt;img :src="url" width="100%" /&gt;</p>
			<p class="source-code">    &lt;h3&gt;{{ title }}&lt;/h3&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: {</p>
			<p class="source-code">    url: String,</p>
			<p class="source-code">    title: String</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p class="source-code">&lt;style scoped&gt;</p>
			<p class="source-code">.card {</p>
			<p class="source-code">  margin: 10px;</p>
			<p class="source-code">  max-width: 150px;</p>
			<p class="source-code">}</p>
			<p class="source-code">h3 {</p>
			<p class="source-code">  font-weight: normal;</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/style&gt;</p>
			<p>Your output will display the entries in card view, as follows:</p>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="image/B15218_05_12.jpg" alt="Figure 5.12: Grid rendering entries in card view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12: Grid rendering entries in card view</p>
			<p>Use <strong class="source-inline">ImageEntry.vue</strong> to render only the image at double the width of the card view:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;img class="image" :src="url" /&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: {</p>
			<p class="source-code">    url: String</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p class="source-code">&lt;style scoped&gt;</p>
			<p class="source-code">.image {</p>
			<p class="source-code">  margin: 20px;</p>
			<p class="source-code">  max-width: 300px;</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/style&gt;</p>
			<p>You will now see the entries in an image view, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/B15218_05_13.jpg" alt="Figure 5.13: Grid rendering entries in an image view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13: Grid rendering entries in an image view</p>
			<p>A caveat of the <strong class="source-inline">component</strong> tag is that the rendered dynamic component gets completely torn down when it is not displayed anymore. In this example, the dynamic components being rendered do not have any state, so this teardown does not create any issues.</p>
			<p>We will now learn how a dynamic component state is cached.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor176"/>Caching a Dynamic Component State with Keep-Alive</h2>
			<p>Components that are dynamically rendered through the <strong class="source-inline">component</strong> tag can have state, such as in a multipart form, with a <strong class="source-inline">name</strong> field and an <strong class="source-inline">address</strong> field on the next page.</p>
			<p>Let's implement this with a <strong class="source-inline">component</strong> tag, as follows:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;component</p>
			<p class="source-code">      :is="activeStep"</p>
			<p class="source-code">      @next="activeStep = 'second-step'"</p>
			<p class="source-code">      @back="activeStep = 'first-step'"</p>
			<p class="source-code">    /&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import FirstStep from './components/FirstStep.vue'</p>
			<p class="source-code">import SecondStep from './components/SecondStep.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    FirstStep,</p>
			<p class="source-code">    SecondStep</p>
			<p class="source-code">  },</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      activeStep: 'first-step',</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>By doing this, we can enter data in the <strong class="source-inline">Name</strong> field:</p>
			<div>
				<div id="_idContainer179" class="IMG---Figure">
					<img src="image/B15218_05_14.jpg" alt="Figure 5.14: My name is entered in the name field&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14: My name is entered in the name field</p>
			<p>If we navigate, using <strong class="source-inline">Next</strong>, (to the address part of the form) and then <strong class="source-inline">Back</strong>, the name will disappear, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="image/B15218_05_15.jpg" alt="Figure 5.15: Empty name field upon clicking Next and then Back in the address step&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15: Empty name field upon clicking Next and then Back in the address step</p>
			<p>This is due to the component being torn down (destroyed) when it is not the currently rendered dynamic component.</p>
			<p>To fix this, we can use the <strong class="source-inline">keep-alive</strong> element around the <strong class="source-inline">component</strong> tag:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;!-- rest of template --&gt;</p>
			<p class="source-code">  &lt;keep-alive&gt;</p>
			<p class="source-code">    &lt;component</p>
			<p class="source-code">      :is="activeStep"</p>
			<p class="source-code">      @next="activeStep = 'second-step'"</p>
			<p class="source-code">      @back="activeStep = 'first-step'"</p>
			<p class="source-code">    /&gt;</p>
			<p class="source-code">  &lt;/keep-alive&gt;</p>
			<p class="source-code">  &lt;!-- rest of template --&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>In this manner, filling out the name and going <strong class="source-inline">Back</strong> from the address section of the form shows the following:</p>
			<div>
				<div id="_idContainer181" class="IMG---Figure">
					<img src="image/B15218_05_16.jpg" alt="Figure 5.16: My name is is still the value in the Name field after navigation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.16: My name is is still the value in the Name field after navigation</p>
			<p>With that, we have learned how to use the <strong class="source-inline">component</strong> tag to denote an area within which we can dynamically display a component based on a string or the component itself (as imported). We have also explored how to work around the main gotcha of <strong class="source-inline">component</strong>; namely, how to use <strong class="source-inline">keep-alive</strong> to maintain component state when it is not the component being actively used in the <strong class="source-inline">component</strong> tag.</p>
			<h2 id="_idParaDest-124">Exercise 5.03: C<a id="_idTextAnchor177"/>reating a Dynamic Card Layout with the component Tag </h2>
			<p>A modern application layout is a grid with cards. <strong class="source-inline">Card</strong> layouts have the benefit of being well-suited to mobile, desktop, and tablet displays. In this exercise, we will create a dynamic <strong class="source-inline">card</strong> layout with three different modes and a way to select between the three of them. This layout will allow the user to select how much information is displayed on the screen to suit their preference. </p>
			<p>The <strong class="source-inline">Rich</strong> view will display all the details for an item, including the image, the title, and the description.</p>
			<p>The <strong class="source-inline">Compressed</strong> view will display all the details but not the image preview.</p>
			<p>The <strong class="source-inline">List</strong> view will only display the title and should be a vertical layout.</p>
			<p>Each of the <strong class="source-inline">card</strong> views will be implemented as a separate component that will then be dynamically rendered using the <strong class="source-inline">component</strong> tag. To access the code files for this exercise, refer to <a href="https://packt.live/3mYYvkq">https://packt.live/3mYYvkq</a>.</p>
			<p>Follow these steps to complete this exercise:</p>
			<ol>
				<li value="1">Create the rich layout at <strong class="source-inline">src/components/Rich.vue</strong>. It contains three props called <strong class="source-inline">url</strong> (the image URL), <strong class="source-inline">title</strong>, and <strong class="source-inline">description</strong> and renders the image, the title, and the description, respectively:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="card"&gt;</p><p class="source-code">    &lt;img :src="url" width="100%" /&gt;</p><p class="source-code">    &lt;h3&gt;{{ title }}&lt;/h3&gt;</p><p class="source-code">    &lt;p&gt;{{ description }}&lt;/p&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  props: ['url', 'title', 'description']</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p class="source-code">&lt;style scoped&gt;</p><p class="source-code">.card {</p><p class="source-code">  display: flex;</p><p class="source-code">  flex-direction: column;</p><p class="source-code">  max-width: 200px;</p><p class="source-code">}</p><p class="source-code">h3 {</p><p class="source-code">  font-weight: normal;</p><p class="source-code">  margin-bottom: 0;</p><p class="source-code">  padding-bottom: 0;</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p></li>
				<li>Set up <strong class="source-inline">src/App.vue</strong> with some fixture data:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      items: [</p><p class="source-code">        {</p><p class="source-code">          id: '10',</p><p class="source-code">          title: 'Forest Shot',</p><p class="source-code">          description: 'Recent shot of a forest overlooking a             lake',</p><p class="source-code">          url: 'https://picsum.photos/id/10/1000/750.jpg',</p><p class="source-code">        },</p><p class="source-code">        {</p><p class="source-code">          id: '1000',</p><p class="source-code">          title: 'Cold cross',</p><p class="source-code">          description: 'Mountaintop cross with snowfall from             Jan 2018',</p><p class="source-code">          url: 'https://picsum.photos/id/1000/1000/750.jpg',</p><p class="source-code">        },</p><p class="source-code">      ]</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Import the <strong class="source-inline">Rich</strong> view component into <strong class="source-inline">src/App.vue</strong> and register it locally:<p class="source-code">&lt;script&gt;</p><p class="source-code">import Rich from './components/Rich.vue'</p><p class="source-code">export default {</p><p class="source-code">  components: {</p><p class="source-code">    Rich</p><p class="source-code">  },</p><p class="source-code">  // other component properties, eg. "data"</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Once we have got the <strong class="source-inline">Rich</strong> view component, wire it into the application in <strong class="source-inline">src/App.vue</strong>, render it with <strong class="source-inline">component</strong>, and pass the relevant props through:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">      &lt;component</p><p class="source-code">        v-for="item in items"</p><p class="source-code">        :key="item.id"</p><p class="source-code">        :is="layout"</p><p class="source-code">        :title="item.title"</p><p class="source-code">        :description="item.description"</p><p class="source-code">        :url="item.url"</p><p class="source-code">      /&gt;</p><p class="source-code">  &lt;!-- rest of template&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code"> // other component properties</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      layout: 'rich',</p><p class="source-code">      // other data definitions eg. `items`</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>This is a good point to add a bit of styling to make the grid look like a grid:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;div class="grid"&gt;</p><p class="source-code">      &lt;component</p><p class="source-code">        v-for="item in items"</p><p class="source-code">        :key="item.id"</p><p class="source-code">        :is="layout"</p><p class="source-code">        :title="item.title"</p><p class="source-code">        :description="item.description"</p><p class="source-code">        :url="item.url"</p><p class="source-code">      /&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;style scoped&gt;</p><p class="source-code">.grid {</p><p class="source-code">  display: flex;</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p><p>This displays the following output:</p><div id="_idContainer182" class="IMG---Figure"><img src="image/B15218_05_17.jpg" alt="Figure 5.17: Rich component rendering dynamically&#13;&#10;"/></div><p class="figure-caption">Figure 5.17: Rich component rendering dynamically</p></li>
				<li>Now, implement the <strong class="source-inline">Compressed</strong> view, which is just the <strong class="source-inline">Rich</strong> view without the image in the <strong class="source-inline">Compressed.vue</strong> file:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="card"&gt;</p><p class="source-code">    &lt;h3&gt;{{ title }}&lt;/h3&gt;</p><p class="source-code">    &lt;p&gt;{{ description }}&lt;/p&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  props: ['title', 'description']</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p class="source-code">&lt;style scoped&gt;</p><p class="source-code">.card {</p><p class="source-code">  display: flex;</p><p class="source-code">  flex-direction: column;</p><p class="source-code">  max-width: 200px;</p><p class="source-code">}</p><p class="source-code">h3 {</p><p class="source-code">  font-weight: normal;</p><p class="source-code">  padding-bottom: 0;</p><p class="source-code">}</p><p class="source-code">p {</p><p class="source-code"> margin: 0;</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p></li>
				<li>Import and register the <strong class="source-inline">Compressed</strong> component in <strong class="source-inline">src/App.vue</strong>:<p class="source-code">&lt;script&gt;</p><p class="source-code">// other imports</p><p class="source-code">import Compressed from './components/Compressed.vue'</p><p class="source-code">export default {</p><p class="source-code">  components: {</p><p class="source-code">    Rich,</p><p class="source-code">    Compressed,</p><p class="source-code">  },</p><p class="source-code">  // other component properties</p><p class="source-code">}</p></li>
				<li>Add a <strong class="source-inline">select</strong> to switch between views. It will have two options with values for <strong class="source-inline">rich</strong> and <strong class="source-inline">compressed</strong> and will be bound to <strong class="source-inline">layout</strong> using <strong class="source-inline">v-model</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">  Layout: &lt;select v-model="layout"&gt;</p><p class="source-code">      &lt;option value="rich"&gt;Rich&lt;/option&gt;</p><p class="source-code">      &lt;option value="compressed"&gt;Compressed&lt;/option&gt;</p><p class="source-code">    &lt;/select&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p>Using this <strong class="source-inline">select</strong>, we can switch to the <strong class="source-inline">compressed</strong> layout, which looks as follows:</p><div id="_idContainer183" class="IMG---Figure"><img src="image/B15218_05_18.jpg" alt="Figure 5.18: Compressed layout with select open&#13;&#10;"/></div><p class="figure-caption">Figure 5.18: Compressed layout with select open</p></li>
				<li>Add the <strong class="source-inline">List</strong> layout to <strong class="source-inline">src/components/List.vue</strong>. The <strong class="source-inline">list</strong> view is the compressed view but without the description:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;h3&gt;{{ title }}&lt;/h3&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  props: ['title']</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p class="source-code">&lt;style scoped&gt;</p><p class="source-code">h3 {</p><p class="source-code">  width: 100%;</p><p class="source-code">  font-weight: normal;</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p></li>
				<li>Import the <strong class="source-inline">List</strong> component into <strong class="source-inline">src/App.vue</strong> and register it locally:<p class="source-code">&lt;script&gt;</p><p class="source-code">// other imports</p><p class="source-code">import List from './components/List.vue'</p><p class="source-code">export default {</p><p class="source-code">  components: {</p><p class="source-code">    Rich,</p><p class="source-code">    Compressed,</p><p class="source-code">    List</p><p class="source-code">  },</p><p class="source-code">  // other component properties</p><p class="source-code">}</p></li>
				<li>Add an extra option with <strong class="source-inline">value="list"</strong> to switch to the <strong class="source-inline">List</strong> layout:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">    Layout: &lt;select v-model="layout"&gt;</p><p class="source-code">      &lt;option value="rich"&gt;Rich&lt;/option&gt;</p><p class="source-code">      &lt;option value="compressed"&gt;Compressed&lt;/option&gt;</p><p class="source-code">      &lt;option value="list"&gt;List&lt;/option&gt;</p><p class="source-code">    &lt;/select&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p>When switching to the <strong class="source-inline">list</strong> layout, the items are displayed in a horizontal row, as follows:</p><div id="_idContainer184" class="IMG---Figure"><img src="image/B15218_05_19.jpg" alt="Figure 5.19: List view with incorrect horizontal stacking&#13;&#10;"/></div><p class="figure-caption">Figure 5.19: List view with incorrect horizontal stacking</p></li>
				<li>To fix this horizontal stacking, create a new <strong class="source-inline">grid-column</strong> class that sets <strong class="source-inline">flex-direction: column</strong> (as opposed to <strong class="source-inline">row</strong>, which is the default) and conditionally applies it when the layout is <strong class="source-inline">list</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;div class="grid" :class="{ 'grid-column': layout ===       'list' }"&gt;</p><p class="source-code">      &lt;!-- grid using component tag --&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;style scoped&gt;</p><p class="source-code">/* existing rules */</p><p class="source-code">.grid-column {</p><p class="source-code">  flex-direction: column;</p><p class="source-code">}</p><p class="source-code">&lt;/style&gt;</p><p>Our <strong class="source-inline">List</strong> layout now looks as follows:</p><div id="_idContainer185" class="IMG---Figure"><img src="image/B15218_05_20.jpg" alt="Figure 5.20: List view with vertical stacking&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.20: List view with vertical stacking</p>
			<p>With that, we have learned how to use the <strong class="source-inline">component</strong> tag to dynamically render different components both by name and by using the component object itself. We have also explored the pitfalls of stateful dynamic components, namely the teardown of components when they are not displayed anymore and how to circumvent them using the <strong class="source-inline">keep-alive</strong> element.</p>
			<p>We will now look at how simple components can be implemented using only a <strong class="source-inline">render</strong> function or <strong class="source-inline">template</strong> tag using functional components.</p>
			<h1 id="_idParaDest-125">Functional Component<a id="_idTextAnchor178"/>s</h1>
			<p>Functional components are a subset of regular Vue.js components. They do not have state or a component instance. They can be thought of as <strong class="source-inline">render</strong> functions (as shown earlier in this chapter) to which props are passed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We can mark components as functional, which means that they are stateless (no reactive data) and instance-less (no <strong class="source-inline">this</strong> context).</p>
			<p>See the Vue.js documentation for more (<a href="https://vuejs.org/v2/guide/render-function.html#Functional-Components">https://vuejs.org/v2/guide/render-function.html#Functional-Components</a>).</p>
			<p>Functional components can only access props, children, slots, and scoped slots, as passed from their parent component. They also receive references to <strong class="bold">parents</strong> and <strong class="bold">listeners</strong>.</p>
			<p>The following is a <strong class="source-inline">Greet</strong> component (in the <strong class="source-inline">Greet.vue</strong> file). Note the <strong class="source-inline">functional</strong> annotation in <strong class="source-inline">template</strong>:</p>
			<p class="source-code">&lt;template functional&gt;</p>
			<p class="source-code">  &lt;div&gt;Functional Component: {{ props.greeting }} {{     props.audience }}&lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>Functional components must access props through <strong class="source-inline">props.propName</strong>. Functional components can also be denoted by the <strong class="source-inline">functional: true</strong> Boolean and be used with a <strong class="source-inline">render</strong> function:</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  functional: true,</p>
			<p class="source-code">  render(h, context) {</p>
			<p class="source-code">    return h(</p>
			<p class="source-code">      'h2',</p>
			<p class="source-code">      `Functional Render: ${context.props.greeting}         ${context.props.audience}`</p>
			<p class="source-code">    )</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>We can use both these functional components in the <strong class="source-inline">App.vue</strong> file:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;Greet greeting="Hello" audience="World" /&gt;</p>
			<p class="source-code">    &lt;GreetRender greeting="Hello" audience="World" /&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import Greet from './components/Greet.vue'</p>
			<p class="source-code">import GreetRender from './components/GreetRender.js'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    Greet,</p>
			<p class="source-code">    GreetRender</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>This renders the following to the browser:</p>
			<div>
				<div id="_idContainer186" class="IMG---Figure">
					<img src="image/B15218_05_21.jpg" alt="Figure 5.21: Functional component rendering&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.21: Functional component rendering</p>
			<p>Functional components are a great way to encapsulate functionality that is render-only; that is, they derive their templates from props. They have a slightly better performance profile than regular components since they do not have any associated reactive state or a component instance.</p>
			<p>A common use case we have covered for non-functional components is emitting events, which can be done as follows:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;input</p>
			<p class="source-code">    type="submit"</p>
			<p class="source-code">    @click="$emit('click', $event)"</p>
			<p class="source-code">  /&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>To emit an event with a functional component, we can bind elements to properties in the <strong class="source-inline">listeners</strong> object.</p>
			<p>To delegate all events to a child, we can use <strong class="source-inline">v-on="listeners"</strong>:</p>
			<p class="source-code">&lt;template functional&gt;</p>
			<p class="source-code">  &lt;input</p>
			<p class="source-code">    v-on="listeners"</p>
			<p class="source-code">    v-bind="data.attrs"</p>
			<p class="source-code">  /&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>To bind a specific listener, we can use <strong class="source-inline">v-on:eventName="listeners.listenerName"</strong>, where <strong class="source-inline">listenerName</strong> is the listener that the parent of the functional component is bound to:</p>
			<p class="source-code">&lt;template functional&gt;</p>
			<p class="source-code">  &lt;input</p>
			<p class="source-code">    type="submit"</p>
			<p class="source-code">    v-on:click="listeners.click"</p>
			<p class="source-code">    v-bind="data.attrs"</p>
			<p class="source-code">  /&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Binding to a listener property that does not exist will result in an error. To avoid this, we can use the <strong class="source-inline">listeners.listenerName || (() =&gt; {})</strong> expression.</p>
			<p>With that, we have learned how to implement common Vue.js component patterns using functional components with both the <strong class="source-inline">.vue</strong> component <strong class="source-inline">template</strong> variant and <strong class="source-inline">render</strong> functions.</p>
			<p>We will now build a to-do application that uses all the patterns we have looked at throughout this chapter.</p>
			<h2 id="_idParaDest-126">Activity 5.01: Buildi<a id="_idTextAnchor179"/>ng a Vue.js Application with Plugins and Reusable Components </h2>
			<p>In this activity, we will build a <strong class="bold">to-do</strong> app that integrates <strong class="source-inline">jsonplaceholder</strong> as a data source.</p>
			<p>Our to-do app will load todos and display them as a list. It will display a checkbox based on whether the to-do has been completed, as well as the name of the to-do.</p>
			<p>When checking off a to-do, the application will sync it to the API.</p>
			<p>We will inject <strong class="source-inline">axios</strong> as a plugin to query against <a href="https://jsonplaceholder.typicode.com">https://jsonplaceholder.typicode.com</a>.</p>
			<p>Follow these steps to complete this activity:</p>
			<ol>
				<li value="1">Install <strong class="source-inline">axios</strong> into the project.</li>
				<li>To inject <strong class="source-inline">axios</strong> as a property into <strong class="source-inline">this</strong> component instances, create a <strong class="source-inline">src/plugins/axios.js</strong> plugin file that, on <strong class="source-inline">install</strong>, will mean component instances have an <strong class="source-inline">axios</strong> property.</li>
				<li>For the plugin to work, import and register it in <strong class="source-inline">src/main.js</strong>.</li>
				<li>We also want to inject our API's <strong class="source-inline">baseUrl</strong> into all our components. We will create a plugin inline of the <strong class="source-inline">src/main.js</strong> file to do this.</li>
				<li>We now want to fetch all the to-dos from our <strong class="source-inline">src/App.vue</strong>. A good place to do this is in the <strong class="source-inline">mounted</strong> life cycle method.</li>
				<li>To display the to-do list, we will create a <strong class="source-inline">TodoList</strong> functional component in <strong class="source-inline">src/components/TodoList.vue</strong> that takes a <strong class="source-inline">todos</strong> prop, loops through the items, and defers rendering of the to-do under a <strong class="source-inline">todo</strong> scoped slot that binds the to-do.</li>
				<li>We can now use the <strong class="source-inline">TodoList</strong> component to render out the todos we have already fetched in <strong class="source-inline">src/App.vue</strong>.</li>
				<li>We now need to create a <strong class="source-inline">TodoEntry</strong> component where we will implement most of the to-do-specific logic. A good practice for components is to have the props be very specific to the component's role. In this case, the properties of the <strong class="source-inline">todo</strong> object we will tackle are <strong class="source-inline">id</strong>, <strong class="source-inline">title</strong>, and <strong class="source-inline">completed</strong>, so those should be the props that our <strong class="source-inline">TodoEntry</strong> component receives. We will not make <strong class="source-inline">TodoEntry</strong> a functional component since we will need a component instance to create HTTP requests.</li>
				<li>We will then update <strong class="source-inline">src/App.vue</strong> so that it consumes <strong class="source-inline">TodoEntry</strong> (making sure to bind <strong class="source-inline">id</strong>, <strong class="source-inline">title</strong>, and <strong class="source-inline">completed</strong>).</li>
				<li>Add the ability to toggle the <strong class="bold">Complete</strong> status of a <strong class="source-inline">todo</strong>. We will implement the majority of this in <strong class="source-inline">src/components/TodoEntry.vue</strong>. We will listen to the <strong class="source-inline">input</strong> change event. On change, we will want to read the new value and send a <strong class="source-inline">PATCH</strong> request to <strong class="source-inline">/todos/{todoId}</strong> with an object containing <strong class="source-inline">completed</strong> set to the new value. We will also want to emit a <strong class="source-inline">completedChange</strong> event in Vue.js so that the <strong class="source-inline">App</strong> component can update the data that's in-memory.</li>
				<li>In <strong class="source-inline">App.vue</strong>, we will want to update the relevant <strong class="source-inline">todo</strong> when <strong class="source-inline">completeChange</strong> is triggered. Since <strong class="source-inline">completeChange</strong> does not include the ID of the <strong class="source-inline">todo</strong>, we will need to read that from the context when setting the <strong class="source-inline">handleCompleteChange</strong> function to listen to <strong class="source-inline">completeChange</strong>.</li>
			</ol>
			<p>The expected output is as follows:</p>
			<div>
				<div id="_idContainer187" class="IMG---Figure">
					<img src="image/B15218_05_22.jpg" alt="Figure 5.22: Our to-do app using jsonplaceholder data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.22: Our to-do app using jsonplaceholder data</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found via <a href="B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor389">this link</a>.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor180"/>Summary</h1>
			<p>Throughout this chapter, we have looked at global composition patterns and advanced component setups that can be used to reduce duplication throughout a Vue.js application. </p>
			<p>First, we learned about mixins, which explicitly share functionality while letting components have the last say and saw the exceptions to this rule. We then saw how plugins are a great hook into multiple Vue.js primitives.</p>
			<p>Next, we looked at how prescriptive patterns maximize component reusability in Vue.js. Ideas such as leveraging props to delegate data, slots to delegate templates, and implementing interfaces that allow components to be used with Vue-idiomatic shorthand such as <strong class="source-inline">v-model</strong> were shown.</p>
			<p>We also took an in-depth look at what Vue.js components are beyond <strong class="source-inline">.vue</strong> files. We delved into what a Vue.js component is by introducing string templates, <strong class="source-inline">render</strong> functions, and JSX, as well as the requirements for each of these approaches to work. The <strong class="source-inline">component</strong> tag and <strong class="source-inline">keep-alive</strong> showed another approach to dynamically rendering components in Vue.js applications based on reactive data. Finally, we saw how functional components cement how we can define components with <strong class="source-inline">.vue</strong> files.</p>
			<p>So far, we have learned how to build applications in terms of components, mixins, and plugins. To build applications that span multiple pages, we need to implement routing. This is what we will tackle in the next chapter.</p>
		</div>
		<div>
			<div id="_idContainer189" class="Content">
			</div>
		</div>
	</body></html>