- en: '*Chapter 5*: Use Effect to Handle Side Effects'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：使用Effect处理副作用'
- en: 'In the previous chapter, we learned how `useState` is designed and how to use
    it to manage state changes in `useEffect` for managing *side effects*. We will
    first introduce what a *side effect* is, and then we will walk through the data
    structure and source code behind `useEffect` and provide various scenarios for
    invoking effects. We will also demonstrate a couple of pitfalls of using `useEffect`
    and discuss some ways to avoid them. At the end of this chapter, we''ll use `useEffect`
    in two practical examples: *Finding the window size* and *Fetching an API resource*.
    The chapter also includes three bonus topics in the *Appendix* section: *React
    side* *effects, Flushing the passive effects,* and *Is a dispatch async*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了`useState`是如何设计的，以及如何使用它来管理`useEffect`中的状态变化以管理*副作用*。我们首先介绍什么是*副作用*，然后我们将遍历`useEffect`背后的数据结构和源代码，并提供各种调用效果的场景。我们还将演示使用`useEffect`的一些陷阱，并讨论一些避免它们的方法。在本章的结尾，我们将使用两个实际示例来使用`useEffect`：*查找窗口大小*和*获取API资源*。本章还包括附录部分中的三个附加主题：*React副作用*、*刷新被动效果*和*是否是异步分发*。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is a side effect?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是副作用？
- en: '`Understanding` `useEffect` design'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`理解` `useEffect` 设计'
- en: Creating effects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建效果
- en: Test driving `useEffect`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动`useEffect`
- en: '`useEffect` examples'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useEffect` 示例'
- en: Questions and answers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问答
- en: Appendix
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附录
- en: What is a side effect?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是副作用？
- en: 'The following function has no side effect:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数没有副作用：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This function is quite pure, in the sense that if it is invoked with the same
    set of input arguments, we should get the same result – that is, `add(1, 1)` will
    return `2`. This type of *pure* function is easy to understand, test, and develop.
    The reason for this is that the function only depends on the input arguments and
    has no additional hidden dependency.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数相当纯净，从某种意义上说，如果以相同的输入参数集调用它，我们应该得到相同的结果——也就是说，`add(1, 1)`将返回`2`。这种*纯净*函数易于理解、测试和开发。原因是该函数只依赖于输入参数，没有其他隐藏的依赖。
- en: 'You might wonder what a hidden dependency could be? Believe it or not, it''s
    quite easy to have one. In the following code, we''ll intentionally introduce
    two lines and each will add a hidden dependency:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道隐藏的依赖项可能是什么？信不信由你，这相当容易发生。在下面的代码中，我们将故意引入两行，每行都会添加一个隐藏的依赖：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first line adds an external dependency from the `c` variable. Because `c`
    is a global variable, it bypasses the input argument list. If we invoke the `add(1,
    1)` function now, it can return any number (or even a non-number). That's because
    `c` can be anything at the time when `add` is invoked. This applies to all *global*
    instances.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行添加了来自`c`变量的外部依赖。因为`c`是一个全局变量，它绕过了输入参数列表。如果我们现在调用`add(1, 1)`函数，它可以返回任何数字（甚至非数字）。这是因为`c`在调用`add`时可以是任何东西。这适用于所有*全局*实例。
- en: Let's take a look at another hidden dependency. Inside the `add` function, the
    first line adds an external dependency from the `console.log` function. Our intention
    here is to log the `a` and `b` variables to the screen. However, the `console.log`
    function could be anything at the runtime. For instance, if `console` doesn't
    exist, we could get an error when invoking `console.log`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看另一个隐藏的依赖项。在`add`函数内部，第一行添加了一个来自`console.log`函数的外部依赖。我们的意图是将`a`和`b`变量记录到屏幕上。然而，`console.log`函数在运行时可能是任何东西。例如，如果`console`不存在，调用`console.log`时可能会出错。
- en: From these preceding examples, we can see that we could work with an *impure*
    function without knowing it. There's one important thing to bear in mind about
    impure functions – that is, they are prone to errors. For instance, in the preceding
    example, if someone changed any of the hidden dependencies, it would be difficult
    for the developer to know that. This can become a nightmare when it comes to refactoring
    the code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些先前的例子中，我们可以看到我们可以与一个*不纯净*的函数一起工作，而不知道这一点。关于不纯净函数，有一件重要的事情需要记住——那就是它们容易出错。例如，在先前的例子中，如果有人更改了任何隐藏的依赖项，开发者很难知道。当涉及到重构代码时，这可能会变成一场噩梦。
- en: To make our code robust, we tend to develop strategies to *avoid* hidden dependencies,
    either by removing them or containing their impact as much as possible so that
    we can be confident when developing and maintaining our code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的代码健壮，我们倾向于开发策略来*避免*隐藏的依赖项，无论是通过移除它们还是尽可能减少它们的影响，这样我们就可以在开发和维护代码时充满信心。
- en: 'In general, there are two strategies to remedy impurity of functions. One way
    is to remove it by adding the dependencies to the input arguments so that they
    are not *hidden* anymore:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，有两种策略可以解决函数的杂质问题。一种方法是通过将依赖关系添加到输入参数中来移除它，这样它们就不再 *隐藏* 了：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This can be a very effective approach. With the preceding code change, the `c`
    variable and the `log` function are explicitly written as input arguments. It
    should take less effort to test this in the case of `add(1, 1, 0, console.log)`.
    The only downside to this approach is that to implement it, you need to know the
    dependencies and declare them explicitly. This means the list of input arguments
    could get very long and impact the effectiveness of the function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是一个非常有效的方法。在之前的代码更改中，`c` 变量和 `log` 函数被明确地写为输入参数。在 `add(1, 1, 0, console.log)`
    的情况下测试这个方法应该会花费更少的精力。这个方法的唯一缺点是，要实现它，你需要知道依赖关系并明确声明它们。这意味着输入参数的列表可能会变得非常长，从而影响函数的有效性。
- en: 'This brings us to the second strategy. Instead of removing the impurity, we
    can package and defer it to a later stage until we actually need to execute it.
    The following is an example of how we can *defer* an impurity:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们来到了第二种策略。我们不仅可以移除杂质，还可以将其打包并延迟到稍后执行。以下是一个如何 *延迟* 杂质的例子：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `addFunc` function returns an `add` function. To use the `add` function,,
    we invoke `addFunc` to get a handle (also called a callback) of our `add` function
    back:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`addFunc` 函数返回一个 `add` 函数。要使用 `add` 函数，我们需要调用 `addFunc` 来获取我们的 `add` 函数的句柄（也称为回调）：'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, what difference does this make? The dependency for `c` and `log` appears
    in the input arguments, so `addFunc` is a *pure* function. Essentially, we package
    any impurities and declare them one level up, so within the context of `addFunc`,
    the new `add` function looks and works a bit purer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这有什么不同呢？`c` 和 `log` 的依赖关系出现在输入参数中，因此 `addFunc` 是一个 *纯* 函数。本质上，我们将任何杂质打包并声明到更高一级，因此在
    `addFunc` 的上下文中，新的 `add` 函数看起来和运作得更加纯净。
- en: 'In a sense, we keep the original code, but we wrap it up to get a callback
    function so that we can execute it later. This helps protect the integrity of
    the main code while relocating the impurity. This deferred strategy is normally
    referred to as a *side effect*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，我们保留了原始代码，但将其包装起来以获取一个回调函数，这样我们就可以稍后执行它。这有助于保护主代码的完整性，同时将杂质重新定位。这种延迟策略通常被称为
    *副作用*：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, the assignment of the `c` variable inside `add` is a
    side effect because it *changes* a global value; the assignment of the `a` variable
    is another side effect because it *reads from* a global value. From here, you
    can see that `console` is a solid side effect because it's an external service
    that writes to a terminal screen.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`add` 函数内部 `c` 变量的赋值是一个副作用，因为它 *改变* 了全局值；`a` 变量的赋值是另一个副作用，因为它 *读取* 了全局值。从这里，你可以看到
    `console` 是一个稳定的副作用，因为它是一个写入终端屏幕的外部服务。
- en: In a loosely connected open system, such as the web, a side effect is unavoidable.
    If you want to perform a range of actions and one action happens to not be defined
    by the internal system, then the action involves accessing an external system.
    Although we cannot avoid the side effect, we can package the side effect so that
    it accesses the external system at the right time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个松散连接的开放系统中，例如网络，副作用是不可避免的。如果你要执行一系列操作，而其中一个操作恰好没有被内部系统定义，那么这个操作就涉及到访问外部系统。虽然我们无法避免副作用，但我们可以在正确的时间打包副作用，以便它访问外部系统。
- en: Introducing passive effects
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍被动效果
- en: In React, a *side effect* refers to a case where we attempt to either *read
    from* or *write to* an *external system*. The external system can be a DOM element,
    an object such as a `document` or `window` object, or a fetch to a web server.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 中，*副作用* 指的是我们尝试从 *外部系统* 中 *读取* 或 *写入* 的情况。外部系统可以是 DOM 元素，例如 `document`
    或 `window` 对象，或者是对 web 服务器的获取。
- en: '![Figure 5.1 – React passive effects'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 *5.1* – React 被动效果'
- en: '](img/Figure_5.01_B17963.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.01_B17963.jpg)'
- en: Figure 5.1 – React passive effects
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 *5.1* – React 被动效果
- en: Upon a user action, a *dispatch* is scheduled to trigger a *render* that is
    followed by a *commit* to form an update (as illustrated in *Figure 5.1*). During
    the update, React doesn't allow custom side effects to be invoked right away.
    Instead, React waits until the end of the commit before invoking them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户执行操作时，会安排一个 *dispatch* 来触发一个 *render*，随后是一个 *commit* 来形成更新（如图 *5.1* 所示）。在更新过程中，React
    不允许立即调用自定义副作用。相反，React 会等待提交结束后再调用它们。
- en: If there are two side effects encountered during the update, both are deferred
    and then invoked one by one after the *commit*. Effects such as these are referred
    to as the passive effects internally. Passive effects are one of several types
    of effects supported by React. If you are interested in the other types of effects,
    please refer to the *Appendix A – React side effects* section at the end of this
    chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在更新过程中遇到了两个副作用，这两个副作用都会被延迟，然后在*提交*之后依次调用。这种类型的副作用在内部被称为被动副作用。被动副作用是React支持的效果类型之一。如果您对其他类型的效果感兴趣，请参阅本章末尾的*附录A
    – React副作用*部分。
- en: It is referred to as *passive* due to the way it's invoked during the update.
    React allows us to invoke a passive effect in each update or to conditionally
    invoke it when responding to a value change. Therefore, the effect isn't actively
    tied as in the case of a user event, but instead, upon a value change, the effect
    gets created, queued, and then invoked later. In a way, the effect can be invoked
    through a passive "event".
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为*被动*，是因为它在更新期间被调用的方式。React允许我们在每次更新中调用被动副作用，或者在响应值变化时有条件地调用它。因此，效果不像用户事件那样被积极绑定，而是在值变化时创建、排队，然后稍后调用。从某种意义上说，效果可以通过被动的“事件”来调用。
- en: A passive effect is modeled as a callback function. In this instance, let's
    say it's called `create`. Invoking the `create` function executes the effect and
    returns a `destroy` function to perform the cleanup job associated with the effect.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 被动副作用被建模为一个回调函数。在这个例子中，让我们假设它被称为`create`。调用`create`函数执行副作用，并返回一个`destroy`函数来执行与副作用相关的清理工作。
- en: Now that we know what a React effect is, let's dive in and see how a `useEffect`
    hook is designed to facilitate this process.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了React副作用是什么，让我们深入探讨`useEffect`钩子是如何设计来促进这一过程的。
- en: Understanding useEffect design
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`useEffect`设计
- en: 'React provides a `useEffect` hook to set up a callback to be invoked after
    an update:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: React提供了一个`useEffect`钩子来设置一个在更新后要调用的回调函数：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `useEffect` function takes a callback function called `create` as its first
    input argument to define the effect. In the preceding example, the effect sets
    the `window.title` to be `Hello World` when the component is mounted.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect`函数将其第一个输入参数称为`create`的回调函数定义为效果。在先前的例子中，该效果在组件挂载时将`window.title`设置为`Hello
    World`。'
- en: A `create` function can return a function called `destroy` to perform the cleanup.
    The interesting thing here is that the `destroy` function is provided by the `create`
    function as a return value. In the preceding example, the cleanup reverts the
    `window.title` object back to `NoTitle` when it is unmounted.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`create`函数可以返回一个名为`destroy`的函数来执行清理工作。这里有趣的是，`destroy`函数是由`create`函数作为返回值提供的。在先前的例子中，当组件卸载时，清理操作将`window.title`对象还原为`NoTitle`。
- en: The second parameter in the `useEffect` argument list is a dependency array
    called `deps`. If `deps` is *not given*, the effect gets invoked each time during
    each update, whereas when `deps` *is given*, the effect only gets invoked upon
    a change from the `deps` array.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect`参数列表中的第二个参数是一个名为`deps`的依赖数组。如果`deps`没有提供，则效果在每次更新期间都会被调用，而如果提供了`deps`，则效果仅在`deps`数组发生变化时被调用。'
- en: The useEffect hook's data structure
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`useEffect`钩子的数据结构'
- en: In this section, we are going to explain how `useEffect` is designed by taking
    a stripped-down version of the source code as an example. First, let's take a
    look at the data structure that makes it happen.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过以源代码的简化版本为例来解释`useEffect`是如何设计的。首先，让我们看看使其发生的数据结构。
- en: '![Figure 5.2 – The data structure for the useEffect hook'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 – useEffect钩子的数据结构'
- en: '](img/Figure_5.2_B17963.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.2_B17963.jpg)'
- en: Figure 5.2 – The data structure for the `useEffect` hook
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – `useEffect`钩子的数据结构
- en: 'To keep track of effects, React creates an `updateQueue` property under a fiber
    of the `UpdateQueue` type (as illustrated in *Figure 5.2*). Inside this queue,
    a list of effects is stored under the `lastEffect` property. Effects are linked
    together using a circular linked list (see *Figure 5.3*), similar to the pending
    queue that we see in `useState`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪副作用，React在`UpdateQueue`类型的纤维下创建了一个`updateQueue`属性（如图5.2所示）。在这个队列中，一个效果列表存储在`lastEffect`属性下。效果通过循环链表链接在一起（见图5.3），类似于我们在`useState`中看到的挂起队列：
- en: '![Figure 5.3 – A fiber''s update queue for useEffect'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – useEffect的纤维更新队列'
- en: '](img/Figure_5.03_B17963.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.03_B17963.jpg)'
- en: Figure 5.3 – A fiber's update queue for useEffect
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – useEffect的纤维更新队列
- en: Each effect in the list, it stores the effect function in the `create` property
    and the cleanup function in the `destroy` property.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个效果，它将效果函数存储在`create`属性中，并将清理函数存储在`destroy`属性中。
- en: The `useEffect` hook follows a typical hook setup where it takes the path of
    either `mountEffect` or `updateEffect`, depending on whether the fiber is under
    mount or update, via the `isFiberMounting` flag (as explained in [*Chapter 3*](B17963_03_Epub.xhtml#_idTextAnchor080),
    *Hooking into React*).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect`钩子遵循典型的钩子设置，它根据纤维是否在安装或更新中，通过`isFiberMounting`标志（如[*第3章*](B17963_03_Epub.xhtml#_idTextAnchor080)，*Hooking
    into React*）采取`mountEffect`或`updateEffect`的路径。'
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `useEffect` hook takes the `create` function as well as the `deps` array
    and it does not return any value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect`钩子接受`create`函数以及`deps`数组，并且不返回任何值。'
- en: Mounting an effect
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装效果
- en: 'When the component is under mount, the `mountEffect` function first creates
    a hook:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件处于安装状态时，`mountEffect`函数首先创建一个钩子：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once it gets a hook, it stores the effect under the hook''s `state`. The effect
    is created with the `pushEffect` function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它获得钩子，它将效果存储在钩子的`state`下。效果是通过`pushEffect`函数创建的：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `pushEffect` function creates an effect with all of the effect information,
    such as `create`, `destroy`, `deps`, and `next`. Then, it finds the `updateQueue`
    function under the currently updating fiber. If the queue is empty, the new effect
    gets attached. Otherwise, the new effect is appended to the queue. Either way,
    it appends the new effect as the `lastEffect` object in the queue. Since it's
    a circular linked list, after all of the previous pointer operations have taken
    place, it makes sure the `lastEffect.next` object still points to the first effect
    in the list.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushEffect`函数使用所有效果信息创建一个效果，例如`create`、`destroy`、`deps`和`next`。然后，它找到当前正在更新的纤维下的`updateQueue`函数。如果队列是空的，新的效果将被附加。否则，新的效果将被附加到队列中。无论如何，它都将新的效果作为队列中的`lastEffect`对象附加。由于它是一个循环链表，在所有先前的指针操作完成后，它确保`lastEffect.next`对象仍然指向列表中的第一个效果。'
- en: Updating an effect
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新效果
- en: 'After the component is mounted, the next time it gets updated and reaches in
    the `useEffect` hook, it goes into `updateEffect` and gets the hook by cloning
    one:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 组件安装后，下一次它更新并达到`useEffect`钩子时，它进入`updateEffect`并通过克隆一个来获取钩子：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once we have the hook, we can check the previous effect set in the mount and
    compare whether the `deps` array has changed. If the `deps` array hasn't changed
    from the `prevDeps` object stored in `prevEffect`, it returns without pushing
    the effect to `updateQueue`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了钩子，我们就可以检查在安装中设置的先前效果，并比较`deps`数组是否已更改。如果`deps`数组没有从存储在`prevEffect`中的`prevDeps`对象中更改，它将返回而不将效果推送到`updateQueue`。
- en: A utility function called `areDepsEqual` is used to compare the current and
    previous dependency arrays. We will examine this function in detail in the *Creating
    effects* section later in this chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`areDepsEqual`的实用函数用于比较当前和先前的依赖数组。我们将在本章后面的*创建效果*部分详细检查此函数。
- en: Scheduling effects
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安排效果
- en: 'There''s something very special about effects: effects are pushed into `queue`
    under each fiber, but they are scheduled around the time the screen is about to
    change.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 效果有一些非常特殊的地方：效果被推入每个纤维的`queue`中，但它们是在屏幕即将更改时安排的。
- en: 'For each effect, there are two callback functions that need to be scheduled:
    one is `create` and one is `destroy`. Taking `create` as an example, each `create`
    function is collected into a list via the `enqueueEffect` function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个效果，都有两个需要安排的回调函数：一个是`create`，另一个是`destroy`。以`create`为例，每个`create`函数都是通过`enqueueEffect`函数收集到一个列表中：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding `enqueueEffect` function takes the fiber and the effect and pushes
    it into the `effectsCreateList` array. It then schedules the `flushEffects` callback.
    The reason why the array doesn't get processed (or flushed out) the right away
    is that it has to wait until the end of the update. Here, React uses a global
    flag (`rootDoesHaveEffects`) to make sure it only triggers this schedule once.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`enqueueEffect`函数将纤维和效果推入`effectsCreateList`数组。然后，它安排`flushEffects`回调。数组之所以不立即处理（或刷新）是因为它必须等待更新结束。在这里，React使用一个全局标志（`rootDoesHaveEffects`）来确保它只触发此安排一次。
- en: 'The same process happens to each `destroy` function as well. For each update,
    we end up with two lists of effects: one for `effectCreateList` and one for `effectDestroyList`.
    Although similar, these two lists don''t necessarily contain the same list of
    effects because some effects don''t have the `destroy` callback. Moreover, when
    the component gets unmounted, the `destroy` callback needs to be added to `effectDestroyList`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的过程也发生在每个 `destroy` 函数上。对于每个更新，我们最终会得到两个效果列表：一个用于 `effectCreateList`，另一个用于
    `effectDestroyList`。尽管相似，这两个列表不一定包含相同的效果列表，因为有些效果没有 `destroy` 回调。此外，当组件卸载时，需要将
    `destroy` 回调添加到 `effectDestroyList`。
- en: The `scheduleCallback` function is quite interesting. Instead of flushing and
    executing the effects right away, it does this a bit later, just like an asynchronous
    task in a new **JavaScript** task. If you are interested in the details of this,
    please refer to the *Appendix B – Flushing passive effects* section at the end
    of this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`scheduleCallback` 函数相当有趣。它不是立即刷新并执行效果，而是稍后执行，就像在新的 **JavaScript** 任务中的异步任务一样。如果您对此感兴趣，请参阅本章末尾的
    *附录B – 清除被动效果* 部分的相关细节。'
- en: Flushing effects
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除效果
- en: 'It is only after the screen has been updated with the DOM changes that React
    can visit the effects lists again:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在屏幕更新了DOM更改之后，React 才能再次访问效果列表：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code goes over `effectDestroyList`, and each `destroy` function
    found, it gets invoked. After all of the `destroy` functions have been invoked,
    React flushes out the effects list for `create`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码遍历 `effectDestroyList`，并对找到的每个 `destroy` 函数进行调用。在所有 `destroy` 函数被调用之后，React
    清除 `create` 的效果列表：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, `effectCreateList` gets flushed out by invoking the `create`
    function under each `effect` object. The result of the `create` function is then
    taken as the `destroy` function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`effectCreateList` 通过在每个 `effect` 对象下调用 `create` 函数而被清除。`create` 函数的结果随后被用作
    `destroy` 函数。
- en: Notice the order in which React goes through both lists – it starts with `destroy`
    and then goes to `create`. Since both lists are collected from all of the fibers,
    there's a chance that the `create` function could contain a reference to a variable
    of a component that is going to be destroyed or cleaned up. In order to give the
    `create` function a chance to be fully aware of this situation, `destroy` functions
    need to be called before this happens. In short, all previous effects need to
    be cleaned up before new effects can be considered.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意React遍历两个列表的顺序 – 它从 `destroy` 开始，然后转到 `create`。由于这两个列表都是从所有纤维中收集的，因此 `create`
    函数可能包含对即将被销毁或清理的组件变量的引用。为了给 `create` 函数一个完全了解这种情况的机会，必须在发生之前调用 `destroy` 函数。简而言之，所有之前的效果都需要清理，然后才能考虑新的效果。
- en: A walk-through of the useEffect hook
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useEffect 钩子的使用方法
- en: 'This is hard work, and we have just gone through a stripped-down version of
    the `useEffect` hook''s source code. To help us understand this from a higher
    level, the following diagram outlines the `useEffect` hook in terms of the effects
    workflow in React (see *Figure 5.4*):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项艰巨的工作，我们刚刚已经浏览了 `useEffect` 钩子源代码的简化版本。为了帮助我们从更高层次理解这一点，以下图表概述了 `useEffect`
    钩子在React中的效果工作流程（参见 *Figure 5.4*）：
- en: '![Figure 5.4 – The useEffect hook and the React effects workflow'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.4 – useEffect 钩子和 React 效果工作流程]'
- en: '](img/Figure_5.04_B17963.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.04_B17963.jpg]'
- en: Figure 5.4 – The useEffect hook and the React effects workflow
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 5.4 – useEffect 钩子和 React 效果工作流程
- en: Let's do a quick run-through of *Figure 5.4*. In an update, as a `useEffect`
    hook is invoked, if the component is under mount, it creates the effect. If the
    component is under update, it creates the effect depending on whether there are
    any dependency changes. If there's no change to the dependency array, the effect
    is skipped. In all cases when the effect is created, it gets appended to the fiber's
    `updateQueue` and stored under the hooks' `state`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下 *Figure 5.4*。在更新过程中，当 `useEffect` 钩子被调用时，如果组件处于挂载状态，它将创建效果。如果组件处于更新状态，它将根据是否有任何依赖项更改来创建效果。如果没有依赖项数组的更改，则跳过效果。在所有情况下，当效果被创建时，它会被附加到纤维的
    `updateQueue` 并存储在钩子的 `state` 中。
- en: Right before the screen update, React takes all of the effects from all of the
    fibers and schedules a flush (denoted by the dotted line in *Figure 5.4*). After
    all of the fiber changes are applied to the DOM, React flushes them out by invoking
    them one by one, starting with the previous `destroy` effects and following them
    with the new `create` effects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕更新之前，React从所有纤维中获取所有效果，并安排一个刷新（在*图5.4*中以虚线表示）。在将所有纤维更改应用到DOM之后，React通过逐个调用它们来刷新它们，从之前的`destroy`效果开始，然后是新的`create`效果。
- en: Creating effects
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建效果
- en: 'An effect can be skipped. As a matter of fact, an effect needs to be created
    in an update for it to take effect. This behavior is captured by a dependency
    array called `deps`. React uses a utility function called `areDepsEqual` to help
    decide whetherthis array changes. Let''s take a closer look at this function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 效果可以被跳过。事实上，为了产生效果，需要在更新中创建效果。这种行为由一个名为`deps`的依赖项数组捕获。React使用一个名为`areDepsEqual`的实用函数来帮助决定这个数组是否发生变化。让我们更仔细地看看这个函数：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `areDepsEqual` function is used to compare two dependency arrays between
    the previous `prevDeps` array and the current `deps` array and returns `true`
    if all of the elements match. Though this sounds easy to carry out, it can run
    into various scenarios depending on the elements of the dependency arrays. We''ll
    explain all of the scenarios in the following list:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`areDepsEqual`函数用于比较前一个`prevDeps`数组和当前`deps`数组之间的两个依赖项数组，如果所有元素都匹配，则返回`true`。虽然这听起来很容易执行，但它会根据依赖项数组中的元素遇到各种情况。我们将在以下列表中解释所有这些情况：'
- en: '`prevDeps` is not provided and the usage omits the array:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未提供`prevDeps`，并且使用时省略了数组：
- en: '[PRE15]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When this happens, the `areDepsEqual` function always returns `false`, and so
    the effect gets created in each update.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当这种情况发生时，`areDepsEqual`函数总是返回`false`，因此效果在每次更新中都会被创建。
- en: '`areDepsEqual` return `true` for all updates except the first one because,
    for the mount, the `deps` array still is considered to be changed from `undefined`.
    Therefore, the effect gets created once and after this, it does not get created
    anymore.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了第一次更新之外，`areDepsEqual`返回`true`，因为对于挂载，`deps`数组仍然被认为是从`undefined`变化而来的。因此，效果只创建一次，之后不再创建。
- en: '`deps` are not empty, each element between the previous and current dependencies
    performs an `Object.is` comparison. We have already discussed the `Object.is`
    function in detail in [*Chapter 4*](B17963_04_Epub.xhtml#_idTextAnchor113), *Use
    State to* *Jumpstart Components*. Here, each element pair goes through this comparison
    to determine whether the array changes:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deps`不为空，前一个和当前依赖项之间的每个元素都会执行一个`Object.is`比较。我们已经在[*第4章*](B17963_04_Epub.xhtml#_idTextAnchor113)中详细讨论了`Object.is`函数，*使用状态启动组件*。在这里，每个元素对都会进行这个比较，以确定数组是否发生变化：'
- en: '[PRE16]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Other than the mount, if any of the elements change, such as `a` or `b`, the
    effect gets created.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了挂载之外，如果任何元素发生变化，例如`a`或`b`，效果也会被创建。
- en: Creating and destroying
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和销毁
- en: If a `destroy` function is given from the effect `create` function, this case
    also needs to be taken into consideration. Remember, we have two separate arrays
    keeping track of both mounted and unmounted cases. In general, the `destroy` function
    is invoked before the `create` function is invoked.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从效果`create`函数中提供了一个`destroy`函数，这种情况也需要考虑。记住，我们有两个独立的数组，分别跟踪挂载和卸载的情况。一般来说，`destroy`函数在`create`函数之前被调用。
- en: So, here's a quick list to summarize all of these cases.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里有一个简短的列表来总结所有这些情况。
- en: It runs `create` once after the mount.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在挂载后运行一次`create`。
- en: For any `deps` changes, it runs `destroy` and `create` once.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何`deps`的变化，它都会运行一次`destroy`和`create`。
- en: It runs `destroy` once after the unmount.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在卸载后运行一次`destroy`。
- en: If the `destroy` function is not provided, this process reduces to a single
    case below.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有提供`destroy`函数，这个过程简化为以下单个情况。
- en: It runs for any `deps` change, including the mount.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对任何`deps`的变化都运行，包括挂载。
- en: Now that we have gone through the `useEffect` hook's design as well as all of
    the scenarios of invoking the callback, let's take the `useEffect` hook for a
    test drive.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了`useEffect`钩子的设计以及所有调用回调的场景，让我们来实际测试一下`useEffect`钩子。
- en: Test driving the useEffect hook
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动`useEffect`钩子
- en: 'The effect callback is defined in the `useEffect` hook''s first input argument:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 效果回调在`useEffect`钩子的第一个输入参数中定义：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The most common way of using the `create` function can be defined by using the
    `() => {}`). For readers interested in learning more about *JavaScript ES6*, please
    see the Embracing *JavaScript ES6* section in [*Chapter 10*](B17963_10_Epub.xhtml#_idTextAnchor363),
    *Building a Website with React*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`create`函数的最常见方式可以通过使用`() => {})`来定义。对于对学习更多关于 *JavaScript ES6* 感兴趣的读者，请参阅[*第10章*](B17963_10_Epub.xhtml#_idTextAnchor363)中的*拥抱
    *JavaScript ES6* 部分，*使用 React 构建网站*。
- en: 'One of the interesting facts about this effect function is that, thanks to
    JavaScript *closures*, it can access all of the variables defined in the functional
    component:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个效果函数的有趣事实之一是，多亏了JavaScript *闭包*，它可以访问在功能组件中定义的所有变量：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `create` callback function in the preceding code references both the `a`
    variable and `text`. Without the JavaScript closure, both variables would have
    to be passed into the inline function through the input arguments explicitly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码中的`create`回调函数引用了`a`变量和`text`。如果没有JavaScript闭包，这两个变量必须通过输入参数显式地传递到内联函数中。
- en: 'Another interesting fact about the `useEffect` hook is that the effect is a
    callback where it''s quite common to see an effect involving a state changed inside.
    Let''s take a look at one example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`useEffect`钩子的另一个有趣的事实是，效果是一个回调，其中通常可以看到涉及状态变化的回调。让我们看看一个例子：
- en: '![Figure 5.5 – A button with clickable text'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 – 可点击文本的按钮'
- en: '](img/Figure_5.05_B17963.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.05 – 图 5.05_B17963.jpg](img/Figure_5.05_B17963.jpg)'
- en: Figure 5.5 – A button with clickable text
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 可点击文本的按钮
- en: 'Let''s say we have a `Title` component that gets a `text` prop. Inside, it
    has a button. When this gets clicked, it can increment a `count` state. Initially,
    the `count` value is set to `0`, and whenever the `text` prop changes, it can
    reset the `count` value back to `0`. Notice that the user clicking and the `text`
    prop change could be entirely unrelated and driven by different mechanisms. The
    former comes from the user action, whereas the latter comes from the change from
    the parent components::'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`Title`组件，它接收一个`text`属性。在其内部，有一个按钮。当这个按钮被点击时，它可以增加一个`count`状态。最初，`count`的值被设置为`0`，并且每当`text`属性发生变化时，它可以将`count`值重置回`0`。请注意，用户点击和`text`属性更改可能是完全无关的，并由不同的机制驱动。前者来自用户操作，而后者来自父组件的变化：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To implement the described behavior, we apply `useEffect` to dispatch `setCount`
    with the `deps` array set to the `text` prop. The following code example shows
    the timeline sketch for two clicks and one text change from the `a` letter to
    the `b` letter:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现所描述的行为，我们使用`useEffect`来分发`setCount`，并将`deps`数组设置为`text`属性。以下代码示例显示了两个点击和一个从`a`字母到`b`字母的文本更改的时间线草图：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As the mount starts, the first update starts with the text as `a` and the `count`
    as `0`. It also creates an effect, but since the `count` value is already `0`,
    the `setCount` dispatch is skipped.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当挂载开始时，第一次更新以文本`a`和计数`0`开始。它还创建了一个效果，但由于`count`值已经是`0`，因此跳过了`setCount`分发。
- en: As the user makes the first click, the `onClick` event handler is invoked, therefore
    setting `count` to `1`. The same applies to the second click in order to arrive
    at the `count` value of `2`. When the parent component changes the `text` prop
    from `a` to `b`, it raises another update.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户进行第一次点击时，`onClick`事件处理程序被调用，因此将`count`设置为`1`。同样适用于第二次点击，以便达到`count`值为`2`。当父组件将`text`属性从`a`更改为`b`时，它引发另一个更新。
- en: In the same update, the unchanged `count` value is printed out again. But this
    time, the dependency array of `useEffect` detects the change due to `[text]`.
    Therefore, it creates an effect to invoke `setCount(0)`. As we know that the `setCount`
    schedules another update, it will bring the `count` back to `0` afterward.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的更新中，未更改的`count`值再次被打印出来。但这次，`useEffect`的依赖数组检测到由于`[text]`引起的更改。因此，它创建了一个效果来调用`setCount(0)`。正如我们所知，`setCount`安排了另一个更新，之后它将`count`值恢复到`0`。
- en: Playground – Button with parent text
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 带有父文本的按钮
- en: Feel free to play with this example online at [https://codepen.io/windmaomao/pen/rNGOVor](https://codepen.io/windmaomao/pen/rNGOVor).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此在线示例中自由玩耍[https://codepen.io/windmaomao/pen/rNGOVor](https://codepen.io/windmaomao/pen/rNGOVor)。
- en: Wow! This is how `useEffect` works. By using `setState` inside the callback,
    an additional update can be requested to update the screen. So, the effect takes
    effect in a different update. Also, to make the effect work, the `deps` array
    needs to be wired with the right state change because if we miss it, the effect
    can be stalled. Let's take a look at one example when this happens.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这就是`useEffect`的工作方式。通过在回调函数中使用`setState`，可以请求额外的更新来更新屏幕。因此，效果在另一个更新中生效。此外，为了使效果生效，`deps`数组需要与正确的状态变化连接起来，因为如果我们遗漏了它，效果可能会停滞。让我们看看一个发生这种情况的例子。
- en: Missing dependencies
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺少的依赖关系
- en: 'Let''s go back to a simple setup:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到一个简单的设置：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you intend to print out `count` every time it changes, the preceding code
    misses the right dependency – the correct one should be `[count]` instead of `[]`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算每次`count`变化时都打印出来，前面的代码缺少了正确的依赖关系——正确的应该是`[count]`而不是`[]`。
- en: 'If this example is too obvious, let''s try a less obvious one:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个例子太明显了，让我们尝试一个不那么明显的例子：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, we introduce a `text` prop and put it in the `deps`
    array. In this case, what we get is that when the `text` changes, it prints out
    `text + count`. However, if the `count` value changes due to a user''s click,
    the screen wouldn''t change. To fix this, we can add the `count` value to the
    dependency array:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们引入了一个`text`属性并将其放入`deps`数组中。在这种情况下，我们得到的是当`text`变化时，它会打印出`text + count`。然而，如果`count`值因为用户的点击而变化，屏幕不会改变。为了解决这个问题，我们可以将`count`值添加到依赖数组中：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A pattern seems to emerge here – if an effect callback uses a variable, that
    variable needs to be in the `deps` array. This statement is practically 99.9%
    true. If you intentionally do not want to update the screen when a variable changes,
    you can skip adding it to the dependency array. However, this is not recommended
    by React. React even adds an `eslint-plugin-react-hooks`) to help us spot the
    cases where we have missed a potential dependency.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里似乎出现了一个模式——如果一个效果回调使用了变量，那么这个变量需要包含在`deps`数组中。这个说法实际上有99.9%的正确性。如果你故意不想在变量变化时更新屏幕，你可以跳过将其添加到依赖数组中。然而，React并不推荐这样做。React甚至添加了一个`eslint-plugin-react-hooks`插件来帮助我们找出我们遗漏了潜在依赖关系的案例。
- en: You might wonder why React doesn't want us to miss any dependencies. This is
    because in React, every value (or state) should be in-sync with the current screen
    and there can't be exceptions to this rule by default.. In [*Chapter 8*](B17963_08_Epub.xhtml#_idTextAnchor278),
    *Use Ref to Hide Stuff*, we will show you a recommended way if you insist on keeping
    things hidden from React.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么React不希望我们遗漏任何依赖关系。这是因为，在React中，每个值（或状态）都应该与当前屏幕保持同步，并且默认情况下不能有违反这一规则的例外。在[*第8章*](B17963_08_Epub.xhtml#_idTextAnchor278)，“使用Ref隐藏内容”，我们将展示如果你坚持要隐藏内容不被React看到的一个推荐方法。
- en: Now that we have seen cases that have used both effects and states , let's take
    a look at another example of when we might run into problems with them.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了同时使用效果和状态的情况，让我们看看另一个我们可能会遇到问题的例子。
- en: Infinite loops
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无限循环
- en: Combining *state* and *effects* can cause another interesting problem because
    an effect can change a state and therefore schedule a new update, and then the
    new update can create a new effect and change a state, and this can continue indefinitely.
    This could lead to an *infinite loop*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将*状态*和*效果*结合起来可能会引起另一个有趣的问题，因为一个效果可以改变状态并因此安排一个新的更新，然后新的更新可以创建一个新的效果并改变状态，这可以无限期地继续下去。这可能会导致一个*无限循环*。
- en: 'We can demonstrate this with a quick example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个快速示例来演示这一点：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code, there''s an effect that increments a `count` state after
    any `count` change. After invoking `setCount`, in the next update, `useEffect`
    would detect a change from the dependency array and thereby invoke `setCount`
    again. Because every time this happens we get a new `count` number, this process
    wouldn''t stop, as you can see in the following timeline sketch:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有一个效果会在任何`count`变化后增加`count`状态。在调用`setCount`之后，在下一次更新中，`useEffect`会检测到依赖数组中的变化，从而再次调用`setCount`。因为每次发生这种情况我们都会得到一个新的`count`数字，这个过程不会停止，就像你在下面的时间线草图中所看到的那样：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Normally, we wouldn't do this intentionally, but we can accidentally run into
    exactly this scenario in a more complex setup, especially when many different
    states and effects are involved. It's our job to avoid an infinite loop whenever
    possible since this isn't accounted for by React.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们不会故意这样做，但我们在更复杂的设置中可能会意外地遇到这种情况，特别是当涉及许多不同的状态和效果时。我们的任务是尽可能避免无限循环，因为React没有考虑到这一点。
- en: 'So, how do we deal with an infinite loop in code? We can break out of a loop
    with an `if` statement, and this is normally the most cost-effective approach:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何处理代码中的无限循环呢？我们可以使用 `if` 语句跳出循环，这通常是成本效益最高的方法：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code, after we add the `if` statement on the first line inside
    the effect, the timeline confirms that we don''t have an infinite loop anymore:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在效果的第一行内部添加了 `if` 语句后，时间线确认我们没有无限循环了：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, it's not too difficult to break out of a loop. You can think
    of this as an equilibrium state that you want to reach – the effect does need
    to be triggered for a state change, but once an equilibrium state is reached,
    it stops without continuing the loop.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，跳出循环并不太难。您可以将这视为您想要达到的平衡状态——效果确实需要被触发以进行状态改变，但一旦达到平衡状态，它就会停止而不会继续循环。
- en: Now that we have gone over how `useEffect` is used, let's take a look at two
    practical cases for applying it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用 `useEffect`，让我们看看两个实际的应用案例。
- en: useEffect examples
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: useEffect 示例
- en: 'The `useEffect` hook is normally used for any side effect – whether that is
    to read from an external object or write to an external object. In the following
    sections, we are going to see two more examples: *Finding the window size* and
    *Fetching an API resource*.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 钩子通常用于任何副作用——无论是从外部对象读取还是写入外部对象。在接下来的几节中，我们将看到两个更多示例：*查找窗口大小* 和
    *获取 API 资源*。'
- en: Finding the window size
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找窗口大小
- en: 'Let''s say that we want to know the current browser window size at runtime
    so that a greeting title can fit perfectly onto the screen (see *Figure 5.6*):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在运行时知道当前浏览器窗口的大小，以便问候标题可以完美地显示在屏幕上（见图 5.6）：
- en: '![Figure 5.6 – Finding the window size'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – 查找窗口大小'
- en: '](img/Figure_5.06_B17963.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – 查找窗口大小](img/Figure_5.06_B17963.jpg)'
- en: Figure 5.6 – Finding the window size
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 查找窗口大小
- en: 'This can be done normally with a **CSS** media query, but this time, we want
    to do it via *JavaScript*, as a runtime *JavaScript* variable obtained can be
    sent for purposes other than CSS usage:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过正常的 **CSS** 媒体查询来完成，但这次，我们想通过 *JavaScript* 来实现，因为获得的运行时 *JavaScript* 变量可以用于除
    CSS 之外的其他目的：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `useEffect` hook is a good fit here. After the component is mounted, we
    can listen for a `resize` event provided by the `window` object. Once it starts
    to listen to the event, every time the window resizes, it kicks off a `handleResize`
    function that sets the `width` state to the new window size. We also invoke `handleResize`
    at the mount to get the initial window size.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 钩子在这里非常适用。组件挂载后，我们可以监听由 `window` 对象提供的 `resize` 事件。一旦开始监听该事件，每当窗口大小改变时，就会触发一个
    `handleResize` 函数，将 `width` 状态设置为新的窗口大小。我们还在挂载时调用 `handleResize` 以获取初始窗口大小。'
- en: In this example, if the current width is greater than 600 px, we know that it
    can fit the `Hello World` string on screen. Otherwise, the `Hello` string will
    be used. This shows that we can control the display based on the window size on
    the fly with J*avaScript.*
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果当前宽度大于 600 像素，我们知道它可以在屏幕上显示 `Hello World` 字符串。否则，将使用 `Hello` 字符串。这表明我们可以使用
    JavaScript 在运行时根据窗口大小动态控制显示。
- en: Playground – Finding the Window Size
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 查找窗口大小
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/BadRoNN](https://codepen.io/windmaomao/pen/BadRoNN).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自由地在这个在线示例中尝试 [https://codepen.io/windmaomao/pen/BadRoNN](https://codepen.io/windmaomao/pen/BadRoNN)。
- en: In order to prevent a memory leak, we return a `destroy` function from the `useEffect`
    callback where the registered event listener is removed when the component is
    unmounted.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止内存泄漏，我们从 `useEffect` 回调函数中返回一个 `destroy` 函数，在组件卸载时移除注册的事件监听器。
- en: There's a subtle detail to be aware of here – the dependency array has `setWidth`
    in it because we reference `setWidth` inside the `useEffect` function. If you
    remember from [*Chapter 4*](B17963_04_Epub.xhtml#_idTextAnchor113), *Use State
    to Jumpstart Components*, we know the `setWidth` function instance doesn't get
    changed after the mount, so actually, `[setWidth]` can be optional here. But React
    insists that we add this because when `setWidth` changes, the effect needs to
    be re-created.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个需要注意的微妙细节——依赖数组中包含 `setWidth`，因为我们已经在 `useEffect` 函数中引用了 `setWidth`。如果您还记得从
    [*第 4 章*](B17963_04_Epub.xhtml#_idTextAnchor113) 的内容，即 *使用状态启动组件*，我们知道 `setWidth`
    函数实例在挂载后不会改变，所以实际上，`[setWidth]` 在这里是可以省略的。但 React 强制要求我们添加它，因为当 `setWidth` 改变时，效果需要被重新创建。
- en: Fetching an API resource
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取 API 资源
- en: 'One popular use of `useEffect` is to fetch an API resource and display the
    data on screen:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 的一个流行用法是获取 API 资源并在屏幕上显示数据：'
- en: '![Figure 5.7 – Fetching an API resource, loading status'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7 – 获取 API 资源，加载状态]'
- en: '](img/Figure_5.07_B17963.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 5.07_B17963.jpg]'
- en: Figure 5.7 – Fetching an API resource, loading status
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 获取 API 资源，加载状态
- en: 'The idea here is to use the `fetch` JavaScript function to get the resource.
    During loading, the screen should say `loading...` (as in *Figure 5.7*). And after
    the resource is successfully fetched, the `loading...` string should be dismissed
    and replaced with the fetched text on the screen:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是使用 `fetch` JavaScript 函数来获取资源。在加载期间，屏幕应该显示 `loading...`（如图 *5.7*）。资源成功获取后，`loading...`
    字符串应该被移除，并在屏幕上替换为获取的文本：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we use a `text` state to store the fetched text and a
    state `loading` flag to store the loading status. A `useEffect` hook is used to
    fetch the resource and when it's successful, it updates the `text` and `loading`
    flag.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用一个 `text` 状态来存储获取的文本，并使用一个 `loading` 标志状态来存储加载状态。使用 `useEffect`
    钩子来获取资源，当成功时，它会更新 `text` 和 `loading` 标志。
- en: Playground – Fetching an API Resource
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏场 – 获取 API 资源
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/ZEJKbev](https://codepen.io/windmaomao/pen/ZEJKbev).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎您在此在线示例中尝试 [https://codepen.io/windmaomao/pen/ZEJKbev](https://codepen.io/windmaomao/pen/ZEJKbev)。
- en: In this case, the effect doesn't return anything. There's actually a cleanup
    to do in this case, but we will wait until [*Chapter 8*](B17963_08_Epub.xhtml#_idTextAnchor278),
    *Use Ref to Hide Stuff*,to explore that in detail.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，效果没有返回任何内容。实际上，在这种情况下需要清理，但我们将在[*第 8 章*](B17963_08_Epub.xhtml#_idTextAnchor278)，*使用
    Ref 隐藏内容*中详细探讨这一点。
- en: Notice that an `if` statement is used before the `return` statement. In [*Chapter
    3*](B17963_03_Epub.xhtml#_idTextAnchor080), *Hooking into React*, we mentioned
    that `if` cannot be used in between hook statements. So, in this case, we move
    it after all of the hook statements and put it right before the last return statement.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `return` 语句之前使用了一个 `if` 语句。在[*第 3 章*](B17963_03_Epub.xhtml#_idTextAnchor080)，*Hooking
    into React*中，我们提到 `if` 不能在钩子语句之间使用。因此，在这种情况下，我们将它移动到所有钩子语句之后，并放在最后一个返回语句之前。
- en: In this case, the `if` statement acts as a short-circuit. If the `loading` status
    is `true`, it does not go any further other than returning a `loading...` string.
    This `if` statement approach is one of the most cost-effective ways to make sure
    the screen only renders material when it's available.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`if` 语句充当短路。如果 `loading` 状态为 `true`，它不会做任何进一步的操作，只是返回一个 `loading...`
    字符串。这种 `if` 语句方法是最经济实惠的确保屏幕仅在内容可用时渲染材料的方法之一。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We really did a lot in this chapter. First, we got to know what a side effect
    is, and we dug deeper into the `useEffect` hook's design. We discovered how an
    effect can be created and then later invoked after a UI update. We also learned
    about various scenarios for creating effects based on dependency arrays. After
    that, we walked through the pitfalls of using `useEffect` with missing dependencies,
    staled values, and infinite loops. Last but not least, we learned to apply `useEffect`
    in practical components, such as the examples of finding the window size in a
    browser and fetching API resources from an online server.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中做了很多工作。首先，我们了解了什么是副作用，并深入研究了 `useEffect` 钩子的设计。我们发现了如何创建一个效果，然后在 UI 更新后稍后调用它。我们还学习了基于依赖数组的创建效果的多种场景。之后，我们探讨了使用
    `useEffect` 时缺少依赖项、过时值和无穷循环的陷阱。最后但同样重要的是，我们学习了如何在实际组件中应用 `useEffect`，例如在浏览器中查找窗口大小和从在线服务器获取
    API 资源的示例。
- en: In the next chapter, we will discover our next hook in the React family and
    focus on how to apply an optimization to boost performance by using values from
    a previous update.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将发现 React 家族中的下一个钩子，并关注如何通过使用前一个更新的值来应用优化以提升性能。
- en: Questions and answers
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和答案
- en: 'Here are some questions and answers to refresh your knowledge:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些问题和答案来刷新您的知识：
- en: What is a side effect?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是副作用？
- en: A side effect is when a function relies on or modifies something outside of
    its input arguments. A very common side effect is the use of `console.log` inside
    a function.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 副作用是指函数依赖于或修改其输入参数之外的内容。一个非常常见的副作用是在函数内部使用 `console.log`。
- en: What is `useEffect`?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 `useEffect`？
- en: The `useEffect` hook is a way of defining a side effect callback to be invoked
    after a screen update in React. The effect can be invoked every time or when one
    of its dependencies changes. Therefore, the `useEffect` hook can be also used
    for listening for value changes.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useEffect`钩子是在React中定义一个在屏幕更新后调用的副作用回调的方式。效果可以每次调用或当其依赖项之一发生变化时调用。因此，`useEffect`钩子也可以用于监听值的变化。'
- en: What are the most common uses of `useEffect`?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`useEffect`最常用的用途是什么？'
- en: The `useEffect` hook is a common hook in the React family. If used along with
    the `useState` hook, it can easily communicate with external resources and bring
    results on screen. External resources can be web servers, DOM elements, `window`
    objects, `document` objects, or any third-party entities.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`useEffect`钩子是React家族中的常见钩子。如果与`useState`钩子一起使用，它可以轻松与外部资源通信并在屏幕上显示结果。外部资源可以是Web服务器、DOM元素、`window`对象、`document`对象或任何第三方实体。'
- en: Appendix
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: Appendix A – React side effects
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录A – React副作用
- en: When it comes to React, the most well-known effects are passive effects, as
    introduced and explained in detail in this chapter. However, React supports different
    kinds of effects, and in the future, it might add more. The two others currently
    are *mutation effects* and *layout effects*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到React时，最知名的效果是被动效果，正如本章所介绍和详细解释的那样。然而，React支持不同类型的效果，并且在未来可能会添加更多。目前另外两种是*突变效果*和*布局效果*。
- en: All effects are shared with certain features, such as getting collected from
    the fibers before the screen gets updated. But they also differ in some ways.
    Take the *mutation effects* as a first example. Under the engine, these kind of
    effects are the most important effects because each mutation effect tracks the
    addition, removal, or change of a DOM element. Therefore, all fiber reconciliation
    ends up with mutation effects that get committed to the screen. The mutation of
    the DOM elements is also part of the update, or more accurately, the *commit*
    phrase of the update. While the passive effects run after the update, all mutation
    effects happen before the passive effects.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 所有效果都与某些功能共享，例如在屏幕更新之前从纤维中收集。但它们在某些方面也有所不同。以*突变效果*为例。在引擎下，这类效果是最重要的效果，因为每个突变效果都跟踪DOM元素的添加、删除或更改。因此，所有纤维协调最终都会产生被提交到屏幕上的突变效果。DOM元素的突变也是更新的一部分，或者更准确地说，是更新的*提交*阶段。而被动效果在更新之后运行，所有突变效果都在被动效果之前发生。
- en: 'To remedy the fact that passive effects run after the update (because by then
    it might be too late to perform a certain action), the *layout effect* is created
    to be invoked a bit earlier. Everything about the layout effect is similar to
    the passive effect, except it gets invoked right after the mutation effect and
    flushes out before the end of the update. The relationships and timing between
    all three kinds of effects can be summarized in the following commit stage outlined
    in *Figure 5.8*:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了纠正被动效果在更新之后运行的事实（因为那时可能已经太晚执行某些操作），创建了*布局效果*以稍早调用。关于布局效果的各个方面都与被动效果相似，除了它在突变效果之后立即调用并在更新结束时刷新。所有三种效果之间的关系和时机可以总结如下，如*图5.8*中概述的提交阶段：
- en: '![Figure 5.8 – React effects during the commit phase'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8 – 提交阶段中的React效果'
- en: '](img/Figure_5.08_B17963.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.08_B17963.jpg)'
- en: Figure 5.8 – React effects during the commit phase
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 提交阶段中的React效果
- en: Note that during the commit stage, only the mutation and layout effects get
    flushed out.. The passive effects get scheduled initially and later enqueued,
    but not flushed out until after the commit. Please read on to the *Appendix B
    – Flushing passive effects* section for more details.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在提交阶段，只有突变和布局效果会被刷新出来。被动效果最初被安排并随后入队，但不会在提交之后刷新。请继续阅读到*附录B – 刷新被动效果*部分以获取更多详细信息。
- en: Appendix B - Flushing passive effects
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录B - 刷新被动效果
- en: In order to understand how passive effects are scheduled and flushed, we need
    to first mention *JavaScript* *tasks*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解被动效果是如何被安排和刷新的，我们首先需要提到*JavaScript* *任务*。
- en: '![Figure 5.9 – JavaScript tasks'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.9 – JavaScript任务'
- en: '](img/Figure_5.09_B17963.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.09_B17963.jpg)'
- en: Figure 5.9 – JavaScript tasks
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – JavaScript任务
- en: In *Figure 5.9*, we can see three *JavaScript* tasks. What is a task? A *task*
    is any *JavaScript* code that is scheduled to run by the standard mechanism. In
    the first task on the left, we finished one update. Normally, that's all we need
    to know about running *JavaScript* code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图5.9*中，我们可以看到三个*JavaScript*任务。什么是任务？*任务*是任何由标准机制安排运行的*JavaScript*代码。在左边的第一个任务中，我们完成了一次更新。通常，我们只需要了解这么多关于运行*JavaScript*代码的情况。
- en: However, because *JavaScript* is a single-thread engine, during the execution
    of the current task, there can be more work added to the pending queue. A typical
    example is a `setTimeout` call, which adds the callback to the queue instead of
    invoking it right away in the same task. API calls (like promises) normally fall
    into this category as well. This is the main reason why these callbacks are referred
    to as *asynchronous operations*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于*JavaScript*是一个单线程引擎，在当前任务的执行过程中，可能会有更多的工作添加到待处理队列中。一个典型的例子是`setTimeout`调用，它将回调添加到队列中而不是立即在同一任务中调用它。API调用（如promises）通常也属于这一类。这是这些回调被称为*异步操作*的主要原因。
- en: There's no specification for how long each task should take. When one task finishes,
    it looks for all the work in the pending queue and then invokes it one task at
    a time, and after everything is done, it looks at the pending queue again. This
    process repeats itself forever. This is what the *JavaScript* engine does.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 没有规定每个任务应该持续多长时间。当一个任务完成时，它会查找待处理队列中的所有工作，然后逐个调用它们，等所有事情都完成后，它再次查看待处理队列。这个过程会永远重复。这就是*JavaScript*引擎所做的事情。
- en: In our case, we have a very short-lived task (middle task in *Figure 5.9*) followed
    by a third task. Guess what – this is when the flushing out of passive effects
    begins. From this, we can be sure that the callback in the `useEffect` callback
    is invoked asynchronously.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们有一个非常短暂的任务（*图5.9*中的中间任务）后面跟着第三个任务。猜猜看——这就是被动效果开始刷新的时候。从这一点我们可以确定，`useEffect`回调中的回调是异步调用的。
- en: We mentioned that the multiple state dispatches are also bundled and executed
    in a deferred way – so is a `setState` dispatch also an asynchronous call? To
    answer that question, please read on to the *Appendix C – Is a dispatch asynchronous?*
    section.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到多个状态分发也是以延迟方式打包和执行的——那么`setState`分发也是一个异步调用吗？为了回答这个问题，请继续阅读*附录C - 分发是异步的吗*部分。
- en: Appendix C – Is a dispatch asynchronous?
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录C – 分发是异步的吗？
- en: Since passive effects are invoked in a new task, at this point, you might wonder
    whether a `setState` dispatch is run in the same task or in a new task. This is
    a very good question.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于被动效果是在新任务中调用的，在这个时候，你可能想知道`setState`分发是在同一个任务中运行还是在新的任务中。这是一个非常好的问题。
- en: 'To answer this, we need to have a reference point in time. Let''s say we have
    an event handler, and inside it, we have a `setState` dispatch call:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我们需要一个时间参考点。假设我们有一个事件处理程序，并在其中有一个`setState`分发调用：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `onClick` event is an event that is requested as a callback via a user action.
    Let's say that the task that invokes the `onClick` event is called *Task 1*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`onClick`事件是一个通过用户操作请求作为回调的事件。假设调用`onClick`事件的任务是称为*Task 1*。'
- en: In React 17 (not the current version), the `setState` code is sync, which means
    it runs in the same *Task 1* for the entire update. React decides it's more efficient
    to finish them all in the same task. So, why do we say the `setState` object is
    normally deferred?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在React 17（不是当前版本）中，`setState`代码是同步的，这意味着它在整个更新过程中都在同一个*Task 1*中运行。React决定将它们都在同一个任务中完成更有效率。那么，我们为什么说`setState`对象通常是延迟的呢？
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That's because right after `setState`, the value hasn't been changed yet. Only
    the next update will set the state to the new version. But calling `setState`
    an async operation isn't exactly accurate (if not wrong) because all of this process
    is performed in the same *JavaScript* task.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在`setState`之后，值还没有被改变。只有下一次更新才会将状态设置为新的版本。但是将`setState`称为异步操作并不完全准确（如果不是错误的话），因为所有这些过程都是在同一个*JavaScript*任务中执行的。
- en: What if we put `setState` in a `useEffect` hook? Does this passive effect change
    the sync or async discussion?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`setState`放入`useEffect`钩子中呢？这会不会改变同步或异步的讨论？
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By now, we know that the `useEffect` callback gets invoked in a new *JavaScript*
    task – let's say this task is called *Task 1*. And the `setState` runs in the
    same *Task 1*. This makes it behave in quite a similar way to an event handler,
    such as in the case of `onClick` discussed previously. For this reason, we could
    also think of a passive effect as an *"event"* that is more passive than an event
    handler.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们知道`useEffect`回调会在一个新的*JavaScript*任务中被调用——让我们称这个任务为*任务1*。而`setState`也是在同一个*任务1*中运行的。这使得它的行为与之前讨论的事件处理器（如`onClick`）非常相似。因此，我们也可以将被动效果视为一个比事件处理器更*被动*的*"事件"*。
- en: 'This doesn''t prevent us from making an async dispatch if we really want to.
    Let''s take a look at one example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不阻止我们真正想要进行异步分发。让我们看看一个例子：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding example, `setTimeout` is used to fire a callback in an async
    way. After the mouse click, `dispatch(5)` is invoked first. And after the update,
    `dispatch(3)` is invoked, even though the timeout duration is set to `0`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`setTimeout`被用来以异步方式触发一个回调。在鼠标点击后，首先调用`dispatch(5)`。更新后，即使超时时间设置为`0`，也会调用`dispatch(3)`。
- en: Keep in mind, if you do that, you are not only running the callback in an async
    way, but you also break out of the React scheduling cycle. The reason you might
    want to do this is that there can be conflicts during DOM changes, for example,
    during drag-and-drop handling. In order to finish our code before making the state
    change, we can push the dispatch to the next *JavaScript* task queue.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果你这样做，你不仅是以异步的方式运行回调，而且还打破了React的调度周期。你可能想要这样做的原因是在DOM变化期间可能会出现冲突，例如在拖放处理期间。为了在我们进行状态更改之前完成我们的代码，我们可以将分发推到下一个*JavaScript*任务队列。
