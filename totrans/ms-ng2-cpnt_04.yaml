- en: Chapter 4. No Comments, Please!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the course of this chapter, we will create reusable components to enable
    commenting not only on projects, but also on any other entity within our application.
    We'll build our commenting system in a way that it will allow us to place it anywhere
    we'd like for our users to put comments. In order to provide our users with a
    feature to edit existing comments and also a seamless authoring experience, we'll
    create an editor UI component that could be used to make arbitrary content within
    our application editable.
  prefs: []
  type: TYPE_NORMAL
- en: Discussing security and proper user management in this chapter is still out
    of scope, but we're going to create a dummy user service that will help us simulate
    a logged-in user. This service will be used by the commenting system, and we'll
    refactor our existing component to make use of it too.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `contenteditable` to create an in-place editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `@HostBinding` and `@HostListener` to bind component members to host element
    properties and events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating directly with view children using the `@ViewChild` annotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing DOM operations by injecting and using `ElementRef`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a dummy user service and using the `@Injectable` annotation to serve
    it as a dependency injection provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying custom actions on component input changes, using the `OnChanges` life
    cycle hook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple pipe to format relative time intervals using the `Moment.js`
    library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One editor to rule them all
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we will be processing a lot of user input within our application, it's
    crucial to provide a nice authoring experience to our users. Within the commenting
    system we're about to create in this chapter, we need a way through which users
    could edit existing comments, as well as add new comments. We could use regular
    text area input and work with dialog boxes to edit comments, but this seems too
    old-fashioned for a modern user interface, which we're going to build, and does
    not really provide a great user experience. What we're looking for is a way to
    edit stuff in place. The commenting system will not only benefit from such an
    in-place editor, but it will also help us create the editor component in such
    a way that we can use it for any content within our application that we'd like
    to make editable.
  prefs: []
  type: TYPE_NORMAL
- en: In order to build our in-place editor, we're going to use the `contenteditable`
    API that will enable a user to modify the content within the HTML elements directly
    in the site document.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how we can use the `contenteditable` attribute
    to make HTML elements editable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Run the preceding example on a blank HTML page and click on the `h1` text. You
    will see that the element has become editable and you can type to modify its content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting notified about changes within editable elements is fairly easy. There''s
    an input event emitted on every DOM element that is editable, and this will allow
    us to react to a change easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With this example, we have already created a naive implementation of an in-place
    editor where we're able to monitor changes applied by the user. Within this topic,
    we'll use this standard technology to build a reusable component that we can use
    wherever we want to make things editable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an editor component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s create a new folder named `editor` within our `ui` folder. In
    this folder, we''re going to create a new component file named `editor.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Okay, that's quite a lot of new code. Let's dissect the different parts of the
    `Editor` component and go through each part step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within our `Editor` component, we''ll need to interact with the native DOM
    element, which is editable. The easiest and also the safest method to do this
    is to use the `@ViewChild` decorator in order to retrieve an element with a local
    view reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous chapter, we learned about the `@ContentChildren` annotation,
    which helps us obtain a list of all the child components within content projection
    points. If we would like to do the same with regular view children, we need to
    use the equivalent `@ViewChildren` annotation. While `@ContentChildren` searches
    for components within content projection points, `@ViewChildren` hunts for the
    regular sub-tree of a component.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to search the component sub-tree for one single component, we can
    use the `@ViewChild` annotation (please note that `@ViewChild` and `@ViewChidren`
    are different).
  prefs: []
  type: TYPE_NORMAL
- en: '| Query annotation | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@ViewChildren`(selector) | Will query the current component''s view for
    either directives or components and return an object of the type `QueryList`.
    If the view is dynamically updated, this list will be updated as well. |'
  prefs: []
  type: TYPE_TB
- en: '| `@ViewChild`(selector) | Will query for only the first matching component
    or directive and return an instance of it. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A selector can be either a directive or component type, or a string that contains
    the name of a local view variable. If a local view variable name is provided,
    Angular will search for the element containing the view variable reference.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to communicate with view child components directly, using `@ViewChild`
    and `@ViewChildren` annotations should be your preferred way.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you need to run the initialization code on view children after your
    component is initialized. In such cases, you can use the `AfterViewInit` life
    cycle hook. While the view child properties of your component class will still
    be undefined within the constructor of your component, they will be populated
    and initialized after the `AfterViewInit` life cycle callback.
  prefs: []
  type: TYPE_NORMAL
- en: The `@ViewChild` and `@ViewChildren` decorators are great tools to interact
    with in your view directly. It doesn't really matter whether you'd like to interact
    with a DOM element or a component instance. Both use cases are nicely covered
    using this declarative API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move back to our `Editor` component code. The next thing we''re going
    to look into are the component''s input functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `content` input property is the main interface for interacting with the
    component from outside. Using property bindings, we can have any preexisting text
    content set up in the editor component.
  prefs: []
  type: TYPE_NORMAL
- en: The `editMode` property is a Boolean value that controls whether the editor
    is in edit or display mode. Our editor component will depend on this flag to know
    whether content should be edited or not. This allows us to switch from read-only
    mode to edit mode and back interactively.
  prefs: []
  type: TYPE_NORMAL
- en: Though an input property, this flag can be controlled from outside the component.
    At the same time, it can also be used to create property binding of a host element.
    Specifically, we can use the flag to create a class attribute binding to add or
    remove the modifier class, `editor--edit-mode`. This class is used to control
    some differences in the visual appearance of the editor while in edit mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last of the three input properties in our editor component, `showControls`,
    controls whether the editor should show the control functions. There are three
    controls that will be shown when this property evaluates to a true value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Edit button**: This will be shown when the component is in display mode,
    and it will switch the component to edit mode using the `editMode` flag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Save button**: This will be shown only if the component is in edit mode.
    This control will save the changes applied within the current edit mode and switch
    the component back to display mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cancel button**: This is the same as the save button, and this control is
    shown only when the component is in edit mode. If activated, the component will
    switch back to display mode, reverting any changes that you may have made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides our input properties, we also need some output properties to notify
    the outer world about the changes within our editor. The following piece of code
    helps us do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `editSaved` event will be emitted once the edited content is saved using
    the save button control. Also, it'll be better if an event is emitted upon every
    input change within our editable content element. For this, we used the `editableInput`
    output property.
  prefs: []
  type: TYPE_NORMAL
- en: Our editor component works in a simple way. If the component is in edit mode,
    it shows an element that can be edited. However, once the editor switches back
    to display mode, we see a different element that cannot be edited. The visibility
    is controlled with the modifier class set by the host element property binding
    to the `editMode` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular has no control over the content within our editable element. We control
    this content manually by using native DOM operations. Let''s look at how we did
    this. First of all, we needed to use delegates to access the element, since we''re
    most likely going to change how we will read and write to and from the editable
    element. We used the following to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we used the `nativeElement` property on our `editableContentElement`
    field, previously set by the `@ViewChild` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Angular does not directly provide us with a DOM element reference but a wrapper
    object of the type `ElementRef`. It's basically a wrapper around the native DOM
    element, holding additional information that is relevant to Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `nativeElement` accessor, we can obtain a reference to the underlying
    DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ElementRef` wrapper plays an important part in Angular's platform-agnostic
    architecture. It allows you to run Angular in different environments (for example,
    native mobile, web workers, or others). It's part of an abstraction layer between
    the components and their views.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also needed a way to set the content of the editable element based on the
    input that we would receive from the content input property. We could use the
    life cycle hook `OnInit`, which will be called only after the input properties
    are checked upon component initialization. However, this life cycle hook fires
    only once after the initialization, and we needed a way that would have helped
    us react to subsequent input changes of the `content` property. Have a look at
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `OnChanges` life cycle hook is exactly what we needed here. With this, once
    a change in the content input property is detected (this also includes the first
    change after the initialization), we can reflect the changed content onto our
    editable element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have already implemented the reflection of the component content input
    property onto the editable field. But what about the opposite direction? We need
    to find a way to reflect the changes in our editable element onto our component
    `content` property. That''s also closely related to the actions performed on the
    component using the available controls within edit mode, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**In the save operation**: Here, we reflect the edited content from the editable
    element back to the component''s `content` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**In the cancel operation**: Here, we ignore what has been edited by the user
    within the editable element and set its content back to the value in the component''s
    `content` property:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the code for those two operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the highlighted code, which shows the reflection between the
    component's `content` property and the editable element, we emitted certain events
    that would help us notify the outside world about the changes. In both the operations,
    we set the `editMode` flag to `false` after completion. This ensures that our
    editor will switch to display mode after any one of the operations is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `edit` method will be called from the edit control button when the component
    is in display mode. The only thing it does is that it switches the component back
    to edit mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Whatever we''ve discussed thus far in relation to the code is good enough for
    us to set up a fully functional component. However, the last part of the code,
    which we haven''t discussed yet, relates to ensuring better accessibility of our
    editor. Since our editor component is a bit larger than the editable element,
    we also want to make sure that a click anywhere inside the editor component will
    cause the editable element to be focused. The following code makes this happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using the `@HostListener` decorator, we registered an event binding on our component
    element that called the `focusEditableContent` method. Inside this method, we
    used the reference to the editable DOM element and triggered a focus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the template of our component that is located within the `editor.html`
    file in order to see how we could interact with the logic within our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The logic within the editor component template is quite straightforward. If
    you've been following the component code, you'll now be able to identify the different
    elements that compose this component's view.
  prefs: []
  type: TYPE_NORMAL
- en: The first element with the `editor__editable-content` class is our editable
    element that has the `contenteditable` attribute. The user will be able to type
    into this element when the editor is in edit mode. It's important to note that
    we've annotated it with a local view variable reference, `#editableContentElement`,
    which we're using in our view child queries.
  prefs: []
  type: TYPE_NORMAL
- en: The second element with the `editor__output` class is only to display the editor
    content and is only visible when the editor is in display mode. The visibility
    of both the elements is controlled using CSS, based on the `editor--edit-mode`
    modifier class, which, if you recall from the component class code, is set through
    host property binding based on the `editMode` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three control buttons are shown using the `NgIf` directive conditionally.
    The `showControls` input property needs to be `true`, and depending on the `editMode`
    flag, the screen will either show the edit button or the save and the cancel button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an editor component](img/image00316.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of our editor component in action
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within this building block, we have created an in-place editor widget, which
    we can use to grab user input for any content within our application. It allows
    us to provide the user with contextual editing capabilities, which will result
    in a great user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also learned about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `contenteditable` HTML5 attribute to enable in-place editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `@ViewChild` and `@ViewChildren` to query view child elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `ElementRef` dependency to perform native DOM operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the logic, using the `OnChange` life cycle hook, to reflect data
    between Angular and the content that is not in immediate control of Angular.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building a commenting system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous topic, we created an editor component that will support users
    in editing content within our application. Here, we''re going to create a commenting
    system that will enable users to write comments in various areas of our application.
    The commenting system will use our editor component to make comments editable,
    and thereby help users create new comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a commenting system](img/image00317.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An illustration of the component sub-tree of a commenting system
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram illustrates the architecture of the component tree within
    the commenting system that we are about to create.
  prefs: []
  type: TYPE_NORMAL
- en: The `Comments` component will be responsible for listing all the existing comments,
    as well as creating new comments.
  prefs: []
  type: TYPE_NORMAL
- en: Each comment itself is encapsulated into a `Comment` component. `Comment` components
    themselves use an editor that enables users to edit comments once they are created.
  prefs: []
  type: TYPE_NORMAL
- en: The `Editor` component, which we built in the previous topic, is used by the
    `Comment` component directly, to provide an input control for adding new comments.
    This allows us to reuse the functionality of our editor component to capture user
    input.
  prefs: []
  type: TYPE_NORMAL
- en: The `Editor` component emits an `editSaved` event once editable content is saved
    using the control buttons of the editor. In the `Comment` component, we will capture
    these events and propagate a new event upward to our `Comments` component. There,
    we will do the necessary updates but then again emit a new event to notify our
    parent about the change. In a composition of components, each component will react
    on change and delegate to the parent component if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Building the comment component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start building our commenting system by fleshing out the `Comment` component
    first. In addition to the comment itself, we'd like to display the user's profile
    who commented, and of course, the time of the comment.
  prefs: []
  type: TYPE_NORMAL
- en: To display the time, we will make use of relative time formatting, as this will
    give our users a better feel of time. Relative time formatting displays timestamps
    in the format "5 minutes ago" or "1 month ago", in contrast to absolute timestamps,
    such as "25.12.2015 18:00". Using the `Moment.js` library, we'll create a pipe
    that we can use within component templates to convert timestamps and dates into
    relative time intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new pipe within a new folder named `pipes`. The pipe needs
    to be created within a file named `from-now.js`, which is created under the `pipes`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This pipe can now be used within the templates of components to format timestamps
    and dates into relative time intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use this pipe and the `Editor` component we created in the previous
    topic to create our `Comment` component. Within a file named `comment.html`, which
    is located within a new `comment` folder in the `comments` folder, we''ll create
    the template for our `Comment` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: From the user object, we will get the user's profile image as well as the username.
    To display the time of the comment in a relative format, we'll use the `fromNow`
    pipe that we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will make use of the in-place editor component to display the content
    of the comment and make it editable at the same time. We will bind the comment
    content property to the content input property of the editor. At the same time,
    we will listen for the `editSaved` event of the editor and call the `onContentSaved`
    method on our comment component class. If you look at our component code again,
    you'll notice that we are re-emitting the event within the method so that the
    outside world is also notified about the change in the comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the component class that we will create in a file named
    `comment.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The component code is pretty straightforward. The only noticeable difference
    to other components we've created so far is the `pipes` property within the component's
    annotation. Here, we specify that we'd like to use the `FromNowPipe` class that
    we've just created. Pipes always need to be declared within the component; otherwise,
    they can't be used within the component's template.
  prefs: []
  type: TYPE_NORMAL
- en: As input, we expect a user object that is passed along with the `user` input
    property. The `content` input property should be filled with the actual comment
    as a string, while the `time` input property should be set to a timestamp that
    reflects the actual time of the comment.
  prefs: []
  type: TYPE_NORMAL
- en: We also have an output property called `commentEdited`, which we will use to
    notify the changes on the comment. The `onEditSaved` method will be called by
    the event binding on our `Editor` component, which will then emit an event using
    the `commentEdited` output property.
  prefs: []
  type: TYPE_NORMAL
- en: Building the comments component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have all the components ready in order to finish building our commenting
    system. The last missing piece of the puzzle is the `Comments` component, which
    will list all the comments and provide an editor to create new comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the template of our `Comments` component that
    we will create in a file named `comments.html` within a folder named `comments`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can see the direct usage of an `Editor` component within the component's
    template. We are using this in-place editor to provide an input component to create
    new comments. We could also use a text area here, but we've decided to reuse our
    `Editor` component. We will set the `editMode` property to true so it will be
    initialized in edit mode. We will also set the `showControls` input to `false`
    because we don't want the editor to become autonomous. We will only use its in-place
    editing capabilities, but control it from our `Comments` component.
  prefs: []
  type: TYPE_NORMAL
- en: To add a new comment, we will use a button that has a click event binding, which
    calls the `addNewComment` method on our component class.
  prefs: []
  type: TYPE_NORMAL
- en: Below the section where users can add new comments, we will create another section
    that will list all the existing comments. If no comments exist, we simply don't
    render the section. With the help of the `NgFor` directive, we could display all
    the existing comments and create a `Comment` component for each repetition. We
    will bind all the comment data properties to our `Comment` component and also
    add an event binding to handle updated comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the component class within a new file named `comments.js` in
    the `comments` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through individual code parts again and discuss what each of them
    does. First, we declared an input property named `comments` in our component class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `comments` input property is a list of comment objects that contains all
    of the data associated with the comments. This includes the user who authored
    the comment and the timestamp, as well as the content of the comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to be able to emit an event once a comment is added or an existing
    comment is modified. For this purpose, we used an output property named `commentsUpdates`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Once a new comment is added or an existing one is modified, we will emit an
    event from this output property with the updated list of comments.
  prefs: []
  type: TYPE_NORMAL
- en: The `Editor` component we're going to use to add new comments will not have
    its own control buttons. We will use the `showControls` input property to disable
    them. Instead, we will control the editor from our `Comments` component directly.
    Therefore, we need a way to communicate with the `Editor` component within our
    component class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the `@ViewChild` decorator for this purpose again. However, this time,
    we did not reference a DOM element, which contains a local view variable reference.
    We directly passed our component type class to the decorator. Angular will search
    for any `Editor` components within the comments view and provide us with a reference
    to the instance of the editor. This is shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since the `Comments` component only hosts one editor directly within the component
    template, we can use the `@ViewChild` annotation to obtain a reference to it.
    Using this reference, we can directly interact with the child component. This
    will allow us to control the editor directly from our `Comments` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the next part of the code, which is the `Comments` component
    constructor. The only thing we''ve done here is inject a user service that will
    provide us with a way to obtain information of the currently logged-in user. As
    of now, this functionality is only mocked, and we will receive information of
    a dummy user. We need this information in the `Comments` component, since we need
    to know which user has actually entered a new comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next part of the code, we controlled how we should react to the changes
    of the `comments` input property. Actually, we would never want the list of comments
    to remain undefined. It should be an empty list in case there are no comments,
    but the input property comments should never be undefined. We controlled this
    by using the `OnChange` life cycle hook and overriding our `comments` property
    if it was set to `undefined` from outside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This small change makes the internal handling of our comment data much cleaner.
    We don't need additional checks when working for array transformation functions,
    and we can always treat the `comments` property as an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `Comments` component is also responsible for handling the logic that
    deals with the process of adding new comments, we needed a method that could implement
    this requirement. In relation to this, we used some immutable practices we learned
    about in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There are a few key aspects in this part of the code. This method will be called
    from our component view when the `Add comment` button is clicked. This is when
    the user will have already entered some text into the editor and a new comment
    will have been created.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will use the user service that we injected within the constructor
    to obtain information related to the currently logged-in user. The content of
    the newly created comment will be obtained directly from the `Editor` component
    we set up using the `@ViewChild` annotation. And, the `getEditableContent` method
    will allow us to receive the content of the editable element within the in-place
    editor.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we wanted to do was to communicate an update of the comment list
    with the outside world. We used the `commentsUpdated` output property to emit
    an event with the updated comment list.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we wanted to clear the editor used to add new comments. As the in-place
    editor in the view of the `Comments` component is only used to add new comments,
    we can always clear it after a comment is added. This will give the user the impression
    that his comment has been moved from the editor into the list of comments. Then,
    once again, we can access the `Editor` component directly using our `newCommentEditor`
    property and call the `setEditableContent` method with an empty string to clear
    the editor. And this is what we've done here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Comments` component will hold the list of all the comments, and its view
    will create a `Comment` component for each comment in that list. Each `Comment`
    component will use an `Editor` component to provide in-place editing of its content.
    These editors work autonomously using their own controls, and they emit an event
    if the content is changed or altered in any way. To take care of this, we need
    to re-emit this event with the name `commentEdited` from the `Comment` component.
    Now we only need to catch this event within our `Comments` component in order
    to update the list of comments with the changes. This is illustrated in the following
    part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This method will be called for each individual `Comment` component that is repeated
    using the `NgFor` directive. From the view, we pass a reference to the comment
    object concerned, as well as the edited content we would receive from the `Comment`
    component event.
  prefs: []
  type: TYPE_NORMAL
- en: The comment object will only be used to determine the position of the updated
    comment within the comment list. If the new comment content is empty, we will
    remove the comment from the list. Otherwise, we will just create a copy of the
    previous comment object, change the content with the new edited content, and replace
    the old comment object in the list with the copy.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, since we wanted to communicate the change in the comment list, we emitted
    an event using the `commentUpdated` output property.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have completed our commenting system, and now it's time to make
    use of it. We already have an empty tab prepared for our project comments, and
    this is going to be the spot where we will add commenting capabilities using our
    commenting system.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s amend our `Project` component template, `project/project.html`,
    to include the commenting system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is as easy as it gets. Since we are paying attention to a clean component
    architecture, the inclusion of our commenting system really works like a breeze.
    The only thing we now need to ensure is that we provide a property on our project
    with a list of comments. We also need a way to react to changes if comments are
    updated within our `Comments` component. For this purpose, we will create an `updateComments`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the component class changes within the `project/project.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are already dealing with project updates in a general way and our
    `Project` component is emitting directly to our `App` component, where projects
    data will be persisted, the only thing we need to implement is an additional input
    property, as well as a method to handle comment updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the comments component](img/image00318.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of the commenting system integrated within our project component
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within this topic, we have successfully created a full-fledged commenting system
    that can be placed in various areas of our application to enable commenting. Users
    can interact with in-place editors to edit the content in comments, which gives
    them a great user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'While writing the code for our commenting system, we learned about the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a simple pipe using the `@Pipe` annotation and the `Moment.js`
    library to provide relative time formatting
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `OnChanges` life cycle hook to prevent unwanted or invalid values
    within input properties
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `@ViewChild` to obtain a reference to the components within the component
    sub-tree in order to establish direct communication
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reusing the `Editor` component as an input field replacement and as an autonomous
    in-place editor within the `Comment` component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a simple in-place editor that we can use for making
    content editable within our application. Going forward, we can use the `Editor`
    component wherever we want to make content editable for our users. They will not
    have to jump into nasty dialogs or separate configuration pages, but will be in
    a position to edit directly, as per their current context. This is a great tool
    for enhancing the user experience for our users.
  prefs: []
  type: TYPE_NORMAL
- en: Besides our shiny new `Editor` component, we created a whole commenting system
    that can be easily included in areas of our application where we'd like to provide
    commenting capabilities. We have now included the commenting system within our
    `Project` component, and users can now comment on projects by navigating to the
    **Comments** tab on the project details.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll use the component-based router of Angular to make
    our application navigable.
  prefs: []
  type: TYPE_NORMAL
