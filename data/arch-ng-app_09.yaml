- en: NgRx – Reduxing that Angular App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgRx – Reduxing that Angular App
- en: We have reached the last chapter of this book. The time has come to understand
    the NgRx library. So far, different topics have been covered, making you as a
    reader more used to thinking about things such as immutable data structures and
    reactive programming. We did all this so it would be easier for you to digest
    what is to come in this chapter. NgRx is an implementation of Redux made for Angular,
    so concepts such as store, action creators, actions, selectors, and reducers are
    well used. What you have hopefully picked up on by reading the past chapters is
    how Redux works. By reading the previous chapter, you will have discovered how
    what you learned about Redux translates to NgRx and its principles on how to organize
    your code. This chapter aims to describe the core library `@ngrx-store`, how to
    handle side effects with `@ngrx-effects`, and how to debug like a pro with `@ngrx/store-devtools`,
    among other things.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了这本书的最后一章。现在是时候理解 NgRx 库了。到目前为止，已经涵盖了不同的主题，使您作为读者更习惯于思考诸如不可变数据结构和响应式编程等问题。我们这样做是为了使您更容易消化本章中将要介绍的内容。NgRx
    是为 Angular 制作的 Redux 实现，因此诸如存储、动作创建器、动作、选择器和还原器等概念被广泛使用。您通过阅读前面的章节可能已经了解到了 Redux
    的工作原理。通过阅读上一章，您将发现您所学的 Redux 知识如何转化为 NgRx 以及其代码组织原则。本章旨在描述核心库 `@ngrx-store`，如何使用
    `@ngrx-effects` 处理副作用，以及如何像专业人士一样使用 `@ngrx/store-devtools` 进行调试，以及其他内容。
- en: 'In this chapter, we will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: State management with `@ngrx/store`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@ngrx/store` 进行状态管理
- en: Handling side effects with `@ngrx/effects`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@ngrx/effects` 处理副作用
- en: How to debug with `@ngrx/store-devtools`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `@ngrx/store-devtools` 进行调试
- en: How to capture and transform the router state with `@ngrx/router-store`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `@ngrx/router-store` 捕获和转换路由状态
- en: NgRx overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgRx 概述
- en: 'NgRx consists of the following parts:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: NgRx 由以下部分组成：
- en: '`@ngrx/store`: This is the core that contains a way for us to maintain state
    and dispatch actions.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ngrx/store`：这是包含我们维护状态和分发动作方式的核心。'
- en: '`@ngrx/effects`: This will handle side effects such as, AJAX requests, for
    example.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ngrx/effects`：这将处理副作用，例如，例如 AJAX 请求。'
- en: '`@ngrx/router-store`: This ensures we can integrate NgRx with the Angular routing.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ngrx/router-store`：这确保我们可以将 NgRx 与 Angular 路由集成。'
- en: '`@ngrx/store-devtools`: This will install a tool that gives us the opportunity
    to debug NgRx by, for example, giving us a time travel debugging functionality.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ngrx/store-devtools`：这将安装一个工具，例如，通过提供时间旅行调试功能，给我们调试 NgRx 的机会。'
- en: '`@ngrx/entity`: This is a library that helps us manage record collections.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ngrx/entity`：这是一个帮助我们管理记录集合的库。'
- en: '`@ngrx/schematics`: This is a scaffolder library that helps you when using
    NgRx.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ngrx/schematics`：这是一个脚手架库，在您使用 NgRx 时提供帮助。'
- en: A word on state management
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于状态管理的一些话
- en: Some components must have state. When there is a need for another component
    to know about that very same state, the first component needs to find a way to
    communicate that to the other component. There are many ways to achieve this.
    One way is to ensure that all state that should be shared lives in a centralized
    store. Think of this store as a single source of truth, from which all components
    can read. Every state does not necessarily need to end up in the centralized store,
    as the state may only concern a specific component. Before NgRx and Redux, one
    way of solving this was to put everything in a globally accessible object or service.
    The store, as we mentioned, is just that. It is globally accessible in the sense
    that it can be injected into any component that might need it. A word of caution;
    even though it is tempting to put all of our state in our store, we really shouldn't.
    State that we notice needs to be shared between components is worth putting there.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组件必须具有状态。当有其他组件需要了解那个非常相同的状态时，第一个组件需要找到一种方法将这个状态传达给其他组件。有许多实现这一目标的方法。一种方法是通过确保所有应该共享的状态都生活在中央存储中。将这个存储视为一个单一的真实来源，所有组件都可以从中读取。并不是每个状态都一定需要最终进入中央存储，因为状态可能只关注特定的组件。在
    NgRx 和 Redux 之前，解决这一问题的方法之一是将所有内容放入一个全局可访问的对象或服务中。正如我们提到的，存储就是这样。它在全局上是可访问的，因为它可以被注入到可能需要它的任何组件中。一个警告：尽管将所有状态放入我们的存储中很有诱惑力，但我们真的不应该这样做。需要在不同组件之间共享的状态值得放入那里。
- en: Another benefit we get from having a centralized store is that it is very easy
    to save down the application's state for later recovery. If state only lives in
    one place, a user, or the system, can easily persist that state to a backend so
    that next time, if they want to continue from where they left off, they can easily
    do so by querying the backend for that state. So, there does exist another reason
    for wanting a centralized store other than wanting to share the data between many
    components.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从拥有集中式存储中我们得到的另一个好处是，保存应用程序的状态以便稍后恢复非常容易。如果状态只存在于一个地方，比如用户或系统，那么用户可以轻松地将该状态持久化到后端，这样下次，如果他们想要从上次离开的地方继续，他们可以通过查询后端的状态来轻松地做到这一点。所以，除了想要在许多组件之间共享数据之外，还存在另一个想要集中存储的原因。
- en: '@ngrx/store – state management'
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ngrx/store – 状态管理'
- en: All of the files in this section points to `Chapter9/State` project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的所有文件都指向`Chapter9/State`项目。
- en: 'This is the moment we have been waiting for. How do we actually get started?
    It''s really easy. Let''s first ensure we have installed Angular CLI. We do so
    by typing the following in our terminal:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们一直等待的时刻。我们实际上该如何开始呢？这真的很简单。首先，让我们确保我们已经安装了Angular CLI。我们通过在终端中输入以下内容来完成此操作：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'At this point, we need an Angular project. We use the Angular CLI for that,
    and scaffold ourselves a new project using the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要一个Angular项目。我们使用Angular CLI来做这件事，并使用以下命令搭建一个新项目：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the scaffolding process is done, we navigate to our newly created director
    project with a simple `cd <project dir>`.We want to use the core functionality
    provided in the `@ngrx/store` library, therefore we install it by typing the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦搭建过程完成，我们使用简单的`cd <项目目录>`命令导航到我们新创建的项目目录。我们想要使用`@ngrx/store`库提供的核心功能，因此我们通过输入以下内容来安装它：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s now open up the `app.module.ts` file in our scaffolded project. The
    time has come to import and register NgRx with `AppModule`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们打开我们搭建的项目中的`app.module.ts`文件。是时候将NgRx导入并注册到`AppModule`中了：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we''ve highlighted the important part, which is importing
    `StoreModule` and registering it with `AppModule` by typing:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们突出显示了重要部分，即导入`StoreModule`并通过输入将其与`AppModule`注册：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we are telling the store what state should exist, which is `counter`,
    and that `counterReducer` is the reducer meant to take care of that slice of state.
    As you can see, the code doesn''t quite work yet because we haven''t created `counterReducer`
    yet, let''s do that next:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉存储应该存在什么状态，即`counter`，以及`counterReducer`是负责该状态片段的reducer。正如你所见，代码还没有完全工作，因为我们还没有创建`counterReducer`，让我们接下来创建它：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Hopefully, you have read [Chapter 8](e29180be-1bdf-4fdb-805b-333607fd6e0d.xhtml),
    *Redux*, and understand why we write the reducer file as we have done. Let''s
    recap a bit, and declare that a reducer is just a function that takes a state
    and produces a new state given an action. It''s also important to stress that
    reducers are so called pure functions that do not change the state, but produce
    a new state, given the old state plus the incoming action. Let''s show here how
    we would theoretically use our reducer if we wanted to use it outside of Redux.
    We do this just to demonstrate how reducers work:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经阅读了[第8章](e29180be-1bdf-4fdb-805b-333607fd6e0d.xhtml)，*Redux*，并理解为什么我们以这种方式编写reducer文件。让我们回顾一下，并声明reducer只是一个函数，它接受一个状态并根据一个动作产生一个新的状态。同样重要的是强调，reducer被称为纯函数，它不会改变状态，而是根据旧状态加上传入的动作产生一个新的状态。让我们在这里展示如果我们想在Redux之外使用reducer时会如何理论性地使用它。我们这样做只是为了演示reducer是如何工作的：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see from this, we start off with an initial value of `0`, and it
    computes a new value that results in `1`. Upon the second execution of the function,
    we provide it with the existing state, which has the value `0`. This results in
    our state now being `2`. This may look simple, but this is pretty much as complicated
    as a reducer can get. Normally, you wouldn''t execute the reducer function yourself
    but rather register it with the store and dispatch actions towards the store.
    This will lead to the reducer being invoked. So, how do we tell the store to dispatch?
    Simple, we use the function `dispatch()` on the store. For this code, let''s move
    to the `app.component.ts` file. We also need to create a file called `app-state.ts`,
    which is an interface, a typed representation of our store:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们从初始值`0`开始，并计算出一个新值，结果为`1`。在函数的第二次执行中，我们向它提供现有的状态，其值为`0`。这导致我们的状态现在变为`2`。这看起来可能很简单，但这几乎是一个reducer可能达到的复杂程度。通常，你不会自己执行reducer函数，而是将其注册到store中，并向store发送动作。这将导致reducer被调用。那么，我们如何告诉store发送动作呢？很简单，我们使用store上的`dispatch()`函数。对于这段代码，让我们转到`app.component.ts`文件。我们还需要创建一个名为`app-state.ts`的文件，它是一个接口，是我们store的类型化表示：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'What we can see from the preceding code is how we inject a store service into
    the constructor, like so:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到我们如何将store服务注入到构造函数中，如下所示：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Thereafter, we call `store.select("count")`, which means we are asking our
    store for the `count` property part of its state as that''s all this component
    cares about. A call `store.select()` returns an `Observable` that when resolved
    contains a value. We can easily show this value by adding it to the template markup,
    like so:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，我们调用`store.select("count")`，这意味着我们正在向store请求其状态的`count`属性部分，因为这就是这个组件所关心的。`store.select()`的调用返回一个`Observable`，当解析时包含一个值。我们可以通过将其添加到模板标记中轻松显示此值，如下所示：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That takes care of getting and displaying the state. What about dispatching
    an action? The store instance has a method on it called `dispatch()`, which takes
    an object containing the property type. So the following is perfectly good input:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了获取和显示状态。那么，发送动作怎么办？store实例上有一个名为`dispatch()`的方法，它接受一个包含属性类型的对象。所以以下是一个完美的输入：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s build out our component a little, and create some methods and markup
    that will allow us to dispatch actions and see the end result of doing so:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建我们的组件，并创建一些方法和标记，以便我们可以发送动作并看到这样做的结果：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We added the `increment()` and `decrement()` methods to the class body, and
    also added two buttons to the markup that invoke said functions. Trying this out,
    we can see how our UI is updated for every press of the button. The reason for
    this working is, of course, that each dispatched action calls our `counterReducer`
    implicitly, and also because we hold a reference to our state in the form of the
    `counter$` variable. As this is an `Observable`, it means it will be updated when
    a change happens. The change is then pushed out to our `counter$` variable when
    an action is dispatched. It's simple, but powerful.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类体中添加了`increment()`和`decrement()`方法，并在标记中添加了两个按钮，这些按钮调用这些函数。尝试这样做，我们可以看到我们的UI在每次按钮按下时都会更新。当然，这是因为每个发送的动作都会隐式调用我们的`counterReducer`，也因为我们在`counter$`变量的形式中持有对状态的引用。由于这是一个`Observable`，这意味着当发生变化时它会被更新。当发送动作时，变化会被推送到我们的`counter$`变量。这很简单，但很强大。
- en: A more complex example – a list
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个更复杂的例子——一个列表
- en: We have so far learned how to set up NgRx by importing and registering its module.
    We have also been taught about the `select()` function that gives us a slice of
    state, and the `dispatch()` function that allows us to dispatch an action. These
    are the basics, we will use these very same basics and create a new reducer to
    reinforce what we already know, while introducing the concept payload.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何通过导入和注册其模块来设置NgRx。我们还学习了`select()`函数，它给我们一个状态切片，以及允许我们发送动作的`dispatch()`函数。这些都是基础知识，我们将使用这些非常相同的基础知识来创建一个新的reducer，以巩固我们已知的知识，同时引入负载的概念。
- en: 'We need to do the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做以下事情：
- en: Tell the store we have a new state, `jedis`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉store我们有一个新的状态，`jedis`
- en: Create a `jediListReducer` and register it with the store
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`jediListReducer`并将其注册到store中
- en: Create a component that supports showing our `jediList`, but is also able to
    dispatch actions that will change our slice of state `jedis`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个组件，它不仅支持显示我们的`jediList`，还能够发送改变我们状态切片`jedis`的动作。
- en: 'Let''s get down to business by defining our reducer, `jediListReducer`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始定义我们的reducer，`jediListReducer`：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s explain what goes on here for each case in our switch. First off, we
    have `ADD_JEDI`. We take our `action.payload` and add it to the list. Or technically,
    we take our existing list and construct a new list based on the old list, plus
    our new list item found in `action.payload`. Secondly we have `REMOVE_JEDI` that
    uses the `filter()` function to take away the list item that we don''t want to
    see. Lastly we have `LOAD_JEDIS` that takes in an existing list and replaces our
    state. Now, let''s demo this reducer by invoking it here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这里的每个case发生了什么。首先，我们有`ADD_JEDI`。我们取我们的`action.payload`并将其添加到列表中。或者技术上，我们取我们的现有列表并根据旧列表构建一个新列表，加上我们在`action.payload`中找到的新列表项。其次，我们有`REMOVE_JEDI`，它使用`filter()`函数来移除我们不希望看到的列表项。最后，我们有`LOAD_JEDIS`，它接受一个现有列表并替换我们的状态。现在，让我们通过在这里调用它来演示这个reducer：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s register this reducer with the store. We will therefore return
    to `app.module.ts`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个reducer注册到store中。因此，我们将返回到`app.module.ts`：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Because we just added a new state to our store, we should make the `app-state.ts`
    file aware of it, and we should also create a `Jedi` model so we can use that
    in our component later on:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们刚刚向我们的store添加了一个新的状态，我们应该让`app-state.ts`文件知道它，我们还应该创建一个`Jedi`模型，这样我们就可以在组件中稍后使用它：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'From the preceding code, we can see that `jediListReducer`, as well as the
    state `jediList`, is added to the object that serves as input to the `StoreModule.forRoot()`
    function. This means that NgRx is aware of this state and will let us retrieve
    it and dispatch actions to it. To do so, let''s build a component with just that.
    We need to create the `jedi-list.component.ts` file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到`jediListReducer`以及状态`jediList`被添加到作为`StoreModule.forRoot()`函数输入的对象中。这意味着NgRx知道这个状态，并将允许我们检索它并向它分发动作。为了做到这一点，让我们构建一个只包含这个功能的组件。我们需要创建`jedi-list.component.ts`文件：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The last thing we need to do is to register this component with our module,
    and we should have a working application:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是将这个组件注册到我们的模块中，我们应该有一个可工作的应用程序：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Best practices
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: The following files points to the demo project `Chapter9/BestPractices`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文件指向演示项目`Chapter9/BestPractices`。
- en: 'So far, we have created some working code, but it could look a lot better,
    and be less error prone as well. There are steps we can take to improve the code,
    those are:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一些可工作的代码，但它可以看起来好得多，并且错误的可能性也更小。我们可以采取一些步骤来改进代码，那些是：
- en: Get rid of so-called magic strings and rely on constants
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摆脱所谓的魔法字符串并依赖常量
- en: Add a default state to your reducer
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的reducer中添加一个默认状态
- en: Create so-called action creators
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建所谓的动作创建者
- en: Move everything into a dedicated module and split up it up into several components
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有内容移动到一个专用模块中，并将其拆分为几个组件
- en: 'Let''s have a look at our first bullet point. Given the type of actions we
    perform on our `jediList`, we can create a `constants.ts` file for them, like
    so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的第一个项目符号。根据我们在`jediList`上执行的动作类型，我们可以为它们创建一个`constants.ts`文件，如下所示：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, when we refer to these actions we can instead import this file and use
    these constants instead, decreasing the risk of us mistyping.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们引用这些动作时，我们可以改用导入这个文件并使用这些常量，从而降低我们输入错误的几率。
- en: 'The second thing we can do is to simplify the creation of actions by creating
    the so-called action creator. We are so far used to typing the following to create
    an action:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第二件事是通过创建所谓的动作创建者来简化动作的创建。到目前为止，我们已经习惯了输入以下内容来创建一个动作：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A better habit here is to create a function that does this for us. For the
    case with the list reducer, there are three possible actions that can take place,
    so let''s put all these in a `actions.ts` file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个更好的习惯是创建一个为我们做这件事的函数。对于列表reducer的情况，有三种可能发生的情况，所以让我们把这些都放在一个`actions.ts`文件中：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The point of creating the `actions.ts` file was so that we would have to write
    less code when we dispatch actions. Instead of writing the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`actions.ts`文件的目的在于，当我们分发动作时，我们不需要写太多的代码。而不是写以下内容：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now write this as:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以写成这样：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A cleanup example
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个清理示例
- en: The following scenario can be found in the **`Chapter9/BestPractices`** folder
    of the code repository.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下场景可以在代码仓库的**`Chapter9/BestPractices`**文件夹中找到。
- en: 'Let''s explain where we are coming from, and why there might be a need to clean
    up your code. If you are starting out with a very simple app, you might add the
    reducer, the actions, and components in the root module of your project. This
    might create a mess as soon as you want to add another component. Let''s illustrate
    what our file structure might look like before we start cleaning up:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下我们是从哪里来的，以及为什么可能需要清理你的代码。如果你从一个非常简单的应用开始，你可能会在项目的根模块中添加reducer、actions和组件。一旦你想添加另一个组件，这可能会造成混乱。让我们在开始清理之前展示一下我们的文件结构可能的样子：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From this, it's pretty clear that this will only hold up if our app will only
    consist of that one component. As soon as we add more components, things will
    start to look messy.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，很明显，如果我们的应用只包含那个一个组件，这只会持续下去。一旦我们添加了更多组件，事情就会开始变得混乱。
- en: 'Let''s list what we need to do to create a better file structure, but also
    utilize the action creator, constants, and reducers in the best way possible:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出我们需要做什么来创建一个更好的文件结构，同时尽可能好地利用动作创建者、常量和reducers：
- en: Create a dedicated feature module and directory
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个专门的功能模块和目录
- en: Create action constants that the reducer and actions file can use
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建reducer和动作文件可以使用的动作常量
- en: Create an action creator file with all the actions we mean to perform
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含所有我们打算执行的动作的动作创建者文件
- en: Create a reducer that handles dispatches
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个处理派发的reducer
- en: Create a `JediList` component that is able to handle all actions we mean to
    use
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个能够处理我们打算使用的所有动作的`JediList`组件
- en: Register our reducer and state with the store
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的reducer和状态注册到store中
- en: Create a dedicated directory and feature module
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个专门的目录和功能模块
- en: 'For that reason, we want to place everything in a dedicated directory, `jedi`.
    The easiest way to do that is to use the Angular CLI and run the following commands:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，我们希望将所有东西都放在一个专门的目录`jedi`中。最容易的方法是使用Angular CLI并运行以下命令：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code will generate the following files:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成以下文件：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Place yourself in your newly created `jedi` directory and type the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将自己置于新创建的`jedi`目录中，并输入以下内容：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will add the following structure to your `jedi` directory:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的`jedi`目录中添加以下结构：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, we have created the `jedi-list.component` and its belonging files
    in a previous section, so we will remove those scaffolded files for now and just
    move in the already created files under the `jedi-list` directory. So, your directory
    should look like:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在前面的部分中已经创建了`jedi-list.component`及其相关文件，所以现在我们将移除这些生成的文件，并将已经创建的文件移动到`jedi-list`目录下。所以，你的目录应该看起来像这样：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Add reducer and constants
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加reducer和常量
- en: 'Let''s create our reducer, like so:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的reducer，如下所示：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our next order of business is our constants file, which has already been created
    and just need to move, like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个任务是我们的常量文件，它已经被创建，只需要移动，如下所示：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A general tip is if you find the number of components and files growing, consider
    creating a dedicated directory for it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个一般的建议是，如果你发现组件和文件的数量在增长，考虑为它们创建一个专门的目录。
- en: 'Next up is the action creator file that we have also already created, and that
    we just need to move to our `jedi` directory, like so:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们也已经创建并需要移动到我们的`jedi`目录的动作创建者文件，如下所示：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our directory should now look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目录现在应该看起来像这样：
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Moving the component to our jedi directory
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将组件移动到我们的jedi目录
- en: 'The next point is about moving our `JediListComponent` to our `jedi` directory,
    like so:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下一点是关于将我们的`JediListComponent`移动到我们的`jedi`目录，如下所示：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After moving our `jedi-list` component, our directory should now look like
    the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将`jedi-list`组件移动之后，我们的目录现在应该看起来如下所示：
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Registering our reducer with the store
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在store中注册我们的reducer
- en: 'Lastly, we just need to do a slight update to the `app.module.ts` file to have
    it point correctly to our `JediListReducer`, like so:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需要对`app.module.ts`文件进行轻微的更新，使其正确指向我们的`JediListReducer`，如下所示：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Leveraging types and feature modules
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用类型和功能模块
- en: The following files is pointing to the demo project `Chapter9/FeatureModules`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文件指向的是演示项目`Chapter9/FeatureModules`。
- en: 'OK, one thing we can definitely improve is how we tell the `StoreModule` about
    what state and reducers exist in our app. Let''s do a quick recap and look at
    its current state:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们可以肯定改进的一点是，我们如何告诉`StoreModule`我们的应用中存在哪些状态和reducers。让我们快速回顾一下，并看看它的当前状态：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So, we are essentially feeding the `forRoot()` method an object. What''s wrong
    with that? Well, imagine you have ten different feature modules and every feature
    module may have three to four states, then the object you pass to `forRoot()`
    will grow in size and the number of imports that you need to do in your `app.module.ts`
    will grow. It will look something like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们实际上是在向`forRoot()`方法传递一个对象。这有什么问题吗？好吧，想象一下你有十个不同的功能模块，每个功能模块可能有三到四个状态，那么传递给`forRoot()`的对象将增大，你需要在`app.module.ts`中进行的导入数量也将增加。它看起来可能像这样：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Going from forRoot() to forFeature()
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从forRoot()到forFeature()
- en: 'To solve the mess we are creating in `app.module.ts,` we will now use a method
    called `forFeature()` on `StoreModule` that will allow us to set up the states
    we need per feature module. Let''s take the existing setup and refactor that:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决我们在`app.module.ts`中造成的混乱，我们现在将使用在`StoreModule`上的`forFeature()`方法，这将允许我们为每个功能模块设置所需的各个状态。让我们从现有的设置开始，进行重构：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We move our two reducer entries to their respective feature modules, `counter.module.ts`
    and `jedi.module.ts`. That would now look like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个还原器条目移动到它们各自的功能模块中，`counter.module.ts`和`jedi.module.ts`。现在它看起来可能像这样：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We left out the implementation on purpose here because we need to take a step
    back. Remember when we called `StoreModule.forRoot()`, we could just pass it an
    object. It doesn''t look quite the same with `forFeature()`. There is a little
    bit of difference, so let''s try to explain what that difference is. We are used
    to setting up our store by passing it an object, which looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意省略了这里的实现，因为我们需要退后一步。记得当我们调用`StoreModule.forRoot()`时，我们可以直接传递一个对象。使用`forFeature()`时看起来并不完全一样。有一点不同，所以让我们尝试解释一下这个差异。我们习惯于通过传递一个对象来设置我们的存储，这个对象看起来像这样：
- en: '[PRE40]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Setting up forFeature() from string to selection function
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将forFeature()从字符串转换为选择函数
- en: 'We can set it up in pretty much the same way, but we need to pass it the name
    of a feature as well. Let''s take our `counter.module.ts` and add a little code
    to it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以几乎相同的方式设置它，但我们需要传递一个功能模块的名称。让我们看看我们的`counter.module.ts`，并给它添加一些代码：
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will change how we select our state, though. Imagine we are inside of
    `counter.component.ts` with the current implementation looking like the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将改变我们选择状态的方式。想象一下我们处于`counter.component.ts`内部，当前的实现看起来如下：
- en: '[PRE42]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Because we changed what the state looked like in `counter.module.ts`, we now
    need to reflect that in `counter.component.ts`, like so:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在`counter.module.ts`中改变了状态的外观，我们现在需要在`counter.component.ts`中反映这一点，如下所示：
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Introducing NgRx types for setting up the state
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍用于设置状态的NgRx类型
- en: 'Up to this point, we have learned how we move the store state declaration from
    `app.module.ts` and register it in each feature module instead. This will provide
    us with a little more order. Let''s take a close look at the types used for registering
    state. `ActionReducerMap` is a type we have been using implicitly so far. We have
    been using it every time we call `StoreModule.forRoot()` or `StoreModule.forFeature()`.
    We have been using it in the sense that, the object we pass containing state and
    their reducers consists of this type. Let''s prove that is the case by turning
    to our `counter.module.ts`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何将存储状态声明从`app.module.ts`移动并注册到每个功能模块中。这将给我们带来更多的秩序。让我们仔细看看用于注册状态的类型。`ActionReducerMap`是我们迄今为止隐式使用的一个类型。每次我们调用`StoreModule.forRoot()`或`StoreModule.forFeature()`时，我们都在使用它。我们在使用它的意义上，传递包含状态及其还原器的对象由这种类型组成。让我们通过转向我们的`counter.module.ts`来证明这一点：
- en: '[PRE44]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s change that a bit, to this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍作改变，变成这样：
- en: '[PRE45]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, we can see that we are leveraging `ActionReducerMap`, which is a generic
    that forces us to provide it with a type. In this case, the type is `CounterState`.
    Running this code should just work. So, why use `ActionReducerMap` explicitly
    like this?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到我们正在利用`ActionReducerMap`，这是一个泛型，它强制我们提供给它一个类型。在这种情况下，类型是`CounterState`。运行这段代码应该可以正常工作。那么，为什么要显式地使用`ActionReducerMap`呢？
- en: Giving forFeature() a type
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给forFeature()一个类型
- en: 'Well, the `forFeature()` method is a generic as well, and we can specify this
    one explicitly like so:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，`forFeature()`方法也是一个泛型，我们可以像这样显式指定它：
- en: '[PRE46]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This protects us from adding a state mapping object that it does not expect
    to the `forFeature()` method. For instance, the following would render an error:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这保护我们不会向`forFeature()`方法添加它不期望的状态映射对象。例如，以下将引发错误：
- en: '[PRE47]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The reason for this is that we are providing the wrong type to the `forFeature()`
    method. It expects a reducer parameter to be something of type `ActionReducerMap<CounterState>`,
    which it clearly is not, as we are sending in `ActionReducerMap<State>`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于我们向`forFeature()`方法提供了错误类型。它期望reducer参数是`ActionReducerMap<CounterState>`类型，这显然不是，因为我们发送的是`ActionReducerMap<State>`。
- en: Several states in the same feature module
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同一特征模块中的多个状态
- en: The following scenario can be found in the `Chapter9/TypesDemo` folder of the
    code repository.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下场景可以在代码仓库的`Chapter9/TypesDemo`文件夹中找到。
- en: 'OK, so now we know about the `ActionReducerMap` type, and we also know that
    we can provide a type to the `forFeature()` method and make it safer to use. What
    happens if we''ve got several states in our feature module, what then? The answer
    is quite simple, but let''s first have a closer look at what we mean exactly by
    several states. Our counter module contains the `counter.value` state. This is
    displayed in our `counter.component.ts`. If we want to add a `counter.list` state,
    we need to add the supporting constants, reducers, actions, and a component file
    so we can properly display it. Our file structure should therefore look like the
    following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们知道了`ActionReducerMap`类型，我们也知道可以向`forFeature()`方法提供一个类型，使其使用更安全。如果我们特征模块中有多个状态，会发生什么？答案是相当简单的，但让我们首先更仔细地看看我们所说的“多个状态”究竟是什么意思。我们的计数器模块包含`counter.value`状态。这在我们`counter.component.ts`中显示。如果我们想添加一个`counter.list`状态，我们需要添加支持常量、reducer、actions和一个组件文件，以便我们能够正确地显示它。因此，我们的文件结构应该如下所示：
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We need to add implementation for all of these bold files.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为所有这些加粗的文件添加实现。
- en: Adding the counter-list reducer
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加计数器列表的reducer
- en: 'Let''s start off with the reducer:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从reducer开始：
- en: '[PRE49]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This reducer supports two types, `ADD_COUNTER_ITEM` and `REMOVE_COUNTER_ITEM`,
    which will let us add and remove items from the list.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个reducer支持两种类型，`ADD_COUNTER_ITEM`和`REMOVE_COUNTER_ITEM`，这将使我们能够向列表中添加和移除项目。
- en: Adding the component
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加组件
- en: 'This one comes in two parts, the HTML template and the class file. Let''s start
    with the class file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分分为两部分，HTML模板和类文件。让我们先从类文件开始：
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The HTML template file is quite simple, and looks like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: HTML模板文件相当简单，看起来像这样：
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding code, we are supporting the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们支持以下内容：
- en: Showing a list of counter objects
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示计数器对象的列表
- en: Adding an item to the list
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目添加到列表中
- en: Removing an item from the list
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表中移除项目
- en: Adding the constants
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加常量
- en: 'Next up is adding the constants. Constants are a nice thing to have; they protect
    us from making mistakes due to us mistyping when we deal with action creators
    as well as reducers:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是添加常量。常量是件好事；它们可以保护我们免受在处理action creators和reducers时因误输入而犯错的困扰：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Adding the action methods
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加动作方法
- en: 'We also need to define the action methods. These are just functions that will
    help us create our actions, so it''s less for us to type:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须定义动作方法。这些只是帮助我们创建动作的函数，所以我们需要输入的更少：
- en: '[PRE53]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Adding the model
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加模型
- en: 'We need to type what our counter-list should contain. For that we need to create
    a model:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的计数器列表指定类型。为此，我们需要创建一个模型：
- en: '[PRE54]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Register our reducers
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册我们的reducer
- en: 'We do need to add and implement all the files in bold, but we also need to
    update the `counter.module.ts` file so we are able to handle the added state:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实需要添加和实现所有加粗的文件，但我们也需要更新`counter.module.ts`文件，以便我们能够处理添加的状态：
- en: '[PRE55]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We need to add a `CombinedState` interface that represents all of our reducers
    with their state. Lastly, we change the call to `StoreModule.forFeature()`. That
    concludes how we deal with several states and reducers within the same module.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个`CombinedState`接口，它代表所有我们的reducer及其状态。最后，我们更改对`StoreModule.forFeature()`的调用。这就完成了我们在同一模块内处理多个状态和reducer的方法。
- en: Component architecture
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件架构
- en: 'There are different kinds of components. Two types of components are of interest
    in the context of NgRx: smart components and dumb components.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同种类的组件。在NgRx的上下文中，有两种类型的组件值得关注：智能组件和哑组件。
- en: Smart components are also called container components. They should be on the
    highest level of your application, and handle routes. For example, `ProductsComponent`
    should be a container component if it handles the `route/products`. It should
    also know about the store.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 智能组件也被称为容器组件。它们应该在应用程序的最高级别，并处理路由。例如，如果`ProductsComponent`处理`route/products`，它应该是一个容器组件。它还应该了解存储。
- en: 'The definition of a dumb component is that it has no knowledge of a store and
    relies solely on the `@Input` and `@Output` properties—it''s all about presentation,
    which is why it is also called a presentational component. A presentational component
    in this context can therefore be a `ProductListComponent` or a `ProductCreateComponent`.
    A quick overview of a feature module could therefore look like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 纯组件的定义是它没有关于存储的知识，并且完全依赖于 `@Input` 和 `@Output` 属性——它完全是关于展示的，这也是为什么它也被称为展示组件。因此，在这个上下文中，一个展示组件可以是
    `ProductListComponent` 或 `ProductCreateComponent`。一个功能模块的快速概述可能看起来像这样：
- en: '[PRE56]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s look at a small code example so you get the idea:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个小代码示例，以便你理解这个概念：
- en: '[PRE57]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Our `ProductsComponent` is responsible for handling the route to `/products`.
    `ProductsListComponent` is a dumb component and just gets a list assigned to it
    that it is more than happy to render to the screen.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `ProductsComponent` 负责处理 `/products` 路由。`ProductsListComponent` 是一个纯组件，它只被分配了一个列表，并且非常乐意将其渲染到屏幕上。
- en: '@ngrx/store-devtools – debugging'
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ngrx/store-devtools – 调试'
- en: The following scenario can be found in the code repository under `Chapter9/DevTools`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下场景可以在代码仓库的 `Chapter9/DevTools` 目录下找到。
- en: 'There are three things we need to do to get DevTools to work:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 DevTools 工作正常，我们需要做三件事：
- en: 'Install the NPM package: `` npm install @ngrx/store-devtools --save`.` ``'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 NPM 包：`npm install @ngrx/store-devtools --save`。
- en: 'Install the Chrome extension: `http://extension.remotedev.io/`. This is called
    the Redux DevTools extension.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Chrome 扩展程序：`http://extension.remotedev.io/`。这个扩展程序被称为 Redux DevTools 扩展程序。
- en: 'Set it up in your Angular module: this requires us to import DevTools into
    our Angular project.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的 Angular 模块中设置它：这需要我们将 DevTools 导入到我们的 Angular 项目中。
- en: 'Providing we have done the two first steps, we should only have the set up
    stage left, so we need to open up the `app.module.ts` file for that:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经完成了前两个步骤，那么我们只剩下设置阶段了，所以我们需要打开 `app.module.ts` 文件：
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Ok, so now everything is set up and we are ready to take our application for
    a spin and see what our debug tool can tell us. Let''s start up our application
    with `ng serve` and surf to `http://localhost:4200/`. First thing we want to do
    is open developer tools in Chrome and click on a tab called Redux. You should
    see something like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在一切都已经设置好了，我们准备运行我们的应用程序并看看我们的调试工具能告诉我们什么。让我们使用 `ng serve` 启动我们的应用程序，并访问
    `http://localhost:4200/`。我们首先想要做的是在 Chrome 中打开开发者工具，并点击一个名为 Redux 的标签页。你应该会看到如下内容：
- en: '![](img/c7818d9f-9121-49c7-af28-4e4f4524deae.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7818d9f-9121-49c7-af28-4e4f4524deae.png)'
- en: Redux tab
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 标签
- en: 'To the left we have our application UI, and to the right we have our Redux
    plugin. At this point, no actions have been carried out other than the initialization
    of the store, which we can see under the plugin part marked as Inspector. There
    is but one log entry, `@ngrx/store/init`. Let''s interact with the UI by clicking
    on the Increment button and see what happens with our store:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们有我们的应用程序 UI，在右侧，我们有 Redux 插件。在这个时候，除了存储的初始化之外，没有执行任何动作，这可以在插件的“检查器”部分看到。只有一个日志条目，`@ngrx/store/init`。让我们通过点击增量按钮与
    UI 交互，看看我们的存储会发生什么：
- en: '![](img/bb2388fa-38d0-4a20-b48d-2b8c23239336.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb2388fa-38d0-4a20-b48d-2b8c23239336.png)'
- en: Increment button
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 增量按钮
- en: 'As you can see, we have a new entry called INCREMENT. Two things are of interest
    now from a debug perspective:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们有一个新的条目叫做 INCREMENT。从调试的角度来看，现在有两个事情值得关注：
- en: What actions were dispatched?
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派发了哪些动作？
- en: What impact did these actions have on the store?
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些动作对存储有什么影响？
- en: 'We learn the answer to both these questions by interacting with the tab buttons
    on the right-hand side of our plugin. The button called Action will tell us what
    action was dispatched and what payload it had, if any:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过与插件右侧的标签按钮交互来了解这两个问题的答案。名为 Action 的按钮会告诉我们派发了什么动作以及它是否有任何负载：
- en: '![](img/95fceeaa-999a-406f-b37f-a47dce810345.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95fceeaa-999a-406f-b37f-a47dce810345.png)'
- en: Action button
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 动作按钮
- en: 'Here, it is clearly stated that an action with type value Increment was dispatched.
    Now to our second question; what was the impact to our store? To find that out,
    we simply click the State button:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，清楚地说明了派发了一个类型值为 Increment 的动作。现在，关于我们的第二个问题；这些动作对存储有什么影响？为了找出答案，我们只需点击状态按钮：
- en: '![](img/ae545d45-0bca-445c-9082-09af2a3d29c8.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ae545d45-0bca-445c-9082-09af2a3d29c8.png)'
- en: State button
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 状态按钮
- en: 'Our state tells us it consists of three properties, `count`, `todos` and `jediList`.
    Our `count` property has the value 1, and is the one affected by us clicking the
    Increment button. Let''s hit the Increment button a few more times to see that
    really is the case:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的状态告诉我们它由三个属性组成，`count`、`todos`和`jediList`。我们的`count`属性值为1，是我们点击增加按钮所影响的。让我们再点击几次增加按钮来看看这是否真的如此：
- en: '![](img/54f3ef2f-6319-4ab2-88c4-1612837dbb4a.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54f3ef2f-6319-4ab2-88c4-1612837dbb4a.png)'
- en: Increment button
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 增加按钮
- en: We now see that our `count` property has the value `3`, and we have three entries
    of Increment actions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在看到我们的`count`属性值为`3`，并且有三个增加动作条目。
- en: 'Now let''s talk about a really cool feature, time-travel debugging. Yes, you
    read that correctly, we can control time in our store by replaying dispatched
    actions, and even change history by removing dispatched actions, all in the name
    of debugging. The Redux plugin gives us several ways to do this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈一个真正酷的功能，时间旅行调试。是的，您没有看错，我们可以通过重放派发动作来控制我们存储中的时间，甚至通过删除派发动作来改变历史，所有这些都是在调试的名义下。Redux插件为我们提供了几种实现这一点的途径：
- en: Click on a specific dispatched action on your left, and choose to skip dispatching
    it
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左侧点击特定的派发动作，并选择跳过派发它
- en: Use a slider to control and replay all the events, and traverse back and forth
    in time as you see fit
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用滑块来控制和重放所有事件，并根据您的需要来回穿梭时间
- en: 'Let''s investigate the first way — click on a specific action:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查第一种方法——点击特定的动作：
- en: '![](img/536749d5-d146-47c5-b158-b4e21df2aa0a.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/536749d5-d146-47c5-b158-b4e21df2aa0a.png)'
- en: Click on a specific action
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 点击特定的动作
- en: Here we've clicked on the Skip button for one dispatch action and the end result
    is that this dispatched action is removed, which is indicated by the action being
    overstricken. We can also see that our `count` property now has the value `2`,
    as the action never took place. We can easily toggle this back if we want to by
    hitting Skip again.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们点击了跳过按钮以跳过一个派发动作，最终结果是这个派发动作被移除，这通过动作被划掉来表示。我们还可以看到，我们的`count`属性现在值为`2`，因为动作从未发生。如果我们想恢复它，可以再次点击跳过。
- en: 'We mentioned there was another way to control the flow of dispatched actions,
    namely by using a slider. There is a button called Slider that toggles the slider.
    Clicking it results in us being shown a slider control with a Play button, like
    so:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到了另一种控制已派发动作流的方法，即使用滑块。有一个名为“滑块”的按钮可以切换滑块。点击它会导致我们看到一个带有播放按钮的滑块控制，如下所示：
- en: '![](img/0997df04-8a9a-47f8-a426-0e765c7139d1.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0997df04-8a9a-47f8-a426-0e765c7139d1.png)'
- en: Play button
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 播放按钮
- en: If you press the Play button, it will simply play all the dispatched actions.
    However, if you choose to interact with the cursor on the slider itself you are
    able to pull it both to the left, to move back in time, and to the right, to move
    forward in time.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按下播放按钮，它将简单地播放所有派发动作。然而，如果您选择与滑块上的光标进行交互，您可以将它向左拉，以回到过去，或者向右拉，以进入未来。
- en: 'As you can see, the Redux plugin is a truly powerful tool to use in order to
    quickly gain an understanding of the following aspects:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Redux插件是一个真正强大的工具，可以帮助我们快速了解以下方面：
- en: What your app's state is at a given point in time
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定时间点您的应用状态是什么
- en: What part of the UI leads to what effects in the store
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI的哪个部分会导致存储中的哪些副作用
- en: '@ngrx/effects – working with side effects'
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ngrx/effects – 处理副作用'
- en: At this point, we have a basic understanding of NgRx. We know how to set up
    our state and create all the artifacts that go with it such as actions, action
    creators, and reducers. Additionally, we have also gained familiarity with the
    Redux plugin for Chrome and understood what a valuable tool it can be to help
    us quickly gain an understanding of the state in our app, and most importantly
    how it can aid us in debugging any problems we may have related to NgRx.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对NgRx有一个基本的了解。我们知道如何设置我们的状态并创建所有相关的工件，如动作、动作创建者和减少器。此外，我们还熟悉了Chrome的Redux插件，并理解它可以帮助我们快速了解应用的状态，最重要的是，它可以帮助我们调试与NgRx相关的任何问题。
- en: Now, the time has come to talk about something that doesn't quite fit in to
    our organized and synchronous world of reducers and actions. I am talking about
    something called side effects. Side effects are operations such as accessing files
    or network resources, and is not really related to our applications state even
    though they may be the vessels that contain the data we want, or be the place
    we persist data to. As we just said, a dispatched action is dispatched in a synchronous
    way and the change to our state happens straight away. A side effect is something
    that may take time. Imagine that we access a large file or ask for a resource
    over the network using AJAX. This request will finish sometime in the future and,
    when done, it may affect our state. How do we make these time consuming and asynchronous
    operations fit in with our synchronous and momentary world? The answer in NgRx
    is a library called `@ngrx/effects`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候讨论一些不太适合我们有序和同步的 reducer 和 actions 世界的东西了。我正在谈论的是叫做副作用的东西。副作用是诸如访问文件或网络资源之类的操作，尽管它们可能包含我们想要的数据的容器，或者是我们持久化数据的地方，但它们实际上与我们应用程序的状态并没有真正关系。正如我们刚才说的，派发的动作是以同步方式派发的，我们的状态变化是立即发生的。副作用是可能需要时间的事情。想象一下，我们访问一个大型文件或使用
    AJAX 在网络上请求资源。这个请求将在未来某个时候完成，完成后可能会影响我们的状态。我们如何让这些耗时和异步的操作与我们的同步和瞬时的世界相适应？在 NgRx
    中的答案是名为 `@ngrx/effects` 的库。
- en: Installing and setting it up
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和设置
- en: 'Installing it is as easy as performing the following command in your terminal:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 安装它就像在终端执行以下命令一样简单：
- en: '[PRE59]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The next step is to set it up. The setup can be seen as consisting of two steps:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置它。设置可以看作是两个步骤：
- en: Create our effect
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的效果
- en: Register the effect with the `EffectsModule`
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将效果注册到 `EffectsModule`
- en: An effect is just an injectable service that listens for a specific action.
    Once the effect is in focus, it can carry out a number of operations and transformations
    before leaving over control. It leaves over control by dispatching an action.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一个效果只是一个可注入的服务，它监听特定的动作。一旦效果被关注，它可以在离开控制之前执行一系列操作和转换。它通过派发一个动作来放弃控制。
- en: Creating our first effect – a realistic scenario
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个效果 – 一个真实场景
- en: The following scenario can be found in the code repository under `Chapter9/DemoEffects`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下场景可以在代码库的 `Chapter9/DemoEffects` 下找到。
- en: 'This sounds a bit cryptic, so let''s take a realistic scenario. You want to
    fetch products using AJAX from an endpoint. If you think about what you are about
    to undertake in the following steps:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来有点晦涩，所以让我们用一个真实场景来说明。你想要从一个端点使用 AJAX 获取产品。如果你考虑以下步骤中你将要做什么：
- en: Dispatch a `FETCHING_PRODUCTS`, this sets up our state so we can see that an
    AJAX request is under way and we can thereby use this to display a spinner for
    as long as the AJAX request is waiting to complete.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 派发一个 `FETCHING_PRODUCTS`，这设置我们的状态，这样我们就可以看到 AJAX 请求正在进行中，我们可以利用这一点来显示一个旋转器，直到
    AJAX 请求完成等待。
- en: Perform an AJAX call and retrieve your products.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 AJAX 调用并检索你的产品。
- en: If successfully retrieving the products, then dispatch `FETCHING_PRODUCTS_SUCCESSFULLY`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果成功检索到产品，则派发 `FETCHING_PRODUCTS_SUCCESSFULLY`。
- en: If there is an error, then dispatch `FETCHING_PRODUCTS_ERROR`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果出现错误，则派发 `FETCHING_PRODUCTS_ERROR`。
- en: 'Let''s solve this task in the following steps:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以下面的步骤来解决这个问题：
- en: Create a reducer for it.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为它创建一个 reducer。
- en: Create actions and action creators.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建动作和动作创建者。
- en: Create an effect.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个效果。
- en: Register the preceding effect with our effects module.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的效果注册到我们的效果模块中。
- en: 'To perform all of this, we will create a feature module. To do so, we create
    the `product/` directory with the following files:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行所有这些，我们将创建一个功能模块。为此，我们创建一个 `product/` 目录，包含以下文件：
- en: '`product.component.ts`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product.component.ts`'
- en: '`product.actions.ts`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product.actions.ts`'
- en: '`product.constants.ts`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product.constants.ts`'
- en: '`product.reducer.ts`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product.reducer.ts`'
- en: '`product.selectors.ts`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product.selectors.ts`'
- en: '`product.module.ts`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product.module.ts`'
- en: '`product.effect.ts`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product.effect.ts`'
- en: All of these files are known to us before, except for `product.effect.ts`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道这些文件，除了 `product.effect.ts`。
- en: Creating our constants
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的常量
- en: 'Let''s start with our constants file. What we need are constants that will
    support us firing away an AJAX request. We also need a constant for when we get
    our data back successfully, but we also need to cater to any error that might
    occur. This means we need the following three constants:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的常量文件开始。我们需要的是支持我们发起 AJAX 请求的常量。我们还需要一个常量来表示我们成功获取数据，但我们还需要应对可能发生的任何错误。这意味着我们需要以下三个常量：
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Action creators
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作创建者
- en: 'We need to expose a number of functions that can build objects for us containing
    a type and a payload property. Depending on what function we invoke, we will assign
    it with a different constant, and of course a different payload, if using one.
    The action creator `fetchProducts()` will create an object where only the type
    is set. This is followed by a `fetchSuccessfully()` action creator, which will
    be invoked once the data comes back from an endpoint. Lastly, we have the `fetchError()`
    action creator, which we will invoke if an error occurs:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要公开一系列函数，这些函数可以为我们构建包含类型和有效载荷属性的对象。根据我们调用的函数不同，我们将赋予它不同的常量，当然，如果使用一个，也会赋予不同的有效载荷。动作创建者
    `fetchProducts()` 将创建一个只设置类型的对象。接着是一个 `fetchSuccessfully()` 动作创建者，它将在数据从端点返回时被调用。最后，我们有
    `fetchError()` 动作创建者，如果发生错误，我们将调用它：
- en: '[PRE61]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Reducer with a new type of default state
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有新类型默认状态的 reducer
- en: 'At first glance, the following reducer is just like any reducer you have written
    before. It is a function that takes a parameters'' state and action, and it contains
    a switch construct that switches between different actions. So far, everything
    is familiar. The `initialState` variable is different though. It contains the
    `loading`, `list`, and `error` properties. `loading` is simply a Boolean that
    indicates whether our AJAX request is still pending. `list` is our data property
    that will contain our list of products once they are are returned. The `error`
    property is simply a property that contains the error if any comes back from the
    AJAX request:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，下面的 reducer 就像你之前写的任何 reducer 一样。它是一个接受参数状态和动作的函数，并包含一个 switch 构造，用于在不同动作之间切换。到目前为止，一切都是熟悉的。不过，`initialState`
    变量是不同的。它包含 `loading`、`list` 和 `error` 属性。`loading` 是一个简单的布尔值，表示我们的 AJAX 请求是否仍在挂起。`list`
    是我们的数据属性，一旦返回，它将包含我们的产品列表。`error` 属性是一个简单的属性，如果 AJAX 请求返回错误，它将包含错误：
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The effect – listening to a specific dispatched action
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效果 – 监听特定的分发的动作
- en: So we come to the effect. Our effect acts like a listener to a dispatched action.
    This gives us the opportunity to carry out a unit of work, but also to dispatch
    an action once that work is done.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们来到了效果。我们的效果像一个监听分发的动作的监听器。这给了我们执行一个工作单元的机会，一旦这项工作完成，我们还可以分发一个动作。
- en: 'We have created all the usual bits that we are used to, so now it is time to
    create our effect that will handle the entire workflow:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了所有我们习惯的组件，所以现在是我们创建处理整个工作流程的效果的时候了：
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The effect is just a class decorated with the `@Injectable` decorator. It also
    contains two members: one member of `Actions` type and another of the `Observable<Action>`
    type. Actions come from the `@ngrx/effects` module and are nothing more than a
    specialized `Observable` with the `ofType()` method on it. `ofType()` is the method
    that takes a string constant, which is the event we are listening for. In the
    previous code, the `products$` is the `Observable` that we decorate with the `@Effect`
    decorator. Our next step is to connect `products$` with `actions$`, and define
    how our effect should work. We do that with the following code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 该效果只是一个用 `@Injectable` 装饰器装饰的类。它还包含两个成员：一个是 `Actions` 类型的成员，另一个是 `Observable<Action>`
    类型的成员。动作来自 `@ngrx/effects` 模块，并且不过是一个带有 `ofType()` 方法的特殊 `Observable`。`ofType()`
    是一个接受字符串常量的方法，这是我们正在监听的事件。在上面的代码中，`products$` 是我们用 `@Effect` 装饰器装饰的 `Observable`。我们的下一步是将
    `products$` 与 `actions$` 连接起来，并定义我们的效果应该如何工作。我们用以下代码来完成：
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Ok, so we have set up our effect a little more. The call to `ofType()` ensures
    we set ourselves up to listen to a specific dispatched action. The call to `switchMap()`
    ensures we are able to take the current `Observable` that we are currently on,
    and turn it into something completely different, such as a call to an AJAX service.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们已经稍微设置好了我们的效果。对 `ofType()` 的调用确保我们为自己设置了监听特定分发的动作。对 `switchMap()` 的调用确保我们能够将我们目前所在的当前
    `Observable` 转换为完全不同的东西，比如调用 AJAX 服务。
- en: 'Let''s now return back to our example and see how we can fit in some product-related
    logic in there:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到我们的例子，看看我们如何在其中加入一些与产品相关的逻辑：
- en: '[PRE65]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: What we do in the preceding code is listen to our `FETCHING_PRODUCTS` action
    and carry out a call to an AJAX service. We added a call to the `delay()` operator
    so as to simulate that our AJAX call takes some time to carry out. This will give
    us a chance to show a loading spinner. The `map()` operator ensures we dispatch
    an action when we get the AJAX response back. We can see that we call the action
    creator, `fetchProductsSuccessfully()`, which implicitly calls the reducer and
    sets a new state on the products property.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们监听 `FETCHING_PRODUCTS` 动作，并对 AJAX 服务进行调用。我们添加了对 `delay()` 操作符的调用，以模拟我们的
    AJAX 调用需要一些时间来完成。这将给我们一个机会来显示一个加载旋转器。`map()` 操作符确保我们在收到 AJAX 响应时分发一个动作。我们可以看到我们调用了动作创建器
    `fetchProductsSuccessfully()`，它隐式地调用 reducer 并在产品属性上设置新的状态。
- en: 'At this point, we need to register the effect before moving on. We can do so
    in the root module or in the feature module. It''s a very similar call, so let''s
    describe both ways of doing it:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要在继续之前注册效果。我们可以在根模块或功能模块中这样做。这是一个非常相似的调用，所以让我们描述两种方法：
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If we have a feature module, on the other hand, we could be using the `forFeature()`
    method on the `EffectsModule` and call that in our feature module like so:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们有一个功能模块，我们可以在 `EffectsModule` 上使用 `forFeature()` 方法，并在我们的功能模块中这样调用：
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Adding a component – introducing selectors
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加组件 - 介绍选择器
- en: That's it, thats all you need to create an effect. We're not done here though,
    we need a component to display our data, as well as a spinner, while we are waiting
    for the AJAX request to finish.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，这就是创建效果所需的所有内容。不过，我们还没有完成，我们需要一个组件来显示我们的数据，以及一个旋转器，在我们等待 AJAX 请求完成时。
- en: 'Ok, first things first: what do we know of components that should be using
    NgRx? The obvious answer is that they should be injecting the store so we can
    listen to a slice of state from the store. The way we listen to a slice of state
    is by calling the stores `select()` function. This will return an `Observable`.
    We know we can easily show Observables in the template through the use of the
    async pipe. So let''s start sketching our component:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，首先的事情是：我们对应该使用 NgRx 的组件了解多少？明显的答案是它们应该注入 store，这样我们就可以监听 store 中的状态片段。我们监听状态片段的方式是通过调用
    stores 的 `select()` 函数。这将返回一个 `Observable`。我们知道我们可以通过使用异步管道轻松地在模板中显示 Observables。所以让我们开始绘制我们的组件：
- en: '[PRE68]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This part of our component here shouldn''t come as too much of a surprise;
    we inject the store into the constructor, call `select()`, and get an Observable
    back. But, there is a *but* here, we are calling the `select()` method differently.
    We used to pass a string to the `select()` function, and now we pass it a function.
    Why is that? Well, because we changed how our state looked. Let''s show our new
    state again, for clarity:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组件的这一部分不应该让人感到太意外；我们在构造函数中注入 store，调用 `select()`，并返回一个 Observable。但是，这里有一个“但是”，我们调用
    `select()` 方法的方式不同。我们过去传递一个字符串到 `select()` 函数，而现在我们传递一个函数。为什么是这样？嗯，因为我们改变了我们的状态看起来。让我们再次展示我们的新状态，以保持清晰：
- en: '[PRE69]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The preceding code shows that we can''t just do `store.select("products")`
    because that would give us the whole object back. So we need a way to dig into
    the previous object in order to get a hold of the list property that should contain
    our list of products. The way to do that is to use the variant of the `select`
    method that takes a function instead. We do just that with the following code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示我们不能简单地做 `store.select("products")`，因为这会返回整个对象。所以我们需要一种方法来深入到前面的对象中，以便抓住应该包含我们的产品列表属性。要做到这一点，我们可以使用
    `select` 方法的变体，它接受一个函数。我们就是这样做的，以下代码所示：
- en: '[PRE70]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Ok, but will this really be type safe? Won''t the `AppState` interface complain?
    Does it know of our changed state structure? Well, we can tell it knows about
    it, but we need to ensure that our reducer exports an interface that represents
    our new state structure. We therefore change the reducer to look like the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，但这真的会是类型安全的吗？`AppState` 接口不会抱怨吗？它知道我们改变的状态结构吗？嗯，我们可以告诉它它知道，但我们需要确保我们的 reducer
    导出一个代表我们新状态结构的接口。因此，我们将 reducer 改成如下所示：
- en: '[PRE71]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'And of course, we need to update the `AppState` interface to look like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要更新 `AppState` 接口，使其看起来像这样：
- en: '[PRE72]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Ok, this made our `AppState` know what kind of beast our `products` property
    really is, and is thereby what makes the `store.select(<Fn>)` call possible. The
    function we gave the `select` method is called a selector, and is actually something
    that doesn''t have to live inside the component. The reason for this is that we
    might want to access that slice of state somewhere else. Let''s therefore create
    a `product.selectors.ts` file. We will add to this later as we keep supporting
    CRUD:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这使得我们的`AppState`知道我们的`products`属性实际上是什么样的怪物，因此使得`store.select(<Fn>)`调用成为可能。我们提供给`select`方法的函数被称为选择器，实际上它不必存在于组件内部。原因是我们可能希望在别处访问那个状态片段。因此，让我们创建一个`product.selectors.ts`文件。我们将随着继续支持CRUD而向其中添加内容：
- en: '[PRE73]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Ok, so now we have created our selectors file, and we can immediately start
    improving our components code and clean it up a bit before we continue to add
    things to it:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以现在我们已经创建了我们的选择器文件，我们就可以立即开始改进我们的组件代码，并在继续添加内容之前对其进行一些清理：
- en: '[PRE74]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Our code looks much better. It''s time to start caring about the other aspect
    of this; what if our HTTP service takes a few seconds, or even one second to return?
    This is a real concern especially with our users being potentially on a 3G connection.
    To take care of this, we grab the `loading` property from our products state and
    use that as a conditional in our template. We will basically say that if the HTTP
    call is still pending, show some text or an image that indicates to the user that
    something is loading. Let''s add that piece of functionality to the component:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码看起来好多了。现在是时候开始关注这个的其他方面了；如果我们的HTTP服务需要几秒钟，甚至一秒钟来返回，会怎样？这是一个真正的担忧，尤其是当我们的用户可能处于3G连接时。为了解决这个问题，我们从产品状态中获取`loading`属性，并将其用作模板中的条件。我们基本上会说，如果HTTP调用仍在挂起，显示一些文本或图像来向用户指示正在加载。让我们将这个功能添加到组件中：
- en: '[PRE75]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Let''s also ensure that we show any errors by subscribing to `products.error`.
    We simply update the component with the following alterations:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再确保通过订阅`products.error`来显示任何错误。我们只需用以下更改更新组件：
- en: '[PRE76]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Ok, we fire up our application at this point. There is just one teeny tiny
    problem; we don''t see any products at all. Why is that? The explanation is simple.
    We don''t actually dispatch an action that will lead to the AJAX call being made.
    Let''s fix that by adding the following code to our component:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在启动应用程序。这里有一个非常小的问题；我们根本看不到任何产品。为什么是这样？解释很简单。我们实际上没有派发一个会导致AJAX调用执行的动作。让我们通过向我们的组件添加以下代码来修复这个问题：
- en: '[PRE77]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This will of course trigger our effect, which will lead to our HTTP call, which
    will lead to `fetchProductsSuccessfully()` being called, and thereby our state
    will be updated and `products.list` will no longer be an empty array, meaning
    our UI will show a list of products. Success!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然会触发我们的效果，这将导致我们的HTTP调用，这将导致调用`fetchProductsSuccessfully()`，从而我们的状态将被更新，`products.list`将不再是一个空数组，这意味着我们的UI将显示产品列表。成功了！
- en: Extending our example with the create effect
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的示例中扩展创建效果
- en: 'So far, we have gone through the full flow of adding an effect, building a
    component, and improved the code with selectors. To make sure we really understand
    how to work with effects and how the application scales with it, let''s add another
    effect, this time let''s add an effect to support an HTTP POST call. What we want
    to happen from an application standpoint is that we add another product to the
    list. This should update the UI and show our added product. What happens data-wise
    is that our store should reflect that change and, as a side effect, a HTTP POST
    should be carried out. We need the following to accomplish this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经走过了添加效果、构建组件和通过选择器改进代码的全过程。为了确保我们真正理解如何使用效果以及应用程序如何随着它而扩展，让我们添加另一个效果，这次让我们添加一个支持HTTP
    POST调用的效果。从应用程序的角度来看，我们想要做的是向列表中添加另一个产品。这应该更新UI并显示我们添加的产品。数据方面发生的事情是，我们的存储应该反映这种变化，并且作为副作用，执行一个HTTP
    POST。我们需要以下内容来完成此操作：
- en: A reducer that supports adding a product to our products list
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持向产品列表添加产品的reducer
- en: An effect that listens to a product being added action and that carries out
    a HTTP POST
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个监听产品添加动作并执行HTTP POST的效果
- en: We also need to register the created effect
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要注册创建的效果
- en: Updating the constants file
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新常量文件
- en: 'Just like with the fetching of products, we need to support one action that
    triggers everything. We need another action for when the HTTP request succeeds
    and one last action to support error handling:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 就像获取产品一样，我们需要支持一个触发所有操作的动作。我们需要另一个动作来处理HTTP请求成功的情况，以及一个最后的动作来支持错误处理：
- en: '[PRE78]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Updating the reducer
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新reducer
- en: 'At this point we take our existing `reducer.ts` file and add what we need to
    support adding a product:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们取我们的现有`reducer.ts`文件并添加我们需要支持添加产品的内容：
- en: '[PRE79]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: It's worth noting how we create the help function, `addProduct()`, which allows
    us to create a new list containing the old content and our new product. It's also
    worth noting that we can group `FETCHING_PRODUCTS_ERROR` and `ADD_PRODUCT_ERROR`
    actions, and also `ADD_PRODUCT` and `ADD_PRODUCT_SUCCESSFULLY`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是我们如何创建帮助函数`addProduct()`，它允许我们创建一个包含旧内容和新产品的新的列表。同样值得注意的还有，我们可以将`FETCHING_PRODUCTS_ERROR`和`ADD_PRODUCT_ERROR`动作分组，以及`ADD_PRODUCT`和`ADD_PRODUCT_SUCCESSFULLY`。
- en: Additional actions
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的动作
- en: 'The next order of business is to update our `products.actions.ts` file with
    the new methods that we need to support the preceding code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的任务是更新我们的`products.actions.ts`文件，添加我们需要支持前面代码的新方法：
- en: '[PRE80]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: What is worth noting with the created actions is that the `addProduct()` method
    takes a product as a parameter. The reason for that is that we want the side effect
    to use that as body data for the forthcoming HTTP POST.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，创建的动作中`addProduct()`方法接受一个产品作为参数。这样做的原因是我们希望副作用使用它作为即将到来的HTTP POST请求的正文数据。
- en: Adding another effect
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加另一个效果
- en: 'Now we are finally ready to construct our effect. It''s going to look very
    similar to the existing one:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于准备好构建我们的效果了。它将非常类似于现有的一个：
- en: '[PRE81]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The first thing we do here is to reuse our `ProductEffects` class and add a
    new member `productsAdd$` to it. While at it, we rename `products$` to `productsGet$`.
    As long as we are dealing with products we can keep on adding to this class.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们首先重用我们的`ProductEffects`类，并给它添加一个新成员`productsAdd$`。同时，我们将`products$`重命名为`productsGet$`。只要我们处理产品，我们就可以继续添加到这个类中。
- en: The similarities we see with the existing effect is that we set up our `ofType()`
    operator to listen for a dispatched action of our choice. Thereafter, we continue
    with our side effect, that is the call to the `HttpClient` service that ends up
    being an HTTP POST call.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到与现有效果相似之处在于我们设置了`ofType()`操作符来监听我们选择的已分发动作。之后，我们继续进行副作用，即调用`HttpClient`服务，最终成为一个HTTP
    POST调用。
- en: Supporting the effect in our component
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的组件中支持效果
- en: 'We don''t need to do much in our component. Of course, we need to add some
    things in the template to support adding a product. In terms of NgRx, we just
    need to dispatch the `ADD_PRODUCT` action. Let''s have a look at the code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的组件中我们不需要做太多。当然，在模板中我们需要添加一些内容来支持添加产品。在NgRx方面，我们只需要分发`ADD_PRODUCT`动作。让我们看看代码：
- en: '[PRE82]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Ok, from this code we set up an input control and a button to be able to handle
    the user inputting a new product. For the class, we added the `newProduct` field
    and we also added the `addNewProduct()` method that, in its body, invokes the
    `addProduct()`, method and thereby passes an `ADD_PRODUCT` action. We really don't
    need to do more. Our product addition sets the loading state before carrying out
    the HTTP call, so we can show a spinner if we want, and our error state picks
    up on any errors that might occur and presents them in the UI. Lastly, don't forget
    to add the `FormsModule` to the `import` property in the `product.module.ts`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，从这段代码中，我们设置了一个输入控件和一个按钮来处理用户输入新产品。对于类，我们添加了`newProduct`字段，并且还添加了`addNewProduct()`方法，在其主体中调用`addProduct()`方法，从而传递一个`ADD_PRODUCT`动作。我们实际上不需要做更多。我们的产品添加在执行HTTP调用之前设置加载状态，因此如果我们想的话，可以显示一个加载指示器，我们的错误状态会捕捉到可能发生的任何错误并在UI中展示它们。最后，别忘了将`FormsModule`添加到`product.module.ts`中的`import`属性。
- en: Running a demo of the app
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用的演示
- en: 'To try out our app, we can simply run the `ng serve` command in the terminal.
    What we expect to see is a screen that for three seconds states it is loading,
    just to be replaced by the fetched data. This will demonstrate both the dispatch
    of the loaded state, as well as us dispatching the data to the store once it arrives.
    The following is the initial screen when our data is yet to arrive. We fire off
    the `FETCHING_PRODUCTS` action, which makes our loading text appear:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试我们的应用，我们可以在终端中简单地运行`ng serve`命令。我们期望看到的是屏幕上显示加载状态三秒钟，随后被获取到的数据所替代。这将展示加载状态的分发，以及我们在数据到达后将其派发到存储中的过程。以下是我们数据尚未到达时的初始屏幕。我们触发`FETCHING_PRODUCTS`动作，这使得加载文本显示出来：
- en: '![](img/322941c2-5f58-4f91-97a7-e8c27e8e020b.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/322941c2-5f58-4f91-97a7-e8c27e8e020b.png)'
- en: 'The next screen is when our data arrives. Subsequently, we fire off `ADD_PRODUCT_SUCCESSFULLY`
    to ensure that the fetched data is placed in the store:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个屏幕是我们数据到达时的情景。随后，我们触发`ADD_PRODUCT_SUCCESSFULLY`以确保获取到的数据被放置在存储中：
- en: '![](img/6c69a9eb-ebef-413a-b7f5-47e5509acea2.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c69a9eb-ebef-413a-b7f5-47e5509acea2.png)'
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have gone through a lot in this chapter. Among the things covered have been
    installing and using the store. To that knowledge, we have added some sound best
    practices to organize your code. It's important to note that consistency is key.
    There are many ways to organize code, so as long as that chosen way remains consistent
    throughout the app, that is the most important factor. With that said, organizing
    your code by domain is what is prescribed for most things Angular. Whether that
    holds true for NgRx is up to you, dear reader. See best practices as a guide rather
    than a rule. Furthermore, we covered side effects and how to handle those with
    `@ngrx/effects`. `@store-devtools` was another thing we covered, which lets us
    use our browser to easily debug our store. In the next, and final, chapter, we
    will cover `@ngrx/schematics` and `@ngrx/entity`, so we really cover everything
    NgRx has to offer us. Also, we will showcase how you can build NgRx yourself to
    gain further understanding on what goes on under the hood. If knowing what goes
    on under the hood isn't exciting to you, then you are in the wrong profession!
    Everything is really set up to make the final chapter a very interesting one.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们经历了很多。其中涉及的内容包括安装和使用存储。在此基础上，我们增加了一些最佳实践来组织你的代码。重要的是要注意一致性。有许多组织代码的方式，只要选择的方式在整个应用中保持一致，这就是最重要的因素。因此，按照领域组织代码是Angular推荐的做法。至于NgRx是否也是如此，取决于你，亲爱的读者。将最佳实践视为指南而不是规则。此外，我们还涵盖了副作用以及如何使用`@ngrx/effects`来处理这些副作用。`@store-devtools`也是我们讨论的内容之一，它允许我们使用浏览器轻松地调试我们的存储。在下一章，也就是最后一章，我们将涵盖`@ngrx/schematics`和`@ngrx/entity`，这样我们就能涵盖NgRx提供的所有内容。此外，我们将展示如何自己构建NgRx，以进一步了解底层发生了什么。如果你对底层发生的事情不感兴趣，那么你可能选择了错误的专业！一切都被设置为使最后一章非常有趣。
